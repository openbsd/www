<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="Content-Type"
	content="text/html; charset=iso-8859-1">
  <meta name="resource-type"
	content="document">
  <meta name="description"
	CONTENT="How to make an OpenBSD port; audio">
  <meta name="keywords"
	content="openbsd,ports,audio">
  <meta name="distribution"
	content="global">
  <meta name="copyright"
	content="This document copyright 1998-2002 by OpenBSD.">
  <title>Portage des applications audio sur OpenBSD</title>
  <link rev="made" HREF="mailto:www@openbsd.org">
 </head>
 <body text="#000000" bgcolor="#FFFFFF" link="#23238E">
<a href="index.html"><img alt="[OpenBSD]" height="30" width="141"
src="../images/smalltitle.gif" border="0"></a>

  <h1>Portage des applications audio sur OpenBSD</h1>

<p>
  Ce document ne traite actuellement que des sons echantillonés. Les
  contributions abordant les synthétiseurs et les tables de mixage sont
  les bienvenues.

</p>
<p>
        Les applications audio sont en général difficiles à porter, le
        son étant un domaine dans lequel les interfaces ne sont pas du
        tout standardisées, même si l'approche ne varie que très peu en
        fonction des systèmes d'exploitation.
</p>

  <h2><font color="#e00000">Utilisation de
      <code>ossaudio</code></font></h2>

  L'émulation <code>ossaudio</code> est peut-être le moyen le plus
  simple, mais elle ne fonctionne pas toujours, et ce n'est pas
  forcément un bon choix.
  <ul>
        <li>Elle redéfinit <code>ioctl</code>. Si le code à porter
        n'utilise pas <code>ioctl</code> seulement pour l'audio, vous
        aurez à utiliser <code>#undef ioctl</code> ainsi que la forme
        dénudée <code>_ossioctl</code>.

        <li>Certaines fonctionnalités du son linux ne sont pas émulées.

        <li>Les applications avec un support du son linux correct non
        spécifique à Intel utilisent généralement ces
        fonctionnalités.

  </ul>

  <h2><font color="#e00000">Utilisation de code NetBSD ou
      FreeBSD</font></h2> Depuis que nous partageons une partie de
      l'interface audio avec NetBSD et FreeBSD, partir d'un port NetBSD
      est chose raisonnable. Pensez que certains fichiers changent de
      place, et que certaines entrées dans <code>sys/audioio.h</code>
      sont obsolètes. De plus, de nombreux ports ne sont pas idéalement
      programmés, et ne fonctionnent réellement que sur un seul type de
      machine. Certains changements deviennent ainsi nécessaires. Lisez
      la partie suivante.

  <h2><font color="#e00000">Ecriture de code OpenBSD</font></h2>
          <h3><font color="#0000e0">Dépendances Matérielles</font></h3>

   <p>
        <strong>VOUS NE DEVRIEZ PARTIR SUR AUCUN PRESUPPOSES CONCERNANT
        LE MATERIEL AUDIO UTILISE.
        </strong><br>
        Du code éronné se caractérise par une simple vérification du
        champ <code>a_info.play.precision</code>, comportant 8 ou 16
        bits, et par le fait qu'il suppose que les échantillons sont
        signés ou non-signés en fonction du comportement de
        soundblaster. Vous devriez vérifier explicitement l'échantillon
        et programmer en fonction. Un simple exemple : </p> <pre>
        AUDIO_INIT_INFO(&amp;a_info); a_info.play.encoding =
        AUDIO_ENCODING_SLINEAR; a_info.play.precision = 16;
        a_info.play.sample_rate = 22050; error = ioctl(audio,
        AUDIO_SETINFO, &amp;a_info); if (error) /* deal with it */ error
        = ioctl(audio, AUDIO_GETINFO, &amp;a_info);
        switch(a_info.play.encoding) { case AUDIO_ENCODING_ULINEAR_LE:
        case AUDIO_ENCODING_ULINEAR_BE: if (a_info.play.precision == 8)
        /* ... */ else /* ... */ break; case ...

    default:
        /* n'oubliez pas de prendre en compte ce que vous ignorez !!!
         * Par exemple,
         */
        fprintf(stderr, 
                "Unsupported audio format (%d), ask ports@ about that\n",
                a_info.play.encoding);

        }
    /* à présent, n'oubliez pas de vérifier la fréquence
     * d'échantillonage que vous avez
     */
        </pre>
  
  <p>
  Ceci concerne le plus petit fragment de code que vous pourriez traiter
  avec un grand nombre de problèmes.

        <h3><font color="#0000e0">Formats 16 bit et
            "endianess"</font></h3> Lors d'une utilisation classique,
            vous demandez simplement le type d'encodage (par exemple,
            <code>AUDIO_ENCODING_SLINEAR</code>), et vous réessayez un
            encodage avec "endianess" (par exemple,
            <code>AUDIO_ENCODING_SLINEAR_LE</code>). Considérant qu'une
            carte son ne doit pas forcément utiliser le même "endianess"
            que votre plateforme, vous devriez vous préparer à
            rencontrer cela. Le moyen le plus simple est probablement de
            préparer un buff audio complet, et d'utiliser
            <code>swab(3)</code> si un changement d'endianess est
            nécessaire. Traiter des échantillons externes consiste en
            général à : <ol>
                <li>Analyser le format de l'échantillon,
                <li>Obtenir l'échantillon présent,
                <li>Permuter l'endianess si ce n'est pas le format natif,
                <li>Calculer ce que vous voulez en sortie dans un buffer,
                <li>Permuter l'endianess si votre carte son n'est pas
                dans le format natif,
                <li>Jouer le contenu du buffer.
        </ol>
        Evidemment, vous pourriez être capable de sauter les étapes 3 et
        5 si vous jouez un son s'averrant être dans le format natif de
        votre carte son.

        <h3><font color="#0000e0">Qualité audio</font></h3>
        <p>
        Le matériel pourrait avoir d'étranges limitations, comme être
        incapable de dépasser les 22050 Hz en stereo, mais plus que
        44100 en mono. C'est dans ce genre de cas que vous devriez
        donner à l'utilisateur la possibilité de changer ses
        préférences, et d'essayer d'avoir les meilleures performances
        possibles. Par exemple, il est stupide de limiter la fréquence à
        22050 Hz sous prétexte que vous produisez un son stereo. Et si
        l'utilisateur n'avait pas un système de son stereo connecté à la
        sortie de sa carte son ? </p>

        <p>
        Il est également grotesque de saisir de manière permanente les
        limitations des compatibles soundblaster dans votre programme.
        Vous devriez en être conscient, mais essayer d'obtenir un son au
        delà de la barrière des 22050&nbsp;Hz/stereo et vérifier les
        résultats.
        </p>

        <h4>Echantillonage de la fréquence</h4>
        Vous devriez définitivement vérifier la fréquence
        d'échantillonage que votre carte vous restitue. Un décalage de
        5% relève déjà du mi-ton, et certaines personnes ont une
        audition beaucoup plus précise que cela, alors que beaucoup
        d'entre nous ne remarquerons rien. Votre application devrait
        être en mesure de rééchantilloner à la volée, peut être
        naïvement, ou via de sournoises applications des formules de
        rééchantillonage de Shannon si vous le pouvez.

        <h4>Gamme dynamique</h4>
        <p>
        Les échantillons n'utilisent pas toujours la gamme complète de
        valeurs possibles. Premièrement, les échantillons enregistrés
        avec un faible gain ne sonneront que très faiblement sur la
        machine, forçant ainsi l'utilisateur à augmenter le volume.
        Deuxièmement, sur les machines avec un matériel audio mal isolé,
        le rendu des sons bas signifie que vous entendrez surtout les
        battements de coeur de votre machine, au lieu du son que vous
        attendiez. Enfin, la conversion idiote de 16 bits à 8 bits
        pourrait vous laisser avec seulement 4 bits audio utilisables,
        ce qui procurerait une qualité désastreuse. </p>
        <p>
        SI cela est possible, la meilleure solution est probablement de
        parcourir intégralement le flux que vous êtes en passe de jouer,
        et de l'arranger afin qu'il utilise la gamme dynamique complète.
        Si vous ne pouvez pas vous le permettre, mais que vous pouvez
        gérer ceci afin d'avoir un minimum de regard sur ce que vous
        êtes en passe de jouer, vous pouvez ajuster le réglage du volume
        à la volée, vous n'avez qu'a vous assurer que ce dernier reste a
        une fréquence bien inférieure à celle du son que vous voulez
        jouer, et que vous n'obtenez <em>aucun débordement</em> -- ces
        derniers sonneront toujours moins bien que les améliorations que
        vous essayez de faire.<br>
        La perception du volume étant logarithmique, l'utilisation de
        décalages logarithmiques est généralement suffisante. Si votre
        donnée est signée, vous devriez explicitement coder le décalage
        comme une division, l'opérateur C <code>&gt;&gt;</code> n'étant
        pas utilisable sur des données signées.
        </p>
        <p>
        Si tout le reste échoue, vous devriez au moins essayer de
        fournir à l'utilisateur une option de décalage du volume.
        </p>

        <h3><font color="#0000e0">Audio performance</font></h3>
        <p>
        Les applications dotées de fins basses n'ont habituellement pas
        à s'en soucier. Gardez en tête que certains d'entre nous
        utilisent OpenBSD en fin basse 68030, et que si une application
        sonore peut fonctionner sur cela, il faut qu'elle le fasse.
        </p>

        <p>
        N'oubliez pas de faire des comparatifs. Les optimisations
        théoriques ne sont que ceci : théoriques. Des figures
        significatives devraient être collectées pour vérifier ce qui
        est une amélioration majeure, et ce qui ne l'est pas.
        </p>

        <p>
        Pour les applications audio haute performance, comme
        mpegI-layer3, certains points doivent être pris en compte :
        </p>
        <ul>
            <li>L'interface audio vous procure la taille de bloc
            matériel naturelle. L'utilisation de plusieurs de ces
            dernières pour votre buffer de sortie est essentielle.
            Gardez en tête que <code>write</code>, en tant qu'appel
            système implique un coût élevé comparé aux traitements audio
            internes.

            <li>La bande passante est un facteur très important lorsque
            l'on traite en matière d'audio. Un moyen utile pour
            optimiser un lecteur audio est de le voir comme un
            décompresseur. Plus long vous pouvez gardez avec la donnée
            compressée, mieux c'est. De très courts sautsqui font de
            très petits traitements sont une mauvaise idée. Il est
            généralement mieux de combiner tous les traitements dans un
            seul saut.

            <li>Certains formats encourent plus de recouvrement que
            d'autres. La primitive <code>ioctl</code>
            <code>AUDIO_GETENC</code> devrait être utilisée pour
            reprendre tous les formats que l'interface audio procure.
            Rendez vous tout spécialement compte du drapeau
            <code>AUDIO_ENCODINGFLAG_EMULATED</code>. Si votre
            application est d'ores et déjà capable de restituer tous les
            types de formats étranges, et raisonnablement optimisée pour
            cela, essayez à tout prix d'utiliser un format natif. D'un
            autre côté, le code d'émulation présent dans le périphérique
            audio peut être considéré comme relativement optimal, et ne
            le remplacez pas par un code rapidement mis sur pieds. </ul>

        <p>Un modèle que vous pourriez avoir à suivre afin d'obtenir des
        résultats optimisés est de commencer par compiler un petit
        programme de test qui s'assure du matériel audio disponible, et
        procède ensuite à la configuration de votre programme pour qu'il
        traite de façon optimale le matériel audio disponible. Vous
        pourriez raisonnablement inciter les personnes voulant de bonnes
        performances audio à recompiler votre port quand ils changent de
        matériel, en s'assurant des changements. </p>

        <h3><font color="#0000e0">Temps réel ou synchronisé</font></h3>
        <p>
        Considérant que OpenBSD n'est pas temps réel, vous pourriez
        quand même vouloir écrire des applications audio souvent
        temps réel, comme par exemple les jeux. Dans ce cas, vous aurez
        à diminuer la taille des blocs afin que les effets sonores ne
        soient pas désynchronisés avec le jeu en court. Le problème avec
        ceci est le l'interface pourrait être affamée, entrainnant des
        rendements horribles. </p>
        <p>
        Dans le cas ou vous voudriez simplement que audio et graphismes
        soient synchronisés, et que le comportement de votre grogramme est
        prévisible, atteindre la synchronisation est chose facile. Vous jouez
        juste vos échantillons audio, et demandez au périphérique audio ce que
        vous êtes actuellement en train de jouer, via
        <code>AUDIO_GETOOFFS</code>, avant d'utiliser cette information
        pour synchroniser à l'avance les graphismes. Si vous demandez
        ceci suffisament fréquemment (disons, tous les dizièmes de
        seconde), et aussi longtemps que vous avez des ressources pour
        utiliser votre application, vous pouvez obtenir une très bonne
        synchronisation par ce moyen. Vous pourriez avoir à peaufiner
        les figures avec un décalage constant, il peut en effet y avoir
        des retards entre les informations rapportées par l'audio, ce
        qui se joue actuellement, et le temps mis par XWindow pour
        afficher quelquechose.
	</p>
  <h2><font color="#e00000">Contribution retour au code</font></h2>
   <p>Dans le cas d'applications audio, travailler avec l'auteur du
        programme est très important. Si son code ne marche par exemple
        qu'avec les cartes soundblaster, il y a de fortes chances pour
        qu'il faille faire face à d'autres technologies très
        prochainement.
        </p>

        <p>
        <strong>Si vous ne lui envoyez pas vos commentaires de cette
        manière, votre code aura été inutile</strong>.</p>
        <p>
        Il se pourrait aussi qu'il ait déjà notifié les problèmes que
        vous rencontrez, et qu'il s'y attèle dans l'arbre de
        développement. Si les patches que vous écrivez représentent plus
        qu'une poignée de lignes, la coopération est certainement une
        très bonne idée.
        </p>

  <hr>
  <a href="porting.html"><img height=24 width=24 src=../back.gif
   border=0 alt=Porting></a> 
  <a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
Originally [OpenBSD: audio-port.html,v 1.9 ]<br>
$Translation: audio-port.html,v 1.3 2004/11/07 08:55:00 saad Exp $<br>
$OpenBSD: audio-port.html,v 1.1 2004/11/07 13:21:10 saad Exp $
</small>
</body>
</html>
