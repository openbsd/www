<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
 <head>
  <meta http-equiv="Content-Language"
        content="de">
  <meta http-equiv="Content-Type"
        content="text/html; charset=iso-8859-1">
  <meta name="resource-type"
        content="document">
  <meta name="description"
        CONTENT="Wie man einen OpenBSD-Port erzeugt">
  <meta name="keywords"
        content="openbsd,ports">
  <meta name="distribution"
        content="global">
  <meta name="copyright"
        content="Dieses Dokument unterliegt dem Copyright von OpenBSD 1997 - 2004.">
<title>Das Erzeugen eines OpenBSD-Ports</title>
<link rev="made" HREF="mailto:www@openbsd.org">
</head>
<body text="#000000" bgcolor="#FFFFFF" link="#23238E">
<a href="index.html"><img alt="[OpenBSD]" height="30" width="141" src="../images/smalltitle.gif" border="0"></a>

  <h2><font color="#e00000">Das Erzeugen eines OpenBSD-Ports</font></h2>

   Du hast also gerade dein Lieblingssoftwarepaket auf deiner
   OpenBSD-Maschine kompiliert und möchtest deinen Erfolg mit anderen
   teilen, indem du davon einen Standard-Port machst? Was also ist
   jetzt zu tun?
  <p>
   Die wichtigste Sache, die du machen solltest, ist mit anderen zu
   <strong>kommunizieren</strong>. Frage die anderen Leute auf
   <a href="mailto:ports@openbsd.org">ports@openbsd.org</a>, ob sie am
   selben Port arbeiten. <em>Teile es dem ursprünglichen Programmierer
   mit</em>, inklusive der Probleme, wenn du welche findest. Wenn die
   Lizenzbedingungen nicht korrekt sind, sag es ihm. Wenn du große
   Schwierigkeiten hattest, den Port zum Laufen zu kriegen, teile ihm
   mit, was verbessert werden könnte. Wenn sie nur auf Linux entwickeln
   und den Rest der Unix-Welt ignorieren, versuche, ihre Sichtweise
   etwas zu erweitern.
  <p>
   <strong>KOMMUNIKATION</strong> macht den Unterschied zwischen einem
   erfolgreichen Port und einem Port, der langsam von allen alleine
   gelassen und nicht mehr benutzt wird, aus.
  <p>
   Sieh dir zuerst die Portierungsinformationen auf dieser Seite an.
   Dann überprüfe all die gelinkten Dokumente, insbesondere die
   OpenBSD-Porting-<a href="../checklist.html">Checkliste</a>.
  <p>
   Teste, teste nochmal und schlussendlich teste nochmals!
  <p>
   Liefere den Port aus (submit). Erzeuge einen ,gzipped tarball' des
   Port-Verzeichnisses. Du kannst diesen entweder auf einen
   öffentlichen FTP- oder HTTP-Server legen und die Addresse an
   <a href="mailto:ports@openbsd.org">ports@openbsd.org</a> mailen,
   oder den Port ,mime encoded' an die selbe Adresse schicken. Wähle
   einfach eine Methode aus.

<h3><font color="#0000e0">Index der Portierungsdokumentation</font></h3>
<ul>
<li><a href="#Avail">Verfügbare Portierungsinformation</a></li>
<li><a href="#Policy">OpenBSD-Portierungsrichtlinie</a></li>
<li><a href="#Security">Sicherheitsemfpehlungen</a></li>
<li><a href="#Generic">Allgemeine Portierungshinweise</a></li>
<li><a href="#Other">Andere hilfreiche Hinweise</a></li>
</ul>

  <h3><font color="#0000e0"><a name="Avail">Verfügbare Portierungsinformation</a></font></h3>
  <ul>
   <li>OpenBSD-Porting-<a href="../checklist.html">Checkliste</a>.
   <li>Die Manualseite
   <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bsd.port.mk&amp;sektion=5">bsd.port.mk(5)</a>.
       Sie dokumentiert die Makefile der Ports-Infrastruktur, die am
       Ende jeder individuellen Port-Makefile eingeschlossen wird.  
       Es gibt am Anfang noch ein paar Kommentare innerhalb der Datei
       selbst, aber die meisten der sinnvollen Informationen sind jetzt
       dokumentiert.
   <li>Einige Unterschiede zu den anderen BSD-Portsystemen,
   hautpsächlich eine Zusammenfassung
   der <a href="../porting/de/diffs.html">Infrastruktur-Unterschiede</a>.
   <li><a href="../porting/de/libraries.html">Das Benutzen von ,shared
   libraries' in OpenBSD-Ports</a>. Die Regeln sind <strong>sehr wichtig
   </strong> sobald du ,shared libraries' benutzt.
   <li><a href="../porting/de/autoconf.html">GNU-autoconf-Spezifikationen</a>,
       wie man sie im Gebrauch mit OpenBSD-Ports handhabt.
   <li><a href="../porting/de/config.html">Konfigurationsdateien</a>,
       ein häufiger Stolperstein für neue Entwickler und die
       einzigartigen Werkzeuge, die der OpenBSD-Ports-Tree besitzt, um
       diese zu verarbeiten.
   <li><a href="../audio-port.html">Das Portieren von
       Audio-Applikationen auf OpenBSD</a>.
   <li>Die
       <a href="http://www.netbsd.org/Documentation/software/packages.html">
       NetBSD Package System</a>-Dokumentation. Dieses Dokument
       beschreibt die NetBSD-Version des FreeBSD-Portsystems und ist
       recht hilfreich.
   <li>Das
       <a href="http://www.freebsd.org/doc/en_US.ISO8859-1/books/porters-handbook/index.html">FreeBSD
       Porter's Handbook</a>.  Das ist die FreeBSD-Porting-Bibel.
   <li>Die OpenBSD-Ports-Mailingliste
       <a href="mailto:ports@openbsd.org">ports@openbsd.org</a>.
  </ul>
  <h3><font color="#0000e0"><a name="Policy">OpenBSD-Portierungsrichtlinie</a></font></h3>
  <ul>
   <li>OpenBSD benutzt NICHT <code>/usr/local/etc/rc.d</code>.<br>
       <code>/usr/local</code> wird dank NFS oftmals von verschiedenen
         Maschinen benutzt.  Aus diesem Grund können
         Konfigurationsdateien, die spezifisch für eine bestimmte
         Maschine sind, auch nicht in <code>/usr/local</code> abgelegt
         werden, <code>/etc</code> ist die zentrale Lagerstätte für
         individuelle Maschinen-Konfigurationsdateien.
         Außerdem ist es eine OpenBSD-Richtlinie, niemals Dateien unter
         <code>/etc</code> automatisch upzudaten. Ports, die ein
         bestimmtes Boot-Setup benötigen, sollten den Administrator
         anweisen, was zu tun ist, anstatt blind Dateien zu
         installieren.
   <li>OpenBSD komprimiert KEINE Manualseiten.
   <li>OpenBSD benötigt KEIN <code>-lcrypt</code>.<br>
       DES ist Teil der Standard-<code>libc</code>.
   <li>OpenBSD hat einen separaten Namensraum für User und Gruppen, 
       die von Ports erzeugt werden.
       Siehe <code>/usr/ports/infrastructure/db/user.list</code> für
       genaue Details.
   <li>OpenBSD is stark sicherheitsorientiert. Du solltest die
       <a href="#Security">Sicherheitssektion</a> auf dieser Seite
       lesen und verstehen.
   <li>Stelle sicher, dass der <code>&#36;OpenBSD&#36;</code>-CVS-Tag
       in die Makefile eingefügt wird. Wenn du einen Port von einem
       anderen System importierst, stelle sicher, dass du auch ihren
       Tag in der Makefile belässt.
   <li>Das Ziel ist, dass alle portierten Anwendungen OpenBSD
       unterstützen. Um dieses Ziel zu erreichen,
       <strong>musst</strong> du alle OpenBSD-Patches auch zurück an
       den ursprünglichen Programmierer zurückliefern.
  </ul>
  <h3><font color="#0000e0"><a name="Security">Sicherheitsempfehlungen</a></font></h3>
  Es gibt viele Sicherheitsprobleme, über die man sich Gedanken machen
       muss. Wenn du nicht absolut sicher bist, was du tust, frage
       bitte auf der
       <a href="mailto:ports@openbsd.org">Ports</a>-Mailingliste um
       Hilfe.

  <ul>
   <li>Benutze <em>keinen</em> Alpha- oder Beta-Code, wenn du einen
       Port vorbereitest. Benutze die letzte reguläre Version oder die
       letzte gepatchte.	 

   <li>Jegliche Software, die auf einem Server installiert werden soll,
       sollte auf Pufferüberläufe (buffer overflows) untersucht werden,
       insbesondere unsichere Benutzung von 
       <code>strcat/strcpy/strcmp/sprintf</code>. Im Allgemeinen sollte
       <code>sprintf</code> durch <code>snprintf</code> ersetzt werden.

   <li>Benutze niemals Dateinamen statt echter Sicherheit. Es gibt
       zahlreiche ,race conditions', in denen du keine saubere
       Kontrolle mehr hast. Ein Angreifer, der bereits normale
       Benutzerrechte auf deiner Maschine hat, könnte Dateien in 
       <code>/tmp</code> mit symbolischen Links auf strategischere
       Dateien setzen, wie etwa <code>/etc/master.passwd</code>.  

   <li>Zum Beispiel erzeugen sowohl <code>fopen</code> als auch
       <code>freopen</code>
       <strong>eine neue Datei oder öffnen eine bereits
       existierende</strong> zum Schreiben. Ein Angreifer könnte einen
       symbolischen Link von <code>/etc/master.passwd</code> auf
       <code>/tmp/addrpool_dump</code> setzen. Sofort wenn du ihn
       öffnest ist deine Passwortdatei verraten. Ja, sogar mit einem 
       <code>unlink</code> direkt davor. Du kannst nur die Anzahl der
       Möglichkeiten verringern.  Benutze stattdessen
       <code>open</code> mit <code>O_CREAT|O_EXCL</code> und
       <code>fdopen</code>.
                 
   <li>Ein weiteres sehr bekanntes Problem ist die
       <code>mktemp</code>-Funktion. Beachte die Warnungen des
       ,bsd linker's bei ihrer Benutzung.
       <strong>Die müssen gefixed werden</strong>. Das ist nicht ganz
       so einfach wie <code>s/mktemp/mkstemp/g</code>.  <br>
       Sieh dir die <code>mktemp(3)</code>-Manualseite von
       OpenBSD-current für mehr Hinweise an.
       Korrekter Code, der <code>mkstemp</code> benutzt, schließt den
       Source zu <code>ed</code> oder <code>mail</code> ein.
       Eine seltenes Beispiel an Code, der <code>mktemp</code> korrekt
       benutzt, kann im <code>rsync</code>-Port gefunden werden.

   <li>Nur weil du etwas lesen kannst heißt es nicht, dass du das
       solltest. Eine sehr bekannte Lücke dieser Art war das
       <code>startx</code>-Problem. Als setuid-Programm konntest du
       startx mit jeder Datei als Skript starten. Wenn die Datei kein
       sauberes Shellskript war, folgte eine Fehlermeldung zusammen mit
       der ersten Zeile der betreffenden Datei, ohne weitere Überprüfung
       der Rechte. Ziemlich einfach die erste Zeile der
       shadow-passwd-Datei zu erhalten, besonders wenn man bedenkt, dass
       die erste Zeile meist den root-Eintrag enthält.
       Öffne nicht deine Datei, um dann ein <code>fstat</code> auf den
       ,open descriptor' zu machen, um zu überprüfen, ob du sie hättest
       öffnen können müssen (oder der Angreifer wird mit /dev/rst0
       spielen und dein Band zurückspulen) -- öffne es mit korrekt 
       gesetzter uid/gid/grouplist.

   <li>Tue nichts, was eine Shell im Hintergrund von setuid-Programmen
       forkt bevor du deine Rechte zurücksetzt. Das schließt
       <code>popen</code> und 
       <code>system</code> ein.  
       Benutze stattdessen <code>fork</code>, <code>pipe</code> und
       <code>execve</code>.

   <li>
       Gebe ,open descriptors' anstatt von Dateiname an andere Programme
       weiter, um ,race conditions' zu vermeiden. Sogar wenn ein
       Programm keine 'file descriptors' akzeptiert, kannst du immernoch
       <code>/dev/fd/0</code> benutzen.

   <li>Zugriffsrechte sind an ,file descriptors' gebunden. Wenn du
       setuid-Rechte setzen musst, um eine Datei zu öffnen, öffne die
       Datei, dann lass deine Rechte fallen. Du kannst nach wie vor auf
       den ,open descriptor' zugreifen, aber du musst dir um ihn weniger
       Sorgen machen. Das hat aber zwei Seiten: auch nachdem du die
       Rechte fallenlassen hast, solltest du noch auf die ,descriptors'
       aufpassen.

   <li>Vermeide root-setuid wo du nur kannst. Grundsätzlich kann root
       alles tun, aber root-Rechte werden nur sehr selten wirklich
       benötigt, vielleicht mit Ausnahme vom Erzeugen von Sockets mit
       einer Nummer kleiner 1024. Es ist beutend besser, das
       <code>inetd</code> zu überlassen und nur die relevanten Einträge
       in <code>inetd.conf</code> zu machen.  Du musst natürlich die
       erforderliche Magie zum Schreiben von Daemonen kennen, um das zu
       erreichen. Man könnte sagen, dass du keinerlei Chancen hast, ein
       gutes setuid-Programm zu schreiben, wenn du nicht weißt, wie man
       das macht.

   <li>Benutze setgid anstelle von setuid. Abgesehen von diesen
       bestimmten Dateien, die von setgid-Programmen benötigt werden,
       sind die meisten Dateien nicht ,group-writable'. Daher werden
       Sicherheitsprobleme in einem setgid-Programm dein System nicht
       bedrohen: nur mit Gruppenrechten wird das schlimmste, was ein
       Angreifer anrichten kann, das Hacken einer Score-Tabelle in einem
       Spiel oder etwas ähnliches sein. Siehe auch den
       <code>xkobo</code>-Port für ein Beispiel einer solchen Änderung.

   <li>Vertraue keinen ,group-writable' Dateien.  Auch wenn sie geprüft
       wurden, werden setgid immer noch als wichtige potentielle
       Sicherheitslöcher betrachtet. Von daher sollten Informationen,
       die hiervon berührt werden nicht als sensitive Information
       betrachtet werden. 

   <li>Vertraue nicht deiner Umgebung! Das schließt einfache Dinge wie
       etwa deinen <code>PATH</code> ein (benutze niemals
       <code>system</code> mit einem unqualifizierten Namen, vermeide
       <code>execvp</code>), es betrifft aber auch solche feinen Dinge
       wie locale, timezone, termcap, und so weiter. Sei vorsichtig mit
       ,transitivity': Auch wenn du alle Vorsichtsmaßregeln triffst,
       machen das Programme, die du aufrufst, noch lange nicht.
       Benutze <strong>niemals</strong> <code>system</code> in
       privilegierten Programmen, baue eine saubere Kommandozeile,
       eine kontrollierte Umgebung und rufe <code>execve</code> direkt
       auf. Die <code>perlsec</code>-Manualseite ist ein gutes Tutorium
       über solche Probleme.

   <li>Benutze niemals setuid-Shellskripte. Sie sind vererbliche
       Sicherheitslücken. Schließe sie in C-Code ein, der eine saubere
       Umgebung sicherstellt. Auf der anderen Seite gibt es unter
       OpenBSD auch die sicheren Perl-Skripte.

   <li>Nimm dich vor dem ,dynamic loader' in Acht. Wenn du ihn mit
       setuid laufen lässt, wird er nur vertraenswürdigen Bibliotheken
       trauen, die mit ldconfig gescannt wurden. Setgid ist nicht genug.

   <li>Dynamische Bibliotheken sind schwierig. C++-Code stellt ein
       ähnliches Problem dar. Grundsätzlich könnten Bibliotheken einige
       Dinge basierend auf deiner Umgebung tun, sogar bevor dein
       Hauptprogramm dazu kommt, seinen setuid-Status zu checken.   
       OpenBSD-<code>issetugid</code> kümmert sich um dieses Problem
       vom Standpunkt eines-Bibliotheks-Autors aus. Versuche nicht
       Bibliotheken zu portieren, bis du diesen Punkt wirklich
       absolut verstanden hast.	 
  </ul>
  <h3><font color="#0000e0"><a name="Generic">Allgemeine Portierungshinweise</a></font></h3>
  <ul>
   <li><code>__OpenBSD__</code> sollte sparsam benutzt werden, wenn
       überhaupt. Konstruktionen, die wie
       <pre>
            #if defined(__NetBSD__) || defined(__FreeBSD__)
       </pre>
       aussehen, sind oft unpassend. Füge nicht blindlings
       <code>__OpenBSD__</code> hinzu. Versuche stattdessen
       herauszufinden, was vor sich geht und welche Funktionalität
       tatsächlich gebraucht wird. Manualseiten sind oftmals hilfreich,
       da sie historische Kommentare enthalten und darstellen, wann eine
       spezielle Funktionalität in OpenBSD eingefügt wurde. Den
       numerischen Wert von <code>BSD</code> gegen bekannte
       Versionen/Zahlen zu prüfen ist meistens der richtige Weg. Der
       <a href="ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/Packages.txt">NetBSD package guide</a>
       enthält noch weitere Informationen.
   <li><code>BSD</code> zu definieren ist eine schlechte Idee. Versuche
       <code>sys/param.h</code> einzubinden. Das definiert nicht nur
       <code>BSD</code>, sondern gibt auch einen sauberen Wert.
       Das richtige Codefragment sollte etwa so aussehen:
       <pre>
           #if (defined(__unix__) || defined(unix)) &amp;&amp; !defined(USG)
           #include &lt;sys/param.h&gt;
           #endif
       </pre>
   <li>Teste, ob Funktionalitäten vorhanden sind, und nicht nach
       bestimmten Betriebssystemen. Auf lange Sicht ist es besser zu
       erfahren, ob <code>tcgetattr</code> funktioniert, als zu
       erfahren, ob man gerade auf 4.3 BSD oder später oder etwa
       SystemVR4 arbeitet. Diese Art von Test trifft einfach nicht den
       Punkt. Ein sinnvoller Weg wäre zum Beispiel auf ein bestimmtes
       System zu testen, eine Runde von <code>HAVE_TCGETATTR</code> zu
       definieren und dann mit dem nächsten System weiterzumachen.
       Diese Technik trennt die Funktionalitätstests von denen auf
       spezielle Betriebssysteme. In großer Eile kann ein anderer
       Portierer das ganze Set an <code>-DHAVE_XXX</code>-Definitionen
       zur Makefile hinzufügen. Man könnte das auch selber schreiben
       oder im configure-Skript testen und es dann automatisch 
       hinzufügen. Als negatives Beispiel, dem man _nicht_ folgen
       sollte, kann der nethack-3.2.2-Source dienen: er nimmt jede
       Menge Dinge basierend auf dem Systemtyp an. Die meisten dieser
       Annahmen sind veraltet und haben nichts mehr mit der Realität zu
       tun: POSIX sind nützlicher als alte
       BSD-versus-SystemV-Unterschiede, da einige traditionelle
       BSD-Funktionen jetzt nur noch durch
       Kompatibilitäts-Bibliotheken unterstützt werden.

   <li>Vermeide include-Dateien, die andere includes enthalten, die
       wiederum andere ... Erstens weil es uneffizient ist. Dein Projekt
       wird mit einer Datei enden, die alles andere ,included'. Und
       außerdem werden dabei Probleme erzeugt, die schwierig zu beheben
       sind. Es wird schwieriger an einem bestimmten Punkt
       <em>nicht</em> eine bestimmte Datei mit einzubinden.

   <li>Vermeide bizarre macro-Tricks. 'Undefining' eines Makros, das von
       einer Header-Datei definiert wurde, ist eine schlechte Idee. Das
       Definieren eines Makros, um ein spezielles Verhalten von einer
       include-Datei zu bekommen, ist auch eine schlechte Idee: 
       Kompiliermodi sollten global sein. Wenn du POSIX-Verhalten willst,
       teile es mit, indem du <code>#define POSIX_C_SOURCE</code> im
       ganzen Projekt einsetzt, nicht nur wenn dir danach ist.

   <li>Schreibe niemals ,system function prototypes'.  Alle modernen
       Systeme, inklusive OpenBSD, haben einen Standardplatz für diese
       ,prototypes'. Wahrscheinliche Plätze sind etwa
       <code>unistd.h</code>, <code>fcntl.h</code> oder
       <code>termios.h</code>. Die Manualseite zeigt regelmäßig wo die
       ,prototypes' zu finden sind. Du könntest noch eine Runde
       <code>HAVE_XXX</code>-Makros benötigen, um die richtige Datei zu
       beschaffen. Mach dir keine Sorgen darum , dass du eine Datei
       zweimal 'includen' könntest, include Dateien haben Aufpasser, die
       solchen Unfug verhindern.<br>
       Falls irgendein kaputtes System von dir verlangt, den ,prototype'
       zu schreiben, dehne das nicht gleich auf alle anderen Systeme
       aus. ,Roll-your-own prototypes' werden nicht funktionieren, da
       sie Typen benutzen könnten, die auf deinem Sytem funktionieren,
       aber eben nicht auf andere Systeme portierbar sind;
       (<code>unsigned long</code> anstelle von <code>size_t</code>)
       benutzen, oder einen <code>const</code>-Status falsch verstehen.
       Außerdem sind einige Compiler, so wie auch OpenBSDs gcc, 
       in der Lage, bessere Arbeit mit sehr oft verwendeten Funktionen
       wie <code>strlen</code> zu leisten, wenn man die richtigen
       header-Dateien einbindet.

   <li>Benutze nicht den Namen einer Standard-Systemfunktion für
       irgendetwas anderes. Wenn du deine eigene Funktion schreiben
       willst, gib ihr einen eigenen Namen und rufe diese Funktion
       überall auf. Wenn du zur Standard-Systemfunktion zurückkehren
       willst, musst du nur deinen Code auskommentieren und den Namen
       wieder auf die Systemfunktion zurückschreiben. Mach es nicht
       andersherum. Der Code sollte etwa so aussehen:
<pre>
       /* ,prototype'-Teil */
       #ifdef USE_OWN_GCVT
       char *foo_gcvt(double number, size_t ndigit, char *buf);
       #else
       /* die richtige Datei einbinden */
       #include &lt;stdlib.h&gt;
       /* use system function */
       #define foo_gcvt  gcvt
       #endif

       /* ,definition'-Teil */
       #ifdef USE_OWN_GCVT
       char *foo_gcvt(double number, size_t ndigit, char *buf)
          {
          /* proper definition */
          }

       /* typische Verwendung */
       s = foo_gcvt(n, 15, b);
       </pre>
  </ul>
  <h3><font color="#0000e0"><a name="Other">Andere hilfreiche Hinweise</a></font></h3>
  <ul>
   <li>Neuere Versionen von <code>bsd.port.mk</code> setzen den
       Installer-Pfad. Sie sorgen insbesondere dafür, dass
       <code>/usr/bin</code> und <code>/bin</code> <em>vor</em>
       <code>/usr/local/bin</code> und <code>/usr/X11R6/bin</code>
       durchsucht werden.
   <li>Erzeuge <em>KEINE</em> ,shared libraries' wenn
       <code>${NO_SHARED_LIBS}</code> auf YES gesetzt ist (Vorsicht: es
       kann nur nach der Einbindung von <code>bsd.port.mk</code>
       definiert werden). Wenn dein Port ein
       GNU-configure benutzt, füge einfach die Zeile
       <code>CONFIGURE_ARGS += ${CONFIGURE_SHARED}</code> in die
       Makefile ein.
   <li>Es ist in Ordnung eine erst neulich hinzugefügte Funktionalität
       von <code>bsd.port.mk</code> zwingend zu benötigen, da die Leute
       sowieso ihren Ports-Tree mitsamt <code>bsd.port.mk</code>
       updaten sollten. NEED_VERSION ist von nun an hinfällig.
   <li>Bevorzuge <code>update-plist</code>, um Paketlisten zu generieren
       und zu aktualisieren, anstatt diese Dinge per Hand zu erledigen.
       Du kannst die unerwünschten Zeilen auskommentieren.
       <code>update-plist</code> kann die meisten Dateitypen alleine
       erkennen und die meisten zusätzlichen ,annotations' korrekt
       kopieren.
   <li>Füge <code>USE_SYSTRACE=Yes</code> in <code>/etc/mk.conf</code>
       ein, um fehlfunktionierende Skripte, Makefiles, etc. zu
       entdecken.
   <li>In OpenBSD sind <code>curses.h/libcurses/libtermlib</code> die
       ,neuen curses'.  Ändere:<br>
       <code>ncurses.h ==&gt; curses.h</code><br>
       ,old (BSD) curses' ist durch das Definieren von
       <code>_USE_OLD_CURSES_</code> verfügbar
       und zwar vor dem Einbinden von <code>curses.h</code> (für
       gewöhnlich in einer Makefile) und dem Linken mit
       <code>-locurses</code>.
   <li>In OpenBSD wurden die Terminals von den alten
       BSD-<code>sgtty</code> zur neuen
       POSIX-<code>tcgetattr</code>-Familie umgestellt. Vermeide den
       alten Stil in neuem Code. Es kann Code geben, der  
       <code>tcgetattr</code> als Synonym für das ältere  
       <code>sgtty</code> definiert, aber das ist auf OpenBSD höchstens
       eine kurzfristige Methode.  
       Der <code>xterm</code>-Quelltext ist ein sehr gutes Beispiel,
       wie man es nicht machen sollte. Versuche deine
       Systemfunktionalität richtig hinzubekommen: Du
       willst ja einen Typen, der den Status deines Terminals behält 
       (möglicher typedef), du willst eine Funktion, die den momentanen
       Status herausfindet, und eine Funktion, die den neuen Status
       setzt. Funktionen, die diesen Status modifizieren sind
       schwieriger als es den Anschein hat, da sie dazu tendieren, von
       System zu System unterschiedlich zu sein. Vergiss auch 
       nicht, dass du Fälle behandeln musst, bei denen du gar nicht an
       einem  Terminal angeschlossen bist, und in denen du ,signals'
       behandeln musst: nicht nur das Beenden, sondern auch 
       (<code>SIGTSTP</code>) im Hintergrund. Du solltest das Terminal
       immer in einem sauberen Zustand belassen. Mach die Tests unter
       einer alten Shell, wie etwa sh, die das Terminal nicht gleich in
       allen Fällen zurücksetzt, nachdem das Programm beendet wurde.
   <li>Die neueren termcap/terminfo und curses, wie sie Teil von
       OpenBSD sind, beinhalten Standardsequenzen für das Kontrollieren
       von Farb-Terminals. Wenn möglich benutze diese, kehre auf
       anderen Systemen auf die ANSI-Farbsequenzen zurück. Trotzdem
       sind noch nicht alle Terminalbeschreibungen auf dem neuesten
       Stand, und du musst möglicherweise in der Lage sein, diese
       Sequenzen von Hand zu bearbeiten. So macht es vim. Das ist aber
       nicht unbedingt notwendig. Mit Ausnahme von privilegierten
       Programmen ist es generell möglich, eine termcap-Definition
       durch die <code>TERMCAP</code>-Variable zu übersteuern 
       und sie dadurch zu sauberem Arbeiten zu bringen.
   <li>Signal-Semantiken sind schwierig und von System zu System
       verschieden.
       Benutze <code>sigaction</code>, um spezifische Semantiken zu
       bekommen, zusammen mit anderen Systemaufrufen, die in der
       entsprechenden Manualseite aufgeführt werden.
  </ul>
  <hr>
<a href="index.html"><img height=24 width=24 src=../back.gif border=0 alt=OpenBSD></a> 
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br><small>
<!--
Originally [OpenBSD: porting.html,v 1.52 ]
$Translation: porting.html,v 1.35 2005/09/09 11:31:21 paldium Exp $
-->
$OpenBSD: porting.html,v 1.34 2005/09/11 06:04:11 saad Exp $
</small>
</body>
</html>
