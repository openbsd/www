<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta name="generator" content="HTML Tidy, see www.w3.org">
<meta http-equiv="Content-Type" content=
"text/html; charset=iso-8859-1">
<meta name="resource-type" content="document">
<meta name="description" content=
"Differences with other BSD porting systems.">
<meta name="keywords" content="openbsd,ports">
<meta name="distribution" content="global">
<meta name="copyright" content="This document copyright 2000 by OpenBSD.">
<title>Unterschiede zu anderen BSD Port Systemen</title>
</head>
<body text="Black" bgcolor="White" link="#23238E">
<img height="30" width="141" src="../../images/smalltitle.gif" alt=
"[OpenBSD]"> 

<h1>OpenBSD Porting Informationen</h1>

<h2><font color="#e00000">Wichtige Unterschiede zu anderen
BSD Projekten</font></h2>

<p>
NetBSD benutzt den Ausdruck <em>ports</em> für Architektur-abhängige
Dinge. Ihre ports Struktur heisst stattdessen <em>packages</em>. 
</p>

<h3>Extra support</h3>
Die porting Infrastructure enthält verschiedene Skripte, die das
Erzeugen neuer Ports erleichtern: 
<dl>
<dt>build/resolve-lib
    <dd>aufgerufen durch <code>make lib-depends-check</code>, um Abhängigkeiten
    von shared libraries zu überprüfen.
<dt>build/update-patches
    <dd>aufgerufen durch <code>make update-patches</code>, das immer benutzt
    <strong>werden sollte um die Patches neu zu erzeugen.</strong>
<dt>install/make-plist
    <dd>aufgerufen durch <code>make update-plist</code>. Hier wird sich
    sich um die meisten kleinen Punkte gek&uml;mmert, mit denen man 
    akkurate Packing-Lists erzeugt. OpenBSD packing-lists sind deutlich verschieden
    von anderen BSDs, zum Teil auch, weil die package tools vollkommen neu geschrieben wurden.
</dl>


<h3>Infrastruktur</h3>

<p>
OpenBSD's make unterstützt <code>${VAR:U}</code> und
<code>${VAR:L}</code> um den Wert einer Variablen in Groß- oder
Kleinschreibung zu ändern. Dementsprechend sollte 'make test' 
auch unabhängig von Gross- und Kleinschreibung programmiert sein,
also z.B.:
</p>

<pre>
	.if ${NEED_XXX:L} == "yes"
	do stuff if yes
	.else
	do other stuff
	.endif
</pre>

<p>
In der Theorie sollten alle Boolean Variablen, die von
<code>bsd.port.mk</code> erkannt werden auch definiert sein,
so dass Code should wie
<code>defined(USE_FOO)</code> nicht notwendig sein sollte.
<code>${USE_FOO:L} != "no"</code> müsste funktionieren.
</p>

<p>
Die Haupt <code>bsd.port.mk</code> Datei wurde deutlich verändert und
schlanker gemacht. Insbesondere ist sie jetzt bereit für 
parallel-make. 
Das <code>scripts/{pre,do,post}-*</code> Feature ging während des Prozesses
verloren. Um das Skript wieder auferstehen zu lassen, rufe es per Hand aus dem
Makefile auf.
</p>

<h3>make sauber benutzen</h3>

<p>
Denk daran, wenn du make mit <code>make VAR=value</code> aufrufst, wird 
die Zuweisung jeden Wert <em>überschreiben</em> den VAR vom Makefile
erhalten kann. Also sind viele Makefile patches nicht mehr notwendig, es ist viel
besser die MAKE_FLAGS korrekt zu setzen, um den Wartungsaufwand zu verringern.
</p>

<h3>Sources holen</h3>

<p>
Es gibt zwei Arten von Archiven: DISTFILES und PATCHFILES.
OpenBSD behandelt sie in gleicher Art und Weise, und holt standardmässig alles
von den MASTER_SITES. Es gibt <strong>keine</strong> 
PATCH_SITES oder PATCH_SITES_SUBDIR.
</p>

<p>
Wenn nicht alle zu holenden Dateien von der selben Site kommen, erlaubt
OpenBSD die erweiterten Dateinamen:0 bis Dateiname:9, in diesem Fall wird
es die Dateien von den
MASTER_SITES0 bis MASTER_SITES9 holen.
</p>

<p>
Manche Architekturen benötigen möglicherweise spezielle distfiles. In der Vergangenheit
gab es Probleme damit, soweit das Spiegeln von distfiles betroffen war. OpenBSD
unterstützt eine dritte Art von Dateien: SUPDISTFILES. Diese werden nur
zum Erzeugen von Checksummen und beim Spiegeln verwendet. Denk dran, dass
SUPDISTFILES möglicherweise mit DISTFILES oder PATCHFILES kollidieren.
Z.B.: 
</p>

<pre>
	DISTFILES=foo-1.0.tgz
	.if ${ARCH} == "i386"
	DISTFILES+=foo-i386.tgz
	.elif ${ARCHI} == "sparc"
	DISTFILES+=foo-sparc.tgz
	.endif
	SUPDISTFILES=foo-i386.tgz foo-sparc.tgz
</pre>

<h3>Die <code>WRKDIR</code>-Infrastruktur</h3>

<p>
Wir wollen nicht, dass ports <code>NO_WRKDIR</code> benutzen. Alle OpenBSD
ports müssen ein 'work directory' haben. Die Details der Namensgebung sollten
keine Angelegenheit des porters sein. Wenn du einen solchen Namen erfahren musst, 
frage einfach das Makefile:
<code>cd that_ports_dir
&amp;&amp; make show VARNAME=WRKDIR</code> wird die Vorstellung des Codes von seinem 
<code>WRKDIR</code> offenlegen.
</p>

<p>
Der Hauptgrund hinter dieser Annahme ist, dass OpenBSD's
<code>bsd.port.mk</code> wie ein echtes Makefile agiert, allerdings mit ein paar Abhängigkeiten.
Die <code>fetch</code> Stufe hängt von den distfiles und patchfiles ab, alle anderen Stufen
sind von echten Dateien im 'working directory' (cookies) abhängig, so dass sie gar nicht ohne
ein 'working directory' existieren können.
</p>

<p>
Wenn die DISTFILES Extraktion speziell ist, setze
</p>

<pre>
EXTRACT_ONLY=
</pre> 

<p>
und mache die Extraktion in <code>post-extract.</code>
</p>

<dl>
<dt>WRKDIR</dt>

<dd>Das port working directory, wo es seine eigenen cookies unterbringt.
</dd>

<dt>WRKDIST</dt>

<dd>Unterverzeichnis von WRKDIR indem der port tatsächlich ausgepackt wird.
Das ist auch das Basisvberzeichnis für Patches. Andere BSD's haben zur Zeit keine
WRKDIST/WRKSRC Aufteilung, sondern nur
WRKSRC.</dd>

<dt>WRKSRC</dt>

<dd>Unterverzeichnis von WRKDIST in dem der tatsächliche Source
lebt.</dd>

<dt>WRKBUILD</dt>

<dd>Unterverzeichnis von WRKDIR wo das Konfigurieren und Erzeugen (build) des port
geschehen wird. Andere BSD's haben die WRKBUILD/WRKSRC Aufteilung nicht.
Programme, die (größtenteils) auf autoconf basieren, können für 
gewöhnlich SEPARATE_BUILD setzen, damit der port in einem anderen Verzeichnis
(WRKBUILD) als
WRKSRC geschieht.</dd>

<dt>WRKINST</dt>

<dd>Verzeichnis, in dem der port installiert wird, bevor er gepackt wird (packaged)
(siehe auch 'Faking ports' weiter unten).</dd>
</dl>

<p>
<em>Denk dran, dass es NO_WRKSUBDIR nicht mehr gibt: seine Funktionalität kann stattdessen
mit dem Setzen von  WRKDIST=$(WRKDIR) erreicht werden.</em>
</p>

<h3>Faking ports</h3>

<h4>Einführung</h4>

<p>
Nachdem ein 'build' komplett ist gehen andere BSDs dazu über den port
zu installieren, und erzeugen dann ein package vom installierten port.
OpenBSD benutzt stattdessen 'faked installation'.
</p>

<ul>
<li>Ein OpenBSD port wird ganz normal konfiguriert und erzeugt (z.B., um unter
<code>PREFIX</code> installiert zu werden, normalerweise
<code>/usr/local</code>).</li>

<li>Aber es wird ihm gesagt, er solle sich woanders installieren, namentlich unter WRKINST, was für
gewöhnlich ein Unterverzeichnis von WRKDIR ist.</li>

<li>Dann wird die angebliche Installation gepackt (packaged), indem die -B Option von
pkg_create benutzt wird.</li>

<li>Schlussendlich wird das daraus resultierende Paket (package) mittels pkg_add installiert.</li>
</ul>

<h4>Vorteile</h4>

<ul>
<li>Für einen 'package builder' bedeutet es, dass die meisten ports
nicht wirklich installiert werden müssen, was eine Menge potentieller
Kompromisse und allgemeine Probleme vermeidet.
Es erlaubt auch das Erzeugen von mehreren Paketen, die einen Konflikt erzeugen,
d.h. zum Beispiel verschiedene Versionen derselben Software, auf einer Maschine.
Schlussendlich erlaubt es das Erzeugen von neuen, ungestesteten Paketen ohne
eine funktionierende Installation zu gefährden.
</li>

<li>Für einen 'port writer' vereinfacht es das Ziel Probleme in den
'packing lists' zu finden, da die 'fake area of installation' leer ist,
bevor der port installiert wird. Zudem ist es nicht mehr nötig die port
Installation zu beeinflussen, wenn ein port zu viele Dateien installiert, es reicht
die unwesentlichen Dateien einfach nicht in der 'packing list' aufzuführen.</li>

<li>Für den User verbessert es die Qualität der packages: da der letzliche port
mit pkg_add installiert wird, erhält der User 
<em>exakt</em> die gleiche Software, wie die, die auf der Maschine des porters vorbereitet wurde.
</li>
</ul>

<h4>Wie man es macht</h4>

<p>
Die Ziele (targets), die <code>make fake</code> aufruft, sind die üblichen
Installationsziele, mit einigen Ausnahmen : 
</p>

<ul>
<li>FAKE_FLAGS wird anstelle von MAKE_FLAGS benutzt. Standardmässig setzt
FAKE_FLAGS auf DESTDIR=${WRKINST}.</li>

<li>FAKE_TARGET wird anstelle von INSTALL_TARGET benutzt.</li>

<li>Die {pre,do,post}-Installationsfragmente werden mittels Setzen von TRUEPREFIX
auf $(PREFIX), PREFIX auf $(WRKINST)$(PREFIX), und DESTDIR
auf $(WRKINST) in Gang gebracht.</li>
</ul>

<p>
Ports, die imake benutzen, sollten so wie sie sind funktionieren, da die imake Fragmente 
konfiguriert sind, um DESTDIR zu benutzen. Genauso sollten neuere GNU configure ports
keine Änderungen benötigen.
</p>

<p>
Eine weitere gute Technik ist ein `late binding' Trick: konfiguriere die
ports so, dass sie einen Präfix von $(DESTDIR)/usr/local benutzen, so dass das resultierende
Makefile den Präfix 
</p>

<pre>
prefix=$(DESTDIR)/usr/local
</pre>
<p>
hat. Wenn der 'port' erzeugt wird, und DESTDIR nichts enthät, wird /usr/local benutzt.
Und die fake-Installation wird alles unter
WRKINST/usr/local installieren (also für GNU configure benutze 
<code>CONFIGURE_STYLE= gnu dest</code>).
</p>

<h4>Fallen</h4>

<ul>
<li>Einige ports sind inkonstistent in ihrer DESTDIR Verarbeitung: die 
meisten Teile des port sind zufrieden mit dem gesetzten DESTDIR, mit Ausnahme
von zwei oder drei Ausreissern. Patche das Problem weg.</li>

<li>Unterscheide immer die wirkliche Stelle, an der port installiert wird und
die, die in den Konfigurationsdateien des packages aufgeführt ist.
Das kann man leicht übersehen, ist aber leicht durch die Verwendung von
TRUEPREFIX zu vermeiden.</li>

<li>Absolute Symlinks müssen immer angepasst werden. Glücklicherweise 
wird <code>bsd.port.mk</code> hier alle Probleme bemerken.</li>

<li>Ein paar ports wollen $(DESTDIR) nicht alleine dem 
configure Schritt überlassen. Ein post-configure Fragment, dass allen 
Makefiles das DESTDIR hinzufügt wird benötigt.</li>

<li>Sehr selten wird ein port allen vernünftigen Versuchen widerstehen, FAKE
zu benutzen. Ein Versuch mit roher Gewalt sollte funktionieren: benutze pre-fake
um alles, was der port im WRKINST Bereich benötigt, zu linken oder zu kopieren,
danach installiere unter chroot.</li>
</ul>

<h3>Flavors</h3>

<p>
Options wurden zu flavors zusammengefasst, so dass das Erzeugen von packages
(package building) konsistent sein kann.
Ein port mit options sollte FLAVORS all der
Optionen setzen, die Sinn für diesen port machen (also
FLAVORS=foo bar zoinx); benutze 'FLAVOR' um zu testen, welche Optionen
tatsächlich gesetzt wurden (also: FLAVOR=zoinx foo).
<code>bsd.port.mk</code> bietet einige Unterstützung: 
</p>

<ul>
<li>Der PKGNAME wird angepasst, um mit Bindestrich getrennte Optionen zu enthalten(z.B.,
package-foo-zoinx).</li>

<li>Das WRKDIR wird so angepasst, dass konkurrierende flavors erzeugt werden können,
ohne zu kollidieren.</li>

<li>Konstrukte der Form %%flavor%% werden die Einbeziehung von pfrag.Flavor auslösen. 
Das %%SHARED%% Konstrukt löst die Einbeziehung von PFRAG.shared aus.</li>

<li>bsd.port.subdir.mk versteht die Erweiterung von
SUBDIR=directory,opt1,opt2  um sagen zu wollen: `baue den port in directory mit
FLAVOR=opt1 opt2.'</li>
</ul>

<p>
Zu überprüfen, ob ein gegebener flavor ausgewählt wurde, ist recht leicht: 
</p>

<pre>
.if ${FLAVOR:L:Mzoinx}
</pre>

Es gibt eine Extra-Erweiterung namens MULTI_PACKAGES.
Allgemein gesagt sind MULTI_PACKAGES und FLAVORS orthogonale 
Mechanismen, also ergäzend.
Zusammen sorgen sie dafür, dass der OpenBSD ports tree 
kleiner ist als der das anderen BSDs, da sie dafür sorgen,
dass ein einzelner Port viele verschiedene packages erzeugen
kann.
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bsd.port.mk&amp;sektion=5&amp;format=html">bsd.port.mk(5)</a>
enthält eine ganze Sektion zu FLAVORS und MULTI_PACKAGES.

<hr>
<small>
Originally [OpenBSD: diffs.html,v 1.17 ]
<br>
$Translation: diffs.html,v 1.14 2004/11/04 16:32:20 jufi Exp $
<br></small>
<small>$OpenBSD: diffs.html,v 1.15 2004/11/04 17:18:16 jufi Exp $</small>
</body>
</html>
