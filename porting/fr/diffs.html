<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta name="generator" content="HTML Tidy, see www.w3.org">
<meta http-equiv="Content-Type" content=
"text/html; charset=iso-8859-1">
<meta name="resource-type" content="document">
<meta name="description" content=
"Différences avec les autres systèmes de ports BSD.">
<meta name="keywords" content="openbsd,ports">
<meta name="distribution" content="global">
<meta name="copyright" content="This document copyright 2000 by OpenBSD.">
<title>Différences avec les autres systèmes de ports BSD</title>
</head>
<body text="Black" bgcolor="White" link="#23238E">
<img height="30" width="141" src="../../images/smalltitle.gif" alt=
"[OpenBSD]"> 

<h1>Informations sur le portage OpenBSD</h1>

<h2><font color="#e00000">Différences importantes avec les autres
    projets BSD</font></h2>

<p>
NetBSD emploie le terme <em>ports</em> dans les cas dépendants de
l'architecture. Leur structure de ports est plutôt appelée
<em>packages</em>.
</p>

<h3>Support additionnel</h3>
L'infrastructure de portage inclut plusieurs scripts qui facilite
la création de nouveaux ports :
<dl>
<dt>build/resolve-lib
    <dd>invoqué via <code>make lib-depends-check</code>, pour vérifier
    les dépendances de librairies dynamiques.
<dt>build/update-patches
    <dd>invoqué via <code>make update-patches</code>, qui devrait
    <strong>toujours être utilisé pour regénérer les patches.</strong>
<dt>install/make-plist
    <dd>invoqué via <code>make update-plist</code>. Il s'inquiète de la
    plupart des points importants influant sur la création des listes de
    package.
    Les listes de package OpenBSD sont significativement différentes de
    celles des autres projets BSD, en partie car les outils de package
    ont été complètement réécris.
</dl>

<h3>Problèmes d'infrastructure Génériques</h3>

<p>
Le make d'OpenBSD supporte <code>${VAR:U}</code> et
<code>${VAR:L}</code> pour transformer la valeur d'une variable dans une
casse majuscule ou minuscule. De la même manière, make tests devrait
être codé d'une manière insensible à la casse, par exemple,
</p>

<pre>
        .if ${NEED_XXX:L} == "yes"
        do stuff if yes
        .else
        do other stuff
        .endif
</pre>

<p>
En théorie, toutes les variables booléennes reconnues par
<code>bsd.port.mk</code> devraient toujours être définies, les codes
comme <code>defined(USE_FOO)</code> ne seraient ainsi pas nécessaires,
et <code>${USE_FOO:L} != "no"</code> devrait fonctionner.
</p>

<p>
Le principal fichier <code>bsd.port.mk</code> a été lourdement profilé
et corrigé. En particulier, il supporte des processus make parallèles.
La fonctionnalité <code>scripts/{pre,do,post}-*</code> a été perdue dans
le processus. Pour remplacer cette fonctionnalité, invoquez le script
manuellement, depuis le Makefile.
</p>

<h3>Utilisation correcte de make</h3>

<p>
Notez que, si vous invoquez make avec <code>make VAR=value</code>,
l'assignation <em>redéfinira</em> toute valeur VAR pouvant provenir du
Makefile. Ainsi, de nombreux patches ne sont pas nécessaires, il est
plus avantageux de fixer correctement MAKE_FLAGS, pour diminuer le
fardeau de la maintenance.
</p>

<h3>Récupération des sources</h3>

<p>
Il y a deux sortes d'archives sources : DISTFILES et PATCHFILES. OpenBSD
les traite d'une manière identique, et les recherche par défaut depuis
MASTER_SITES. Il n'y a ni PATCH_SITES ni PATCH_SITES_SUBDIR.
</p>

<p>
Si tous les fichiers récupérés ne viennent pas du même ensemble de
sites, OpenBSD autorise l'extension filename:0 à filename:9, auquel cas
MASTER_SITES0 à MASTER_SITES9 seront utilisés pour récupérer les
fichiers.
</p>

<p>
Certaines architectures pourraient avoir besoin d'archives de
distribution spécifiques. Par le passé, ceci a causé des problèmes quand
des archives de distribution sur les mirroirs étaient concernées.
OpenBSD supporte un troisième ensemble de fichiers : SUPDISTFILES. Ceux-
ci seront seulement utilisés pour la création de sommes de contrôle et
de contenus liés aux mirroirs. Notez que SUPDISTFILES pourrait
chevaucher les DISTFILES ou PATCHFILES. Par exemple,
</p>

<pre>
        DISTFILES=foo-1.0.tgz
        .if ${ARCH} == "i386"
        DISTFILES+=foo-i386.tgz
        .elif ${ARCHI} == "sparc"
        DISTFILES+=foo-sparc.tgz
        .endif
        SUPDISTFILES=foo-i386.tgz foo-sparc.tgz
</pre>

<h3>L'infrastructure <code>WRKDIR</code></h3>

<p>
Nous ne voulons pas des ports qui utilisent <code>NO_WRKDIR</code>. Tous
les ports OpenBSD doivent avoir un répertoire de travail. Les détails de
nommage de ces répertoires de travail ne devraient pas être le soucis du
porteur. Si vous avez besoin de trouver un tel nom, demandez au Makefile
: <code>cd that_ports_dir &amp;&amp; make show VARNAME=WRKDIR</code>
devrait vous donner une idée du <code>WRKDIR</code> ce ce port.
</p>

<p>
La raison principale derrière cette interdiction est que le
<code>bsd.port.mk</code> d'OpenBSD agit comme un vrai Makefile, avec des
dépendances. L'étape <code>fetch</code> dépend des archives de
distribution et des fichiers de patch, toutes les autres étapes
dépendent de vrais fichiers peuplant le répertoire de travail (cookies),
ne pouvant exister sans répertoire de travail.
</p>

Si l'extraction des DISTFILES est spécifique, fixez
</p>

<pre>
EXTRACT_ONLY=
</pre> 

<p>
et faites l'extraction dans <code>post-extract.</code>
</p>

<dl>
<dt>WRKDIR</dt>

<dd>Le répertoire de travail des ports, ou sont mis les cookies de celui-
    ci.</dd>

<dt>WRKDIST</dt>

<dd>Le sous-répertoire de WRKDIR ou les ports sont actuellement
    décompressés. C'est aussi le répertoire de base pour les patchs. Les
    autres BSD ne font actuellement pas la distinction WRKDIST/WRKSRC et
    ont seulement WRKSRC.</dd>

<dt>WRKSRC</dt>

<dd>Répertoire sous-jacent de WRKDIST ou les sources actuelles se
    trouvent.</dd>

<dt>WRKBUILD</dt>

<dd>Répertoire sous-jacent de WRKDIR ou la configuration et la
    construction du port se réalisera. Les autres BSD ne font pas la
    distinction WRKBUILD/WRKSRC. Les programmes basés sur autoconf (la
    plus grande partie) peuvent habituellement fixer SEPARATE_BUILD pour
    permettre la construction du port dans un répertoire WRKBUILD
    distinct de WRKSRC.</dd>

<dt>WRKCONF</dt>

<dd>Sous-répertoire de WRKDIR d'ou les scripts configure devraient être
    lancés. Il est par défaut WRKBUILD, qui est correct 99% du
    temps.</dd>

<dt>WRKINST</dt>

<dd>Répertoire ou le port sera installé avant la mise en package
    (consultez la section Simulation des ports ci-dessous).</dd>
</dl>

<p>
<em>Notez que NO_WRKSUBDIR a été retiré : l'équivalent peut être
accomplit en fixant à la place WRKDIST=$(WRKDIR). </em>
</p>

<h3>Simulation des ports</h3>

<h4>Introduction</h4>

<p>
Lorsque la construction du port est terminée, les autres BSD traitent
ensuite de l'installation du port, puis construisent un package grâce au
port installé. OpenBSD utilise à la place la simulation d'installation.
</p>

<ul>
<li>Un port OpenBSD est configuré et construit normalement (par exemple,
    installé dans <code>PREFIX</code>, habituellement
    <code>/usr/local</code>).</li>

<li>Mais il est possible de l'installer partout, normalement dans
    WRKINST, qui est habituellement un répertoire sous-jacent de
    WRKDIR.</li>

<li>Ensuite l'installation fictive est mise en package, en utilisant
    l'option -B de pkg_create.</li>

<li>Enfin, le package résultant peut être installé, en utilisant
    pkg_add.</li>
</ul>

<h4>Avantages</h4>

<ul>
<li>Pour un constructeur de package, ceci signifie que la plupart des
    ports n'ont pas à être installés, ce qui évite un grand nombre de
    compromis et d'effets généraux néfastes provoqués par des ports mal
    installés. Ceci permet aussi la construction de plusieurs packages
    conflictuels sur la même machine. Enfin, ceci permet de construire
    un nouvel ensemble de packages non testés sans éclabousser une
    installation correcte.</li>

<li>Pour un développeur de ports, ceci simplifie agréablement la
    recherche de problèmes dans les listes de package, puisque le lieu
    de l'installation fictive est vide avant que le port soit installé.
    Ainsi, si un port installe trop de fichiers, il n'est désormais plus
    nécessaire de personnaliser l'installation du port : ce n'est pas
    suffisant pour enregistrer les fichiers supplémentaires dans la
    liste des packages.</li>

<li>Pour l'utilisateur final, ceci améliore la qualité des packages : à
    condition que le port final soit installé en utilisant pkg_add,
    l'utilisateur final <em>obtient exactement</em> le même logiciel que
    celui qui fut préparé sur la machine du porteur.</li>
</ul>

<h4>Comment le faire</h4>

<p>
Les cibles invoquées pour <code>make fake</code> sont les cibles
habituelles d'installation, excepté sur quelques points de différence :
</p>

<ul>
<li>FAKE_FLAGS est utilisé au lieu de MAKE_FLAGS. Par défaut, FAKE_FLAGS
    fixe DESTDIR=${WRKINST}.</li>

<li>FAKE_TARGET est utilisé au lieu de INSTALL_TARGET.</li>

<li>Les fragments {pre,do,post}-install sont invoqués avec TRUEPREFIX
    fixé à $(PREFIX), PREFIX fixé à $(WRKINST)$(PREFIX), et DESTDIR fixé
    à $(WRKINST).</li>
</ul>

<p>
Les ports utilisant imake devraient fonctionner ainsi, puisque les
fragments imake sont configurés pour utiliser DESTDIR. De même, les GNU
configure récents de devrait pas nécessiter de changement.
</p>

<p>
Une autre bonne technique est une astuce d'attache tardive : configurez
les ports pour utiliser un préfixe $(DESTDIR)/usr/local, le Makefile
résultant aura ainsi
</p>

<pre>
prefix=$(DESTDIR)/usr/local
</pre>

<p>
fixé. Quand le port est construit, puisque DESTDIR n'est pas fixée,
/usr/local est utilisé, et l'installation fictive mettra tous les
fichiers dans WRKINST/usr/local (par exemple, pour les configure GNU,
utilisez <code>CONFIGURE_STYLE= gnu dest</code>).
</p>

<h4>Pièges</h4>

<ul>
<li>Certains ports sont contradictoires dans leur traitement de DESTDIR
    : la plupart des ports préfèrent que DESTDIR soit fixée, mais pas un
    ou deux contrevenants. Corrigez le problème.</li>

<li>Soyez attentifs à distinguer l'emplacement actuel ou le port est
    installé, et l'emplacement enregistré dans les fichiers de
    configuration du package. Ceci est très facile à outrepasser, mais
    facile à corriger en utilisant TRUEPREFIX.</li>

<li>Les liens symboliques absolus nécessitent toujours une
    personnalisation. Heureusement, bsd.port.mk</code> notifiera les
    problèmes de ce genre.</li>

<li>Quelques ports ne veulent pas laisser $(DESTDIR) seule à l'étape de
    configuration. Un fragment post-configure qui peaufine tous les
    Makefiles pour ajouter DESTDIR est nécessaire.</li>

<li>Très rarement, un port résistera à tous les essais raisonnables pour
    faire un FAKE. Une approche par force brute devrait fonctionner :
    utilisez pre-fake pour lier ou copier tout ce que le port veut
    trouver dans WRKINST, et passez à l'installation dans le
    chroot.</li>
</ul>

<h3>Outils de Packaging</h3>

<p>
Les outils de package connaissent quelques types de fichiers, et peuvent
faire un grand nombre de choses automatiquement : dans la plupart des
cas, les scripts de commande <code>@exec</code> ou <code>INSTALL</code>
ne sont pas nécessaires.<br>
<em>Notez que tous les scripts non nécessaires devraient être bannis,
car ils posent des problèmes de stabilité. Il est plus facile de
deboguer une infrastructure simple de package que de modifier des
centaines de scripts afin de gérer de nouveaux problèmes.
</em><br>
Par exemple :
</p>

<ul>
<li><code>@exec ldconfig</code> n'est pas nécessaire, car les librairies
    partagées annotées avec <code>@lib libfoo.so.1.0</code> et
    <code>ldconfig</code> ne sont lancées que quand celà est utile, et
    gèrent les chroot correctement.</li>
<li><code>@exec install-info</code> n'est pas nécessaire, car les
    fichiers de documentation sont annotés de <code>@info
    file.info</code>. Ceci prend également en compte les fichiers d'info
    multiples, et enlève le besoin de <code>makeinfo --no-split
    </code>.</li>
<li>les fonts sont intégrées automatiquement grâce à <code>@font</code>
    et <code>@fontdir</code>.</li>
<li>Les nouveaux utilisateurs et groupes sont gérés par
    <code>@newuser</code> et <code>@newgroup</code> plutôt que par les
    scripts d'installation. Ils sont créés assez tôt afin que
    l'extraction du package puisse les utiliser.</li>
<li>Les fichiers de configuration sont gérés via <code>@sample</code>
    plutôt que par les scripts d'installation.</li>
</ul>

<p>
Référez vous à
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pkg_create&amp;sektion=1&amp;format=html">pkg_create(1)</a>
pur plus de détails. Dans la plupart des cas,
<code>make update-plist</code>
écrira une très bonne approximation de la packing-list complète, et
gèreront les améliorations d'une version à l'autre.
</p>

<h3>Saveurs</h3>

<p>
Les options ont été regroupées en saveurs, la construction des packages
peut ainsi être conforme. Un port avec des options devrait fixer FLAVORS
avec la liste des options qui ont un sens pour ce port (par exemple,
FLAVORS=foo bar zoinx), et utiliser ensuite FLAVOR pour tester quelles
options sont actuellement sélectionnées (par exemple, FLAVOR=zoinx foo).
<code>bsd.port.mk</code> fournit un support :
</p>

<ul>
<li>Le PKGNAME est personnalisé pour inclure des options séparées par
    des "-" (par exemple, package-foo-zoinx).</li>

<li>Le WRKDIR est personnalisé, des saveurs distinctes peuvent ainsi
    être construites sans collision.</li>

<li>Les constructions de la forme %%flavor%% déclencheront la saveur
    PFRAG. La construction %%SHARED%% déclenchera l'inclusion de
    PFRAG.shared.</li>

<li>bsd.port.subdir.mk comprend l'extension SUBDIR=directory,opt1,opt2
    pour spécifier la construction du port dans le répertoire avec
    FLAVOR=opt1 opt2.</li>
</ul>

<p>
Rechercher si une saveur donnée a été sélectionnée est aussi simple que
:
</p>

<pre>
.if ${FLAVOR:L:Mzoinx}
</pre>

Il y a une extension additionnelle, connue sous le nom de
MULTI_PACKAGES. De manière générale, MULTI_PACKAGES et FLAVORS sont des
mécanismes orthogonaux. Ensemble, ils essaient de rendre l'arbre des
ports OpenBSD plus petit que sur les autres BSD, en autorisant un seul
répertoire pour construire un grand nombre de paquets distincts.
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bsd.port.mk&amp;sektion=5&amp;format=html">bsd.port.mk(5)</a>
possède une section complète consacrée à FLAVORS et MULTI_PACKAGES.

<hr>

<small>
<!--
Originally [OpenBSD: diffs.html,v 1.18 ]<br>
$Translation: diffs.html,v 1.6 2005/07/16 17:00:38 aanriot Exp $<br>
-->
$OpenBSD: diffs.html,v 1.5 2005/07/17 16:06:31 saad Exp $
</small>

</body>
</html>
