<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>6 - Redes</title>
<link rev="made" href="mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta http-equiv="Content-Language" content="es">
<meta name="resource-type" content="documento">
<meta name="description"   content="Preguntas Frecuentes de OpenBSD">
<meta name="keywords"      content="openbsd,faq,documentación">
<meta name="distribution"  content="global">
<meta name="copyright"     content="Este documento es copyright 1998-2003 de OpenBSD.">
</head>

<body bgcolor="#ffffff" text="#000000">
<!-- máx. 72 caracteres por línea -->

<img alt="[OpenBSD]" height="30" width="141" src="../../images/smalltitle.gif">
<p>
<font color="#0000e0">
<a href="index.html">[&Iacute;ndice de documentos]</a>
<a href="faq5.html">[Secci&oacute;n 5 - Compilaci&oacute;n del sistema
con el c&oacute;digo fuente]</a>
<a href="faq7.html">[Secci&oacute;n 7 - Controles de teclado y
pantalla]</a>
</font>

<h1><font color="#e00000">6 - Redes</font></h1>

<hr>

<p>
<h3>&Iacute;ndice de contenidos</h3>
<ul>
<li><a href="#Intro">6.0.1 - Introducci&oacute;n</a>
<li><a href="#Setup">6.1 - Configuraci&oacute;n inicial de la red</a>
<li><a href="#PF">6.2 - El subsistema de Filtro de Paquetes IP (PF)</a>
<li><a href="#NAT">6.3 - Traducci&oacute;n de Direcciones de Red
(NAT)</a>
<li><a href="#DHCP">6.4 - El Protocolo de Configuraci&oacute;n para
Anfitriones Din&aacute;micos (DHCP)</a>
<li><a href="#PPP">6.5 - Protocolo Punto a Punto (PPP)</a>
<li><a href="#Tuning">6.6 - Ajuste de par&aacute;metros de red</a>
<li><a href="#NFS">6.7 - C&oacute;mo usar el Sistema de Archivos de Red
(NFS)</a>
<li><a href="#DNS">6.8 - El Servicio de Nombres de Dominio  - DNS,
BIND, y named</a>
<li><a href="#PPTP">6.9 - Configuraci&oacute;n de una conexi&oacute;n
PPTP en OpenBSD</a>
<li><a href="#Bridge">6.10 - Configuraci&oacute;n de un &laquo;puente de
red&raquo; (<i>bridge</i>) con OpenBSD</a>
</ul>

<hr>

<p>
<a name="Intro"></a>
<a name="6.0.1"></a>
<h2>6.0.1 - Introducci&oacute;n</h2>

<p>
Para la comprensi&oacute;n de la mayor parte de este documento
ser&aacute; de gran ayuda haber le&iacute;do antes y, por lo menos
asimilado en parte, el cap&iacute;tulo sobre la
<a href="faq5.html">&laquo;Configuraci&oacute;n del
N&uacute;cleo&raquo;</a> que se encuentra en estos documentos, y las
p&aacute;ginas del manual de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
y de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&amp;sektion=1">netstat(1)</a>.

<p>
Tanto si se es un administrador de redes y se est&aacute; configurando
protocolos de enrutamiento, como si se est&aacute; usando el sistema
OpenBSD como un enrutador, como si se necesita conocer m&aacute;s a
fondo los protocolos de redes IP, es realmente necesario leer
<a href="http://www.3com.com/other/pdfs/infra/corpinfo/en_US/501302.pdf">
Understanding IP addressing</a>
&iexcl;Es un documento excelente que contiene conocimientos
fundamentales sobre redes de IP!

<p>
Si se est&aacute; trabajando con aplicaciones como servidores de http,
servidores de ftp y servidores de correo, entonces la lectura de los
<a href="http://the.rfceditor.org/rfc.html">RFC</a> supondr&aacute; un
considerable beneficio.

<p>
<i>(Nota: existe un proyecto de traducci&oacute;n de documentos RFC al
castellano, <a href="http://www.rfc-es.org/">RFC-ES</a>)</i>

<p>
Pero lo m&aacute;s seguro es que no se puedan leer todos, y por ello lo
m&aacute;s pr&aacute;ctico es seleccionar algunos temas de
inter&eacute;s o aquellos que se usen en el entorno de red del que se
disponga.  Es aconsejable leerlos al mismo tiempo que se intenta
averiguar su funcionamiento.  Los RFC definen much&iacute;simas (miles)
de las normas para protocolos en Internet y c&oacute;mo se supone que
deben funcionar estos protocolos.

<p>
<a name="Setup"></a>
<a name="6.1"></a>
<h2>6.1 - Configuraci&oacute;n inicial de la red</h2>

<p>
<a name="Setup.1"></a>
<a name="6.1.1"></a>
<h3>6.1.1 - Idenficaci&oacute;n y configuraci&oacute;n de las interfaces
de red</h3>

<p>
Para empezar a configurar una red, lo primero que se debe hacer es
identificar la interfaz de red.  En OpenBSD las interfaces se designan
por el tipo de tarjeta, no por el tipo de conexi&oacute;n.  Se puede ver
la tarjeta de red durante el arranque, mientras se inicia el sistema, o
despu&eacute;s del arranque, usando la orden
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)</a>.
Tambi&eacute;n se puede ver la interfaz de red usando la orden
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>.
Por ejemplo, v&eacute;ase a continuaci&oacute;n la salida originada por
dmesg para una tarjeta de red Intel Fast Ethernet, que usa el nombre de
dispositivo fxp.

<blockquote>
<pre>
fxp0 at pci0 dev 10 function 0 &quot;Intel 82557&quot; rev 0x0c: irq 5, address 00:02:b3:2b:10:f7
inphy0 at fxp0 phy 1: i82555 10/100 media interface, rev. 4
</pre>
</blockquote>

<p>
Si se desconoce es el nombre del dispositivo, se puede buscar en la
<a href="../../es/plat.html">lista de hardware con soporte</a> de la
plataforma correspondiente.  En esa p&aacute;gina hay un listado con
muchos nombres de tarjetas comunes y sus correspondientes nombres de
dispositivo en OpenBSD.  Combinando el nombre abreviado
alfab&eacute;tico (como fxp) con un n&uacute;mero asignado por el
n&uacute;cleo del sistema se obtendr&aacute; el nombre de la interfaz
(como fxp0).

<p>
Se puede averiguar qu&eacute; interfaces de red han sido identificadas
usando la utilidad 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>.
La orden siguiente mostrar&aacute; todas las interfaces de red que
existan en un sistema.  Esta salida muestra s&oacute;lo una interfaz
f&iacute;sica de ethernet, la
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp&amp;sektion=4">fxp(4)</a>.

<blockquote>
<pre>
$ <b>ifconfig -a</b>
lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 33224
        inet 127.0.0.1 netmask 0xff000000
        inet6 ::1 prefixlen 128
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x5
lo1: flags=8008&lt;LOOPBACK,MULTICAST&gt; mtu 33224
fxp0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        address: 00:04:ac:dd:39:6a
        media: Ethernet autoselect (100baseTX full-duplex)
        status: active
        inet 192.168.1.35 netmask 0xffffff00 broadcast 192.168.1.255
        inet6 fe80::204:acff:fedd:396a%fxp0 prefixlen 64 scopeid 0x1
pflog0: flags=0&lt;&gt; mtu 33224
pfsync0: flags=0&lt;&gt; mtu 2020
sl0: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt; mtu 296
sl1: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt; mtu 296
ppp0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500
ppp1: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500
tun0: flags=10&lt;POINTOPOINT&gt; mtu 3000
tun1: flags=10&lt;POINTOPOINT&gt; mtu 3000
enc0: flags=0&lt;&gt; mtu 1536
bridge0: flags=0&lt;&gt; mtu 1500
bridge1: flags=0&lt;&gt; mtu 1500
vlan0: flags=0&lt;&gt; mtu 1500
        address: 00:00:00:00:00:00
vlan1: flags=0&lt;&gt; mtu 1500
        address: 00:00:00:00:00:00
gre0: flags=9010&lt;POINTOPOINT,LINK0,MULTICAST&gt; mtu 1450
gif0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif1: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif2: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif3: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
</pre>
</blockquote>

<p>
Como se puede comprobar, 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
muestra mucha m&aacute;s informaci&oacute;n de la que necesitamos en
este momento.  Pero aqu&iacute; lo importante es que nos permite ver
nuestra interfaz.  En el ejemplo anterior, la tarjeta de la interfaz ya
est&aacute; configurada.  Esto es obvio porque ya hay una red IP
configurada en fxp0, y de aqu&iacute; los valores &quot;inet 10.0.0.38
netmask 0xffffff00 broadcast 10.0.0.255&quot;.  Adem&aacute;s, los
indicadores <b>UP</b> y <b>RUNNING</b> se encuentran activados.

<p>
Finalmente, n&oacute;tese que hay otras interfaces que tambi&eacute;n se
encuentran activadas de modo predeterminado.  &Eacute;stas son
interfaces virtuales que tienen varias funciones.  Las siguientes
p&aacute;ginas del manual las describen:

<ul>
<!-- XXXrelease -->
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lo&amp;sektion=4">lo</a> - Interfaz de circuito cerrado (<i>loopback</i>)
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflog&amp;sektion=4&amp;manpath=OpenBSD+3.3">pflog</a> - Interfaz de registros del Filtro de Paquetes (<i>PF</i>)
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sl&amp;sektion=4">sl</a> - Interfaz de red SLIP
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=4">ppp</a> - Protocolo punto a punto (PPP)
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tun&amp;sektion=4">tun</a> - Interfaz de red por t&uacute;nel
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=enc&amp;sektion=4">enc</a> - Interfaz de encapsulamiento
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4">bridge</a> - Interfaz de puente Ethernet
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vlan&amp;sektion=4">vlan</a> - Interfaz de encapsulaci&oacute;n IEEE 802.1Q
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gre&amp;sektion=4">gre</a> - Interfaz de encapsulaci&oacute;n GRE/MobileIP
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gif&amp;sektion=4">gif</a> - Interfaz de t&uacute;nel IPv4/IPv6 gen&eacute;rica
</ul>

<p>
Si la interfaz no se ha configurado, el primer paso ser&aacute; crear el
fichero <tt>/etc/hostname.xxx</tt>, donde se debe sustituir <tt>xxx</tt>
por el nombre de la interfaz.  De acuerdo con la informaci&oacute;n de
los ejemplos anteriores, el nombre ser&iacute;a
<tt>/etc/hostname.fxp0</tt>.  La composici&oacute;n de este fichero es
as&iacute; de sencilla:<br>

<blockquote>
<pre>
address_family address netmask broadcast [other options]
</pre>
</blockquote>

<p>
(Puede verse m&aacute;s informaci&oacute;n sobre el formato de este
fichero en la p&aacute;gina del manual de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5">hostname.if(5)</a>)

<p>
El fichero de configuraci&oacute;n de una interfaz t&iacute;pica,
configurada para una direcci&oacute;n de IPv4, ser&iacute;a parecido a
lo siguiente:

<blockquote>
<pre>
$ <b>cat /etc/hostname.fxp0</b>
inet 10.0.0.38 255.255.255.0 NONE
</pre>
</blockquote>

<p>
Tambi&eacute;n se podr&iacute;a especificar tipos de media para
Ethernet, por ejemplo, si se quisiera forzar el modo 100baseTX
full-duplex:

<blockquote><pre>
inet 10.0.0.38 255.255.255.0 NONE media 100baseTX mediaopt full-duplex
</pre></blockquote>

<p>
Aunque nunca se debe forzar el modo <i>full duplex</i> a menos que ambas
partes de la conexi&oacute;n est&eacute;n configuradas para hacerlo.  A
menos que sea necesario por alg&uacute;n motivo especial, la
configuraci&oacute;n del tipo de media se debe excluir.

<p>
O puede que se prefiera usar indicadores especiales para especificar una
cierta interfaz.  &iexcl;El formato del fichero <i>hostname</i> no
cambiar&aacute; mucho!

<blockquote><pre>
$ <b>cat /etc/hostname.vlan0</b>
inet 172.21.0.0 255.255.255.0 NONE vlan 2 vlandev fxp1
</pre></blockquote>

<p>
El siguiente paso ser&aacute; la configuraci&oacute;n de la pasarela
(<i>gateway</i>) predeterminada.  Para ello basta con poner la
direcci&oacute;n IP de la pasarela en el fichero <tt>/etc/mygate</tt>.
Esto permitir&aacute; que la pasarela se active en el momento del
arranque.  A continuaci&oacute;n hay que configurar los nombres de
servidores (<i>nameservers</i>) y el fichero <tt>/etc/hosts</tt>
(v&eacute;ase la p&aacute;gina del manual de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hosts&amp;sektion=5">hosts(5)</a>).
Para configurar los nombres de servidores, antes se debe crear un
fichero con el nombre <tt>/etc/resolv.conf</tt>.  Puede verse m&aacute;s
informaci&oacute;n sobre el formato de este fichero en la p&aacute;gina
del manual de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&amp;sektion=5">resolv.conf(5)</a>.
El siguiente ejemplo es para un uso t&iacute;pico.  En este ejemplo los
servidores de dominio son 125.2.3.4 y 125.2.3.5.  Tambi&eacute;n
pertenece al dominio &laquo;example.com&raquo;.

<blockquote>
<pre>
$ <b>cat /etc/resolv.conf</b>
search example.com
nameserver 125.2.3.4
nameserver 125.2.3.5
lookup file bind
</pre>
</blockquote>

<p>
Desde este punto ya se puede reiniciar o bien ejecutar el gui&oacute;n
de configuraci&oacute;n (<i>script</i>) <b>/etc/netstart</b>.  Este
gui&oacute;n de configuraci&oacute;n se ejecuta como superusuario
(<i>root</i>) del siguiente modo:

<blockquote>
<pre>
# <b>sh /etc/netstart</b>
writing to routing socket: File exists
add net 127: gateway 127.0.0.1: File exists
writing to routing socket: File exists
add net 224.0.0.0: gateway 127.0.0.1: File exists
</pre>
</blockquote>

<p>
N&oacute;tese que se produce un peque&ntilde;o n&uacute;mero de errores.
Pero al ejecutar este gui&oacute;n, se reconfingurar&aacute;n cosas que
ya se hab&iacute;an configurado anteriormente.  De hecho, algunas rutas
ya existen en la tabla de enrutamiento del n&uacute;cleo del sistema.
Desde aqu&iacute;, el sistema deber&iacute;a funcionar con normalidad.
Se puede realizar una comprobaci&oacute;n con
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
para asegurarse de que la interfaz se ha configurado correctamente.
Tambi&eacute;n es posible comprobar las rutas con
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&amp;sektion=1">netstat(1)</a> o <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=route&amp;sektion=8">route(8)</a>.
Si tenemos problemas con el enrutamiento, podemos usar el indicador
<tt>-n</tt> para la orden route(8), que muestra las direcciones de IP en
lugar de realizar una b&uacute;squeda de DNS y mostrar el
<i>hostname</i>.  He aqu&iacute; un ejemplo en el que se ven las tablas
de enrutamiento usando ambos programas.

<blockquote>
<pre>
$ <b>netstat -rn</b>
Routing tables

Internet:
Destination        Gateway            Flags     Refs     Use    Mtu  Interface
default            10.0.0.1           UGS         0       86      -  fxp0
127/8              127.0.0.1          UGRS        0        0      -  lo0
127.0.0.1          127.0.0.1          UH          0        0      -  lo0
10.0.0/24          link#1             UC          0        0      -  fxp0
10.0.0.1           aa:0:4:0:81:d      UHL         1        0      -  fxp0
10.0.0.38          127.0.0.1          UGHS        0        0      -  lo0
224/4              127.0.0.1          URS         0        0      -  lo0

Encap:
Source             Port  Destination        Port  Proto SA(Address/SPI/Proto)

$ <b>route show</b>
Routing tables

Internet:
Destination      Gateway            Flags
default          10.0.0.1           UG
127.0.0.0        LOCALHOST          UG
localhost        LOCALHOST          UH
10.0.0.0         link#1             U
10.0.0.1         aa:0:4:0:81:d      UH
10.0.0.38        LOCALHOST          UGH
BASE-ADDRESS.MCA LOCALHOST          U
</pre>
</blockquote>

<p>
<a name="Setup.2"></a>
<a name="6.1.2"></a>
<h3>6.1.2 - Configuraci&oacute;n del sistema OpenBSD como pasarela
(<i>gateway</i>)</h3>

<p>
&Eacute;sta es la informaci&oacute;n b&aacute;sica necesaria para
configurar el sistema OpenBSD como una pasarela (tambi&eacute;n conocida
como &laquo;enrutador&raquo; o &laquo;encaminador&raquo;).  Si se va a
usar OpenBSD como un enrutador en Internet, sugerimos la lectura de la
secci&oacute;n que contiene las instrucciones sobre la
configuraci&oacute;n del Filtro de Paquetes IP (PF), para poder bloquear
tr&aacute;fico que sea potencialmente malicioso.  Adem&aacute;s, debido
a la escasa disponibilidad de direcciones de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4">
IPv4</a> en los proveedores de servicios de redes y registros
regionales, es conveniente leer la secci&oacute;n sobre la
Traducci&oacute;n de Direcciones de Red (NAT), que contiene
informaci&oacute;n sobre c&oacute;mo conservar el espacio de
direcci&oacute;n IP.

<p>
El n&uacute;cleo GENERIC posee la capacidad de permitir el
reenv&iacute;o de IP (<i>IP Forwarding</i>), pero debe ser activado.
Para activarlo hay que usar la utilidad
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>.
Para que los cambios sean permanentes, hay que editar el fichero
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5">/etc/sysctl.conf(5)</a>
y activar <i>IP Forwarding</i> en &eacute;ste.  Esto se puede hacer
a&ntilde;adiendo la siguiente l&iacute;nea a ese fichero de
configuraci&oacute;n.

<blockquote>
<pre>
net.inet.ip.forwarding=1
</pre>
</blockquote>

<p>
Para que este cambio surja efecto sin que haya que reiniciar el sistema,
hay que usar directamente la utilidad
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>.
Recu&eacute;rdese que este cambio todav&iacute;a no existir&aacute;
despu&eacute;s de reiniciar, y que habr&aacute; que ejecutarlo como
superusuario.

<blockquote>
<pre>
# <b>sysctl -w net.inet.ip.forwarding=1</b>
net.inet.ip.forwarding: 0 -&gt; 1
</pre>
</blockquote>

<p>
A continuaci&oacute;n se debe modificar las rutas en los otros
anfitriones en ambos extremos.  OpenBSD ofrece muchas posibilidades de
uso como enrutador, usando <i>software</i> como 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=routed&amp;sektion=8">routed(8)</a>,
<a href="http://www.gated.org">gated</a>, <a href="http://www.mrtd.net">mrtd</a> y <a href="http://www.zebra.org">zebra</a>.
OpenBSD dispone de soporte para zebra, gated y mrtd en la
colecci&oacute;n de portes, e incluye soporte para varias interfaces T1,
HSSI, ATM, FDDI, Ethernet, e interfaces de serie (PPP/SLIP).

<p>
<a name="Setup.3"></a>
<a name="6.1.3"></a>
<h3>6.1.3 - Configuraci&oacute;n de un alias en una interfaz</h3>

<p>
OpenBSD dispone de un simple mecanismo para la configuraci&oacute;n de
los alias de IP en una interfaz.  Para configurarlos s&oacute;lo hay que
editar el fichero
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5"><tt>/etc/hostname.&lt;if&gt;</tt></a>.
El gui&oacute;n
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&amp;sektion=8">/etc/rc(8)</a>,
que forma parte de la <a href="faq10.html#rc">jerarqu&iacute;a de inicio
rc</a>, leer&aacute; este fichero durante el proceso de inicio del
sistema.  Por ejemplo, supongamos que el usuario tiene una interfaz
<b>dc0</b> y pertenece a la red 192.168.0.0.  Otra informaci&oacute;n de
importancia es:

<ul>
<li>IP para dc0 es 192.168.0.2
<li>NETMASK es 255.255.255.0
</ul>

<p>
Unas notas sobre los alias:  en OpenBSD s&oacute;lo se usa el nombre de
la interfaz y no existen diferencias entre el primer alias y el segundo;
por lo tanto, y a diferencia de otros sistemas operativos, en OpenBSD no
hay que referirse a ellos como dc0:0 y dc0:1.  Si hacemos referencia a
una direcci&oacute;n de IP alias espec&iacute;fica con ifconfig, o si
estamos a&ntilde;adiendo un alias, debemos asegurarse de escribir
'<kbd>ifconfig int alias</kbd>' en lugar de '<kbd>ifconfig int</kbd>' en
la l&iacute;nea de &oacute;rdenes.  Se puede eliminar los alias con la
orden '<kbd>ifconfig int delete</kbd>'.

<p>
Asumiendo que se est&eacute;n usando direcciones de IP m&uacute;ltiples
que se encuentran en la misma subred IP con alias, la
configuraci&oacute;n del enmascaramiento de red (<i>netmask</i>) para
cada alias pasa a ser 255.255.255.255.  No necesitan seguir el
<i>netmask</i> del primer IP vinculado a la interfaz.  En el siguiente
<tt>/etc/hostname.dc0</tt> de ejemplo, se a&ntilde;aden dos alias al
dispositivo <b>dc0</b>, el cual, por cierto, se configur&oacute; como
192.168.0.2 netmask 255.255.255.0.

<blockquote>
<pre>
# <b>cat /etc/hostname.dc0</b>
inet 192.168.0.2 255.255.255.0 media 100baseTX
inet alias 192.168.0.3 255.255.255.255
inet alias 192.168.0.4 255.255.255.255
</pre>
</blockquote>

<p>
Una vez que se haya configurado este fichero, ser&aacute; necesario
reiniciar para que los cambios funcionen.  Aunque tambi&eacute;n es
posible hacer efectivos los alias a mano, usando la utilidad
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>.
Para hacer efectivo el primer alias se usar&iacute;a la orden:

<blockquote>
<pre>
# <b>ifconfig dc0 inet alias 192.168.0.3 netmask 255.255.255.255</b>
</pre>
</blockquote>

<p>
Para ver estos alias se usar&iacute;a la orden:

<blockquote>
<pre>
$ <b>ifconfig -A</b>
dc0: flags=8863&lt;UP,BROADCAST,NOTRAILERS,RUNNING,SIMPLEX,MULTICAST&gt;
        media: Ethernet manual
        inet 192.168.0.2  netmask 0xffffff00 broadcast 192.168.0.255
        inet 192.168.0.3 netmask 0xffffffff broadcast 192.168.0.3
</pre>
</blockquote>


<p>
<a name="PF"></a>
<a name="6.2"></a>
<h2>6.2 - El subsistema de Filtro de Paquetes IP (PF)</h2>
<!-- XXXrelease -->
<p>
El subsistema de Filtros de Paquetes, que fue introducido a partir de la
versi&oacute;n 3.0, realiza dos tareas:  se encarga de los permisos de
reenv&iacute;o al nivel del paquete, y asigna anfitriones/subrredes a
una variedad de direcciones externas.  El fichero de
configuraci&oacute;n para este servicio es
<tt><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+3.3">/etc/pf.conf(5)</a></tt>.

<p>
Nota:  en OpenBSD 3.0 y 3.1 hab&iacute;a un fichero de
configuraci&oacute;n adicional, <tt>/etc/nat.conf</tt>.  Sus funciones
se han incorporado ahora en <tt>/etc/pf.conf</tt>.

<p>
El fichero
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5"><tt>/etc/pf.conf(5)</tt></a>
consta de cuatro partes:

<ul>
<li><b>Options:</b>  Varias opciones para el control del funcionamiento
de PF.
<li><b>Scrub:</b>  Reprocesamiento de paquetes para normalizarlos y
desfragmentarlos.
<li><b><a href="#NAT">NAT and Redirection Rules:</a></b>  Las reglas de
redireccionamiento de NAT.  NAT permite que muchas m&aacute;quinas
puedan acceder a Internet a trav&eacute;s de una sola direcci&oacute;n
IP.  El redireccionamiento permite reenviar las peticiones entrantes a
una m&aacute;quina particular detr&aacute;s de NAT.
<li><b>Filter Rules:</b>  Las reglas de filtrado permiten el filtrado o
bloqueo selectivo de paquetes a medida que van pasando a trav&eacute;s
de cualquiera de las interfaces.
</ul>

<p>
No es necesario que exista ninguna de estas secciones, pero las que
existan deben aparecer en el mismo orden en el que se ha indicado.

<p>
Para iniciar estos servicios con el sistema, antes es necesario editar
el fichero
<tt><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&amp;sektion=8">/etc/rc.conf(8)</a></tt>
y activar las siguientes l&iacute;neas:

<blockquote>
<pre>
pf=YES
</pre>
</blockquote>

<p>
Si no se va a usar NAT, es probable que tambi&eacute;n haya que
configurar el valor de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>,
<tt>net.inet.ip.forwarding</tt>, a 1.  Para ello se debe activar las
l&iacute;neas relevantes en
<tt><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5">/etc/sysctl.conf(5)</a></tt>
y reiniciar la m&aacute;quina.

<p>
Si PF se encuentra compilado en el n&uacute;cleo, pero no ha sido
activado en el fichero
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&amp;sektion=8">/etc/rc.conf(8)</a>,
se puede activar f&aacute;cilmente con la orden
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pfctl&amp;sektion=8&amp;manpath=OpenBSD+3.3">pfctl(8)</a>.

<blockquote>
<pre>
# <b>pfctl -f /etc/pf.conf</b>
# <b>pfctl -e</b>
</pre>
</blockquote>

<p>
La primera l&iacute;nea configura el filtrado y NAT, usando
<tt>/etc/pf.conf</tt>, y la segunda activa PF.

<p>
Esto tambi&eacute;n puede combinarse en una sola l&iacute;nea de
&oacute;rdenes:

<blockquote><pre>
# <b>pfctl -f /etc/pf.conf -e</b>
</pre></blockquote>

<p>
Si se realiza alg&uacute;n cambio en <tt>/etc/pf.conf</tt>
despu&eacute;s de haber iniciado PF, se pueden volver a cargar sus
reglas recargando el fichero:

<blockquote><pre>
# <b>pfctl -f /etc/pf.conf</b>
</pre></blockquote>

<p>
A partir de aqu&iacute; este documento cubrir&aacute; algunos aspectos
b&aacute;sicos de la configuraci&oacute;n de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+3.3">pf.conf(5)</a>
Puede verse el ejemplo del <a href="#sample_pf.conf">juego de reglas
resultante</a> que incluye todos los cambios que se explican a
continuaci&oacute;n en detalle.  Tambi&eacute;n se puede encontrar
m&aacute;s informaci&oacute;n sobre el filtro de paquetes PF en las
<a href="http://www.benzedrine.cx/pf.html">p&aacute;ginas de PF</a> y en
el documento <a href="http://www.inebriated.demon.nl/pf-howto/">Packet
Filter HOWTO</a>.

<p>
<h3>El Filtro de Paquetes IP (PF)</h3>

<p>
Para activar PF en el momento del inicio del sistema es necesario
modificar <tt>/etc/rc.conf</tt> de modo que se lea <tt>pf=YES</tt>.  El
filtro de paquetes IP (PF) est&aacute; controlado por el fichero
<tt>/etc/pf.conf</tt>, que se leer&aacute; durante el inicio.  Puede
verse una explicaci&oacute;n m&aacute;s detallada en la p&aacute;gina
del manual de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+3.3">pf.conf(5)</a>. 
En los siguientes ejemplos, <tt>fxp0</tt> representa la interfaz externa
a Internet.  En otros casos puede ser diferente, dependiendo del
adaptador de ethernet del que se disponga en la m&aacute;quina.  En
estas reglas asumiremos que existe una conexi&oacute;n permanente a
Internet, del mismo tipo que la de un servidor de <i>web</i>.

<p>
Las reglas de PF se procesan de modo secuencial desde el principio hasta
el final, lo que ayuda a visualizar cada uno de los paquetes que tengan
que atravesar cada una de las regla antes de alcanzar su destino.

<p>
Por ejemplo, el grupo de reglas predeterminado permite que entren y
salgan todos los paquetes:

<blockquote><pre>
pass out all 
pass in all
</pre></blockquote>

<p>
que es la forma abreviada de:

<blockquote><pre>
pass in from any to any
pass out from any to any
</pre></blockquote>

<p>
y que se puede leer como &laquo;dejar pasar los paquetes entrantes
procedentes de cualquier parte y hacia cualquier destino&raquo;, y que
implica &laquo;en cualquier interfaz (siempre impl&iacute;cito si no se
especifica una interfaz) de cualquier familia de direcciones de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inet&amp;sektion=4">inet (v4)</a> &oacute; <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inet6&amp;sektion=4">inet6 (v6)</a>&raquo;.

<p>
L&oacute;gicamente, estas reglas no representan un buen ejemplo de
filtrado.  Un filtrado m&aacute;s &uacute;til estar&aacute; basado en la
familia de direcciones (IPv4 &oacute; IPv6), en los protocolos y en los
puertos usados por los servicios que se desean filtrar.  Se puede
especificar cualquiera de los protocolos que aparecen en la lista de
<tt><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=protocols&amp;sektion=5">/etc/protocols(5)</a></tt>,
bien por su nombre o por su n&uacute;mero, pero nosotros s&oacute;lo
trataremos los protocolos
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcp&amp;sektion=4">tcp(4)</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=udp&amp;sektion=4">udp(4)</a> e
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp&amp;sektion=4">icmp(4)</a>.

<p>
Supongamos ahora que no quisi&eacute;ramos permitir ninguna
conexi&oacute;n IPv4 entrante por el puerto TCP 3306 (MySQL) porque la
base de datos s&oacute;lo deber&iacute;a permitir la conexi&oacute;n de
forma local.  En este caso, el grupo de reglas ser&iacute;a como sigue:

<blockquote><pre>
pass out all
pass in all
block in on fxp0 inet proto tcp from any to any port 3306
</pre></blockquote>

<p>
que traducido viene a decir lo siguiente: &laquo;bloquear todos los
paquetes IPv4 entrantes procedentes cualquier sitio y con destino a
cualquier sitio, por el puerto tcp 3306&raquo;.  N&oacute;tese que hay
que especificar un protocolo con cada filtro basado en los puertos, y se
recomienda que se indique la familia de direcciones a la que pertenece.
Para los servicios definidos en el fichero
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=services&amp;sektion=5">/etc/services(5)</a>,
tambi&eacute;n se puede usar los nombres del servicio, como por ejemplo
<i>www</i> o <i>mysql</i>.  Un paquete con destino al puerto tcp 3306 en
una interfaz <tt>fxp0</tt>, pasar&aacute; la primer regla &quot;pass
in&quot;, y a continuaci&oacute;n ser&aacute; bloqueado por la regla
&quot;block in port 3306&quot;.  Si se invirtiera el orden de las reglas
entrantes (recu&eacute;rdese que el orden es importante):

<blockquote><pre>
pass out all
block in on fxp0 inet proto tcp from any to any port 3306
pass in all
</pre></blockquote>

<p>
los paquetes con destino al puerto tcp 3306 pasar&iacute;an porque la
&uacute;ltima regla en el grupo permite que pasen todos los paquetes.
Cuando se escriban reglas para el filtrado de paquetes es importante
tener en cuenta lo siguiente: <b>La &uacute;ltima regla que concuerde
tendr&aacute; precedencia</b>.

<p>
Y, por supuesto, existen excepciones para toda regla.  La opci&oacute;n
<i>quick</i> filtra el paquete en la primera regla que concuerde.
Veamos de nuevo el defectuoso ejemplo anterior,
a&ntilde;adi&eacute;ndole la opci&oacute;n <i>quick</i> a la regla
&quot;block in&quot;:

<blockquote><pre>
pass out all
block in quick on fxp0 inet proto tcp from any to any port 3306
pass in all
</pre></blockquote>

<p>
Un paquete destinado para el puerto tcp 3306 ser&aacute; filtrado por la
regla &quot;block in quick&quot; y bloqueado inmediatamente.  Todos los
paquetes destinados a otros puertos no encontrar&aacute;n una
concordancia en las reglas hasta llegar a la regla &quot;pass in&quot;,
que permite que pasen todos los paquetes.

<p>
<b>Denegaci&oacute;n predefinida</b>

<p>
La pol&iacute;tica de filtrado de p&aacute;quetes m&aacute;s segura es
la de &laquo;denegaci&oacute;n por definici&oacute;n&raquo;.  Esta
pol&iacute;tica es mucho m&aacute;s segura que la denegaci&oacute;n
expl&iacute;cita de cada uno de los servicios protegidos, permite el uso
de grupos de reglas m&aacute;s breves, y puede proteger de un servicio
que haya sido mal configurado de forma accidental y que haya quedado
expuesto.

<p>
Veamos ahora otro ejemplo de un grupo de reglas real, seguido por una
explicaci&oacute;n, l&iacute;nea por l&iacute;nea.  El siguiente ejemplo
es para un servidor de web con una pol&iacute;tica de denegaci&oacute;n
predefinida que s&oacute;lo permita conexiones ssh (para
administraci&oacute;n), y conexiones http (puerto 80) y https (puerto
443).

<blockquote>
<pre>
block in on fxp0 all
pass  in on fxp0 inet proto tcp from any to any port 22
pass  in on fxp0 inet proto tcp from any to any port 80
pass  in on fxp0 inet proto tcp from any to any port 443
pass out on fxp0 all
</pre>
</blockquote>

<p>
Esto permitir&aacute; el paso de conexiones desde cualquier punto de
origen con destino a los puertos tcp 22 (ssh), 80 (http) y 443 (https).
Cualquier otro intento de conexi&oacute;n distinto ser&aacute;
bloqueado, y permitir&aacute; el paso a todas las conexiones salientes,
cualquiera que sea su destino.  Este grupo de reglas es muy estricto.
Pero, &iquest;y si quisi&eacute;ramos que s&oacute;lo puedan conectarse
a ssh los anfitriones internos de nuestro bloque de direcciones 1.1.1.0,
y que al mismo tiempo que se permitan las conexiones externas a http y
https?

<blockquote><pre>
block in on fxp0 all
pass  in on fxp0 inet proto tcp from 1.1.1.0/24 to any port 22
pass  in on fxp0 inet proto tcp from any to any port 80
pass  in on fxp0 inet proto tcp from any to any port 443
pass out on fxp0 all
</pre></blockquote>

<p>
De acuerdo, pero, &iquest;y si s&oacute;lo quisi&eacute;ramos permitir
la administraci&oacute;n remota de nuestro servidor de web a una sola
m&aacute;quina (1.1.1.1)?  Entonces cambiar&iacute;amos esta regla:

<blockquote><pre>
pass  in on fxp0 inet proto tcp from 1.1.1.0/24 to any port 22
</pre></blockquote>

<p>
por esta otra:

<blockquote><pre>
pass  in on fxp0 inet proto tcp from 1.1.1.1/32 to any port 22
</pre></blockquote>

<p>
<b>Ejemplos de reglas</b>

<p>
He aqu&iacute; algunas ejemplos de reglas que pueden ser de utilidad
para todos (en las que se asume que <tt>fxp0</tt> es la interfaz externa
conectada a Internet).  Primero configuraremos un filtro simple para la
protecci&oacute;n contra la falsificaci&oacute;n de direcciones IP
(<i>ip address spoofing</i>).  Estas direcciones, por lo general, no
deber&iacute;an vagar por Internet y, si lo hacen, lo que es bastante
raro, las bloquearemos:

<blockquote><pre>
block in quick on fxp0 inet from { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 } to any
block out quick on fxp0 inet from any to { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 }
</pre></blockquote>

<p>
Nuestro grupo de reglas est&aacute; mejorando;  cuando lo ponemos todo
junto obtenemos lo siguiente:

<blockquote><pre>
# no permitir a nadie falsificar direcciones que no se
# puedan enrutar
block in quick on fxp0 inet from { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 } to any
block out quick on fxp0 inet from any to { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 }

# permitir la conexi&oacute;n por ssh s&oacute;lo a nuestra
# m&aacute;quina de administraci&oacute;n

pass in quick on fxp0 inet proto tcp from 1.1.1.1/32 to any port 22

# permitir que otros usen http y https

pass in quick on fxp0 inet proto tcp from any to any port 80
pass in quick on fxp0 inet proto tcp from any to any port 443

# finalmente, cerrar el resto con una denegaci&oacute;n
# predeterminada
block in quick on fxp0 from any to any

# y dejar pasar todo el tr&aacute;fico saliente
pass out on fxp0 from any to any
</pre></blockquote>

<p>
<b>Registro de paquetes</b>

<p>
De momento va bastante bien, pero a&uacute;n podr&iacute;a ir mejor.
&iquest;Qué har&iacute;amos si quisi&eacute;ramos obtener un registro de
cualquier intento de conexi&oacute;n al puerto 22 (ssh) que pasara a
trav&eacute;s de nuestro cortafuegos?  Ser&iacute;a fácil, ya que PF
puede gestionar este caso con la opci&oacute;n clave:
<i>log</i>:

<blockquote><pre>
pass in quick on fxp0 inet proto tcp from 1.1.1.1/32 to any port 22
block in log quick on fxp0 inet proto tcp from any to any port 22
</pre></blockquote>

<p>
Esta regla permitir&aacute; la conexi&oacute;n remota por el puerto 22 a
nuestra m&aacute;quina de administraci&oacute;n, pero denegar&aacute; y
registrar&aacute; cualquier otro intento de conexi&oacute;n al puerto
22.

<p>
Los paquetes registrados se env&iacute;an a la interfaz pflog0, que
est&aacute; siendo monitorizada por
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+3.3">pflogd(8)</a>,
el cual suele volcar los paquetes a <tt>/var/log/pflog</tt> en el
formato binario de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcpdump&amp;sektion=8&amp;manpath=OpenBSD+3.3">tcpdump(8)</a>.
Si pf se encuentra activado en
<tt><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&amp;sektion=8">/etc/rc.conf(8)</a></tt>,
pflogd(8) se inicia de modo predefinido desde
<tt><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&amp;sektion=8">/etc/rc(8)</a></tt>.
Estos ficheros de registro se pueden leer usando la siguiente orden:

<blockquote><pre>
# <b>tcpdump -n -e -ttt -r /var/log/pflog</b>
</pre></blockquote>

<p>
Hay que tener en cuenta que la utilizaci&oacute;n de tcpdump para la
monitorizaci&oacute;n del fichero <i>pflog</i> NO ofrece
informaci&oacute;n en tiempo real.  Para ver la informaci&oacute;n en
tiempo real hay que usar la siguiente orden:

<blockquote><pre>
# <b>tcpdump -i pflog0</b>
</pre></blockquote>

<p>
Tambi&eacute;n es posible usar tcpdump para estrechar el objetivo y
facilitar as&iacute; el depurado:

<blockquote><pre>
# <b>tcpdump -e -i pflog0 port 80</b>
</pre></blockquote>

<p>
Esta orden NO altera los datos que se incluyen en el fichero
<tt>/var/log/pflog</tt>.

<p>
Cuando se examinan los registros propios, es aconsejable tener mucho
cuidado con la descodificaci&oacute;n del protocolo (la verbosidad en
los mensajes se activa a&ntilde;adiendole a la orden la opci&oacute;n
<tt>-v</tt>).  Los descodificadores de protocolo de tcpdump no tienen un
historial impecable.  En teor&iacute;a, ser&iacute;a posible un ataque
retrasado a trav&eacute;s de paquetes parciales de carga &uacute;til
(<i>partial packet payload</i>) registrados por el dispositivo de
ingreso.

<p>
Es preciso tener un cuidado especial con el acceso a los registros.
pflogd captura 96 bytes del paquete y los registra.  El acceso a los
registros podr&iacute;a dar acceso parcial a paquetes de carga
&uacute;til de car&aacute;cter reservado (como los registros de ingreso
de 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=telnet&amp;sektion=1">telnet(1)</a> o
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftp&amp;sektion=1">ftp(1)</a>).

<p>
<b>Registro de paquetes con <tt>syslog</tt></b>

<p>
Hay muchas situaciones en las que es conveniente que los registros
(<i>logs</i>) del cortafuegos est&eacute;n disponibles en formato ASCII
(texto simple) y/o enviarlos a un servidor de registros remoto.  Esto se
puede llevar a cabo mediante dos peque&ntilde;os guiones de
ejecuci&oacute;n del int&eacute;rprete de &oacute;rdenes (<i>shell
scripts</i>) y con unos cambios m&iacute;nimos de los ficheros de
configuraci&oacute;n de OpenBSD.

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=syslogd&amp;sektion=8&amp;manpath=OpenBSD+3.3">Syslogd(8)</a>
es el d&aelig;mon est&aacute;ndar para registros, que los realiza en
formato ASCII y que tambi&eacute;n puede enviarlos a un servidor de
registros remoto.

<p>
Para ello, primero debemos crear un usuario, <i>pflogger</i>, con
<i>.nologin.</i> como int&eacute;rprete.  La forma m&aacute;s
f&aacute;cil de crear este usuario es con la orden
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser&amp;sektion=8&amp;manpath=OpenBSD+3.3">adduser(8)</a>.

<p>
Despu&eacute;s de crear el usuario <i>pflogger</i> crearemos los dos
guiones de ejecuci&oacute;n siguientes:

<p>
<tt>/etc/pflogrotate</tt>
<blockquote><pre>
FILE=/home/pflogger/pflog5min.$(date "+%Y%m%d%H%M")
kill -ALRM $(cat /var/run/pflogd.pid)
if [ $(ls -l /var/log/pflog | cut -d " " -f 8) -gt 24 ]; then
        mv /var/log/pflog $FILE
        chown pflogger $FILE
        kill -HUP $(cat /var/run/pflogd.pid)
fi
</blockquote></pre>

<p>
<tt>/home/pflogger/pfl2sysl</tt>
<blockquote><pre>
#!/bin/sh
# alimentar a syslog con los ficheros pflog rotados
for logfile in /home/pflogger/pflog5min* ; do
        tcpdump -n -e -ttt -r $logfile | logger -t pf -p local0.info
        rm $logfile
done
</blockquote></pre>

<p>
A continuaci&oacute;n abriremos la tarea de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cron&amp;sektion=8">cron(8)</a>
del usuario <i>root</i> en modo de edici&oacute;n mediante la orden
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=crontab&amp;sektion=1">crontab(1)</a>:

<blockquote><pre>
# <b>crontab -u root -e</b>
</pre></blockquote>

<p>
y le a&ntilde;adiremos las dos l&iacute;neas siguientes:

<blockquote><pre>
# rotar el fichero de registro de pf cada 5 minutos
0-59/5 *       *       *       *       /bin/sh /etc/pflogrotate
</blockquote></pre>

<p>
luego crearemos una tarea de cron para el usuario <i>pflogger</i>:

<blockquote><pre>
# <b>crontab -u pflogger -e</b>
</pre></blockquote>

<p>
y le a&ntilde;adiremos la l&iacute;nea siguiente:

<blockquote><pre>
# alimentar syslog con los ficheros de pflog rotados
0-59/5 *       *       *       *       /bin/sh /home/pflogger/pfl2sysl
</blockquote></pre>

<p>
y la siguiente l&iacute;nea en <tt>/etc/syslog.conf</tt>:

<blockquote><pre>
local0.info    /var/log/pflog.txt
</blockquote></pre>

<p>
Si queremos que los registros se realicen mediante un servidor de
registros remoto, tambi&eacute;n a&ntilde;adiremos la l&iacute;nea:

<blockquote><pre>
local0.info    @syslogger
</blockquote></pre>

<p>
asegur&aacute;ndonos de que el anfitri&oacute;n <i>syslogger</i> se
encuentre definido en el fichero
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hosts&amp;sektion=5&amp;manpath=OpenBSD+3.3">/etc/hosts(5)</a>.

<p>
Todos los paquetes registrados ser&aacute;n enviados al fichero
<tt>/var/log/pflog.txt</tt>.  Si adem&aacute;s hemos a&ntilde;adido la
segunda l&iacute;nea, tambi&eacute;n ser&aacute;n enviados al
anfitri&oacute;n de registro remoto, <i>syslogger</i>.

<p>
Ahora <tt>/etc/pflogrotate</tt> procesa y luego elimina
<tt>/var/log/pflog</tt>, por lo que la rotaci&oacute;n de <i>pflog</i>
por
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newsyslog&amp;sektion=8&amp;manpath=OpenBSD+3.3">newsyslogd(8)</a>
ya no es necesaria y debe ser desactivada.  Sin embargo,
<tt>/var/log/pflog.txt</tt> sustituye <tt>/var/log/pflog</tt>, y la
rotaci&oacute;n deber&iacute;a permanecer activada.  Para ello
cambiaremos <tt>/etc/newsyslog.conf</tt> de la siguiente forma:

<blockquote><pre>
#/var/log/pflog        600     3       250     *       ZB      /var/run/pflogd.pid
/var/log/pflog.txt     600     7       *       24
</blockquote></pre>

<p>
Ahora los registros de pf en ASCII ir&aacute;n a
<tt>/var/log/pflog.txt</tt>.  Adem&aacute;s, si lo hemos configurado en
<tt>/etc/syslog.conf</tt>, tambi&eacute;n enviar&aacute; los registros a
un servidor remoto.  El proceso del registro no es inmediato, sino que
tarda entre unos 5 &oacute; 6 minutos (el intervalo de la tarea de cron)
antes de que los paquetes registrados aparezcan en el fichero.

<p>
<b>Protocolos m&uacute;ltiples</b>

<p>
&iquest;Qu&eacute; ocurrir&iacute;a si necesit&aacute;ramos permitir las
conexiones a un servicio que funcionara sobre m&uacute;ltiples
protocolos (como bind, que usa TCP y UDP)?  PF nos permite agrupar
opciones (m&aacute;s adelante volveremos a este tema):

<blockquote><pre>
# Permitir el tr&aacute;fico de DNS para BIND
pass in quick on fxp0 inet proto { tcp, udp } from any to any port 53
</pre></blockquote>

<p>
N&oacute;tese los espacios a ambos lados de los caracteres '{ }'.  Esta
forma es m&aacute;s elegante que la que habr&iacute;a que usar como
alternativa:

<blockquote><pre>
pass in quick on fxp0 inet proto tcp from any to any port 53
pass in quick on fxp0 inet proto udp from any to any port 53
</pre></blockquote>

<p>
<a name="normalization"></a>
<b>Normalizaci&oacute;n de paquetes</b>

<p> 
La &laquo;normalizaci&oacute;n de paquetes&raquo; implica el
reensamblaje de los paquetes fragmentados y la limpieza de las opciones
de IP.  Algunos sistemas operativos y aplicaciones tienen problemas con
paquetes fragmentados o an&oacute;malos, y en general es bueno
normalizar los paquetes para que los puedan buscar bien las reglas de
filtros y los anfitriones de destino de estos paquetes.  Por lo tanto,
casi siempre es beneficioso normalizar los paquetes antes de que lleguen
a su destino final.  Para esto se utiliza la directiva
<b>scrub</b>, que se usa como sigue:

<blockquote><pre>
scrub in all
</pre></blockquote>

<p>
Esta directiva a&ntilde;ade una peque&ntilde;a carga adicional al
sistema, y requiere de un poco de memoria para los fragmentos del
paquete.  Las ventajas de la normalizaci&oacute;n de paquetes casi
siempre son mayores que este peque&ntilde;o coste.

<p>
<b>Opciones de IP</b>

<p>
En su modo predeterminado, PF bloquea los paquetes que tienen las
opciones de IP activadas.  Esto puede dificultar a&uacute;n m&aacute;s
la tarea a las utilidades de detecci&oacute;n de sistemas como nmap.  Si
se tiene una aplicaci&oacute;n que requiera el paso de estos paquetes,
como puede ser IGMP, puede usarse la directiva <b>allow-opts</b>:

<blockquote><pre>
pass in quick on fxp0 all allow-opts
</pre></blockquote>

<p>
<b>Indicadores de TCP, conexiones establecidas, y mantenimiento del
estado</b>

<p>
PF tambi&eacute;n puede filtrar los paquetes bas&aacute;ndose en los
indicadores de TCP, y mantener as&iacute; las conexiones establecidas y
el estado de la conexi&oacute;n.  Se recomienda que todos los usuarios
que quieran filtrar paquetes bas&aacute;ndose en los indicadores TCP
entiendan antes el papel que desempe&ntilde;a cada indicador.  Por
ejemplo, si un usuario quisiera denegar la conexi&oacute;n a todos los
paquetes con los indicadores FIN, URG, y PSH activados (por ejemplo, en
un intento por obtener la huella digital de un sistema operativo
mediante nmap), podr&iacute;a usar una regla como la siguiente:

<blockquote><pre>
block in quick on fxp0 inet proto tcp from any to any flags FUP/FUP
</pre></blockquote>

<p>
(Gracias a <a href="mailto:halogen@nol.net">Kyle Hargraves</a> por esta
regla)

<p>
El pr&oacute;ximo truco de PF es su capacidad para &laquo;mantener el
estado&raquo; (<i>keep state</i>).  El concepto de &laquo;mantener el
estado&raquo; se puede definir como &laquo;no contestar hasta que no ser
preguntado&raquo; o, en otras palabras, una vez que se ha establecido
una conexi&oacute;n, los paquetes ya no tienen que atravesar grupos de
reglas.  &Eacute;sta es una funcionalidad muy potente que permite
escribir unas reglas mucho m&aacute;s sencillas y seguras.

<p>
Veamos c&oacute;mo se podr&iacute;a aplicar este estado al ejemplo del
grupo de reglas anterior.  &iquest;Confuso?  Revis&eacute;moslo: estamos
permitiendo el acceso para la gesti&oacute;n del sistema desde nuestra
m&aacute;quina de clase C al puerto 22 (ssh), y el acceso al servidor de
<i>web</i> a todo el tr&aacute;fico entrante a los puertos 80 (http) y
443 (https); y estamos bloqueando el resto del tr&aacute;fico.  pero,
&iquest;y si quisi&eacute;ramos establecer una conexi&oacute;n a
trav&eacute;s de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh&amp;sektion=1">ssh(1)</a>
fuera del servidor de <i>web</i>? o, &iquest;y si necesit&aacute;ramos
usar
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lynx&amp;sektion=1">
lynx(1)</a> para buscar algo en los documentos de las preguntas
frecuentes?  No podr&iacute;amos, ya que habr&iacute;amos bloqueado
todas las conexiones entrantes que no fueran dirigidas a los puertos
especificados.  Aunque &eacute;sta es la ruta m&aacute;s segura, puede
ser muy poco conveniente.  a&ntilde;adiendo las opciones clave <i>keep
state</i> a la regla &quot;pass out&quot;, podemos permitir de forma
autom&aacute;tica el paso de los paquetes que sean una respuesta a
conexiones que hayamos iniciado nosotros previamente, como por ejemplo
al navegar por la <i>web</i>.  Recu&eacute;rdese que es necesario
especificar para qu&eacute; protocolo estamos efectuando el
mantenimiento del estado.

<blockquote><pre>
block in  on fxp0 inet proto tcp all
pass  in  on fxp0 inet proto tcp from 1.1.1.0/24 to any port 22 keep state
pass  in  on fxp0 inet proto tcp from any to any port 80 keep state
pass  in  on fxp0 inet proto tcp from any to any port 443 keep state
pass  out on fxp0 inet proto tcp all keep state
</pre></blockquote>

<p>
Este peque&ntilde;o cambio supondr&aacute; un dram&aacute;tico
incremento en la flexibilidad y seguridad de nuestro grupo de reglas:
por ejemplo, en el grupo de reglas anterior, estamos permitiendo el paso
a todo el tr&aacute;fico tcp hacia los puertos 80 y 443.  A&uacute;n
podemos hacer que sea un poco m&aacute;s estricto.  Para establecer una
conexi&oacute;n tcp s&oacute;lo se necesita permitir que tenga lugar el
saludo inicial (<i>handshake</i>); una vez que esto ocurra, podemos
bloquear el tr&aacute;fico a ese puerto y permitir que la regla
&quot;keep state&quot; gestione la conexi&oacute;n.  Para que se
complete el saludo inicial, s&oacute;lo es necesario que los paquetes
SYNACK est&eacute;n activados.  Dejando pasar s&oacute;lo paquetes con
SYN activado se puede prevenir muchas formas de barridos de puertos
(<i>port scanning</i>), como puede ser el barrido de FIN.  Los
indicadores S/SA del indicador S (SYN) y el indicador A (ACK) indican
que s&oacute;lo se puede activar SYN.  No se investiga sobre otros
paquetes.  Ahora, las reglas est&aacute;n de este modo:

<blockquote><pre>
block in  on fxp0 inet proto tcp all
pass  in  on fxp0 inet proto tcp from 1.1.1.0/24 to any port 22 \
	flags S/SA keep state
pass  in  on fxp0 inet proto tcp from any to any port 80 \
	flags S/SA keep state
pass  in  on fxp0 inet proto tcp from any to any port 443 \
	flags S/SA keep state
block out on fxp0 inet proto tcp all
pass  out on fxp0 inet proto tcp all flags S/SA keep state
</pre></blockquote>

<p>
Empecemos a poner un poco de orden colocando juntas todas las reglas que
tenemos hasta ahora.  Este grupo de reglas tendr&aacute; soporte para
IPv4, una pol&iacute;tica de denegaci&oacute;n predefinida,
permitir&aacute; conexiones para la gesti&oacute;n del sistema
s&oacute;lo si provienen de una red interna (a trav&eacute;s de ssh), y
permitir&aacute; el paso del tr&aacute;fico entrante hacia los puertos
80 (http) y 443 (https).  Adem&aacute;s, proteger&aacute; contra
direcciones de ip falsificadas no enrutables, y bloquear&aacute; todos
los paquetes que est&eacute;n tan fragmentados que no se puedan
inspeccionar.  Una configuraci&oacute;n bastante completa para un
servidor de <i>web</i> p&uacute;blico.  He aqu&iacute; c&oacute;mo
quedar&iacute;a <tt>/etc/pf.conf</tt>:

<blockquote><pre>
# limpiar paquetes fragmentados y an&oacute;malos
scrub in all

# no permitir a nadie que falsee direcciones no enrutables
block in quick on fxp0 inet from { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 } to any
block out quick on fxp0 inet from any to { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 }

# por definici&oacute;n, bloquear todos los paquetes entrantes
# excepto los que est&eacute;n expl&iacute;citamente
# permitidos en reglas siguientes
block in on fxp0 all

# permitir que otros usen http y https
pass in on fxp0 inet proto tcp from any to any port 80 \
	flags S/SA keep state
pass in on fxp0 inet proto tcp from any to any port 443 \
	flags S/SA keep state

# y dejar pasar todo el tr&aacute;fico saliente, incluido TCP,
# UDP, e ICMP, y crear un estado, de modo que los servidores
# de DNS externos puedan responder a nuestros propios
# requerimientos de DNS (UDP).
block out on fxp0                 all
pass  out on fxp0 inet proto tcp  all flags S/SA keep state
pass  out on fxp0 inet proto udp  all            keep state
pass  out on fxp0 inet proto icmp all            keep state
</pre></blockquote>

<p>
Aunque esto pueda parecer suficiente, todav&iacute;a hay algunas cosas
que PF nos permitir&aacute; realizar para que el fichero
<tt>pf.conf</tt> sea m&aacute;s claro y m&aacute;s f&aacute;cil de
mantener.

<p>
<b><i>Sets</i> (agrupaciones)</b>

<p>
Las agrupaciones son abreviaciones que sirven para escribir reglas
m&aacute;s simples y claras en PF.  Por ejemplo, &iquest;qu&eacute;
har&iacute;amos si quisi&eacute;ramos permitir conexiones a un servicio
que funcionase sobre m&uacute;ltiples protocolos como BIND, que usa TCP
y UDP?

<blockquote><pre>
pass in quick on fxp0 inet proto { tcp, udp } from any to any port 53
</pre></blockquote>

<p>
N&oacute;tense los espacios a ambos lados de los caracteres '{ }'.

<p>
Los grupos de IP relacionadas entre s&iuacute; se pueden reagrupar en
agrupaciones (<i>sets</i>);  estas agrupaciones se pueden utilizar en
cualquier parte en la que se pueda usar una IP.  Por ejemplo, tomando
como partida nuestras reglas contra la falsificaci&oacute;n de IP
anteriores:

<blockquote><pre>
# no permitir que nadie pueda falsificar las
# direcciones no enrutables
block in quick on fxp0 inet from { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 } to any
block out quick on fxp0 inet from any to { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 }
</pre></blockquote>

<p>
<b>Expansi&oacute;n de variables</b>

<p>
Un problema con el ejemplo del fichero <tt>pf.conf</tt> anterior es que,
si necesit&aacute;ramos cambiar nuestro NIC, o cambiar una
direcci&oacute;n IP, tendr&iacute;amos que modificar muchas
l&iacute;neas.  Para suavizarlo podemos definir variables de
expansi&oacute;n:

<blockquote><pre>
NoRouteIPs=&quot;{ 127.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, 10.0.0.0/8 }&quot;
ExtIF=&quot;fxp0&quot;
block in quick on $ExtIF from $NoRouteIPs to any
block out quick on $ExtIF from any to $NoRouteIPs
</pre></blockquote>

<p>
<a name="sample_pf.conf"></a>
<b>Todo junto</b>

<p>
Pongamos todo lo que hemos visto hasta ahora en un fichero y comprobemos
la elegancia de este fichero:

<blockquote><pre>
# definir algunas variables
ExtIF=&quot;fxp0&quot;              # la interfaz externa
IntNet=&quot;1.1.1.0/24&quot;       # nuestra red interna
NoRouteIPs=&quot;{ 127.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, 10.0.0.0/8 }&quot;
Services=&quot;{ www, https }&quot;

# eliminar los paquetes fragmentados y an&oacute;malos
scrub in all

# no permitir que alguien pueda falsificar
# las direcciones no enrutables
block in  quick on $ExtIF from $NoRouteIPs to any
block out quick on $ExtIF from any to $NoRouteIPs
 
# por definici&oacute;n, bloquear todos los paquetes
# entrantes, excepto los que tengan el paso permitido de forma
# expl&iacute;cita en reglas siguientes
block in on $ExtIF all

# permitir a otros el uso de http y https
pass  in on $ExtIF inet proto tcp from any to any port $Services \
	flags S/SA keep state

# y dejar salir al tr&aacute;fico saliente, y mantener el
# estado en las conexiones establecidas
# pass out all protocols, including TCP, UDP and ICMP, and create state,
# so that external DNS servers can reply to our own DNS requests (UDP).
block out on $ExtIF                 all
pass  out on $ExtIF inet proto tcp  all flags S/SA keep state
pass  out on $ExtIF inet proto udp  all            keep state
pass  out on $ExtIF inet proto icmp all            keep state
</pre></blockquote>

<p>
Si se experimenta problemas, puede activarse el registro en reglas
individuales con la clave <i>log</i> para facilitar la
resoluci&oacute;n de los problemas, o sea:

<blockquote><pre>
pass in log quick on fxp0 proto tcp from 1.1.1.0/24 to any port 22
</pre></blockquote>

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp ;manpath=OpenBSD+3.3">pflogd(8)</a>
escribir&aacute; las entradas de registros de ip a
<tt>/var/log/pflog</tt>.
Recu&eacute;rdese que <tt>/var/log/pflog</tt> es un fichero binario que
debe ser le&iacute;do por medio de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcpdump&amp;sektion=8&amp;manpath=OpenBSD+3.3">tcpdump(8)</a>,
y NO directamente como un fichero normal de texto.

<p>
&iexcl;Cuando se modifique el fichero de configuraci&oacute;n para el
registro de paquetes, no hay que olvidarse de ejecutar <kbd>pfctl -R
/etc/pf.conf</kbd> para que se efect&uacute;en los cambios!

<p>
<a name="6.3"></a>
<a name="NAT"></a>
<h2>6.3 - NAT, el sistema de Traducci&oacute;n de Direcciones de
Red</h2>
<!-- XXXrelease -->
<p>
<h4>Nota:  En OpenBSD 3.2 y en versiones posteriores, las funciones de
NAT se han incorporado en el fichero <tt>/etc/pf.conf</tt>, no en el
fichero aparte <tt>/etc/nat.conf</tt> que se usaba en OpenBSD 3.0 y
3.1</h4>

<p>
<a name="nat1.0"></a>
<h3><u>6.3.1 Introducci&oacute;n a NAT</u></h3>

<a name="nat1.1"></a>

<p>
Basado en la especificaci&oacute;n
<a href="http://www.geektools.com/rfc/rfc1631.txt">RFC 1631</a>, NAT
provee de un modo f&aacute;cil para la asignaci&oacute;n de redes
internas a una sola direcci&oacute;n de Internet enrutable
(&laquo;real&raquo;).  Es de gran utilidad si no se dispone de
direcciones asignadas oficialmente para cada anfitri&oacute;n en la red
interna.  Cuando se configuren redes privadas/internas se pueden
aprovechar los bloques de direcci&oacute;n reservados (asignados en la
especificaci&oacute;n
<a href="http://www.geektools.com/rfc/rfc1918.txt">RFC 1918</a>), como:

<p>
10.0.0.0/8 (10.0.0.0 - 10.255.255.255)<br>
172.16.0.0/12 (172.16.0.0 - 172.31.255.255)<br>
192.168.0.0/16 (192.168.0.0 - 192.168.255.255)

<p>
Se asume que el usuario ya disponde de un sistema OpenBSD configurado
con dos tarjetas de red (una conectada a Internet y la otra a la red
local).

<p>
<a name="nat1.3"></a>
<b>Detalles de configuraci&oacute;n</b>

<p>
Usaremos el sistema que se describe a continuaci&oacute;n como ejemplo.
Como la configuraci&oacute;n particular de cada usuario ser&aacute;, con
casi toda seguridad, distinta a &eacute;sta, hay que tener mucho cuidado
con no copiar literalmente todo lo que aqu&iacute; se vea y
despu&eacute;s esperar que funcione correctamente.

<blockquote>
<b>NICs: </b>
<pre>
Intel EtherExpress Pro/100 <b>fxp0</b>
Conectada a la LAN EXTERNA (o WAN)
<b>IP Address: </b>24.5.0.5
<b>Netmask: </b>255.255.255.0

Compaq Netelligent 10/100Mb <b>tl0</b>
Conectada a la LAN INTERNA
<b>IP Address: </b>192.168.1.1
<b>Netmask: </b>255.255.255.0
</pre>
</blockquote>

<blockquote>
<b>IP enrutable por Internet, externo (en este ejemplo, una
conexi&oacute;n por m&oacute;dem anal&oacute;gico a trav&eacute;s de un
proveedor de servicios de Internet)</b><br>
<pre>
<b>IP Address: </b>24.5.0.5
<b>Netmask: </b>255.255.255.0
<b>Gateway: </b>24.5.0.1
</pre>
</blockquote>

<blockquote>
<b>Red de &Aacute;rea Local (LAN)</b><br>
En este entorno de ejemplo las m&aacute;quinas de la LAN usan el esquema
de direcciones IP 192.168.1.xxx (en donde xxx es un n&uacute;mero
&uacute;nico).  Existe una gran variedad de sistemas operativos
diferentes en la red interna, incluidos Windows 98, Windows NT, OpenBSD
y Linux, pero el sistema operativo cliente no es un problema para NAT.
Cada m&aacute;quina est&aacute; conectada a un concentrador
(<i>hub</i>) designado para el uso interno.  Para este documento y sus
ejemplos, se asumir&aacute; que el cliente en la red interna tiene una
direcci&oacute;n de IP 192.168.1.40
</blockquote>

<blockquote>
<b>Diagrama de configuraci&oacute;n</b>
<pre>

+-----+              +---------+          +----------+
| Hub |--------- tl0 |   NAT   | fxp0 ----| Internet |
+-----+              +---------+          +----------+
| |
| +-- Cliente A
+---- M&aacute;s clientes

		      +--------------------------+
		      |          LEYENDA         |
		      +--------------------------+
		      |  NIC fxp0 - 24.5.0.5     |
		      |  NIC tl0  - 192.168.1.1  |
		      | Cliente A - 192.168.1.40 |
		      +--------------------------+

</pre>
</blockquote>

<p>
<a name="nat2.0"></a>
<h3><u>6.3.2 Traducci&oacute;n de Direcciones de Red</u></h3>

<p>
<a name="nat2.1"></a>
<b>Introducci&oacute;n a NAT</b>

<p>
Cada nodo en Internet requiere una direcci&oacute;n IP &uacute;nica.
Con IPv4 hay un n&uacute;mero finito de direcciones IP diferentes
disponibles, y como resultado no son gratuitas.  La mayor&iacute;a de
proveedores de Internet a &laquo;bajo coste&raquo; limitan un sitio a
cualquier parte desde 1 a 30 direcciones, y mientras organizaciones con
presupuestos m&aacute;s grandes pueden permitirse un bloque mayor, en la
mayor&iacute;a de los casos existen pocos beneficios y demasiados
riesgos al tener cada m&aacute;quina con una direcci&oacute;n individual
en Internet.

<p>
La &laquo;Traducci&oacute;n de Direcciones de Red&raquo; (<i>Network
Address Translation</i>), o NAT, tambi&eacute;n conocida como
&laquo;Enmascaramiento de IP&raquo; en Linux (<i>IP Masquerading</i>),
permite que varias m&aacute;quinas se encuentren <i>detr&aacute;s</i> de
una sola, o de varias, direcci&oacute;n IP.  Cada m&aacute;quina en la
red interna tiene una direcci&oacute;n IP no registrada que se asigna de
forma interna (de acuerdo con las especificaciones del
<a href="http://www.geektools.com/rfc/rfc1918.txt">RFC 1918</a>), y
todas utilizan la misma direcci&oacute;n IP externa de forma
simult&aacute;nea.

<p>
NAT funciona de un modo bastante simple.  Cuando un cliente dentro de la
LAN quiere conectarse a la m&aacute;quina en Internet, le env&iacute;a
un paquete TCP con un requerimiento de conexi&oacute;n.  Dentro de la
cabecera del paquete TCP se encuentra la direcci&oacute;n IP del cliente
(por ejemplo, 192.168.1.40) y la direcci&oacute;n IP del
anfitri&oacute;n requerido (por ejemplo, 123.45.67.89).  La
m&aacute;quina en la que est&aacute; funcionando NAT intercepta este
paquete TCP y cambia la direcci&oacute;n IP del cliente de 192.168.1.40
a la direcci&oacute;n IP de la m&aacute;quina conectada a Internet (por
ejemplo, 24.5.0.5).  De este modo enga&ntilde;a a la m&aacute;quina
anfitriona, haci&eacute;ndole pensar que la conexi&oacute;n requerida
proviene de la m&aacute;quina con NAT, no de la m&aacute;quina cliente.
Entonces, el anfitri&oacute;n env&iacute;a de vuelta respuestas a la
m&aacute;quina NAT como si &eacute;sta fuera la que se estuviera
conectando.  Cuando la m&aacute;quina NAT recibe las respuestas, las
traduce r&aacute;pidamente y env&iacute;a el paquete al cliente.
Generalmente, el cliente no tiene ni la m&aacute;s remota idea de lo que
est&aacute; ocurriendo, y la supuesta conexi&oacute;n a Internet es
transparente para el usuario y para las aplicaciones del usuario.

<p>
El ejemplo siguiente muestra NAT de un modo m&aacute;s claro:

<blockquote><pre>
Cliente ---------------- tl0 [ NAT ] fxp0 ---------- Internet Host
192.168.1.40 --- 192.168.1.1 [ NAT ] 24.5.0.5 --- 123.45.67.89

Paquete TCP SALIENTE                             Paquete TCP SALIENTE
Desde: 192.168.1.40  &gt;&gt;=== NAT ===&gt;&gt; Hacia: 24.5.0.5
Hacia: 123.45.67.89                              Hacia: 123.45.67.89

Paquete TCP ENTRANTE				 Paquete TCP ENTRANTE
Desde: 123.45.67.89 				 Desde: 123.45.67.89
Hacia: 192.168.1.40  &lt;&lt;=== NAT ===&lt;&lt; Hacia: 24.5.0.5
</pre></blockquote>

<p>
<a name="nat2.2"></a>
<b>&iquest;Por qu&eacute; usar NAT?</b>

<p>
Despu&eacute;s de haber conseguido un m&oacute;dem cable en mi nuevo
apartamento, me d&iacute; cuenta de que ten&iacute;a un peque&ntilde;o
problema:  &iquest;c&oacute;mo podr&iacute;a conseguir acceso a Internet
para mis compa&ntilde;eros de apartamento si el m&oacute;dem estaba en
mi habitaci&oacute;n?  S&oacute;lo hab&iacute;a unas pocas opciones que
pod&iacute;a utilizar, y que iban desde obtener direcciones IP extras,
pasando por instalar un servidor proxy, hasta instalar NAT (el ejemplo
casero del m&oacute;dem cable no debe llevarnos a enga&ntilde;o, NAT es
lo suficientemente potente como para enmascarar un gran red con cientos
o incluso miles de m&aacute;quinas).

<p>
Existen varias razones por las que decid&iacute; instalar NAT, la
primera de ellas fue el ahorro en costes.  En la casa viv&iacute;an dos
compa&ntilde;eros de piso, y compartir gastos es una buena idea.
Adem&aacute;s, cada uno ten&iacute;a su propio PC y yo ten&iacute;a
tres; ten&iacute;amos cinco m&aacute;quinas que conectar, pero mi ISP
s&oacute;lo permit&iacute;a tres direcciones IP por casa, lo que
significaba que no hab&iacute;an direcciones IP suficientes para que
cada m&aacute;quina pudiera acceder a Internet de forma
simult&aacute;nea.

<p>
Usando NAT, cada m&aacute;quina tendr&iacute;a una direcci&oacute;n IP
interna &uacute;nica,  pero todas compartir&iacute;an la &uacute;nica
direcci&oacute;n IP que mi ISP me dio.  El coste se redujo notablemente.

<p>
<a name="nat2.4"></a>
<b>Preconfiguraci&oacute;n</b>

<p>
Para activar NAT en una m&aacute;quina OpenBSD, antes hay que configurar
PF.  Esto se puede hacer f&aacute;cilmente editando los ficheros que
aparecen en la siguiente lista (los cambios al fichero deben hacerse de
tal modo que aparezcan como las opciones que siguen a
continuaci&oacute;n):

<p>
<b>/etc/rc.conf</b> (este fichero se usa para iniciar servicios durante
el arranque)

<blockquote><pre>
pf=YES<br>
</pre></blockquote>

<p>
<b>/etc/sysctl.conf</b>

<blockquote><pre>
net.inet.ip.forwarding=1
</pre></blockquote>

<p>
Despu&iacute;s de haber realizado estos cambios, la m&aacute;quina
estar&aacute; lista para la configuraci&oacute;n de NAT.

<p>
<a name="nat2.5"></a>
<b>Configuraci&oacute;n</b>

<p>
El primer paso es configurar el fichero de reglas de PF
(<tt><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+3.3">/etc/pf.conf</a></tt>).
Para el prop&oacute;sito que persigue este documento, dejaremos que el
tr&aacute;fico pase a trav&eacute;s de este cortafuegos sin que haya
interferencias.  El fichero quedar&aacute; como sigue:

<blockquote><pre>
pass in all
pass out all
</pre></blockquote>

<p>
Se puede ver m&aacute;s informaci&oacute;n en la secci&oacute;n que
trata sobre <a href="#PF"><tt>PF</tt>, el paquete de filtros IP</a> de
OpenBSD.

<p>
La sintaxis de la parte correspondiente a NAT del fichero de
configuraci&oacute;n
(<tt><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+3.3">/etc/pf.conf</a></tt>)
es bastante simple.  De acuerdo con el ejemplo de configuraci&oacute;n
anterior, el fichero de configuraci&oacute;n de NAT contendr&aacute; las
siguientes entradas:

<blockquote><pre>
nat on fxp0 from 192.168.1.0/24 to any -&gt; 24.5.0.5
</pre></blockquote>

<p>
He aqu&iacute; el significado de cada una de estas l&iacute;neas.

<dl>
<dt>&quot;nat&quot;
<dd>Indica que la orden que se est&aacute; dando es una regla de NAT.
</dl>

<dl>
<dt>&quot;fxp0&quot;
<dd>&Eacute;sta es la interfaz de red que est&aacute; conectada a
Internet.
</dl>

<dl>
<dt>&quot;192.168.1.0/24&quot;
<dd>La direcci&oacute;n IP y de enmascaramiento de red
(<i>netmask</i>, cuyo formato es CIDR).  La combinaci&oacute;n de ambas
indica que &laquo;se debe asignar cualquier direcci&oacute;n IP con un
valor desde 192.168.1.1 hasta 192.168.1.254&raquo;.
</dl>

<dl>
<dt>&quot;24.5.0.5&quot;
<dd>&Eacute;sta es la direcci&oacute;n IP externa que se asignar&aacute;
a la direcci&oacute;n IP interna.
</dl>


<p>
<a name="nat2.6"></a>
<b>Funcionamiento</b>

<p>
Una vez que se haya acabado de configurar, hay dos formas de activar
NAT.  La primera forma, y la mejor si fuera posible, es reiniciando el
sistema OpenBSD.  Para ello basta con usar la orden <kbd>reboot</kbd>.

<p>
Si se quiere ejecutar NAT desde la l&iacute;nea de &oacute;rdenes,
ser&aacute; necesario usar las siguientes &oacute;rdenes:

<blockquote>
<pre>
# <b>pfctl -N /etc/nat.conf</b>
# <b>pfctl -e</b>
</pre>
</blockquote>

<p>
La primera l&iacute;nea es para cargar un grupo de reglas de NAT en PF
(y eliminar cualquier regla anterior), y la segunda para activar PF.
Despu&eacute;s de esto, la mejor manera de asegurarse de que todo
iniciar&aacute; como se espera, es reiniciar el sistema.

<p>
<b>Nota:</b> para volver a cargar las configuraciones de NAT (en el caso
en que se cambiaran y no se quisiera reiniciar) debe ejecutarse de nuevo
la primera orden.  Las configuraciones ser&aacute;n descargadas y
cargadas de nuevo.

<p>
<a name="nat3.0"></a>
<h3><u>6.3.3 Base de conocimientos de NAT</u></h3>

<p>
<a name="nat3.1"></a>
<b>Comprobaci&oacute;n del estado de NAT</b>

<p>
Para averiguar c&oacute;mo est&aacute; funcionando NAT o asegurarse de
que las configuraciones hayan hecho efecto, se usa la opci&oacute;n
&quot;-ss&quot;.  Esta opci&oacute;n mostrar&aacute; un listado de todas
las sesiones que NAT est&eacute; usando actualmente:

<blockquote>
<pre>
# pfctl -ss
TCP  192.168.1.40:2132 -&gt; 24.5.0.5:53136 -&gt; 65.42.33.245:22       TIME_WAIT:TIME_WAIT
TCP  192.168.1.40:2492 -&gt; 24.5.0.5:55011 -&gt; 65.42.33.245:22       ESTABLISHED:ESTABLISHED
UDP  192.168.1.40:2491 -&gt; 24.5.0.5:60527 -&gt; 24.2.68.33:53       2:1
</pre>
</blockquote>

<p>
A continuaci&oacute;n puede verse una explicaci&oacute;n sobre lo que
significa la primera l&iacute;nea (las otras son similares):

<dl>
<dt>&quot;192.168.1.40:2132&quot;
<dd>Indica la direcci&oacute;n IP de la m&aacute;quina que est&eacute;
usando NAT (192.168.1.40) en la LAN.  El n&uacute;mero del puerto que se
use para realizar la conexi&oacute;n (2132) se mostrar&aacute; a
continuaci&oacute;n.
</dl>

<dl>
<dt>&quot;24.5.0.5:53136&quot;
<dd>Indica que la conexi&oacute;n se dirige hacia Internet a
trav&eacute;s de la direcci&oacute;n 24.5.0.5, usando el puerto 53136.
</dl>

<dl>
<dt>&quot;65.42.33.245:22&quot;
<dd>La direcci&oacute;n IP y el puerto al que se conecta.
</dl>

<dl>
<dt>&quot;TIME_WAIT:TIME_WAIT&quot;
<dd>Indica el estado en que PF cree que se encuentra la conexi&oacute;n
TCP.
</dl>

<p>
<a name="nat3.2"></a>
<b>Consideraciones sobre FTP y NAT</b>

<p>
Existen unas cuantas limitaciones de NAT a tener en cuenta, de las
cuales la m&aacute;s com&uacute;n es con FTP.  FTP se puede usar de dos
modos:  pasivo y activo;  de &eacute;stos, FTP pasivo est&aacute;
considerado como el m&aacute;s seguro en la mayor&iacute;a de los casos.

<p>
Con FTP activo, cuando un usuario se conecta a un servidor de FTP remoto
y pide un fichero o informaci&oacute;n, el cliente de FTP env&iacute;a
al servidor un n&uacute;mero de puerto aleatorio en el que el servidor
establecer&aacute; una conexi&oacute;n para el cliente y por el que
tranmitir&aacute; la informaci&oacute;n requerida.  Esto supone un
problema para los usuarios que intenten acceder a servidores de FTP
desde dentro de la misma red interna.  Cuando el servidor de FTP
env&iacute;a su informaci&oacute;n, la env&iacute;a al NIC externo y a
un puerto aleatorio.  La m&aacute;quina de NAT la recibe, pero debido a
que no tiene asignaciones para el paquete desconocido ni para este
puerto, bloquea el paquete y no lo entrega.

<p>
Con el modo pasivo de FTP (el predeterminado en el cliente de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftp&amp;sektion=1">ftp(1)</a>
en OpenBSD), el cliente realiza una petici&oacute;n para que el servidor
escoja un puerto aleatorio, y se mantiene a la escucha por ese puerto en
espera de recibir los datos de conexi&oacute;n.  El servidor informa al
cliente del puerto que ha elegido, y el cliente se conecta a ese puerto
para transferir los datos.  Esto, desafortunadamente, no siempre es
posible ni deseable.  ftp(1) usa este modo por definici&oacute;n;  para
forzar el uso del modo activo de FTP hay que usar el indicador <i>-A</i>
con la orden de <kbd>ftp</kbd>, o desactivar el modo pasivo mediante la
orden

<blockquote><pre>
passive off
</pre></blockquote>

<p>
desde el punto de inserci&oacute;n <i>ftp&gt;</i>.

<p>
PF dispone de otra soluci&oacute;n para este caso, redireccionando el
tr&aacute;fico de FTP a trav&eacute;s de un servidor <i>proxy</i> de
FTP, un proceso que &laquo;gu&iacute;a&raquo; el tr&aacute;fico de FTP a
trav&eacute;s de los filtros.  El <i>proxy</i> de FTP utilizado por
OpenBSD y PF es
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftp-proxy&amp;sektion=8&amp;manpath=OpenBSD+3.3">ftp-proxy(8)</a>.

Para activarlo hay que a&ntilde;adir al fichero <tt>/etc/pf.conf</tt>
algo parecido a esto:

<blockquote><pre>
rdr on tl0 proto tcp from any to any port 21 -&gt; 127.0.0.1 port 8021
</pre></blockquote>

<p>
En pocas palabras, esta l&iacute;nea significa que el
&laquo;tr&aacute;fico por el puerto 21 de TCP en la interfaz interna se
redirecciona al servidor de proxy que hay funcionando en esta
m&aacute;quina y que est&aacute; a la escucha por el puerto 8021&raquo;.

<p>
Con suerte, es f&aacute;cil ver que el servidor de proxy se debe iniciar
y ejecutar en la m&aacute;quina OpenBSD, lo que se hace introduciendo la
siguiente l&iacute;nea en el fichero <tt>/etc/inetd.conf</tt>:

<blockquote><pre>
127.0.0.1:8021 stream tcp nowait root /usr/libexec/ftp-proxy ftp-proxy
</pre></blockquote>

y reiniciando el sistema of enviando una se&ntilde;al 'HUP' a
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inetd&amp;sektion=8">inetd(8)</a>.
Una modo de enviar esta se&ntilde;al 'HUP' es mediante la orden:

<blockquote><pre>
kill -HUP `cat /var/run/inetd.pid`
</pre></blockquote>

<p>
N&oacute;tese que ftp-proxy quedar&aacute; a la escucha por el puerto
8021, el mismo puerto al que rdr estaba enviando el tr&aacute;fico de
FTP.  Hemos escogido el puerto 8021 de forma arbitraria, aunque 8021 es
una buena elecci&oacute;n ya que no est&aacute; asignado para ninguna
otra aplicaci&oacute;n.

<p>
<a name="nat3.3"></a>
<b>Redireccionamiento del tr&aacute;fico</b>

<p>
Con algunas aplicaciones es probable que haya que redireccionar el
tr&aacute;fico entrante o saliente para un cierto protocolo y/o puerto,
hacia una cierta m&aacute;quina que se encuentre detr&aacute;s del
sistema de filtros.  Un ejemplo de esto podr&iacute;a ser el caso de una
m&aacute;quina que se encontrara dentro de la red local y que tuviera un
servidor de <i>web</i> al que hubiera que acceder desde fuera (o, por
supuesto, por el ya consabido ftp-proxy(8)).  Las conexiones entrantes a
nuestra IP v&aacute;lida de Internet se encontrar&aacute;n con que, a
menos que la m&aacute;quina de NAT tambi&eacute;n tenga un servidor de
<i>web</i>, no pondr&aacute;n conectarse.  Para ello usaremos la
directiva 'rdr' de NAT en el fichero de reglas, a fin de dar las
instrucciones sobre hacia d&oacute;nde se debe redireccionar una
conexi&oacute;n concreta.

<p>
Para nuestro ejemplo, supongamos que un servidor de <i>web</i> reside en
la LAN y que su direcci&oacute;n IP es 192.168.1.80.  El fichero de
reglas de NAT necesita una nueva directiva para gestionar esta
situaci&oacute;n.  Hay que a&ntilde;adir una l&iacute;nea parecida a la
siguiente en el fichero <tt>/etc/pf.conf</tt>:

<blockquote>
<pre>
rdr on fxp0 proto tcp from any to any port 80 -&gt; 192.168.1.80 port 80
</pre>
</blockquote>

<p>
Desglosando esta l&iacute;nea para ver qu&eacute; signfica cada
componente de ella:

<dl>
<dt>&quot;rdr&quot;
<dd>Es la orden que le est&aacute; pasando a NAT.  Indica a NAT que lo
que viene a continuaci&oacute;n es una entrada para redireccionar una
conexi&oacute;n.
</dl>


<dl>
<dt>&quot;on fxp0&quot;
<dd>Es la interfaz de red que est&aacute; conectada a Internet.
</dl>

<dl>
<dt>&quot;from any to any&quot;
<dd>Indica cu&aacute;l es la direcci&oacute;n IP que hay que
redireccionar (cualquiera de las que entren en fxp0, como se indica
anteriormente, con cualquier IP como destino).
</dl>

<dl>
<dt>&quot;port 80&quot;
<dd>&Eacute;ste es el puerto (80) entrante que debe ser redireccionado.
No es estrictamente necesario indicar el puerto con el n&uacute;mero
&laquo;80&raquo;, tambi&eacute;n se podr&iacute;a indicar como
&laquo;port www&raquo; para especificar una redirecci&oacute;n del
puerto 80.  Si se quiere usar un nombre en lugar de un n&uacute;mero, el
nombre del servicio y el puerto correspondiente deben existir en el
fichero <tt>/etc/services</tt>.
</dl>

<dl>
<dt>&quot;192.168.1.80 port 80&quot;
<dd>La direcci&oacute;n IP de la m&aacute;quina LAN a la que son
redireccionados los paquetes.  N&oacute;tese que el puerto de destino NO
tiene porqu&eacute; coincidir con el puerto entrante.  Por ejemplo, lo
siguiente es v&aacute;lido e incluso puede ser &uacute;til:
<pre>
rdr on fxp0 proto tcp from any to any port 8080 -&gt; 192.168.1.35 port 80
</pre>
Esta l&iacute;nea redireccionar&iacute;a el tr&aacute;fico entrante en
el puerto 8080 a un servidor de <i>web</i> de una m&aacute;quina en la
red interna, en el puerto 80.
</dl>

<p>
Cuando hayamos terminado de a&ntilde;adir todos los datos, recargaremos
las reglas de NAT y el redireccionamiento comezar&aacute; de inmediato.

<p>
<b>Denegaci&oacute;n</b>

<p>
En ocasiones es necesario aplicar excepciones a una regla de
redireccionamiento de NAT.  Un ejemplo de esto ser&iacute;a <i>AOL
Instant Messenger</i>, que suele escabullirse de los cortafuegos a
trav&eacute;s de cualquier puerto disponible.  Es posible que ftp-proxy
interfiera con AIM cuando decide salir por el puerto remoto 21.  Si
alguien que esto puede ser malo (muchas personas pierden bastante tiempo
intentando bloquear AIM), se pueden excluir las direcciones IP utilizada
por los servidores AIM del tr&aacute;fico redireccionado por nuestra
l&iacute;nea de ftp-proxy anterior.  Para ello, se usar&aacute; la
siguiente regla:

<blockquote>
<pre>
rdr on tl0 proto tcp from any to ! 64.12.163.199 port 21 -&gt; 127.0.0.1 port 8021
</pre>
</blockquote>

Interpretaci&oacute;n: redireccionar el tr&aacute;fico que entra en tl0
con direcci&oacute;n al puerto 21, pero NO por 64.12.163.199 (por el que
los usuarios del servidor de AIM ten&iacute;an problemas) al puerto 8021
del anfitri&oacute;n local (en donde se supone que estar&aacute;
esperando ftp-proxy).  Pero avisamos que existen muchos servidores de
AIM;  si alguien est&aacute; interesado en esta aplicaci&oacute;n, es
probable que tenga que jugar con estas direcciones IP (64.12.0.0/16
puede ser m&aacute; productiva, aunque es probable que tambi&eacute;n
interfiera con algunos sitios que no sean de AOL).

<p>
<a name="nat3.4"></a>
<b>NAT frente a proxy</b>

<p>
La diferencia entre NAT y una aplicaci&oacute;n basada en <i>proxy</i>
es que el software de <i>proxy</i> act&uacute;a como un intermediario
entre Internet y las m&aacute;quinas conectadas a la LAN.  En
prinicipio, esto no representa ning&uacute;n problema;  sin embargo,
cada aplicaci&oacute;n que se quiera ejecutar en la m&aacute;quina y
conectarla a Internet a trav&eacute;s del servidor de <i>proxy</i>, DEBE
reconocer el <i>proxy</i> (ser capaz de usarlo).  No todas las
aplicaciones son capaces de esto (en especial los juegos).  A&uacute;n
m&aacute;s, no existen aplicaciones para servidores de <i>proxy</i> para
todos los servicios de Internet.  NAT asigna la red interna de un modo
transparente, para que sea posible conectares a Internet.  La
&uacute;nica ventaja de seguridad que proxy tiene sobre NAT es que el
software de <i>proxy</i> puede haber sido programado para funciones de
seguridad, y puede filtrar de acuerdo con el contenido a fin de evitar
que una macro de virus se interne en la m&aacute;quina Windows, o
proteger los programas contra desbordamientos de la memoria intermedia
(<i>buffer overflows</i>) y otros peligros.  El mantenimiento de estos
filtros es, con frecuencia, un trabajo muy pesado.

<p>
<a name="nat3.5"></a>
<b>Redireccionamiento y reflexi&oacute;n</b>

<p>
Con frecuencia, las reglas de redireccionamiento se usan para reenviar
conexiones entrantes desde Internet hacia un servidor local con una
direcci&oacute;n privada en la LAN, como en:

<pre>
rdr on $ext_if proto tcp from any to $ext_if port 80 -&gt; $server port 80
</pre>

<p>
Pero cuando se comprueba la regla de redireccionamiento desde un cliente
en la LAN, no funciona.  El motivo es que las reglas de
redireccionamiento s&oacute;lo son aplicables a los paquetes que pasan a
trav&eacute;s de la interfaz especificada (<tt>$ext_if</tt>, la interfaz
externa en el ejemplo).  Sin embargo, el conectarse a la
direcci&oacute;n externa del cortafuegos desde un anfitri&oacute;n en la
LAN no significa que los paquetes vayan a pasar a trav&eacute;s de su
interfaz externa.  La pila TCP/IP del cortafuegos compara la
direcci&oacute;n de destino de los paquetes entrantes con su propia
direcci&oacute;n y sus alias, y detecta las conexiones a si misma tan
pronto como pasan la interfaz interna.  Estos paquetes no pasan de
f&iacute;sicamente por la interfaz interna, y la pila no simula un pase
de este tipo de nin&uacute;n modo.  pf nunca ve estos paquetes en la
interfaz externa, y la regla de redireccionamiento especificando la
interfaz interna, no es aplicable.

<p>
Al a&ntilde;adir una segunda regla de redireccionamiento para la
interfaz interna no surte el efecto deseado.  Cuando el cliente local se
conecta a la direcci&oacute;n externa del cortafuegos, el paquete
inicial del saludo de conexi&oacute;n de TCP (<i>TCP handshake</i>)
llega al cortafuegos a trav&eacute;s de la interfaz interna.  La regla
de redirecci&oacute;n es entonces aplicable y la direcci&oacute;n de
destino se sustituye con la del servidor interno.  El paquete se
reenv&iacute;a de vuelta a trav&eacute;s de la interfaz interna y llega
al servidor interno.  Pero la direcci&oacute;n de origen no se ha
traducido y todav&iacute;a contiene la direcci&oacute;n local del
cliente, por lo que el servidor env&iacute;a sus respuestas directamente
al cliente.  El cortafuegos nunca llega a ver la respuesta y por lo
tanto no tiene la oportunidad de invertir correctamente la
traducci&oacute;n.  El cliente recibe una respuesta desde una fuente que
no esperaba, por lo que la bloquea, falla el saludo de conexi&oacute;n
de TCP, y no se llega a establecer ninguna conexi&oacute;n.

<p>
Aun as&iacute;, con frecuencia es deseable que los clientes en la LAN se
conecten al mismo servidor interno como clientes externos, de forma
transparente.  Existen varias soluciones para este problema:

<p>
<b>Dividir el horizonte de DNS</b>

<p>
Es posible configurar los servidores de DNS para que respondan a
requerimientos de anfitriones locales de forma diferente que a
requerimientos externos, para que los clientes locales reciban la
direcci&oacute;n interna del servidor durante la resoluci&oacute;n del
nombre.  Entonces se conectar&aacute;n directamente al servidor local, y
el cortafuegos no formar&aacute; parte en modo alguno.  De este modo se
reduce el tr&aacute;fico local, ya que los paquetes no tienen que ser
enviados a trav&eacute;s del cortafuegos.

<p>
<b>Trasladar el servidor a una red local separada</b>

<p>
Al a&ntilde;adir una interfaz de red adicional al cortafuegos y
trasladar el servidor local desde la red del cliente a una red dedicada
(DMZ), se permite el redireccionamiento de las conexiones desde clientes
locales del mismo modo que el redireccionamiento de conexiones externas.
El uso de redes separadas tiene varias ventajas, incluida la mejora de
la seguridad mediante el aislamiento del servidor del resto de los
anfitriones locales.  Si alguna vez se comprometiera el servidor (que en
nuestro caso es accesible desde Internet), no podr&iacute;a acceder a
otros anfitriones locales de forma directa, ya que todas las conexiones
tienen que pasar a trav&eacute;s del cortafuegos.

<p>
<b>TCP proxying</b>

<p>
Se puede configurar una proxy de TCP en el cortafuegos, bien a la
escucha en el puerto de reenv&iacute;o o bien redireccionando las
conexiones de la interfaz interna al puerto por el que est&eacute; a la
escucha.  Cuando un cliente local se conecta al cortafuegos, la proxy
acepta la conexi&oacute;n, establece una segunda conexi&oacute;n al
servidor interno, y reenv&iacute;a los datos entre esas dos conexiones.

<p>
Las proxies simples se pueden crear usando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inetd&sektion=8">inetd(8)</a>
y <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nc&sektion=1">nc(1)</a>.
La siguiente entrada de <tt>/etc/inetd.conf</tt> crea un conector
(<i>socket</i>) vinculado a la direcci&oacute;n de circuito cerrado
(<i>loopback</i>) y al puerto 5000.  Las conexiones se reenv&iacute;an
al puerto 80 del servidor 192.168.1.10.

<pre>
127.0.0.1:5000 stream tcp wait nobody /usr/bin/nc nc -w 20 192.168.1.10 80
</pre>

<p>
La siguiente regla de redireccionamiento reenv&iacute;a el puerto 80 de
la interfaz interna a la proxy:

<pre>
rdr on $int_if proto tcp from $int_net to $ext_if port 80 -&gt; 127.0.0.1 port 5000
</pre>

<p>
<b>Combinaci&oacute;n de RDR y NAT</b>

<p>
Con una regla adicional de NAT en la interfaz interna se puede obtener
la traducci&oacute;n de la direcci&oacute;n de origen que falta y que se
ha descrito anteriormente.

<pre>
rdr on $int_if proto tcp from $int_net to $ext_if port 80 -&gt; $server
no nat on $int_if proto tcp from $int_if to $int_net
nat on $int_if proto tcp from $int_net to $server port 80 -&gt; $int_if
</pre>

<p>
Esto har&aacute; que el paquete inicial desde el cliente sea traducido
de nuevo cuando se reenv&iacute;e de vuelta a trav&eacute;s de la
interfaz interna, sustituyendo la direcci&oacute;n de origen del cliente
con la direcci&oacute;n interna del cortafuegos.  El servidor interno
enviar&aacute; un respuesta de vuelta al cortafuegos, que puede invertir
las traducciones de NAT y RDR cuando lo reenv&iacute;e al cliente local.
Esta construcci&oacute;n es algo compleja, ya que crea dos estados
separados por cada conexi&oacute;n reflectada.  Hay que tener cuidado de
evitar que la regla de NAT sea aplicable a otro tr&aacute;fico, por
ejemplo a conexiones que provengan de anfitriones externos (a
trav&eacute;s de otros redireccionamientos) o del mismo cortafuegos.
N&oacute;tese que la regla de rdr anterior har&aacute; que la pila
TCP/IP vea los paquetes que lleguen a la interfaz interna con una
direcci&oacute;n de destino de dentro de la red interna.  Para evitar
que la pila lance mensajes de redireccionamiento de ICMP (indicando al
cliente que puede alcanzar su destino directamente y rompiendo la
reflexi&oacute;n), se puede desactivar los redireccionamientos en la
pasarela usando

<pre>
# <strong>sysctl -w net.inet.ip.redirect=0</strong>
</pre>

<p>
En general, se deber&iacute;an utilizar las soluciones que se han
mencionado.

<p>
<a name="nat4.0"></a>
<b>6.3.4 Enlaces y referencias</b>

<p>
Ficheros de OpenBSD:
<ul>
<li><tt>/etc/pf.conf</tt> - fichero de reglas de PF/NAT
<li><tt>/etc/rc.conf</tt> - fichero de configuraci&oacute;n general de
inicio del sistema que hay que editar para iniciar NAT y PF durante el
arranque del sistema
<li><tt>/etc/sysctl.conf</tt> - fichero para activar el reenv&iacute;o
de IP (<i>IP forwarding</i>)
</ul>

<p>
Enlaces de NAT en Internet:
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+3.3">p&aacute;gina del manual de pf.conf</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pfctl&amp;sektion=8&amp;manpath=OpenBSD+3.3">p&aacute;gina del manual de pfctl</a>
<li><a href="http://www.geektools.com/rfc/rfc1631.txt">http://www.geektools.com/rfc/rfc1631.txt</a>
</ul>


<p>
<a name="DHCP"></a>
<a name="6.4"></a>
<h2>6.4 - DHCP</h2>

<p>
<h3>6.4.1 Cliente DHCP</h3>

<p>
Para usar el cliente de DHCP que se incluye en OpenBSD, 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient&amp;sektion=8">dhclient(8)</a>,
hay que editar el fichero <tt>/etc/hostname.xl0</tt> (suponiendo que la
interfaz principal de ethernet sea xl0) para modificarlo;  la interfaz
podr&iacute;a ser ep0, o fxp0, o cualquier otra).  La &uacute;nica
modificaci&oacute;n necesaria en este fichero es a&ntilde;adir 'dhcp'.

<pre>
# <b>echo dhcp &gt;/etc/hostname.xl0</b>
</pre>

<p>
Esto har&aacute; que OpenBSD inicie el cliente DHCP
autom&aacute;ticamente durante el arranque.  OpenBSD obtendr&aacute; la
informaci&oacute;n sobre nuestra direcci&oacute;n IP, pasarela, y
servidores de DNS desde el servidor de DHCP.

<p>
Si se quiere iniciar un cliente dhcp desde la l&iacute;nea de
&oacute;rdenes, hay que asegurarse de que el fichero
<tt>/etc/dhclient</tt> exista, y entonces usar la orden:

<pre>
# <b>dhclient fxp0</b>
</pre>

<p>
en donde fxp0 es la interfaz en la que se desea recibir dhcp.

<p>
Sea cual fuere el modo en que se inicie dhclient, se puede editar el
fichero <tt>/etc/dhclient</tt> para <b>evitar</b> que se actualice la
DNS de acuerdo con la idea que tenga el servidor de dhcp sobre la DNS,
comentando las l&iacute;neas precedidas por 'request' (son ejemplos de
la configuraci&oacute;n predefinida, pero es necesario activarlos para
anular la configuraci&oacute;n predefinida de dhclient).

<pre>
request subnet-mask, broadcast-address, time-offset, routers,
      domain-name, domain-name-servers, host-name, lpr-servers, ntp-servers;
</pre>

<p>
y a continuaci&oacute;n <b>eliminar</b> domain-name-servers.
Tambi&eacute;n es posible que se quiera anular hostname u otras
configuraciones.

<p>
<h3>6.4.2 Servidor DHCP</h3>

<p>
Si se quiere usar OpenBSD como servidor DHCP con
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd&amp;sektion=8">dhcpd(8)</a>,
hay que editar el fichero <tt>/etc/rc.conf</tt>, y configurarlo
a&ntilde;adiendo dhcp_flags=&quot;-q&quot; en lugar de dhcp_flags=NO.
Tambi&eacute;n hay que a&ntilde;adir en <tt>/etc/dhcp.interfaces</tt>
las interfaces en las que se quiera que dhcp est&eacute; <b>a la
escucha</b>:

<pre>
# <b>echo xl1 xl2 xl3 &gt;/etc/dhcpd.interfaces</b>
</pre>

<p>
y editar <tt>/etc/dhcpd.conf</tt>.  Las opciones son bastante claras:

<pre>
        option  domain-name &quot;example.com&quot;;
        option  domain-name-servers 192.168.1.3, 192.168.1.5;

        subnet 192.168.1.0 netmask 255.255.255.0 {
                option routers 192.168.1.1;

                range 192.168.1.32 192.168.1.127;
        }
</pre>

<p>
Con esto indicaremos a los clientes de DHCP que el dominio que deben
a&ntilde;adir a sus requerimientos de DNS es example.com (as&iacute;, si
un usuario escribiera 'telnet joe', los enviar&iacute;a a
joe.example.com).  Les dirigir&aacute; a los servidores de DNS
192.168.1.3 y 192.168.1.5.  Para los anfitriones que se encuentren en la
misma red que una interfaz de ethernet en la m&aacute;quina de OpenBSD,
que est&aacute; en el rango 192.168.1.0/24, les asignar&aacute; una
direcci&oacute;n de IP entre 192.168.1.32 y 192.168.1.127, con una
configuraci&oacute;n predeterminada de la pasarela como 192.168.1.1.

<p>
Si se quiere iniciar dhcpd(8) desde la l&iacute;nea de &oacute;rdenes,
hay que intentar lo siguiente despu&eacute;s de editar
<tt>/etc/dhcpd.conf</tt>:

<pre>
# <b>dhcpd -q fxp0</b>
</pre>

<p>
En donde <tt>fxp0</tt> es la interfaz que se quiere que empiece a servir
dhcp.  El indicador <tt>-q</tt> fuerza una salida silenciosa de dhcpd,
ya que de otro modo es muy ruidoso.

<p>
Si se est&aacute; actuando como servidor de DHCP para una m&aacute;quina
Windows, es posible que se desee que dhcpd(8) ofrezca al cliente una
direcci&oacute;n de servidor 'WINS'.  Para ello se debe a&ntilde;adir la
siguiente l&iacute;nea al fichero <tt>/etc/dhcpd.conf</tt>:

<pre>
     option    netbios-name-servers    192.168.92.55;
</pre>

<p>
En donde <tt>192.168.92.55</tt> es el IP del servidor de Windows o
Samba.  Para ver m&aacute;s opciones que puedan aceptar sus clientes
DHCP, v&eacute;se
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcp-options&amp;sektion=5">dhcp-options(5)</a>.

<p>
<a name="PPP"></a>
<a name="6.5"></a>
<h2>6.5 - PPP </h2>

<p>
El &laquo;Protocolo Punto a Punto&raquo;, PPP, es el que se suele usar
para crear una conexi&oacute;n con su ISP a trav&eacute;s de un
m&oacute;dem.  OpenBSD puede hacer esto de dos maneras:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppd&amp;sektion=8">pppd(8)</a> - Es el d&aelig;mon ppp del n&uacute;cleo (<i>kernel</i>) del sistema.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8">ppp(8)</a> - Es el d&aelig;mon ppp del modo de usuario.
</ul>

<p>
Primero trataremos el d&aelig;mon del modo de usuario.  Para empezar
necesitaremos algo de informaci&oacute;n sobre nuestro proveedor.  He
aqu&iacute; una lista de la informaci&oacute;n que ser&aacute;
necesaria:

<ul>
   <li>El n&uacute;mero de tel&eacute;fono de conexi&oacute;n de.
   proveedor (ISP)
   <li>Nuestro <i>nameserver</i> (nombre del servidor) 
   <li>Nuestro nombre de usuario y contrase&ntilde;a
   <li>Nuestra pasarela (<i>gateway</i>)
</ul>

<p>
Parte de esta informaci&oacute;n no es estrictamente necesaria, pero
ser&aacute; de gran ayuda para configurar ppp.  El d&aelig;mon PPP del
modo de usuario utiliza el fichero
<a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.conf.sample">/etc/ppp/ppp.conf</a>
como fichero de configuraci&oacute;n.  Existen muchos ficheros en
<tt>/etc/ppp</tt> de gran utilidad, que pueden contener diferentes
ejemplos de configuraci&oacute;n para situaciones distintas.  Es
aconsejable mirar en ese directorio.

<p>
En caso de no estar usando un n&uacute;cleo GENERIC, debemos asegurarnos
de que tenemos la siguiente l&iacute;nea en nuestro fichero de
configuraci&oacute;n:

<blockquote><pre><strong>
pseudo-device   tun             2
</strong></pre></blockquote>

<p>
<h3>Configuraci&oacute;n inicial para PPP(8)</h3>

<p>
La configuraci&oacute;n inicial del d&aelig;mon PPP del modo de usuario
consiste en editar su fichero <tt>/etc/ppp/ppp.conf</tt>.  Este fichero
no existe y se debe crear, pero se puede tomar el fichero
<tt>/etc/ppp/ppp.conf.sample</tt>, editarlo, y crear un fichero
<tt>ppp.conf</tt> propio a partir de ah&iacute;.  Aqu&iacute;
empezaremos con la m&aacute;s simple, y probablemente m&aacute;s
utilizada, configuraci&oacute;n.  A continuaci&oacute;n puede verse un
peque&ntilde;o fichero <tt>ppp.conf</tt> que realizar&aacute; la
conexi&oacute;n con el ISP y usar&aacute; nuestras rutas predefinidas y
nuestro <i>nameserver</i>.  Para este fichero, toda la
informaci&oacute;n que necesitaremos ser&aacute; el n&uacute;mero de
tel&eacute;fono de nuestro ISP, nuestro nombre de usuario, y nuestro
contrase&ntilde;a.

<blockquote><pre>
default:
set log Phase Chat LCP IPCP CCP tun command     
set device /dev/cua01                           
set speed 115200     
set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \"\" AT OK-AT-OK ATE1Q0 OK\\dATDT\\T TIMEOUT 40 CONNECT"
</pre></blockquote>

<p>
La secci&oacute;n bajo la opci&oacute;n <tt>default:</tt> se ejecutada
cada vez que se requiera una conexi&oacute;n.  En ella se configura toda
la informaci&oacute;n cr&iacute;tica.  Con &quot;set log&quot; se
configuran los niveles de ingreso.  Esto se puede cambiar; para
m&aacute;s informaci&oacute;n sobre c&oacute;mo configurar los niveles
de ingreso v&eacute;ase la p&aacute;gina del manual de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8">
ppp(8)</a>.  El dispositivo se configura con &quot;set device&quot;.
&Eacute;ste es el dispositivo en el que se encuentra el m&oacute;dem.
En este ejemplo el m&oacute;dem est&aacute; en el puerto de
comunicaciones 2 (COM2), mientras que el puerto de comunicaciones 1
corresponder&iacute;a a <tt>/dev/cua00</tt>.  Con &quot;set speed&quot;
se configura la velocidad de la conexi&oacute;n por llamada, y con
&quot;set dial&quot; se configuran los par&aacute;metros de la llamada.
Con esto se puede cambiar el tiempo muerto, etc...  Es conveniente dejar
esta l&iacute;nea m&aacute;s o menos como est&aacute;.

<p>
A continuaci&oacute;n podemos pasar a configurar la informaci&oacute;n
espec&iacute;fica para nuestro ISP.  Para ello debemos a&ntilde;adir
otra opci&oacute;n en la secci&oacute;n <b>default:</b>.  Se puede dar
cualquier nombre a esta etiqueta, pero lo m&aacute;s f&aacute;cil es
darle el nombre del ISP.  En el ejemplo usaremos <b>myisp:</b> para la
opci&oacute;n que har&aacute; referencia a nuestro ISP.  He aqu&iacute;
una configuraci&oacute;n simple que incorpora todo lo necesario para
conectar:

<blockquote><pre>
myisp:
set phone 1234567   
set login "ABORT NO\\sCARRIER TIMEOUT 5 ogin:--ogin: ppp word: ppp"
set timeout 120   
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
add default HISADDR 
enable dns
</pre></blockquote>

<p>
Aqu&iacute; hemos configurado informaci&oacute;n esencial para un ISP
espec&iacute;fico.  La primera opci&oacute;n, &quot;set phone&quot;, es
para configurar el n&uacute;mero de tel&eacute;fono para la
conexi&oacute;n con el ISP.  La opci&oacute;n &quot;set login&quot; es
para configurar nuestras opciones de ingreso.  En el ejemplo hemos
puesto un tiempo muerto de espera de 5, lo que significa que nuestro
intento de ingreso terminar&aacute; despu&eacute;s de 5 segundos si no
hay transportador.  De lo contrario esperar&aacute; hasta recibir un
&quot;login&quot; para enviar nuestro nombre de usuario y
contrase&ntilde;a.  En el ejemplo, tanto el nombre de usuario como la
contraseña son &quot;ppp&quot;.  Estos valores hay que sustituirlos por
otros reales.  La opci&oacute;n &quot;set timeout&quot; es para
configurar el tiempo de espera para todo el proceso de ingreso.  La
opci&oacute;n &quot;set ifaddr&quot; es algo complicada.  He aqu&iacute;
una explicaci&oacute;n m&aacute;s extensa sobre ella:

<blockquote><pre>
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
</pre></blockquote>

<p>
Hemos configurado la l&iacute;nea anterior con el formato &quot;<b>set
ifaddr [myaddr[/nn] [hisaddr[/nn] [netmask [triggeradr]]]]</b>&quot;.
De este modo el primer IP que se especifique es el que querremos como
nuestro IP.  Si se tiene una direcci&oacute;n IP est&aacute;tica, se
debe a&ntilde;adir aqu&iacute;.  En el ejemplo hemos usado /0, que
indica que no es necesario que concuerde ning&uacute;n bit de esta
direcci&oacute;n ip, y que se puede sustituir todo.  El segundo IP que
se especifique es el que esperamos como el IP de nuestro ISP.  Si lo
conocemos lo podemos especificar aqu&iacute;, pero en la l&iacute;nea no
sabemos cu&aacute;l se asignar&aacute;, as&iacute; que dejaremos que nos
lo digan.  Esto es muy &uacute;til al negociar con algunas
implementaciones PPP que no asignan un n&uacute;mero IP a menos que la
conexi&oacute;n les requiera ``0.0.0.0''.

<p>
La siguiente opci&oacute;n &quot;add default HISADDR&quot; es para
configurar la ruta predefinida hasta nuestra IP.  Si nuestra IP
cambiara, la ruta se actualizar&iacute;a de forma autom&aacute;tica.
Con &quot;enable dns&quot; indicamos a nuestro ISP que autentifique
nuestras direcciones <i>nameservers</i>.  Esto no debe hacerse si se
est&aacute; usando una DNS local, ya que ppp circunvalar&aacute; su uso
introduciendo algunas l&iacute;neas en <tt>/etc/resolv.conf</tt>.

<p>
<h3>C&oacute;mo usar PPP(8)</h3>

<p>
Ahora que ya tenemos el fichero <i>ppp.conf</i> configurado, podemos
intentar una conexi&oacute;n con nuestro ISP.  A continuaci&oacute;n se
dar&aacute;n algunos detalles sobre argumentos de uso com&uacute;n con
ppp.

<ul>
   <li><tt>ppp -auto myisp</tt> - Inicia ppp, configura las interfaces,
   conecta con el ISP, y a continuaci&oacute;n pasa a un plano de fondo.
   <li><tt>ppp -ddial myisp</tt> - Parecido a -auto, pero si la
   conexi&oacute;n cayera volver&iacute;a a conectar.
</ul>

<p>
Si se usa <tt>/usr/sbin/ppp</tt> sin pasarle ninguna opci&oacute;n,
pasar&aacute; al modo interactivo, desde donde se podr&aacute;
interaccionar directamente con el m&oacute;dem.  De este modo se pueden
depurar problemas en el fichero <tt>ppp.conf</tt>.

<p>
<h3>Acciones adicionales con ppp(8)</h3>

<p>
Si se necesitara ejecutar &oacute;rdenes al tiempo que se conecta o
desconecta, puede hacerse creando dos ficheros adicionales,
<tt>/etc/ppp/ppp.linkup</tt> y <tt>/etc/ppp/ppp.linkdown</tt>.  Pueden
verse ejemplos de configuraci&oacute;n para estos ficheros en:

<ul>
   <li><a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkup.sample">ppp.linkup</a>
   <li><a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkdown.sample">ppp.linkdown</a>
</ul>

<p>
Se puede obtener m&aacute;s informaci&oacute;n en el
<a href="http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/userppp.html">cap&iacute;tulo sobre <i>userppp</i> de la Gu&ieacute;a de FreeBSD</a>.

<p>
<a name="Tuning"></a>
<a name="6.6"></a>
<h2>6.6 - Ajuste de par&aacute;metros de red</h2>
<!-- XXXrelease -->
<p>
<h3>6.6.1 - &iquest;C&oacute;mo se puede forzar al n&uacute;cleo del
sistema para obtener un mayor n&uacute;mero de reintentos y tiempos de
espera mayores en las sesiones de TCP?</h3>

<p>
Para problemas de conexi&oacute;n o enrutamiento se puede usar lo
siguiente (hay que tener en cuenta que para que sea más efectivo, ambos
lados de la conexi&oacute;n deben usar valores similares):

<p>
Para forzarlo hay que usar <tt>sysctl</tt> e incrementar los valores de:

<pre>
net.inet.tcp.keepinittime
net.inet.tcp.keepidle
net.inet.tcp.keepintvl
</pre>

<p>
Si se usa sysctl -a se podr&aacute;n ver los valores actuales de estos y
muchos otros par&aacute;metros.  Para cambiar cualquiera de ellos, hay
que usar <tt>sysctl -w</tt>; como por ejemplo en
<tt>sysctl -w net.inet.tcp.keepidle=28800</tt>.

<p>
<h3>6.6.2 - &iquest;C&oacute;mo se pueden activar emisiones
dirigidas?</h3>

<p>
Por lo general, no es aconsejable hacerlo, ya que si el sistema OpenBSD
es un enrutador, permite que se pueda enviar tr&aacute;fico a la
direcci&oacute;n o direcciones de emisi&oacute;n de nuestras redes.

<p>
En algunos casos, como en el de las redes cerradas, puede tener cierta
utilidad, en particular cuando se est&eacute;n usando implementaciones
antiguas del protocolo NetBIOS.  Se puede activar con
<tt>sysctl -w net.inet.ip.directed-broadcast=1</tt>.  Es convienente
informarse sobre los <a href="http://www.netscan.org">ataques
<i>&quot;smurf&quot;</i></a> para saber por qu&eacute; se encuentra
desactivado por definici&oacute;n.

<p>
<h3>6.6.3 - No quiero que el n&uacute;cleo haga asignaciones
din&aacute;micas de ciertos puertos</h3>

<p>
Tambi&eacute;n existe un sysctl para esto.  De la p&aacute;gina del
manual de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>:

<pre>
A&ntilde;ada la lista de puertos TCP que no deber&iacute;an ser
asignados de forma din&aacute;mica por el n&uacute;cleo.  Esto puede
utilizarse para evitar que algunos d&aelig;mons se apropien de un cierto
puerto que sea necesario para el funcionamiento de otro programa.  La
lista de elementos puede ir separada por comas y/o espacios en blanco.

 #  <b>sysctl -w  net.inet.tcp.baddynamic=749,750,751,760,761,871</b>

Tambi&eacute;n se pueden a&ntilde;adir o eliminar puertos de la lista
actual.

 #  <b>sysctl -w net.inet.tcp.baddynamic=+748</b>
 #  <b>sysctl -w net.inet.tcp.baddynamic=-871</b>
</pre>

<p>
<a name="NFS"></a>
<a name="6.7"></a>
<h2>6.7 - Uso simple de NFS</h2>

<p>
El &laquo;Sistema de Archivos de Red&raquo; (NFS, <i>Network File
System</i>) se usa para compartir un sistema de archivos en una red.
Algunas p&aacute;ginas del manual que se deber&iacute;an leer antes de
intentar configurar un servidor de NFS son:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nfsd&amp;sektion=8">nfsd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mountd&amp;sektion=8">mountd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&amp;sektion=5">exports(5)</a>
</ul>

<p>
En esta secci&oacute;n se detallar&aacute;n los pasos para una
configuraci&oacute;n simple de NFS.  El ejemplo ofrece detalles sobre un
servidor en una LAN, con clientes que tengan acceso NFS en la LAN.  En
esta secci&oacute;n no se tratar&aacute; sobre la seguridad de NFS.
Asumiremos que ya se ha configurado el paquete de filtros, u otra
protecci&oacute;n como cortafuegos, para prevenir el acceso desde el
exterior.  Si nuestra configuraci&oacute;n permite el acceso desde el
exterior a nuestro servidor de NFS, y si tenemos alg&uacute;n tipo de
datos confidenciales o importantes, es muy recomendable usar
<a href="faq13.html">IPsec</a>.  De otro modo existe la posibilidad de
que extra&ntilde;os puedan ver nuestro tr&aacute;fico de NFS.
Tambi&eacute;n ser&iacute;a posible que alguien pretendiera estar en la
direcci&oacute;n IP a la que hayamos autorizado la entrada en el
servidor de NFS.  Existen varios tipos de ataques efectivos en este
aspecto.  Cuando IPsec est&aacute; correctamente configurado, protege
contra todos estos tipos de ataques.

<p>
Otra nota importante sobre seguridad.  No se debe a&ntilde;adir un
sistema de archivos a <tt>/etc/exports</tt> sin alg&uacute;n tipo de
lista de anfitriones autorizados.  Sin una lista de anfitriones que
puedan montar un directorio particular, cualquiera que pueda llegar al
anfitri&oacute;n podr&aacute; montar los directorios de NFS en
<tt>exports</tt>.

<p>
NFS depende de que
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=portmap&amp;sektion=8">portmap(8)</a>
se encuentre en ejecuci&oacute;n antes de poder operar.  Portmap(8),
desde la versi&oacute;n 3.2 de OpenBSD, se encuentra desactivado en el
modo predeterminado, y por lo tanto hay que activarlo en el fichero
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&amp;sektion=8">rc.conf(8)</a>
cambiando la l&iacute;nea de <tt>portmap</tt> as&iacute;:

<blockquote><pre>
portmap=YES
</pre></blockquote>

<p>
y reiniciar para que el cambio sea efectivo.

<p>
La configuraci&oacute;n consiste en un servidor con el ip
<b>10.0.0.1</b>, que servir&aacute; NFS s&oacute;lo a clientes dentro de
esa red.  El primer paso para configurar NFS es configurar el fichero
<tt>/etc/exports</tt>.  Este fichero se compone de una lista con los
sistemas de archivos que se quiera que sean accesibles por medio de NFS,
y define qui&eacute;n puede acceder a cada uno de ellos.  Existen muchas
opciones que puede usar en su fichero <tt>/etc/exports</tt>, y es
conveniente leer la p&aacute;gina del manual de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&amp;sektion=5">exports(5)</a>.
En este ejemplo empezaremos con un fichero <tt>/etc/exports</tt> como el
siguiente:

<blockquote><pre>
#
# Base de datos de NFS exports
# V&eacute;ase exports(5) para m&aacute;s informaci&oacute;n.  Vaya con
# cuidado, una mala configuraci&oacute;n puede hacer que
# sus sistemas de archivos sean legibles por todo el mundo.
/work -alldirs -ro -network 10.0.0 -mask 255.255.255.0
</pre></blockquote>

<p>
Esto quiere decir que el sistema de archivos local <tt>/work</tt>
estar&aacute; disponible a trav&eacute;s de NFS.  <tt>-alldirs</tt>
indica que los clientes podr&aacute;n montar en cualquier parte bajo el
punto de montaje <tt>/work</tt>.  <tt>-ro</tt> indica que
&uacute;nicamente se permitir&aacute; montarlo en modo de s&oacute;lo
lectura.  Los dos &uacute;ltimos argumentos indican que s&oacute;lo los
clientes dentro de la red 10.0.0.0 que usen una m&aacute;scara de red
255.255.255.0, estar&aacute;n autorizados a montar este sistema de
archivos.  Esto es importante en algunos servidores accesibles desde
diferentes redes.

<p>
Una vez que se haya configurado el fichero <tt>/etc/exports</tt>, se puede
continuar y pasar a configurar el servidor de NFS.  Primero hay que
asegurarse de que las opciones NFSSERVER y NFSCLIENT se encuentren en la
configuraci&oacute;n del n&uacute;cleo del sistema (el n&uacute;cleo
GENERIC incluye estas opciones).  A continuaci&oacute;n hay que
configurar <tt>nfs_server=YES</tt> en el fichero <tt>/etc/rc.conf</tt>.
De este modo, cuando se reinicie el sistema, se activar&aacute;n nfsd(8)
y mountd(8).  Ahora ya se pueden iniciar los d&aelig;mons.  Estos
d&aelig;mons deben ser iniciados por el superusuario, <i>root</i>, y es
necesario asegurarse de que portmap(8) est&eacute; en funcionamiento en
el sistema.  El ejemplo que sigue sobre c&oacute;mo iniciar nfsd(8)
sirve tanto para TCP como para UDP usando 4 d&aelig;mons.  Para
gestionar el m&aacute;ximo n&uacute;mero de requerimientos de clientes
concurrentes a los que se quiera dar servicio, hay que activar un
n&uacute;mero apropiado de d&aelig;mons del servidor de NFS.

<blockquote><pre>
# <b>/sbin/nfsd -tun 4</b>
</pre></blockquote>

<p>
No s&oacute;lo se debe iniciar el servidor de nfsd(8), sino que
tambi&eacute;n es necesario iniciar mountd(8).  &Eacute;ste es el
d&aelig;mon que da servicio a los requerimientos para montar en NFS.
Para iniciar mountd(8), hay que asegurarse de que existe un fichero
vac&iacute;o <tt>mountdtab</tt> e invocar el d&aelig;mon:

<blockquote><pre>
# <b>echo -n &gt;/var/db/mountdtab</b>
# <b>/sbin/mountd</b>
</pre></blockquote>

<p>
Si se hace alg&uacute;n cambio en el fichero <tt>/etc/exports</tt>
mientras NFS est&eacute; funcionando, se tendr&aacute; que avisar a
mountd sobre el cambio pas&aacute;ndole una se&ntilde;al
&quot;HUP&quot;:

<blockquote><pre>
# <b>kill -HUP `cat /var/run/mountd.pid`</b>
</pre></blockquote>

<p>
<h3>Comprobaci&oacute;n de estad&iacute;sticas en NFS</h3>

<p>
Se pueden realizar comprobaciones para asegurarse de que estos
d&aelig;mons est&eacute;n funcionando y registrados con RPC.  Para ello
se usa rcpinfo(8).

<blockquote><pre>
$ <b>rpcinfo -p 10.0.0.1</b>
   program vers proto   port
    100000    2   tcp    111  portmapper
    100000    2   udp    111  portmapper
    100005    1   udp    633  mountd
    100005    3   udp    633  mountd
    100005    1   tcp    916  mountd
    100005    3   tcp    916  mountd
    100003    2   udp   2049  nfs
    100003    3   udp   2049  nfs
    100003    2   tcp   2049  nfs
    100003    3   tcp   2049  nfs
</pre></blockquote>

<p>
Durante su uso normal, existen unas pocas utilidades más que nos
permitir&aacute;n ver lo que est&aacute; ocurriendo con NFS.  Una de
ellas es
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=showmount&amp;sektion=8">showmount(8)</a>
que nos permite ver qu&eacute; se encuentra montado y qui&eacute;n lo
est&aacute; montando.  Tambi&eacute;n est&aacute; nfsstat(8), que
muestra una informaci&oacute;n de las estad&iacute;sticas mucho
m&aacute;s amplia.  Para usar showmount(8), basta con escribir
<tt>/usr/bin/showmount -a host</tt>.  Por ejemplo:

<blockquote><pre>
$ <b>/usr/bin/showmount -a 10.0.0.1</b>
All mount points on 10.0.0.1:
10.0.0.37:/work
</pre></blockquote>

<p>
<h3>C&oacute;mo montar Sistemas de Archivos de Red (NFS)</h3>

<p>
Los sistemas de archivos NFS se deben montar mediante mount(8) o,
m&aacute;s exactamente, mediante
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount_nfs&amp;sektion=8">mount_nfs(8)</a>.
Para montar el sistema de archivos <tt>/work</tt> del anfitri&oacute;n
10.0.0.1 en un sistema de archivo local <tt>/mnt</tt>, se debe hacer lo
siguiente (no es necesario usar una direcci&oacute;n IP, mount se
encargar&aacute; de la resoluci&oacute;n de nombres):

<blockquote><pre>
# <b>mount -t nfs 10.0.0.1:/work /mnt</b>
</pre></blockquote>

<p>
Para que el sistema se monte al iniciar, hay que a&ntilde;adir algo como
lo que viene a continuaci&oacute;n en el fichero <tt>/etc/fstab</tt>:

<blockquote><pre>
10.0.0.1:/work /mnt nfs rw 0 0
</pre></blockquote>

<p>
&iexcl;&iexcl;Es importante usar <tt>0 0</tt> al final de esta
l&iacute;nea para que la m&aacute;quina no intente ejecutar fsck sobre
el sistema de archivo NFS durante el inicio del sistema!!  El resto de
opciones de seguridad t&iacute;picas, como noexec, nodev y nosuid,
tambi&eacute;n deber&iacute;an usarse donde sean posibles, como en:

<blockquote><pre>
10.0.0.1:/work /mnt nfs rw,nodev,nosuid 0 0
</pre></blockquote>

<p>
De este modo ning&uacute;n dispositivo o programa setuid en el servidor
de NFS podr&aacute; traspasar las medidas de seguridad en el cliente de
NFS.  Si los programas que se monten no deben ser ejecutados por el
cliente de NFS, se debe a&ntilde;adir noexec a esta lista.

<p>
<a name="DNS"></a>
<a name="6.8"></a>
<h2>6.8 - Servicio de Nombres de Dominio  - DNS, BIND, y named</h2>

<p>
<i>Nota: La siguiente secci&oacute;n ha sido escrita para OpenBSD 3.2 y
versiones anteriores, que inclu&iacute;an BIND4.  OpenBSD 3.3 ahora
incluye BIND9, que est&aacute; mejor documentado en libros y en Internet
de lo que estaba la versi&oacute;n anterior, BIND4.

<p>
Al igual que suced&iacute;a con BIND4 en OpenBSD, BIND9 en OpenBSD se
ejecuta en un entorno chroot(2), y tiene una cantidad de mejoras de
seguridad sobre la versi&oacute;n est&aacute;ndar de BIND9:

<ul>
<li>soporte para arc4random() (integrado en 9.3.0-snapshot)
<li>llama tzset antes que chroot
<li>abre /dev/null antes que chroot
<li>vuelve al dispositivo aleatorio predeterminado del sistema cuando se
est&aacute; ejecutando en chroot
<li>a&ntilde;ade la implementaci&oacute;n LCG (Linear Congruential
Generator) a libisc
<li>usa LCG en lugar de LFSR para generaci&oacute;n de ID hasta que se
pruebe que LFSR es fiable
<li>selecci&oacute;n de transporte de requerimiento IPv{4,6} para dig(1)
<li>reparaci&oacute;n de sha1.c para circunvalar un error de
optimizaci&oacute;n de gcc (sparc64)
<li>chroot a <tt>/var/named</tt> predeterminado
<li>setuid al usuario <tt>named</tt> predeterminado
<li>write pid-file antes que chroot
</ul>
Los usuarios de OpenBSD 3.3 pueden mirar la siguiente
documentaci&oacute;n:
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=named&amp;sektion=8">named(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/src/usr.sbin/bind/doc/arm/Bv9ARM.html">BIND 9 Administrator Reference Manual</a>
(estas p&aacute;ginas tambi&eacute;n est&aacute;n disponibles en el
directorio <tt>/usr/share/doc/html/bind/</tt> del sistema)
</ul>
</blockquote></i>

<h3>6.8.1 &iquest;Qu&eacute; es DNS?</h3>

<p>
El &laquo;Servicio de Nombres de Dominio&raquo; (DNS, <i>Domain Name
Service</i>) es una facilidad de red que permite a los dominios de
redes IP proveer resoluciones de direcciones nombre-a-IP y resoluciones
direcci&oacute;n-a-nombre en respuesta a un requerimiento.  La
instalaci&oacute;n t&iacute;pica de OpenBSD est&aacute; configurada por
definici&oacute;n como un cliente de DNS, pero no como un servidor de
DNS.  O sea, la instalaci&oacute;n predeterminada de OpenBSD puede
llevar a cabo un requerimiento de DNS para la direcci&oacute;n de una
m&aacute;quina contra un servidor de nombres de dominio, pero no puede
responder a uno de esos requerimientos de DNS de por s&iacute; a menos
que se configure con ese fin.

<p>
Mi m&aacute;quina con OpenBSD est&aacute; conectada actualmente a
Internet a trav&eacute;s de mi proveedor, y por lo tanto puedo usar la
utilidad
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nslookup&amp;sektion=8">nslookup(8)</a>
para ejecutar el requerimiento de DNS:

<blockquote>
<pre>
$ <b>nslookup www.openbsd.org</b>
Server:  ns4.us.prserv.net
Address:  165.87.201.244

Non-authoritative answer:
Name:    www.openbsd.org
Address:  129.128.5.191
</pre>
</blockquote>

<p>
<b>165.87.201.244</b> es el nombre del servidor que ha contestado,
porque es el &laquo;nombre de servidor&raquo; (<i>nameserver</i>) que
mi proveedor me dijo que usara con mi cuenta, y cuyo n&uacute;mero se
debe introducir en el fichero
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&amp;sektion=5">/etc/resolv.conf</a>.
Pero la respuesta no fue autorizada.  Para una respuesta autorizada,
investiguemos cu&aacute;l es el servidor de DNS autorizado para el
dominio <i>openbsd.org</i>, y pregunt&eacute;mosle por la
direcci&oacute;n de <i>www.openbsd.org</i>:

<blockquote>
<pre>
# Identificar el nombre de los servidores de openbsd.org
# con la ayuda del nombre del servidor de mi ISP.
$ <b>nslookup -type=NS openbsd.org</b>
Server:  ns4.us.prserv.net
Address:  165.87.201.244

Non-authoritative answer:
openbsd.org     nameserver = cvs.openbsd.org
openbsd.org     nameserver = gandalf.sigmasoft.com
openbsd.org     nameserver = cs.colorado.edu
openbsd.org     nameserver = ns.appli.se
openbsd.org     nameserver = zeus.theos.com

Authoritative answers can be found from:
cvs.openbsd.org internet address = 199.185.137.3
gandalf.sigmasoft.com   internet address = 198.144.202.98
cs.colorado.edu internet address = 128.138.243.151
ns.appli.se     internet address = 194.198.196.230
zeus.theos.com  internet address = 199.185.137.1

# Usar la informaci&oacute;n obtenida para requerir una
# resoluci&oacute;n autorizada:
# requerir la autorizaci&oacute;n zeus.theos.com.
$ <b>nslookup www.openbsd.org zeus.theos.com</b>
Server:  zeus.theos.com
Address:  199.185.137.1

Name:    www.openbsd.org
Address:  129.128.5.191
</pre>
</blockquote>

<p>
<i>zeus.theos.com</i> es, como es de suponer, una m&aacute;quina que
funciona con OpenBSD y que est&aacute; correctamente configurada para
ser un servidor de DNS para el dominio <i>openbsd.org</i>.

<p>
<a name="DNS.1.1"></a>
<a name="6.8.1.1"></a>
<h3>6.8.1.1 &iquest;D&oacute;nde se puede aprender todo sobre DNS y su
implementaci&oacute;n en OpenBSD?</h3>

<ul>
<li>En los RFC <a href="http://www.faqs.org/rfcs/rfc1033.html">1033</a>, <a href="http://www.faqs.org/rfcs/rfc1034.html">1034</a>, y <a href="http://www.faqs.org/rfcs/rfc1035.html">1035</a> 
se puede encontrar m&aacute;s informaci&oacute;n sobre el sistema de
nombres de dominio en Internet.
<li>En el libro de O'Reilly Associates
<i><a href="../../es/books.html#6">DNS and BIND</a></i>.
<li>En las
<a href="http://www.openbsd.org/cgi-bin/man.cgi">p&aacute;ginas del
manual de OpenBSD</a>, en especial las p&aacute;ginas de
   <ul>
   <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&amp;sektion=1&format=html">dig(1)</a>
   <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nslookup&amp;sektion=8&format=html">nslookup(8)</a>
   <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gethostbyname&amp;sektion=3&format=html">gethostbyname(3)</a>
   <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=named&amp;sektion=8&format=html">named(8)</a>
   <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolver&amp;sektion=3&format=html">resolver(3)</a>
   <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolver&amp;sektion=5&format=html">resolver(5)</a>
   </ul>
</ul>

<p>
La orden
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&amp;sektion=1">dig(1)</a>
es epecialmente &uacute;til porque puede requerir un dominio y devolver
la informaci&oacute;n pr&aacute;cticamente en el mismo formato requerido
por los ficheros de configuraci&oacute;n de BIND.  Se puede usar
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&amp;sektion=1">dig(1)</a>
para examinar nombres de servidores que se sepa que est&aacute;n
operando correctamente para comparar la configuraci&oacute;n con la de
ellos.

<p>
<h3>6.8.2 &iquest;Es necesario que mi m&aacute;quina sea un servidor de
nombres de dominio?</h3>

<p>
No se debe configurar como servidor de nombres de dominio a menos que se
est&eacute; seguro que se necesita que funcione como un servidor de DNS.
La instalaci&oacute;n predeterminada de OpenBSD no activa la
m&aacute;quina como servidor de nombres de dominio, aunque todos los
ficheros necesarios se encuentran instalados y listos para la
activaci&oacute;n.  Para la mayor&iacute;a de estaciones de trabajo, es
suficiente con los ficheros
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hosts&amp;sektion=5">/etc/hosts</a>
para indicar las direcciones de IP de las m&aacute;quinas locales y
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&amp;sektion=5">/etc/resolv.conf</a>
para indicar qu&eacute; servidores de DNS har&aacute;n el servicio en la
intranet o Internet.

<p>
Por otra parte, alguien podr&iacute;a necesitar que la m&aacute;quina
estuviera configurada como un servidor de nombres de dominio si:

<ul>
<li>se tiene una LAN IP en la que no se quieren replicar los ficheros
<tt>hosts</tt> de direcciones locales en cada m&aacute;quina; en este
caso se puede configurar la m&aacute;quina con OpenBSD como servidor de
DNS para que d&eacute; servicio a los requerimientos de otras
m&aacute;quinas de la LAN.

<ul>
<li><b>Nota:</b> No existen restricciones en la pr&aacute;ctica al
n&uacute;mero de servidores de DNS en una LAN.  Cualquier m&aacute;quina
o todas las de la LAN puede ofrecer el servicio de DNS si se configuran
para ello.  Que uno de estos servidores se considere autorizado desde
fuera de la LAN (o incluso conocido desde fuera de la LAN), es un factor
de configuraci&oacute;n que suele estar controlado por el nivel superior
inmediato de la LAN en la jerarqu&iacute;a de dominios.
</ul>

<li>se tiene una LAN IP en la que residan m&aacute;quinas que se quiera
que sean localizables a trav&eacute;s de requerimientos de DNS por
m&aacute;quinas en otra LAN o WAN.

<li>se tiene dificultades al resolver el nombre de dominio local a una
direcci&oacute;n IP, o al resolver cualquier otro nombre local a
direcciones IP aunque los ficheros <tt>/etc/hosts</tt> y
<tt>/etc/resolv.conf</tt> est&eacute;n correctamente configrados (por
ejemplo, en OpenBSD, Netscape a veces se comporta de este modo porque
implementa su propia herramienta de resoluci&oacute;n, en lugar de usar
gethostbyname(3) para la b&uacute;squeda de direcciones).
</ul>

<p>
Algo m&aacute;s a tener en cuenta es la velocidad de ejecuci&oacute;n.
Como la resoluci&oacute;n de nombres es un proceso repititivo en el que
el servidor de nombres realiza repetidos requerimientos sobre
direcciones en dominios remotos a otros servidores de nombres, la
resoluci&oacute;n de nombres puede tardar algo m&aacute;s si se tiene
una conexi&oacute;n por m&oacute;dem a Internet y se est&aacute;n
requiriendo direcciones remotas al servidor propio de DNS (que a su vez
har&aacute; continuos requerimientos a servidores de nombres remotos a
trav&eacute;s del m&oacute;dem) que si se est&aacute; requiriendo el
servidor de nombres del ISP (que probablemente tenga una conexi&oacute;n
m&aacute;s r&aacute;pida a los servidores de nombres remotos).

<p>
<h3>6.8.3 &iquest;Cu&aacute;les son los componentes de software del
servidor de DNS?</h3>

<ul>
<li>named <i>(``d&aelig;mon de name'')</i>
<li>Los ficheros de configuraci&oacute;n en el directorio bajo la
jerarqu&iacute;a de <tt>/var/named/</tt>
</ul>

<p>
<h4>6.8.3.1 &iquest;Qu&eacute; nivel de BIND tiene soporte?</h4>
<!-- XXXchanges - changes with OpenBSD 3.3 -->
<p>
BIND es el nombre de la especificaci&oacute;n sobre la forma en que
act&uacute;a un servidor de nombres de dominio.  Los componentes de DNS
existen para implementar BIND de forma colectiva.

<p>
Existen tres especificaciones de BIND diferentes:

<ol>
<li>BIND 4
<li>BIND 8
<li>BIND 9
</ol>

<p>
En la instalaci&oacute;n predeterminada de OpenBSD, <b>named</b> tiene
soporte para BIND 4.x.

<p>
<h4>6.8.3.2 &iquest;Cu&aacute;les son algunas de las alternativas a
proveer DNS a trav&eacute;s de la implementaci&oacute;n predeterminada
de BIND 4.x?</h4>
<!-- XXXexpires - goes away when 3.2 becomes unsupported -->
<ul>
<li>La implementaci&oacute;n de BIND 9.x, que se encuentra en
<tt>/usr/ports/net/bind9</tt> (v&eacute;ase la p&aacute;gina sobre los
<a href="../../es/ports.html">portes</a>).
</ul>

<p>
<h5>6.8.3.2.1 Nota de <u>Seguridad</u></h5>

<p>
Si se usan estas implementaciones alternativas de DNS, se estar&aacute;
ofreciendo un servicio de red cr&iacute;tico mediante la
utilizaci&oacute;n de unos programas que pueden no haber sido sometidos
al mismo nivel de escrutinio que el d&aelig;mon de <code>name</code> en
la instalaci&oacute;n base, <b><code>named</code></b>, el cual ha pasado
una <a href="../../es/security.html">auditor&iacute;a de seguridad</a>.
&Eacute;sta es una consideraci&oacute;n a tener muy en cuenta, ya que si
se pone en peligro un servidor de nombres de dominio, los
resolucionadores que usen ese servidor de DNS pueden ser redireccionados
al sitio de un impostor.

<p>
<h3>6.8.4 &iquest;Cu&aacute;nto hay que instalar?</h3>

<p>
Si la configuraci&oacute;n predefinida de la red se instal&oacute;
correctamente durante la instalaci&oacute;n de OpenBSD, ya estar&aacute;
todo instalado.  S&oacute;lo ser&aacute; necesario configurar el
d&aelig;mon de <code>name</code> (<b>named</b>).

<p>
<h3>6.8.5 &iquest;C&oacute;mo se configura DNS?</h3>
<!-- XXXchanges - changes with OpenBSD 3.3 -->
<p>
Para configurar DNS en OpenBSD, se debe editar y/o crear los ficheros
que controlan el d&aelig;mon de <code>name</code>, <b>named</b>.  La
ubicaci&oacute;n predeterminada de estos ficheros es el directorio
<tt>/var/named</tt> y sus subdirectorios, y en especial el fichero
<tt>/var/named/named.boot</tt> que es el fichero de
inicializaci&oacute;n para <b>named</b>.  Tambi&eacute;n hay un par
pasoso m&aacute;s para la configuraci&oacute;n que deben realizarse en
<tt>/etc</tt>.

<p>
En este documento configuraremos el d&aelig;mon de <code>name</code> en
<i>nemo.yewtopia.com</i> como el nombre nombre primario del servidor
para el dominio (&iexcl;muy peque&ntilde;o!) <i>yewtopia.com</i>.  La
direcci&oacute;n de <i>nemo.yewtopia.com</i> es <i>192.168.1.9</i>.
Otras dos m&aacute;quinas en esa subrred son <i>crater.yewtopia.com</i>
en 192.168.1.1 y <i>earhart.yewtopia.com</i> en 192.168.1.2.

<p>
<h4>6.8.5.1 Configuraci&oacute;n en <tt>/var/named</tt></h4>
<!-- XXXchanges - changes with OpenBSD 3.3 -->
<p>
<h5>6.8.5.1.1 <tt>/var/named/named.boot</tt></h5>

<blockquote>
<pre>
; qu&eacute; subdirectorio contiene los ficheros de
; la base de datos de lookup
directory       /namedb

; type    domain   source host/file backup file
; tipo    dominio  file/host origen fichero respaldo
cache     .	   root.cache
primary   0.0.127.IN-ADDR.ARPA  localhost.rev

; ejemplo de configuraci&oacute;n de servidor primario:
primary  yewtopia.com yewtopia
primary  1.168.192.IN-ADDR.ARPA yewtopia.rev
</pre>
</blockquote>

<p>
Esto indica al proceso de inicializaci&oacute;n en qu&eacute;
subdirectorio y bajo qu&eacute; nombres encontrar&aacute; los ficheros
de configuraci&oacute;n de <tt>yewtopia.com</tt>.

<p>
<h5>6.8.5.1.2 <tt>/var/named/namedb/localhost.rev</tt></h5>

<blockquote>
<pre>
; lookup inversa para interfaz local
@       IN      SOA     nemo.yewtopia.com.  your_id.nemo.yewtopia.com.  (
                                14      ; Serial
                                3600    ; Refresh
                                900     ; Retry
                                3600000 ; Expire
                                3600 )  ; Minimum
        IN      NS      nemo.yewtopia.com.
1       IN      PTR     localhost.yewtopia.com.
</pre>
</blockquote>

<p>
<h5>6.8.5.1.3 <tt>/var/named/namedb/yewtopia</tt></h5>

<blockquote>
<pre>
; Base de datos del dominio yewtopia.com
@       IN      SOA     nemo.yewtopia.com.  your_id.nemo.yewtopia.com.  (
                                14      ; Serial
                                3600    ; Refresh
                                900     ; Retry
                                3600000 ; Expire
                                3600 )  ; Minimum
                     IN      NS      nemo.yewtopia.com.

; Direcciones
localhost.yewtopia.com.      IN A    127.0.0.1
crater.yewtopia.com.         IN A    192.168.1.1
earhart.yewtopia.com.        IN A    192.168.1.2
nemo.yewtopia.com.           IN A    192.168.1.9
</pre>
</blockquote>

<p>
<h5>6.8.5.1.4 <tt>/var/named/namedb/yewtopia.rev</tt></h5>

<blockquote>
<pre>
; Base de datos de lookup inversa del dominio yewtopia
@       IN      SOA     nemo.yewtopia.com.  your_id.nemo.yewtopia.com.  (
                                14      ; Serial
                                3600    ; Refresh
                                900     ; Retry
                                3600000 ; Expire
                                3600 )  ; Minimum
1.168.192.in-addr.arpa. IN      NS      nemo.yewtopia.com.

; Direcciones
1.1.168.192.in-addr.arpa. IN PTR crater.yewtopia.com.
2.1.168.192.in-addr.arpa. IN PTR earhart.yewtopia.com.
9.1.168.192.in-addr.arpa. IN PTR nemo.yewtopia.com.
</pre>
</blockquote>

<p>
<h4>6.8.5.2 Configuraci&oacute;n en <tt>/etc</tt></h4>

<p>
<h5>6.8.5.2.1 <tt>/etc/resolv.conf</tt></h5>

<p>
Hay que asegurarse de que <tt>/etc/resolv.conf</tt> apunte al dominio de
la m&aacute;quina local (en vez de, por ejemplo, al nombre del servidor
del ISP), de modo que la resoluci&oacute;n del nombre en requerimientos
sea enviada al <b>named</b> que se haya configurado.

<blockquote><pre>
domain yewtopia.com
lookup file bind
</pre></blockquote>

<p>
<h4>6.8.5.2.2 <tt>/etc/hosts</tt></h4>

<p>
Si anteriormente se han a&ntilde;adido las direcciones de varias
m&aacute;quinas al fichero <tt>/etc/hosts</tt>, puede ser conveniente
acortar el fichero <tt>/etc/hosts</tt> al estado en que se encontraba
por definic&oacute;n:

<blockquote><pre>
# Host addresses
127.0.0.1       localhost       localhost.localdomain
192.168.1.9     nemo            nemo.yewtopia.com
</pre></blockquote>

<p>
de modo que <b>named</b> no sea circunvalado en favor de direcciones
(probablemente caducadas) en el fichero <tt>/etc/hosts</tt>.
&iexcl;<u>Es necesario asegurarse de que se tiene como m&iacute;nimo la
entrada predefinida de <i>localhost</i></u>, o la red no se
iniciar&aacute; correctamente!  N&oacute;tese tambi&eacute;n que
<i>nemo</i> debe aparecer en el propio fichero hosts, o de lo contrario
se producir&aacute; un mensaje de error (no da&ntilde;ino) durante el
arranque cuando <tt>/etc/netstart</tt> se invoque
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=route&amp;sektion=8">route(8)</a>
para a&ntilde;adir <i>nemo</i> (cuyo nombre aparece en
<tt>/etc/myname</tt>).

<p>
<h4>6.8.5.3 C&oacute;mo usar
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&amp;sektion=1">dig(1)</a>
para examinar los resultados.</h4>

<blockquote>
<pre>
$ <b>dig @nemo.yewtopia.com yewtopia.com any any</b>

; &lt;&lt;&gt;&gt; DiG 2.2 &lt;&lt;&gt;&gt; @nemo.yewtopia yewtopia any any
; (1 server found)
;; res options: init recurs defnam dnsrch
;; got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 59904
;; flags: qr rd ra; Ques: 1, Ans: 2, Auth: 0, Addit: 1
;; QUESTIONS:
;;      yewtopia.com, type = ANY, class = ANY

;; ANSWERS:
yewtopia.com.   3600    SOA    nemo.yewtopia.com.  your_id.nemo.yewtopia.com. (
                        14      ; serial
                        3600    ; refresh (1 hour)
                        900     ; retry (15 mins)
                        3600000 ; expire (41 days 16 hours)
                        3600 )  ; minimum (1 hour)
yewtopia.com.   3600    NS      nemo.yewtopia.com.

;; ADDITIONAL RECORDS:
nemo.yewtopia.com.  3600    A       192.168.1.9

;; Total query time: 4 msec
;; FROM: nemo to SERVER: nemo.yewtopia.com  192.168.1.9
;; WHEN: Tue May  2 23:47:19 2000
;; MSG SIZE  sent: 25  rcvd: 102
</pre>
</blockquote>

<p>
<h3>6.8.6 &iquest;C&oacute;mo y cu&aacute;ndo se inicia y se para
DNS?</h3>

<p>
<h4>6.8.6.1 C&oacute;mo iniciar DNS</h4>

<p>
El d&aelig;mon de name <b>named</b> se lanza durante el inicio del
sistema desde
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&amp;sektion=8">/etc/rc</a>
si la l&iacute;nea instalada por definici&oacute;n en
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&amp;sektion=8">/etc/rc.conf</a>,

<blockquote><pre>
named_flags=NO          # para uso normal: &quot;&quot;
</pre></blockquote>

<p>
se cambia a

<blockquote><pre>
named_flags=&quot;&quot;          # para uso normal: &quot;&quot;
</pre></blockquote>

<p>
Tambi&eacute;n se deben examinar las siguientes l&iacute;neas en
<tt>/etc/rc.conf</tt>:

<blockquote><pre>
named_user=named                # named no deber&iacute;a ejecutarse como root a menos que fuera necesario
named_chroot=/var/named         # D&oacute;nde chroot named si no est&aacute; vac&iacute;o
</pre></blockquote>

<p>
Estos valores predefinidos ser&aacute;n v&aacute;lidos para casi todas
las configuraciones.

<p>
Para iniciar <b>named</b> de forma manual, se usa la orden
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ndc&amp;sektion=8">ndc(8)</a>
Por ejemplo:

<blockquote><pre>
# <b>ndc start</b>
          o
# <b>ndc restart</b>
</pre></blockquote>

<p>
<h4>6.8.6.2 C&oacute;mo parar DNS</h4>

<p>
El mejor modo de parar el d&aelig;mon de <code>name</code> es usando la
orden
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ndc&amp;sektion=8">ndc(8)</a>.
Por ejemplo:

<blockquote><pre>
# <b>ndc stop</b>
</pre></blockquote>

<p>
Si no funciona, hay que encontrar el PID (identificador del proceso) de
<b>named</b> y usar la orden
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=kill&amp;sektion=1">kill(1)</a>
para finalizar el proceso.  El PID de <b>named</b> mientras est&eacute;
funcionando se encontrar&aacute; en la primera l&iacute;nea del fichero
<tt>/var/named/named.pid</tt>:

<blockquote><pre>
# <b>cat /var/named/named.pid</b>
4608
named -t /var/named -u named
# <b>kill -KILL 4608</b>
</pre></blockquote>

<p>
<h4>6.8.6.3 C&oacute;mo reiniciar DNS con una configuraci&oacute;n
alterada</h4>

<p>
Para hacer que un proceso en funcionamiento del d&aelig;mon de name se
reinicie recargando su configuraci&oacute;n despu&eacute;s de haberle
hecho cambios, se debe enviar una se&ntilde;al HUP:

<blockquote><pre>
# <b>kill -HUP 4608</b> 
</pre></blockquote>

<p>
o usar la orden
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ndc&amp;sektion=8">ndc(8)</a>.
Por ejemplo:

<blockquote><pre>
# <b>ndc reload</b>
</pre></blockquote>

<p>
<h3>6.8.7 &iquest;C&oacute;mo bloqueo los requerimientos AXFR?</h3>

<p>
ejemplo:

<blockquote><pre>
garden:/home/jeremy$<b>  host -l openssh.com</b>
openssh.com.            NS      zeus.theos.com.
openssh.com.            NS      cvs.openbsd.org.
openssh.com.            NS      gandalf.sigmasoft.com.
openssh.com.            NS      cs.colorado.edu.
openssh.com.            NS      ns.appli.se.
openssh.com.            A       199.185.137.4
cvs.openssh.com.        A       199.185.137.4
localhost.openssh.com.  A       127.0.0.1
</pre></blockquote>

<p>
Esta informaci&oacute;n es &uacute;til para depurar DNS, pero en algunos
casos puede que no interese que esta informaci&oacute;n se haga
p&uacute;blica.  Si se est&aacute; usando in-addr(rfc2317) sin clase
para inverso, &iexcl; 'host -' podr&iacute;a dar informaci&oacute;n
sobre todos los dominios hospedados en el sistema!  Esto se puede
solucionar f&aacute;cilmente con la cl&aacute;usula 'allow-transfer' en
el fichero <tt>zone</tt>.
<br><br>
Si se usa Bind8 ser&aacute; necesario especificar los anfitriones a los
que se quiere permitir la transferencia de zonas en el fichero (o
ficheros) individual de zona:

<blockquote><pre>
zone &quot;foo.com&quot; in {
        type master;
        file &quot;directory/zonefile&quot;;
        allow-transfer {
          127.0.0.1;
          10.0.0.6;
          10.0.255.12;
        };
};
</pre></blockquote>

<p>
Tambi&eacute;n se pueden bloquear las transferencias para todos los
dominios editando <tt>/var/named.conf</tt> y a&ntilde;adi&eacute;ndo el
par&aacute;metro 'allow-transfer' a la secci&oacute;n 'options' del
fichero de configuraci&oacute;n:

<blockquote><pre>
   options {
        allow-transfer { 127.0.0.1; };
    };
</pre></blockquote>

<p>
El m&eacute;todo para Bind8 tambi&eacute;n funciona para Bind9.<br>
Si se est&aacute; usando Bind 4 (predeterminado en OpenBSD), se puede
editar <tt>/var/named/named.boot</tt> y usar la opci&oacute;n
'xfrnets'.<br>

<blockquote><pre>
xfrnets 209.142.221.5 12.7.96.7
; type    domain                source host/file                backup file
cache     .                                                     root.cache
primary   0.0.127.IN-ADDR.ARPA  localhost.rev
</pre></blockquote>

<p>
Bind 4 permite transferencias desde clases enteras, por lo que no es tan
exacto.  Generalmente, los &uacute;nicos anfitriones que necesitan
efectuar transferencias son los esclavos y los anfitriones de DNS desde
los que se quiera depurar (127.0.0.1 es normalmente un buen
anfitri&oacute;n desde donde permitir transferencias).  El bloqueo de
requerimientos AXFR a&ntilde;ade un nivel adicional de privacidad, pero
puede entorpecer el &uacute;til depurado de DNS (gracias a 
<a href="mailto:ntang@nachtwache.org">Nicholas Tang</a> por este
consejo).

<p>
<h3>6.8.7 &iquest;Qu&eacute; queda por ver sobre la configuraci&oacute;n
de DNS?</h3>

<p>
Hay muchas cosas de las que no hemos hablado, como por ejemplo
c&oacute;mo configurar DNS para que los requerimientos para dominios de
intranet que no sean visibles desde la ra&iacute;z de la
jerarqu&iacute;a del dominio, dependan de servidores dentro de la
empresa.  Se puede obtener m&aacute;s informaci&oacute;n sobre DNS en
los <a href="#DNS.1.1">documentos que recomendamos</a>.

<p>
<a name="PPTP"></a>
<a name="6.9"></a>
<h2>6.9 - Configuraci&oacute;n de una conexi&oacute;n PPTP en
OpenBSD</h2>

<p>
<strong>NOTA:</strong> Esta informaci&oacute;n no es v&aacute;lida para
<strong>TODOS</strong> los proveedores de conexiones ADSL, pero mucha de
la informaci&oacute;n que aqu&iacute; se encuentra se puede usar como
base.  Esta informaci&oacute;n s&oacute;lo se ha verificado con
<a href="http://www.inode.at">Inode</a>, un proveedor de ADSL en
Austria.

<p>
Antes que nada hay que instalar <i>pptp</i>.  El porte de <i>pptp</i> se
encuentra en <tt>/usr/ports/net/pptp</tt>.  Se puede encontrar
m&aacute;s informaci&oacute;n sobre el &aacute;rbol de portes de OpenBSD
en la secci&oacute;n sobre los
<a href="faq8.html#Ports"><tt>Portes</tt></a> del cap&iacute;tulo 8 de
estos documentos.

<p>
Debido a un conflicto entre el soporte integrado en el n&uacute;cleo de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gre&amp;sektion=4">gre(4)</a>
y pptp, es preciso recompilar el n&uacute;cleo del sistema, eliminando
el soporte para gre(4).

<blockquote>Parche para eliminar el soporte para GRE(4).
<pre>
Index: GENERIC
===================================================================
RCS file: /cvs/src/sys/conf/GENERIC,v
retrieving revision 1.86
diff -u -r1.86 GENERIC
--- GENERIC     14 Mar 2002 00:42:25 -0000      1.86
+++ GENERIC     17 May 2002 01:52:17 -0000
@@ -87,7 +87,7 @@
 pseudo-device  enc     1       # option IPSEC needs the encapsulation interface
 pseudo-device  bridge  2       # network bridging support
 pseudo-device  vlan    2       # IEEE 802.1Q VLAN
-pseudo-device  gre     1       # GRE encapsulation interface
+#pseudo-device gre     1       # GRE encapsulation interface
 #pseudo-device strip   1       # Starmode Radio IP interface

 pseudo-device  pty     64      # pseudo-terminals
</pre>
</blockquote>

<p>
Para recompilar el n&uacute;cleo, antes hay que obtener el c&oacute;digo
fuente de OpenBSD mediante cvs (v&eacute;ase la p&aacute;gina de
<a href="../../es/anoncvs.html">AnonCVS</a> para m&aacute;s
informaci&oacute;n), aplicar el parche anterior, y recompilar el
n&uacute;cleo tal y como se indica en la secci&oacute;n sobre la
<a href="faq5.html#Building"><tt>compilaci&oacute;n del
n&uacute;cleo</tt></a> del cap&iacute;tulo 5 de estos documentos.

<p>
Una vez que ya se haya instalado el paquete <b>pptp</b> y el nuevo
n&uacute;cleo, hay que editar unos cuantos ficheros para configurar la
conexi&oacute;n.  Este paquete utiliza el programa de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8">ppp(8)</a>
nativo de OpenBSD;  si se est&aacute; familiarizado con ppp(8), gran
parte de la configuraci&oacute;n es id&eacute;ntica.  V&eacute;se
tambi&eacute;n la secci&oacute;n sobre <a href="#PPP">PPP</a> de este
documento.

<ul>
<li>1 - /etc/ppp/options
<li>2 - /etc/ppp/pap-secrets
</ul>

<p>
Para el fichero <tt>/etc/ppp/options</tt>, una configuraci&oacute;n como
la siguiente ser&aacute; probablemente todo lo que se necesite:

<blockquote><pre>
# <b>cat /etc/ppp/options</b>
name &quot;LOGINNAME&quot;
noauth
noipdefault
defaultroute
debug
</pre></blockquote>

<p>
Se debe sustituir <tt>LOGINNAME</tt> con el identificador de usuario.

<p>
Para el fichero <tt>/etc/ppp/pap-secrets</tt> se necesitar&aacute; una
l&iacute;nea como &eacute;sta:

<blockquote><pre>
# <b>cat /etc/ppp/pap-secrets</b>
LOGINNAME 10.0.0.138 PASSWORD
</pre></blockquote>

<p>
en donde LOGINNAME es el identificador de usuario y PASSWORD la
contrase&ntilde;a.  10.0.0.138 es la direcci&oacute;n IP asignada al
m&oacute;dem en caso de que se use ADSL, etc.  Hay que asegurarse de que
este fichero s&oacute;lo pueda ser le&iacute;do por es superusuario
<i>root</i> (modo 600).

<p>
<h3>6.9.1 - Asignaci&oacute;n de una direcci&oacute;n a la interfaz de
red</h3>

<p>
En el ejemplo anterior, el m&oacute;dem ten&iacute;a una interfaz
10.0.0.38 preconfigurada.  Pero ahora necesitaremos asignar
una direcci&oacute;n a NUESTRA interfaz.  Lo mejor es escoger
una direcci&oacute;n de IP cercana a la asignada para el MODEM, o
usar la direcci&oacute;n de IP est&aacute;tica que nos hayan
asignado.  La secci&oacute;n sobre
<a href="#Setup"><tt>Configuraci&oacute;n inicial de la red</tt></a> de
este documento contiene m&aacute;s informaci&oacute;n sobre la
configuraci&oacute;n de interfaces.

<p>
Una vez que hayamos configurado la interfaz, deber&iacute;amos estar en
disposici&oacute;n de establecer una conexi&oacute;n pptp con la orden:

<blockquote><pre>
# <b>/usr/local/sbin/pptp 10.0.0.138 &amp;</b>
</pre></blockquote>

<p>
Como ya hemos dicho, se usar&aacute; el ppp(8) nativo de OpenBSD, y se
iniciar&aacute;n dos procesos;  en consecuencia, para matar pptp
ser&aacute; necesario matar estos dos procesos:

<blockquote><pre>
# <b>kill -9 [pid de pppd]</b>
$ <b>kill -9 [pid de pptp]</b>
</pre></blockquote>

<p>
Es recomendable abrir <tt>/var/log/messages</tt> en una ventana de
terminal aparte, para poder reconocer cualquier posible problema.

<blockquote><pre>
# <b>tail -f /var/log/messages</b>
</pre></blockquote>

<p>
Tambi&eacute;n es aconsejable poner la orden de inicio en
<tt>/etc/rc.local</tt> para que se conecte de forma autom&aacute;tica
cuando se reinicie el sistema.


<p>
<a name="Bridge"></a>
<h2>6.10 - Configuraci&oacute;n de un &laquo;puente de red&raquo; en
OpenBSD</h2>

<p>
Un puente o <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4">bridge</a>
es un enlace entre dos o m&aacute;s redes separadas entre s&iacute;.  A
diferencia de los enrutadores, la transferencia de paquetes a
trav&eacute;s de un puente es &laquo;invisible&raquo;;
l&oacute;gicamente, los dos segmentos de red aparecen como un solo
segmento a los nodos de cada extremo del puente.  El puente s&oacute;lo
reenv&iacute;a aquellos paquetes que deban pasar desde un segmento hacia
el otro, por lo que, entre otras cosas, ofrecen una forma f&aacute;cil
para reducir el tr&aacute;fico en una red compleja, y a&uacute;n
as&iacute;, permiten que cualquier nodo pueda acceder a otro nodo
cualquiera siempre que esto sea preciso.

<p>
N&oacute;tese que, debido a esta &laquo;naturaleza invisible&raquo;, una
interfaz en un puente puede o no tener una direcci&oacute;n IP propia.
Si la tiene, la interfaz tendr&aacute; dos modos de operaci&oacute;n,
uno que ser&aacute; parte de un puente y el otro un NIC normal
independiente.  Si ninguna de las interfaces tiene una direcci&oacute;n
IP, entonces el puente pasar&aacute; los datos de red, pero no se
podr&aacute; mantener externamente (esto se puede considerar una
funcionalidad).

<p>
<h3>Ejemplo de una aplicaci&oacute;n de puente</h3>

<p>
Uno de mis bastidores tiene unos cuantos sistemas ya viejos, y ninguno
de &eacute;stos tiene un NIC 10BASE-TX integrado.  Aunque todos tienen
un conector AUI o AAUI, mis transportadores se limitan al cable coaxial.
Una de las m&aacute;quinas en este bastidor es un servidor de OpenBSD
que siempre est&aacute; conectado a la red de alta velocidad.
A&ntilde;adi&eacute;ndole un segundo NIC con puerto coaxial puedo usar
esta m&aacute;quina como un puente hacia la red coaxial.

<p>
Ahora este sistema tiene dos NIC, una tarjeta Intel EtherExpress/100
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp&amp;sektion=4"><tt>fxp0</tt></a>)
y otra tarjeta 3c590-Combo
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&amp;sektion=4"><tt>ep0</tt></a>)
para el puerto coaxial.  <tt>fxp0</tt> es el enlace con el resto de mi
red, y por lo tanto tendr&aacute; una direcci&oacute;n IP;  <tt>ep0</tt>
s&oacute;lo se va a usar para el puente, y por lo tanto no tendr&aacute;
ninguna direcci&oacute;n IP.  Las m&aacute;quinas conectadas al segmento
coaxial se comunican como si estuvieran en el resto de la red...
&iquest;c&oacute;mo se hace esto?

<p>
El fichero <tt>hostname.fxp0</tt> contiene la informaci&oacute;n de
configuraci&oacute;n de la tarjeta <tt>fxp0</tt>.  Esta m&aacute;quina
est&aacute; configurada mediante DCHP, por lo que el fichero es como
sigue:

<blockquote><pre>
$ <b>cat /etc/hostname.fxp0</b>
dhcp NONE NONE NONE NONE
</pre></blockquote>

<p>
Hasta aqu&iacute; sin sorpresas.

<p>
La tarjeta <tt>ep0</tt> es, l&oacute;gicamente, algo diferente:

<blockquote><pre>
$ <b>cat /etc/hostname.ep0</b>
up media 10base2
</pre></blockquote>

<p>
Aqu&iacute; pasamos al sistema la instrucci&oacute;n de activar esta
interfaz usando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>,
y de configurarla como 10BASE-2 (coaxial).  No es necesario especificar
ninguna direcci&oacute;n IP ni informaci&oacute;n parecida para esta
interfaz.  Las opciones que acepta la tarjeta <tt>ep</tt> se pueden
encontrar en la p&aacute;gina del manual de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&amp;sektion=4">ep(4)</a>.

<p>
Ahora necesitamos configurar el puente.  Los puentes se inician siempre
que exista un fichero que se llame algo como
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridgename.if&amp;sektion=5"><tt>nombre_puente.bridge0</tt></a>.
He aqu&iacute; un ejemplo de mi situaci&oacute;n:

<blockquote><pre>
$ <b>cat /etc/bridgename.bridge0</b>
add fxp0
add ep0
up
</pre></blockquote>

<p>
Lo que dice es que se configure un puente que consista de dos NIC, fxp0
y ep0, y que se active.  No importa el orden en que aparezcan las
tarjetas, recu&eacute;rdese que un puente es muy sim&eacute;trico, los
paquetes pasan en ambas direcciones.

<p>
&iexcl;Eso es todo!  Despu&eacute;s de reiniciar ya tendremos un puente
totalmente funcional.

<p>
<h3>Filtros de paquetes en un puente (<i>bridge</i>)</h3>
<!-- XXXchanges - changes with OpenBSD 3.3 -->
<p>
Aunque existen varios usos para un puente simple como &eacute;ste, es
muy probable que quiera hacer algo con los paquetes mientras pasan a
trav&eacute;s del puente.  Se puede usar <a href="#PF">PF</a> para
restringir el tr&aacute;fico que pasar&aacute; a trav&eacute;s del
puente.

<p>
Hay que tener en cuenta que, por la naturaleza del puente, los mismos
datos pasar&aacute;n a trav&eacute;s de ambas interfaces, por lo que
s&oacute;lo ser&aacute; necesario filtrar en una sola interfaz.  Las
reglas &quot;Pass all&quot; pueden quedar as&iacute;:

<blockquote><pre>
pass in  on ep0  all
pass out on ep0  all
pass in  on fxp0 all
pass out on fxp0 all
</pre></blockquote>

<p>
Supongamos ahora que quiero filtrar el tr&aacute;fico que llegue a estas
viejas m&aacute;quinas, y que s&oacute;lo quiero que pase el
tr&aacute;fico de <i>web</i> y SSH por ellas.  En este caso dejaremos
salir y entrar todo el tr&aacute;fico de la interfaz ep0, y filtraremos
el de la interfaz fxp0, usando &quot;keep state&quot; para manejar la
respuesta de datos:

<blockquote><pre>
# Pass all traffic through ep0
pass in quick on ep0 all
pass out quick on ep0 all

# Block fxp0 traffic
block in  on fxp0 all
block out on fxp0 all

pass in quick on fxp0 proto tcp from any to any port {22, 80} \
     flags S/SA keep state
</pre></blockquote>

<p>
N&oacute;tese que este grupo de reglas evitar&aacute; que llegue
cualquier tr&aacute;fico a la m&aacute;quina puente o a cualquier otro
nodo &laquo;detr&aacute;s&raquo; de ella, excepto el tr&aacute;fico
entrante de HTTP y SSH.  Es posible obtener otros resultado filtrando la
otra interfaz.

<p>
Para monitorizar y controlar el puente, se puede usar la orden
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=brconfig&amp;sektion=8">brconfig(8)</a>,
que tambi&eacute;n puede ser usada para crear un puente despu&eacute;s
del arranque.

<p>
<h3>Consejos</h3>

<ul>
<li>Es MUY recomendable filtrar en una sola interfaz.  Aunque se puede
filtrar en ambas, para ello hay que saber muy bien lo que se est&aacute;
haciendo.

<li>Usando la opci&oacute;n <i>blocknonip</i> de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=brconfig&amp;sektion=8">brconfig(8)</a>
o en
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridgename.if&amp;sektion=5">bridgename.bridge0</a>,
se puede evitar que se cuele tr&aacute;fico no IP (como IPX o NETBEUI)
por los filtros.  Hay que tener en cuenta que los puentes funcionan para
todo tipo de tr&aacute;fico, no s&oacute;lo para IP.

<li>Un puente requiere que los NIC est&eacute;n en &laquo;modo
prom&iacute;scuo&raquo; (que est&eacute;n a la escucha para TODO el
tr&aacute;fico de red, no s&oacute;lo para el de la interfaz
redireccionada).  Esto implica una mayor carga en el procesador y el bus
de la esperada.  Algunos NIC no funcionan correctamente en este modo; el
<i>chip</i> TI ThunderLAN
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tl&amp;sektion=4">tl(4)</a>)
es un ejemplo de un <i>chip</i> que no funciona como parte de un puente.
</ul>


<p>
<font color="#0000e0">
<a href="index.html">[&Iacute;ndice de documentos]</a>
<a href="faq5.html">[Secci&oacute;n 5 - Compilaci&oacute;n del sistema
con el c&oacute;digo fuente]</a>
<a href="faq7.html">[Secci&oacute;n 7 - Controles de teclado y
pantalla]</a>
</font>

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../back.gif" border="0" alt="[&iacute;ndice]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
Originally [OpenBSD: faq6.html,v 1.169 2003/05/01 01:47:41 nick Exp ]<br>
$Translation: faq6.html,v 1.86 2003/05/01 18:42:42 horacio Exp $<br>
$OpenBSD: faq6.html,v 1.73 2003/05/01 20:47:29 jufi Exp $
</small>
</body>
</html>
