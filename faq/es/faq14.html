<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>14 - Configuraci&oacute;n del disco</title>
<link rev="made" href="mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta http-equiv="Content-Language" content="es">
<meta name="resource-type" content="documento">
<meta name="description"   content="Preguntas Frecuentes de OpenBSD">
<meta name="keywords"      content="openbsd,faq,documentación">
<meta name="distribution"  content="global">
<meta name="copyright"     content="Este documento es copyright 1998-2003 de OpenBSD.">
<style type="text/css">
  <!--
  pre { margin-left: 20px; }
  -->
</style>
</head>

<body bgcolor="#ffffff" text="#000000">
<!-- máx. 72 caracteres por línea -->

<img alt="[OpenBSD]" height="30" width="141" src="../../images/smalltitle.gif">
<p>
<font color="#0000e0">
<a href="index.html">[&Iacute;ndice de documentos]</a>
<a href="faq13.html">[Secci&oacute;n 13 - IPsec]</a>
</font>

<h1><font color="#e00000">14 - Configuraci&oacute;n del
disco</font></h1><hr>

<h3>Tabla de contenidos</h3>
<ul>
<li><a href="#disklabel">14.1 - Utilizaci&oacute;n del <i>disklabel</i>
de OpenBSD</a>
<li><a href="#fdisk">14.2 - Utilizaci&oacute;n del <i>fdisk</i> de
OpenBSD</a>
<li><a href="#NewDisk">14.3 - C&oacute;mo a&ntilde;adir discos
adicionales en OpenBSD</a>
<li><a href="#SwapFile">14.4 - C&oacute;mo usar un fichero como memoria
de intercambio (<i>swap</i></a>
<li><a href="#SoftUpdates">14.5 - &quot;Soft Updates&quot;</a>
<li><a href="#D0P3">14.6 - Cuando arranco el sistema despu&eacute;s de
la instalaci&oacute;n de OpenBSD/i386, se para en<br>
&quot;Using Drive: 0 Partition 3&quot;.</a>
<li><a href="#LargeDrive">14.7 - &iquest;Qu&eacute; problemas puede
haber en OpenBSD con dispositivos de gran capacidad?</a>
<li><a href="#InstBoot">14.8 - Instalaci&oacute;n de bloques de arranque
(espec&iacute;fico de i386)</a>
<li><a href="#Backup">14.9 - C&oacute;mo prepararse para el desastre:
hacer copias de seguridad (respaldo) y restaurar desde una cinta</a>
<li><a href="#MountImage">14.10 - C&oacute;mo montar im&aacute;genes de
disco en OpenBSD.</a>
<li><a href="#pciideErr">14.11 - &iexcl;Ayuda! &iexcl; da errores con
PCIIDE!</a>
<li><a href="#IDEDMA">14.12 - C&oacute;mo forzar el acceso DMA en discos
IDE</a>
<li><a href="#RAID">14.13 - Opciones de RAID con OpenBSD</a>
</ul>
<hr>

<a name="disklabel"></a>
<a name="14.1"></a>
<h2>C&oacute;mo usar disklabel</h2>
   
<h3>Tabla de contenidos de disklabel</h3>

<ul>
<li><a href="#disklabel.1">&iquest;Qu&eacute; es disklabel?</a>
<li><a href="#disklabel.2">disklabel durante la instalaci&oacute;n de
OpenBSD</a>
<li><a href="#disklabel.3">Usos comunes de disklabel</a>
</ul>
   

<a name="disklabel.1"></a>
<h3>&iquest;Qu&eacute; es disklabel?</h3>

<p>
Antes de empezar, se recomienda leer la p&aacute;gina del manual de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>.
   
<p>
Las &laquo;clasificaciones del disco&raquo; (<i>disklabels</i>) se crean
para permitir una interfaz eficiente entre el disco y los controladores
del disco que contiene el n&uacute;cleo del sistema (<i>kernel</i>).
Estas clasificaciones contienen cierta informaci&oacute;n sobre el
disco, como la geometr&iacute;a del controlador e informaci&oacute;n
sobre los sistemas de archivos (<i>filesystems</i>).  Esta
informaci&oacute;n la utiliza el programa de arranque para cargar el
controlador y para saber en qu&eacute; parte del controlador se
encuentran los sistemas de archivos.  Las clasificaciones tambi&eacute;n
se usan en conjunto con los sistemas de archivos para crear un entorno
m&aacute;s eficiente.  Hay una documentaci&oacute;n m&aacute;s detallada
sobre disklabel en la p&aacute;gina del manual de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=5">disklabel(5)</a>.

<p>
Adem&aacute;s, el uso de disklabel ayuda a superar las limitaciones de
las arquitecturas al particionar el disco.  Por ejemplo, en i386
s&oacute;lo se puede crear cuatro particiones primarias (particiones que
puedan ver otros sistemas operativos como Windows NT o DOS).  Con
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>,
una de esas particiones primarias se usa para almacenar <b>todas</b>
nuestras particiones de OpenBSD (<i>swap</i>, <i>/</i>, <i>/usr</i>,
<i>/var</i>, ...), y todav&iacute;a nos quedar&aacute;n tres particiones
libres para otros sistemas operativos.

<p>
<a name="disklabel.2"></a>
<h3>disklabel durante la instalaci&oacute;n de OpenBSD</h3>

<p>
Una de las partes principales de la instalaci&oacute;n de OpenBSD es la
creaci&oacute;n inicial de &laquo;clasificaciones&raquo;
(<i>labels</i>).  Para los usuarios de plataformas i386, &eacute;ste es
el paso que viene justo despu&eacute;s de usar
<a href="#fdisk">fdisk(1)</a>.  Durante la instalaci&oacute;n, el
programa que se usa para crear clasificaciones separadas que contengan
los puntos de montaje separados es
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>.
Durante este proceso se puede configurar los puntos de montaje desde
dentro de disklabel, pero esto no es del todo necesario si consideramos
que m&aacute;s tarde nos pedir&aacute; que confirmemos nuestras
elecciones.  De todos modos hace que la instalaci&oacute;n sea un poco
m&aacute;s suave.

<p>
Ya que esto ocurre durante la instalaci&oacute;n, todav&iacute;a no
tendremos ninguna clasificaci&oacute;n creada y, por lo tanto, antes
debemos crearlas.  La primera clasificaci&oacute;n que tendremos que
crear es la clasificaci&oacute;n '<b>a</b>'.  Esta clasificaci&oacute;n
DEBE ser en la que se monte el sistema de archivos <b>/</b>.  Puede
verse una lista de las particiones que se recomienda crear, y sus
respectivos tama&ntilde;os recomendados, en la
<a href="faq4.html#SpaceNeeded">secci&oacute;n 4.3</a> de las preguntas
frecuentes.  Para servidores se recomienda que, como m&iacute;nimo, se
creen estas particiones separadas.  Para los usuarios de computadoras
(ordenadores) de sobremesa, ser&aacute; suficiente con crear un
s&oacute;lo punto de montaje para <b>/</b>.  Cuando se cree por primera
vez esta partici&oacute;n ra&iacute;z (clasificaci&oacute;n <b>a</b>),
hay que tener en cuenta que ser&aacute; necesario dejar ALGO de espacio
para la clasificaci&oacute;n de <i>swap</i>.  Ahora que ya hemos
explicado lo m&aacute;s b&aacute;sico, pasemos a ver un ejemplo de la
utilizaci&oacute;n de disklabel durante la instalaci&oacute;n.  En este
primer ejemplo se asume que OpenBSD va a ser el &uacute;nico sistema
operativo en la m&aacute;quina, y que se llevar&aacute; a cabo una
instalaci&oacute;n completa.

<p>
<i>N. del T.:  el texto que sigue a continuaci&oacute;n est&aacute;
traducido para el prop&oacute;sito de este documento, pero durante la
instalaci&oacute;n el texto aparecer&aacute; en ingl&eacute;s</i>

<pre>
Si se comparte el disco con otros sistemas operativos, esos sistemas
operativos deben tener una entrada de la partici&oacute;n en la BIOS
que abarque completamente el espacio que ocupen.  Hay que asegurarse
de que todos los sistemas de archivos de OpenBSD se encuentren dentro
del tama&ntilde;o especificado en la tabla de particiones de la BIOS 'A6'
(por definici&oacute;n, el editor de disklabel tratar&aacute; de forzar
esto).  Si no se est&aacute; seguro de c&oacute;mo usar correctamente
particiones m&uacute;ltiples (o sea, /, /usr, /tmp, /var, /usr/local, y
otras separadas), se puede dividir el espacio de momento en una
partici&oacute;n ra&iacute;z y otra <i>swap</i>.

# using MBR partition 3: type A6 off 63 (0x3f) size 4991553 (0x4c2a41) 

Treating sectors 63-16386300 as the OpenBSD portion of the disk.
You can use the 'b' command to change this.

Initial label editor (enter '?' for help at any prompt)
&gt; <b>d a</b>
&gt; <b>a a</b>
offset: [63] <b>&lt;Intro&gt;</b>
size: [16386237] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <b>&lt;Intro&gt;</b>
mount point: [none] <b>/</b>
fragment size: [1024] <b>&lt;Intro&gt;</b>
block size: [8192] <b>&lt;Intro&gt;</b>
cpg: [16] <b>&lt;Intro&gt;</b>
&gt; <b>a b</b>
offset: [131103] <b>&lt;Intro&gt;</b>
size: [16255197] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [swap] <b>&lt;Intro&gt;</b>
</pre>

<p>
Hasta este punto hemos creado una partici&oacute;n ra&iacute;z de 64MB
montada en <b>/</b>, y una partici&oacute;n <i>swap</i> de 64MB.  Note
que empieza (&quot;offset&quot;) en el sector 63.  En la parte
correspondiente al tama&ntilde;o, disklabel muestra su tama&ntilde;o en
sectores; sin embargo no es necesario introducirlos en el mismo formato.
Como en el ejemplo anterior, puede introducir los tama&ntilde;os de la
forma <i>64 Megabytes = 64M</i> y <i>2 Gigabytes = 2G</i>.  Disklabel
los redondear&aacute; hasta el cilindro m&aacute;s cercano.
Tambi&eacute;n notar&aacute; en el ejemplo anterior que disklabel asume
que la clasificaci&oacute;n '<b>b</b>' ser&aacute; <i>swap</i>.  Esto es
correcto ya que el n&uacute;cleo del sistema GENERIC est&aacute;
configurado para buscar <i>swap</i> en la clasificaci&oacute;n <b>b</b>,
y todo lo que usted debe hacer es seguir esta gu&iacute;a y usar
<b>b</b> como su &aacute;rea de <i>swap</i>.

<p>
El siguiente ejemplo le guiar&aacute; por la creaci&oacute;n de dos
clasificaciones m&aacute;s.  Esto quiere decir que no es una
instalaci&oacute;n completa, ya que el tama&ntilde;o de &eacute;stas no
ser&aacute; suficiente para instalar OpenBSD al completo.  Mostrar otra
vez la creaci&oacute;n de todas las particiones ser&iacute;a redundante.

<pre>
&gt; <b>a d</b>
offset: [262143] <b>&lt;Intro&gt;</b>
size: [16124157] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <b>&lt;Intro&gt;</b>
mount point: [none] <b>/tmp</b>
fragment size: [1024] <b>&lt;Intro&gt;</b>
block size: [8192] <b>&lt;Intro&gt;</b>
cpg: [16] <b>&lt;Intro&gt;</b>
&gt; <b>a e</b>
offset: [393183] <b>&lt;Intro&gt;</b>
size: [15993117] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <b>&lt;Intro&gt;</b>
mount point: [none] <b>/var</b>
fragment size: [1024] <b>&lt;Intro&gt;</b>
block size: [8192] <b>&lt;Intro&gt;</b>
cpg: [16] <b>&lt;Intro&gt;</b>
</pre>

<p>
En este ejemplo puede notar dos diferencias con el anterior.  Una, que
el inicio del sector (<i>offset</i>) lo averigua de forma
autom&aacute;tica.  Cuando haga una instalaci&oacute;n de este tipo no
tendr&aacute; que configurar los sectores.  Otra diferencia es que la
clasificaci&oacute;n '<b>c</b>' representa a todo el disco.  Por este
motivo no debe tocar la clasificaci&oacute;n <b>c</b>.

<p>
Una vez que todas las clasificaciones hayan sido creadas, todo lo
quedar&aacute; por hacer ser&aacute; grabarlas en el disco y pasar al
proceso de instalaci&oacute;n.  Para grabarlo todo y salir de disklabel
(y continuar con la instalaci&oacute;n), haga lo siguiente:

<pre>
&gt; <b>w</b>
&gt; <b>q</b>
</pre>

<p>
<b>*NOTA*</b> - Para usuarios con discos grandes.  Si la BIOS de su
equipo no tiene soporte para el tama&ntilde;o de su disco, OpenBSD
tampoco tendr&aacute; soporte para &eacute;ste.  En cualquier otro caso
OpenBSD deber&iacute;a ser capaz de tratar su disco sin problema alguno.
Si se encuentra en una situaci&oacute;n en la que la BIOS de su
m&aacute;quina no dispone de soporte para su disco, puede probar Maxtor
EZ-Drive u otro producto complementario de similares
caracter&iacute;sticas.

<p>
<a name="disklabel.3"></a>
<h3>Uso general de disklabel(8)</h3>

<p>
Una vez que est&eacute; instalado el sistema, el uso frecuente de
disklabel no deber&iacute;a ser necesario.  Pero a veces tendr&aacute;
que usarlo cuando a&ntilde;ada, elimine, o reestructure sus discos.  Una
de las primeras cosas que tendr&aacute; que hacer ser&aacute; ver su
disklabel actual.  Para ello, escriba lo siguiente:

<pre>
# <b>disklabel wd0</b> &lt;----- O cualquier dispositivo de disco que quiera ver

# using MBR partition 3: type A6 off 64 (0x40) size 16777152 (0xffffc0)
# /dev/rwd0c:
type: ESDI
disk:
label: TOSHIBA MK2720FC
flags:
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 2633
total sectors: 2654064
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # milliseconds
track-to-track seek: 0  # milliseconds
drivedata: 0 

16 partitions:
#        size   offset    fstype   [fsize bsize   cpg]
  a:  2071440    65583    4.2BSD     1024  8192    16   # (Cyl.   65*- 2120)
  b:    65520       63      swap                        # (Cyl.    0*- 65)
  c:  2654064        0    unused        0     0         # (Cyl.    0 - 2632)
  j:   512001  2137023    4.2BSD     1024  8192    16   # (Cyl. 2120*- 2627*)
</pre>

<p>
La orden anterior le permite ver el disklabel presente, y de este modo
asegurarse de que no l&iacute;a nada (algo que todos necesitamos algunas
veces).  Pero para poder hacer cambios debe usar disklabel con la
opci&oacute;n -E, de este modo:

<pre>
# <b>disklabel -E wd0</b>
</pre>

<p>
Esto le llevar&aacute; hasta un &laquo;punto de pedido&raquo;
(&quot;prompt&quot;), el mismo que us&oacute; durante la
instalaci&oacute;n de OpenBSD.  Probablemente, la orden m&aacute;s
importante de todas en este punto de pedido sea '?'.  Con esta orden
obtendr&aacute; una lista de posibles opciones relacionadas con
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>.
Incluso podr&aacute; ver la p&aacute;gina del manual de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
al completo con la orden 'M'.  Desde este punto podr&aacute;
a&ntilde;adir o eliminar todo lo que desee, o hacer cambios en las
particiones.  Para m&aacute;s informaci&oacute;n al respecto lea la
p&aacute;gina del manual de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>.


<a name="fdisk"></a>
<a name="14.2"></a>
<h2>14.2 - C&oacute;mo usar fdisk</h2>

<p>
Antes que nada, aseg&uacute;rese de leer la p&aacute;gina del manual
principal de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>

<p>
Fdisk es un programa de ayuda para el mantenimiento de sus particiones.
Este programa se usa durante la instalaci&oacute;n para configurar la
partici&oacute;n de OpenBSD (esta partici&oacute;n puede contener
<u>varias</u> clasificaciones, cada una de ellas con sistemas de
archivos, <i>swap</i>, etc... ).  Puede dividir el espacio de sus
dispositivos y activar uno de ellos.  Fdisk se suele usar en &laquo;Modo
Monousuario&raquo; (<b>boot -s</b> - &quot;Single User Mode&quot;).
Fdisk tambi&eacute;n configura el MBR de los discos.

<p>
Para la instalaci&oacute;n, la mayor&iacute;a de las veces s&oacute;lo
necesitar&aacute; <b>UNA</b> partici&oacute;n de OpenBSD, y a
continuaci&oacute;n usar disklabel para poner en ella una <i>swap</i> y
un sistema de archivos.

<p>
Para ver s&oacute;lo su tabla de particiones con fdisk, haga lo
siguiente:

<pre>
# <b>fdisk fd0</b>
</pre>

<p>
lo que le dar&aacute; una salida parecida a &eacute;sta:

<pre>
         Disk: fd0       geometry: 80/2/18 [2880 sectors]
         Offset: 0       Signatures: 0xAA55,0x0
                  Starting        Ending
          #: id  cyl  hd sec -  cyl  hd sec [     start -       size]
----------------------------------------------------------------------
----------------------------------------------------------------------
         *0: A6    0   0   1 -   79   1  18 [         0 -       2880] OpenBSD
          1: 00    0   0   0 -    0   0   0 [         0 -          0] unused
          2: A7    0   0   2 -   79   1  18 [         1 -       2879] NEXTSTEP
          3: 00    0   0   0 -    0   0   0 [         0 -          0] unused
</pre>

<p>
En este ejemplo estamos viendo la salida de fdisk para el dispositivo de
la disquetera.  Podemos ver la partici&oacute;n de OpenBSD (A6) y su
tama&ntilde;o.  El asterisco (*) nos indica que la partici&oacute;n de
OpenBSD es una partici&oacute;n de arranque.

<p>
En el ejemplo anterior s&oacute;lo vimos nuestra informaci&oacute;n.
&iquest;Y si quisi&eacute;ramos editar nuestra tabla de particiones?
Pues bien, para ello debemos usar el indicador <b>-e</b>, que nos
trasladar&aacute; a una l&iacute;nea de &oacute;rdenes desde la que
podremos interaccionar con fdisk.

<pre>
# <b>fdisk -e wd0</b>
Enter 'help' for information
fdisk: 1&gt; <b>help</b>
        help            Command help list
        manual          Show entire OpenBSD man page for fdisk
        reinit          Re-initialize loaded MBR (to defaults)
        setpid          Set the identifier of a given table entry
        disk            Edit current drive stats
        edit            Edit given table entry
        flag            Flag given table entry as bootable
        update          Update machine code in loaded MBR
        select          Select extended partition table entry MBR
        print           Print loaded MBR partition table
        write           Write loaded MBR to disk
        exit            Exit edit of current MBR, without saving changes
        quit            Quit edit of current MBR, saving current changes
        abort           Abort program without saving current changes
fdisk: 1&gt; 
</pre>

<p> 
Entrar en fdisk y explorar el disco es totalmente seguro, s&oacute;lo
debe asegurarse de contestar <b>N</b> cuando le pregunte si quiere
guardar los cambios, y de que NO usa la orden <b>write</b>.

<p>
Aqu&iacute; tiene una revisi&oacute;n de las &oacute;rdenes que puede
usar cuando escoja el indicador <b>-e</b>.

<ul>
<li><b>help</b> Mostrar una lista de las &oacute;rdenes comprensibles
para fdisk en el modo de edici&oacute;n interactiva.
<li><b>reinit</b> Iniciar la copia residente en memoria del bloque de
arranque seleccionado.
<li><b>disk</b> Mostrar la geometr&iacute;a del dispositivo que haya
verificado fdisk.  Si lo desea, puede editarla para aplicarle cambios.
<li><b>setpid</b> Cambiar el identificador de particiones de la entrada
en la tabla para la partici&oacute;n indicada.  Esta orden es
&uacute;til para la reasignaci&oacute;n de una partici&oacute;n
existente a OpenBSD.
<li><b>edit</b> Editar una cierta entrada en la tabla en la copia
residente en memoria del bloque de arranque actual.  Puede editarla en
modo de geometr&iacute;a de la BIOS o en modo de sectores de inicio y
tama&ntilde;os.
<li><b>flag</b> Activar una cierta entrada en la tabla de particiones
como partici&oacute;n de arranque.  Solamente se puede marcar una
entrada como partici&oacute;n de arranque.  Si quiere arrancar desde una
partici&oacute;n extendida, tendr&aacute; que marcar la entrada de la
partici&oacute;n en la tabla como partici&oacute;n de arranque.
<li><b>update</b> Actualizar el c&oacute;digo de la m&aacute;quina en la
copia residente en memoria del bloque de arranque seleccionado.
<li><b>select</b> Seleccionar y cargar en memoria el bloque de arranque
que se&ntilde;ala a la entrada en la tabla de particiones extendidas del
bloque de arranque actual.
<li><b>print</b> Mostrar en pantalla la copia residente en memoria del
bloque de arranque seleccionado y su tabla MBR.
<li><b>write</b> Grabar la copia residente en memoria del bloque de
arranque al disco.  Le pedir&aacute; que confirme esta operaci&oacute;n.
<li><b>exit</b> Salir del nivel actual de fdisk, volviendo al bloque de
arranque residente en memoria previamente seleccionado, o saliendo
completamente del programa si no hubiera ninguno.
<li><b>quit</b> Salir del nivel actual de fdisk, volviendo al bloque de
arranque residente en memoria previamente seleccionado, o saliendo
completamente del programa si no hubiera ninguno.  A diferencia de
<b>exit</b>, no guarda los cambios del bloque modificado.
<li><b>abort</b> Salir del programa sin guardar cambios.
</ul>

<a name="NewDisk"></a>
<a name="14.3"></a>
<h2>14.3 - C&oacute;mo a&ntilde;adir discos adicionales</h2>

<p>
Una vez que ya tenga su disco instalado <b>CORRECTAMENTE</b>,
deber&aacute; usar
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
(<i>s&oacute;lo i386</i>) y
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
para configurarlo en OpenBSD.

<p>
Los usuarios de plataformas i386 deben empezar con fdisk.  El resto de
plataformas pueden ignorar esta parte.  En el ejemplo que sigue a
continuaci&oacute;n estamos a&ntilde;adiendo un tercer dispositivo SCSI
al sistema.

<pre>
# <b>fdisk -i sd2</b>
</pre>

<p>
De este modo se iniciar&aacute; la tabla de particiones
&laquo;real&raquo; para su uso exclusivo por OpenBSD.  A
continuaci&oacute;n debe crear un disklabel.  Esto le parecer&aacute;
algo confuso.

<pre>
# <b>disklabel -e sd2</b>

<i>(la pantalla se queda en blanco y aparece su $EDITOR)</i>
type: SCSI
<i>...bla...</i>
sectors/track: 63
total sectors: 6185088
<i>...bla...</i>
16 partitions:
#        size   offset    fstype   [fsize bsize   cpg]
  c:  6185088        0    unused        0     0         # (Cyl.    0 - 6135)
  d:  1405080       63    4.2BSD     1024  8192    16   # (Cyl.    0*- 1393*)
  e:  4779945  1405143    4.2BSD     1024  8192    16   # (Cyl. 1393*- 6135)
</pre>

<p>
Ignore la partici&oacute;n <b>c</b>, siempre est&aacute; ah&iacute; y es
para que funcionen programas como disklabel.  Para operaciones normales,
<i>fsize</i> siempre debe ser 1024, <i>bsize</i> siempre debe ser 8192,
y <i>cpg</i> siempre debe ser 16.  <i>fstype</i> es 4.2BSD.  <i>total
sectors</i> es el tama&ntilde;o total del disco.  Supongamos que
&eacute;ste es un disco de 3GB;  tres gigabytes, en t&eacute;rminos del
fabricante del disco, son 3000 megabytes.  Divida 6185088 entre 3000
(use
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bc&amp;sektion=1">
bc(1)</a>) y obtendr&aacute; 2061.  Por lo tanto, para crear particiones
para a, d, e, f, g, ... simplemente multiplique X*2061 y obtendr&aacute;
el n&uacute;mero de megabytes de espacio en esa partici&oacute;n.  El
sector de inicio (<i>offset</i>) para su primera partici&oacute;n nueva
debe ser el mismo que el &quot;<i>sectors/track</i>&quot; que le haya
dado anteriormente la salida de disklabel.  En este caso es 63.  El
sector de inicio para cada partici&oacute;n consecutiva debe ser una
combinaci&oacute;n del tama&ntilde;o de cada partici&oacute;n y el
sector de inicio de la misma (excepto la partici&oacute;n <b>c</b>, ya
que no juega ning&uacute;n papel aqu&iacute;).

<p>
O, si s&oacute;lo quiere tener una partici&oacute;n en el disco (si, por
ejemplo, quisiera usarlo todo para almacenaje de web o como directorio
home), tome el tama&ntilde;o total del disco y r&eacute;stele los
sectores por pista (&quot;sectors/track&quot;).  En este caso,
6185088-63 = 6185025.  La partici&oacute;n quedar&aacute; as&iacute;:

<pre>
    d:  6185025       63    4.2BSD     1024  8192    16 
</pre>

<p>
<b>&iexcl;Si todo esto le parece complicado e innecesario, puede usar
disklabel -E para obtener el mismo modo de particiones que tiene en su
disco de instalaci&oacute;n!</b> Ah&iacute; puede usar &laquo;96M&raquo;
para especificar &laquo;96 megabytes&raquo; (o con un disco lo bastante
grande, 96G para 96 gigabytes).  Desafortunadamente, el modo -E usa la
geometr&iacute;a del disco de la BIOS, no la geometr&iacute;a del disco
real, y con frecuencia &eacute;stas no son las mismas.  Para evitar esta
limitaci&oacute;n, escriba 'g d' para la 'geometr&iacute;a del disco'.
Otras opciones son 'g b' para la 'geometr&iacute;a de la bios' y 'g u'
para la 'geometr&iacute;a del usuario', o simplemente lo que indique la
&laquo;clasificaci&oacute;n&raquo; (<i>label</i>) antes de que disklabel
efect&uacute;e alg&uacute;n cambio.

<p>
Esto ha sido largo, pero todav&iacute;a no ha terminado.  Para
finalizar, debe crear el sistema de archivos en el disco usando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&amp;sektion=8">newfs(8)</a>.

<pre>
# <b>newfs sd2a</b>
</pre>

<p>
O cualquiera otra denominaci&oacute;n de su disco de acuerdo con el
esquema de numeraci&oacute;n del disco de OpenBSD (mire la salida de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)</a> 
para averiguar el nombre que OpenBSD da a su disco).

<p>
Ahora debe decidir d&oacute;nde va a montar la nueva partici&oacute;n
que acaba de crear.  Digamos que quiere ponerla en /u.  Primero cree el
directorio /u, y luego m&oacute;ntelo.

<pre>
# <b>mount /dev/sd2a /u</b>
</pre>

<p>
Finalmente, a&ntilde;&aacute;dalo a
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a>:

<pre>
/dev/sd2a /u ffs rw 1 1
</pre>

<p>
&iexcl;Y si necesitara migrar a un directorio ya existente como
/usr/local?  Entonces deber&iacute;a montar la partici&oacute;n nueva en
/mnt, y usar <tt>cpio -pdum</tt> para copiar /usr/local al directorio
/mnt.  A continuaci&oacute;n editar el fichero
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a>
para indicar que la partici&oacute;n /usr/local es ahora /dev/sd2a (su
partici&oacute;n reci&eacute;n creada).  Por ejemplo:

<pre>
<b>/dev/sd2a /usr/local ffs rw 1 1</b>
</pre>

<p>
Reinicie en modo monousuario con <b>boot -s</b> y copie el fichero
/usr/local existente a /usrs/local-backup (eliminando el original cuando
est&eacute; seguro), y cree un directorio /usr/local vac&iacute;o.
Reinicie el sistema y &iexcl;ya est&aacute;!  &iexcl;ah&iacute;
est&aacute;n los ficheros!


<a name="SwapFile"></a>
<a name="14.4"></a>
<h2>14.4 - C&oacute;mo usar un fichero como memoria de <i>swap</i></h2>

<p>
(Nota: si lo que quiere es usar un fichero como memoria de intercambio
(<i>&quot;swap&quot;</i>) porque obtiene errores del tipo &quot;virtual
memory exhausted&quot;, deber&iacute;a intentar antes elevar los
l&iacute;mites por proceso con la utilidad
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=unlimit&amp;sektion=1">unlimit(1)</a> de csh, o
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ulimit&amp;sektion=1">ulimit(1)</a>) de sh.

<p>
Para el uso de un fichero como memoria de intercambio (<i>swap file</i>)
no es estrictamente necesaria la compilaci&oacute;n de un n&uacute;cleo
del sistema personalizado, pero en este documento mostraremos
c&oacute;mo a&ntilde;adir espacio <i>swap</i> de las dos formas.

<p>
<h3>Usar un fichero como <i>swap</i></h3>

<p>
Usar un fichero como memoria de <i>swap</i> es la forma m&aacute;s
f&aacute;cil y r&aacute;pida de obtener una configuraci&oacute;n
adicional del espacio de <i>swap</i>.  El fichero no debe residir en un
sistema de archivos que tenga SoftUpdates activado (se encuentra
desactivado por definici&oacute;n).  Para empezar, puede ver
cu&aacute;nta memoria de <i>swap</i> tiene en ese momento y
cu&aacute;nta est&aacute; usando con la utilidad
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=swapctl&amp;sektion=8">swapctl(8)</a>,
del modo siguiente:

<pre>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
</pre>

<p>
Esto le mostrar&aacute; los dispositivos que est&aacute;n siendo usados
como memoria de <i>swap</i> y sus estad&iacute;sticas actuales.  En el
ejemplo anterior, s&oacute;lo hay un dispositivo denominado
&quot;swap_device&quot;.  &Eacute;ste es el &aacute;rea predefinida para
<i>swap</i> (si lo vi&eacute;ramos con disklabel, lo mostrar&iacute;a
como la partici&oacute;n b).  Tambi&eacute;n puede ver en el ejemplo
anterior que el dispositivo no est&aacute; siendo muy usado en ese
momento.  Pero para el prop&oacute;sito de este documento, procederemos
como si necesit&aacute;ramos 32MB adicionales.

<p>
El primer paso para configurar un fichero como un dispositivo de
<i>swap</i> es crear el fichero.  El mejor modo de hacerlo es con la
utilidad
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&amp;sektion=1">
dd(1)</a>.  He aqu&iacute; un ejemplo de c&oacute;mo crear el fichero
<i>/var/swap</i>, que tendr&aacute; un tama&ntilde;o de 32MB.

<pre>
$ <b>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</b>
32768+0 records in
32768+0 records out
33554432 bytes transferred in 20 secs (1677721 bytes/sec)
</pre>

<p>
Una vez que lo hayamos creado, podemos activar el uso de ese dispositivo
como memoria de <i>swap</i>.  Para activarlo, use la siguiente orden:

<pre>
$ <b>sudo chmod 600 /var/swap</b>
$ <b>sudo swapctl -a /var/swap</b>
</pre>

<p>
Ahora debemos comprobar si se ha a&ntilde;adido correctamente a la lista
de nuestros dispositivos de <i>swap</i>.

<pre>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
/var/swap        65536        0    65536     0%    0
Total           131056        8   131048     0%
</pre>

<p>
Ahora que ya est&aacute; activado el fichero y que se est&aacute; usando
como <i>swap</i>, debe a&ntilde;adir una l&iacute;nea a su fichero
<i>/etc/fstab</i>, para que el fichero tambi&eacute;n se active en el
pr&oacute;ximo arranque.  Si no a&ntilde;ade esta l&iacute;nea, no
tendr&aacute; este dispositivo de <i>swap</i> configurado.

<pre>
$ <b>cat /etc/fstab</b>
/dev/wd0a / ffs rw 1 1
/var/swap /var/swap swap sw 0 0
</pre>

<p>
<h3>Usar <i>swap</i> a trav&eacute;s de un dispositivo vnode</h3>

<p>
&Eacute;sta es una soluci&oacute;n m&aacute;s permanente que la de
a&ntilde;adir m&aacute;s espacio de <i>swap</i>.  Para usar
permanentemente un fichero como memoria de <i>swap</i>, primero compile
un n&uacute;cleo con vnd0c como <i>swap</i>.  Si su sistema de archivos
ra&iacute;z es wd0a, entonces wd0b es el <i>swap</i> anterior y debe
usar la siguiente l&iacute;nea en el fichero de configuraci&oacute;n del
n&uacute;cleo (si tiene dudas, lea el
<a href="faq5.html">cap&iacute;tulo 5</a> de las preguntas frecuentes
referente a la compilaci&oacute;n del n&uacute;cleo del sistema):

<pre>
config          bsd     root on wd0a swap on wd0b and vnd0c dumps on wd0b
</pre>

<p>
Despu&eacute;s de esto, tendr&aacute; que crear el fichero que se
usar&aacute; como memoria de <i>swap</i>.  Debe hacerlo usando la misma
orden que en los ejemplos anteriores.

<pre>
$ <b>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</b>
32768+0 records in
32768+0 records out
33554432 bytes transferred in 20 secs (1677721 bytes/sec)
</pre>

<p>
Ahora el fichero est&aacute; en su sitio y debe a&ntilde;adirlo a
<i>/etc/fstab</i>.  Aqu&iacute; tiene una l&iacute;nea de ejemplo de
c&oacute;mo arrancar con este dispositivo como <i>swap</i>.

<pre>
$ <b>cat /etc/fstab</b>
/dev/wd0a / ffs rw 1 1
/dev/vnd0c none swap sw 0 0 
</pre>

<p>
En este punto su m&aacute;quina debe ser reiniciada para que los cambios
en el n&uacute;cleo hagan efecto.  A continuaci&oacute;n deber&aacute;
configurar el dispositivo como memoria de <i>swap</i>.  Para ello
usar&aacute;
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&amp;sektion=8">vnconfig(8)</a>.

<pre>
$ <b>sudo vnconfig -c -v vnd0 /var/swap</b>
vnd0: 33554432 bytes on /var/swap
</pre>

<p>
El &uacute;ltimo paso es activar ese dispositivo como memoria de
<i>swap</i>.  Lo haremos como en los ejemplos anteriores, usando
swapctl(8).  Despu&eacute;s comprobaremos si ha sido correctamente
a&ntilde;adido a nuestra lista de dispositivos de <i>swap</i>.

<pre>
$ <b>sudo swapctl -a /dev/vnd0c</b>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
/dev/vnd0c       65536        0    65536     0%    0
Total           131056        8   131048     0%
</pre>


<a name="SoftUpdates"></a>
<a name="14.5"></a>
<h2>14.5 - Soft Updates</h2>

<p>
Durante los &uacute;ltimos a&ntilde;os, Kirk McKusick ha estado
trabajando en algo llamado &quot;Soft Updates&quot;.  Esto se basa en la
idea propuesta por Greg Ganger y Yale Patt de imponer un orden parcial
sobre las operaciones en la memoria intermedia para permitir que los
requerimientos de escritura sincr&oacute;nica de entradas de directorio
sean eliminadas del c&oacute;digo FFS.  En resumen, un gran incremento
en el rendimiento de la escritura en disco.

<p>
Como &quot;Soft Updates&quot; todav&iacute;a se encuentra en fase de
desarrollo, es necesario ejecutar
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)</a>
despu&eacute;s de una interrupci&oacute;n de la m&aacute;quina sin una
secuencia de apagado limpia, pero esto es algo que se solucionar&aacute;
en las pr&oacute;ximas versiones.

<p>
Puede encontrar m&aacute;s detalles sobre &quot;Soft Updates&quot; en la
documentaci&oacute;n de
<a href="http://www.ece.cmu.edu/~ganger/papers/CSE-TR-254-95/">Ganger y
Patt</a> y de
<a href="http://www.mckusick.com/softdep/index.html">McKusick</a>.

<p>
Para activar <i>Softupdates</i>, el n&uacute;cleo debe estar compilado
con

<p>
<b>option FFS_SOFTUPDATES</b>

<p>
Esta opci&oacute;n est&aacute; incluida en el n&uacute;cleo GENERIC.

<p>
La activaci&oacute;n de <i>Soft Updates</i> se debe realizar con una
opci&oacute;n de tiempo en el montaje.  Cuando se monta una
partici&oacute;n con la utilidad
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>,
se puede indicar que se active <i>soft updates</i> en esa
partici&oacute;n.  La siguiente muestra es de una entrada en
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a></i> 
para una partici&oacute;n <i>sd0a</i> que queremos que se monte con
<i>soft updates</i> activado.

<pre>
/dev/sd0a / ffs rw,softdep 1 1
</pre>

<p>
Nota para los usuarios de sparc:  no se debe activar <i>soft updates</i>
en las m&aacute;quinas sun4 o sun4c.  Estas arquitecturas s&oacute;lo
tienen soporte para una cantidad de memoria del n&uacute;cleo muy
limitada, y no pueden usar esta funcionalidad.  Las m&aacute;quinas
sun4m no tienen esta limitaci&oacute;n y s&iacute; pueden usarla.

<a name="D0P3"></a>
<a name="14.6"></a>
<h2>14.6 -  Cuando arranco el sistema despu&eacute;s de
instalaci&oacute;n de OpenBSD/i386, se para en &quot;Using Drive: 0
Partition: 3&quot; - espec&iacute;fico de i386.</h2>

<p>
En realidad esto no es un mensaje de error, sino un aviso del cargador
de arranque del MBR en el que indica desde qu&eacute; dispositivo y
qu&eacute; partici&oacute;n va a arrancar.  El problema es que el
proceso de arranque se para aqu&iacute;.

<p>
Hay dos motivos por los que esto suele ocurrir:  una incompatibilidad
entre la BIOS y el MBR de OpenBSD, o un problema con la geometr&iacute;a
del dispositivo.  Un ejemplo del problema con la geometr&iacute;a del
dispositivo ser&iacute;a si traslad&aacute;ramos un dispositivo desde
una m&aacute;quina a otra, o si actualiz&aacute;ramos una BIOS o
cambi&aacute;ramos su configuraci&oacute;n;  aunque esto tambi&eacute;n
puede ocurrir por motivos desconocidos durante la instalaci&oacute;n.

<p>
<b>Nota:</b>  A partir de la versi&oacute;n 3.1 de OpenBSD, el problema
de compatibilidad de la BIOS deber&iacute;a estar resuelto en casi todos
los sistemas; sin embargo, a&uacute;n podr&iacute;a surgir un problema
con la geometr&iacute;a del controlador del disco, por lo que es posible
que el sistema se colgase despu&eacute;s de este mensaje.

<p>
Para solucionar el problema de compatibilidad con la BIOS, se debe
sustituir el cargador de arranque con uno que sea compatible con el
sistema.  Por suerte, los cargadores de arranque son f&aacute;ciles de
tratar.

<h3>Instalaci&oacute;n del cargador de arranque BootEasy:</h3>

<p>
Para ello es necesario arrancar antes el sistema.  Como no se
podr&aacute; arrancar directamente desde el disco duro, tendremos que
usar un disquete o un CD-ROM de arranque para iniciar el proceso de
arranque.  Cuando el sistema muestre el punto de pedido
'<b>boot&gt;</b>', redirecci&oacute;nelo para que arranque desde el
disco duro:

<pre>
reading boot.......
probing pc0 com0 com1 pci mem [639k 79m a20=on]
disk hd0 fd0
&gt;&gt; OpenBSD BOOT 1.28
boot&gt; <b>boot hd0a:/bsd</b>
</pre>

<p>
Esta orden redirecciona el proceso de arranque al fichero <i>/bsd</i> en
la partici&oacute;n 'a' del primer disco duro, permitiendo de este modo
el arranque.

<p>
<!-- XXXversion -->
Una vez que el sistema haya arrancado, tendr&aacute; que instalar el
cargador de arranque BootEasy.  El archivo se puede encontrar en el
CD-ROM y en las r&eacute;plicas de FTP, en el directorio
<tt>3.3/tools/booteasy/Boot.bin</tt>, y se puede instalar mediante la
siguiente orden de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a> :

<pre>
<!-- XXXversion -->
# <b>fdisk -i -f /mnt/3.3/tools/booteasy/Boot.bin wd0</b>
</pre>

<p>
<!-- XXXversion -->
Se asume que tiene un CD 3.3 montado en <i>/mnt</i>, y que est&aacute;
usando un dispositivo IDE.  Dependiendo de la ubicaci&oacute;n de
<i>Boot.bin</i> y del tipo de disco duro que tenga (un dispositivo SCSI
suele ser 'sd0'), tendr&aacute; que cambiar esta l&iacute;nea de
&oacute;rdenes.  <b>Nota: &iexcl;NO haga esto si su partici&oacute;n
OpenBSD no ocupa el disco por completo!</b>  Al iniciar el MBR de este
modo se crea una partici&oacute;n de OpenBSD que se expande por todo el
disco y que elimina cualquier otra partici&oacute;n, lo que no suele ser
una buena idea.

<p>
BootEasy tiene otra funcionalidad que puede ser de inter&eacute;s aun
cuando no se tengan problemas con el cargador predeterminado:  es capaz
de seleccionar una partici&oacute;n de arranque durante el inicio.  Para
ello pregunta por la partici&oacute;n desde la que se desea arrancar, y
si no introduce una arranca desde la partici&oacute;n activa.  Esto
puede ser de gran utilidad si se tienen varios sistemas operativos en un
mismo disco.  La instalaci&oacute;n de BootEasy para esto se lleva a
cabo desde MS-DOS con el programa <i>BOOTINST.EXE</i>, que se puede
encontrar en el mismo directorio que BootEasy en el CD-ROM y en los
servidores de FTP.

<h3>Instalci&oacute;n del cargador de arranque de MS-DOS:</h3>

<p>
Inicie desde un disco de arranque de Windows 9x &oacute; DOS v6 que
tengan <i>FDISK.EXE</i> instalado.  Cuando el sistema muestre el punto
de pedido de MS-DOS, introduzca lo siguiente:

<pre>
A:\&gt;<b>fdisk /mbr</b>
</pre>

<p>
Deber&iacute;a mostrar un breve acceso al disco, e inmediatamente
despu&eacute;s un punto de pedido de &oacute;rdenes, sin ning&uacute;n
tipo de mensaje.  &quot;<i>Bad command or file name</i>&quot; significa
que el disco que ha usado no tiene <i>FDISK.EXE</i>.  Si lo ha hecho
bien, el mensaje &quot;<i>Using ...</i>&quot; ser&aacute; eliminado, ya
que se habr&aacute; sustituido el c&oacute;digo que produce este
mensaje.  Si ten&iacute;a alg&uacute;n problema de compatibilidad con la
BIOS, &eacute;ste habr&aacute; desaparecido; reinicie y su
instalaci&oacute;n de OpenBSD deber&iacute;a ser correcta ahora.

<p>
Seg&uacute;n algunos informes, esto tambi&eacute;n deber&iacute;a
funcionar con FreeDOS.

<h3>El cargador de arranque OS-BS:</h3>

<p>
Otro cargador de arranque, OS-BS, tambi&eacute;n viene incluido en los
CD-ROM de OpenBSD y en los servidores de FTP, en el directorio
<i>2.9/tools/osbs135.exe</i>.  Las p&aacute;ginas de OS-BSD se
encuentran en <a href="http://www.prz.tu-berlin.de/~wolf/os-bs.html">
http://www.prz.tu-berlin.de/~wolf/os-bs.html</a>.

<h3>LILO:</h3>

<p>
El programa LILO para Linux tambi&eacute;n se puede usar.  M&aacute;s
detalles en
<a href="ftp://ftp.openbsd.org/pub/OpenBSD/3.3/i386/INSTALL.linux">
INSTALL.linux</a>

<h3>C&oacute;mo evitar el problema de compatibilidad de la BIOS:</h3>

<p>
Hay pocas m&aacute;quinas que tengan un problema de compatibilidad con
la BIOS, pero si &eacute;ste es su caso, es bastante f&aacute;cil de
evitar.  El &uacute;nico momento en el que el cargador de OpenBSD se
instala en el sistema durante una instalaci&oacute;n t&iacute;pica es
cuando se responde 'Y' a la pregunta 'Use entire disk for OpenBSD'
(&laquo;&iquest;usar todo el disco?&raquo;).  Si la respuesta es 'N' y
se procede a crear las particiones del disco para OpenBSD de forma
manual, no se substituir&aacute; el cargador de arranque a menos que se
usen las &oacute;rdenes <code>reinit</code> o <code>update</code> de
<i>fdisk</i>.  Por supuesto, se asume que el dispositivo HA INICIADO con
alg&uacute;n tipo de cargador de arranque;  si no es as&iacute; (bien
porque sea nuevo, est&eacute; en blanco o porque haya sido sacado de
otra plataforma), tendr&aacute; que instalar uno antes de que arranque
el sistema.

<h3>C&oacute;mo solucionar un problema con la geometr&iacute;a del
disco:</h3>

<p>
La soluci&oacute;n ideal es la de evitar este problema manteniendo la
misma geometr&iacute;a en el dispositivo, no cambi&aacute;ndola;  sin
embargo, algunas veces no es posible evitarlo, como cuando se traslada
un dispositivo de gran capacidad desde una m&aacute;quina ya vieja que
no tenga soporte para la geometr&iacute;a LBA a una m&aacute;quina nueva
que insista en usar LBA.

<p>
Inicie la m&aacute;quina usando un disco o CD-ROM de arranque tal y como
se ha indicado anteriormente.  Ingrese como superusuario y ejecute las
siguientes &oacute;rdenes:

<pre>
# cp /usr/mdec/boot /boot
# /usr/mdec/installboot -v /boot /usr/mdec/biosboot wd0
</pre>

<p>
Reinicie y el sistema deber&iacute;a funcionar correctamente.

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=installboot&amp;sektion=8&amp;arch=i386">installboot(8)</a>
instala y configura la partici&oacute;n del cargador de arranque,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8&amp;arch=i386">biosboot(8)</a>,
que carga
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">boot(8)</a>.  
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">boot(8)</a> 
es el m&oacute;dulo que carga el n&uacute;cleo del sistema en la RAM.
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8&amp;arch=i386">biosboot(8)</a>
tiene una tabla que apunta a la ubicaci&oacute;n f&iacute;sica (de
acuerdo con la BIOS del sistema) de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">boot(8)</a>.
Si cambia algo que a su vez cambie la percepci&oacute;n que tiene la
BIOS de la ubicaci&oacute;n de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">boot(8)</a>, 
tendr&aacute; que volver a ejecutar
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=installboot&amp;sektion=8&amp;arch=i386">installboot(8)</a>
como antes para reiniciar la tabla que apunta a
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">boot(8)</a>.

<p>
V&eacute;ase <a href="#InstBoot">la secci&oacute;n 14.8</a> para
m&aacute;s informaci&oacute;n.

<a name="LargeDrive"></a>
<a name="14.7"></a>
<h2>14.7 - &iquest;Qu&eacute; problemas puede haber en OpenBSD con
dispositivos de gran capacidad?</h2>

<p>
<!-- XXXexpires - paragraph need rewriting when 3.1 becomes unsupported -->
OpenBSD tiene soporte para sistemas de archivos de tama&ntilde;os mucho
mayores que cualquier de los discos duros que existen en la actualidad o
incluso de los que puedan aparecer en breve;  sin embargo, existen
limitaciones en algunas interfaces que son de menor tama&ntilde;o que el
m&aacute;ximo te&oacute;rico de OpenBSD.  En el caso de dispositivos
IDE, el l&iacute;mite es de 128GB, que es el mismo l&iacute;mite que
tiene actualmente la interfaz ATA.  N&oacute;tese que en la
pr&oacute;xima generaci&oacute;n de dispositivos ATA, aquellos con
capacidad mayor de 128G (1G=2^30, no 1.000.000.000, aunque los
fabricantes de dispositivos lo llamar&aacute;n 137G) no tienen soporte
en OpenBSD 3.1 ni en versiones anteriores.

<p>
Desafortunadamente, la capacidad absoluta del sistema operativo no se
encontrar&aacute; disponible hasta DESPU&Eacute;S de que el sistema
operativo haya sido cargado en la memoria y el proceso de arranque haya
introducido sus propios l&iacute;mites.  El proceso de arranuqe tiene
que utilizar (y por lo tanto est&aacute; limitado por) la ROM de
arranque del sistema.  Los cargadores de arranque de OpenBSD para i386
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8&amp;arch=i386">biosboot(8)</a> y
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">boot(8)</a>)
tambi&eacute;n tienen sus propias limitaciones internas de 8G, heredadas
del l&iacute;mite de una BIOS antigua.

<p>
Por este motivo, todo el fichero <i>/bsd</i> (el n&uacute;cleo del
sistema) se debe ubicar dentro del &aacute;rea direccionable de la ROM
de arranque en el disco, o dentro de los primeros 8G del disco,
cualquiera que sea m&aacute;s peque&ntilde;a.  Esto significa que en
algunos equipos i386 m&aacute;s antiguos, la partici&oacute;n
<i>root</i> debe encontrarse dentro del l&iacute;mite de los primeros
504M, pero en la mayor&iacute;a de equipos nuevos se puede encontrar en
cualquier parte dentro de los primeros 8G.

<p>
N&oacute;tese que es posible instalar un dispositivo de 40GB en un 486
antiguo y cargar OpenBSD como una sola partici&oacute;n gigante, y por
ello creer que la regla anterior ha sido violada con &eacute;xito.  Sin
embargo, puede volver para vengarse en un modo horrible:

<ul>
<li>Instala el sistema en la partici&oacute;n <i>/</i> de 40G.
Funciona, ya que el sistema operativo base y sus ficheros, incluido
<i>/bsd</i>, se encuentran dentro de los primeros 504M.
<li>Utiliza el sistema hasta que acaba con m&aacute;s de 504M en
ficheros.
<li>Lo actualiza, compila su propio n&uacute;cleo, cualquier otra cosa,
y copia su nuevo <i>/bsd</i> sobre el antiguo.
<li>Reinicia el sistema.
<li>Le aparece un mensaje tipo &quot;bad magic&quot;.
</ul>

<p>
&iquest;Por qu&eacute;?  Porque cuando copi&oacute; &laquo;sobre&raquo;
el nuevo fichero <i>/bsd</i>, no sobreescribi&oacute; el antiguo, sino
que se reubic&oacute; en un nuevo espacio del disco, probablemente fuera
del rango de los 504M para los que tiene soporte la BIOS.  El cargador
de arranque no pudo localizar <i>/bsd</i> y el sistema se colg&oacute;.

<p>
Para que OpenBSD arranque, <i>/bsd</i> debe encontrarse dentro del rango
de la ROM.  Para mayor seguridad, hay una regla muy simple:

<p>
<b>Toda la partici&oacute;n <i>root</i> debe estar dentro del espacio
direccionable por la BIOS (o ROM de arranque) de la m&aacute;quina o
dentro de los primeros 8G, cualquiera que sea el m&aacute;s
peque&ntilde;o de los dos.</b>
En este momento no hay forma de evitar esto, <i>es necesario</i> seguir
esta regla.

<p>
&Eacute;sta es otra buena raz&oacute;n para
<a href="faq4.html#SpaceNeeded">dividir el disco duro en
particiones</a>, en lugar de usar una &uacute;nica partici&oacute;n
grande.

<a name="InstBoot"></a>
<a name="14.8"></a>
<h2>14.8 - Instalaci&oacute;n de bloques de arranque (espec&iacute;fico
de i386)</h2>

<p>
Las versiones m&aacute;s antiguas de MS-DOS s&oacute;lo pod&iacute;an
reconocer geomtr&iacute;as de disco de 1024 cilindros o menos.  Ya que
casi pr&aacute;cticamente todos los discos modernos tienen m&aacute;s de
1024 cilindros, la mayor&iacute;a de chips de BIOS SCSI (que vienen
integrados en la tarjeta controladora SCSI) y de BIOS IDE (que son parte
del resto de la BIOS para PCs) disponen de una opci&oacute;n (algunas
veces preactivada) para &laquo;traducir&raquo; la geometr&iacute;a real
del disco en algo que est&eacute; dentro de los l&iacute;mites de la
capacidad de MS-DOS.  Sin embargo, no todos los chips de BIOS
&laquo;traducen&raquo; la geometr&iacute;a del mismo modo.  Si cambia su
BIOS (instalando una nueva placa base o a&ntilde;adiendo una nueva
controladora SCSI) y la nueva usa una &laquo;traducci&oacute;n&raquo; de
la geometr&iacute;a diferente, no podr&aacute; cargar la segunda fase
del gestor de arranque (y por lo tanto no podr&aacute; cargar el
n&uacute;cleo).  Esto se debe a que la primera fase del gestor de
arranque contiene una lista de bloques que comprende <i>/boot</i> en
t&eacute;rminos de la geometr&iacute;a &laquo;traducida&raquo; original.
Si est&aacute; usando discos IDE y realiza cambios en la
configuraci&oacute;n de su BIOS, tambi&eacute;n puede cambiar sin
saberlo su traducci&oacute;n (la mayor&iacute;a de BIOS IDE ofrecen 3
traducciones diferentes).  Para que su bloque de arranque pueda iniciar
con normalidad, ponga un disquete de arranque (o use un CDROM con
capacidad arranque), y en el punto <kbd>boot&gt;</kbd> escriba <kbd>b
hd0a:/bsd</kbd> para forzar el arranque desde el primer disco duro (y no
desde el disquete).  Su m&aacute;quina deber&iacute;a iniciar sin
ning&uacute;n problema.  Ahora debe actualizar la primera fase del
gestor de arranque para poder ver la nueva geometr&iacute;a (y
reescribir el bloque de arranque de acuerdo con ella).<br>
En el ejemplo se asume que su disco de arranque es sd0 (SCSI, pero si
fuera IDE ser&iacute;a wd0, etc... ):

<pre>
# <b>cd /usr/mdec; ./installboot /boot biosboot sd0</b>
</pre>

<p>
Si installboot protesta porque es incapaz de leer la geometr&iacute;a de
la BIOS, puede invocar la orden 'machine diskinfo' (o su forma
abreviada, 'ma di') desde el punto <kbd>boot&gt;</kbd>, para ver la
informaci&oacute;n que necesite.  Rellene con los valores
&quot;heads&quot; y &quot;secs&quot; los indicadores <code>-h</code> y
<code>-s</code> de installboot respectivamente, para que la orden
modificada de installboot quede como sigue:

<pre>
#<b> cd /usr/mdec; ./installboot -h &lt;heads&gt; -s &lt;secs&gt; /boot biosboot sd0</b>
</pre>

<p>
Si se requiriera una versi&oacute;n de los bloques de arranque,
tendr&iacute;a que compilarlos usted mismo.

<pre>
# <b>cd /sys/arch/i386/stand/</b>
# <b>make &amp;&amp; make install </b>
# <b>cd /usr/mdec; cp ./boot /boot</b>
# <b>./installboot /boot biosboot sd0</b> (o cualquier otro
dispositivo que sea su disco)
</pre>

<a name="Backup"></a>
<a name="14.9"></a>
<h2>14.9 - Prepararaci&oacute;n para el desastre: hacer copias de
seguridad (respaldo) y restaurar desde la cinta</h2>

<p>
<h3>Introducci&oacute;n:</h3>

<p>
Si su instalaci&oacute;n de OpenBSD va a ser lo que se llama un servidor
de producci&oacute;n, es aconsejable disponer de alg&uacute;n tipo de
respaldo por si acaso uno de sus discos fijos fallara.

<p>
Esta informaci&oacute;n le ayudar&aacute; a usar las utilidades
t&iacute;picas
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>/<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>
disponibles con OpenBSD.  Existe una utilidad para copias de seguridad
m&aacute;s avanzada, llamada &quot;Amanda&quot;, con la que se pueden
hacer copias de seguridad de m&uacute;ltiples servidores en una sola
cinta.  En la mayor&iacute;a de entornos,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>/<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>
es suficiente.  Sin embargo, si necesita hacer copias de seguridad de
m&uacute;ltiples m&aacute;quinas en una sola cinta, vale la pena que
conozca Amanda.

<p>
Los dispositivos de ejemplo en este documento son para una
configuraci&oacute;n que usa discos y cintas SCSI.  En un entorno de
producci&oacute;n, se recomiendan los discos SCSI sobre los IDE debido
al modo que gestionan los bloques err&oacute;neos, lo que no significa
que esta informaci&oacute;n sea in&uacute;til si est&aacute; usando un
disco IDE u otro tipo de cinta;  en este caso los nombres de sus
dispositivos ser&aacute;n ligeramente diferentes.  Por ejemplo, sd0a
ser&iacute;a wd0a en un sistema basado en IDE.

<p>
<h3>Hacer copias en cinta</h3>

<p>
Para hacer copias en una cinta es necesario saber de antemano
d&oacute;nde est&aacute;n montados los sistemas de archivos.  Esto se
puede determinar usando la orden
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>
desde el punto de pedido del int&eacute;rprete de &oacute;rdenes
(<i>shell prompt</i>).  Deber&iacute;a obtener una salida similar a
&eacute;sta:

<pre>
# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0h on /usr type ffs (local)  
</pre>

<p>
En este ejemplo, el sistema de archivos ra&iacute;z (/) reside
f&iacute;sicamente en sd0a, lo que indica que es la partici&oacute;n a
del disco fijo SCSI 0.  El sistema de archivos /usr reside en sd0h, lo
que indica que es la partici&oacute;n h del disco fijo SCSI 0.

<p>
Otro ejemplo de una tabla de puntos de montaje m&aacute;s avanzado
ser&iacute;a:

<pre>
# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0d on /var type ffs (local)
/dev/sd0e on /home type ffs (local)
/dev/sd0h on /usr type ffs (local)  
</pre>

<p>
En este ejemplo, el sistema de archivos ra&iacute;z reside
f&iacute;sicamente en sd0a, el sistema de archivos <i>/var</i> reside en
sd0d, el sistema de archivos <i>/home</i> en sd0e y finalmente,
<i>/usr</i> en sd0h.

<p>
Para hacer copias de seguridad de su m&aacute;quina necesitar&aacute;
pasar informaci&oacute;n a dump sobre el nombre de cada partici&oacute;n
del disco fijo.  Aqu&iacute; tiene un ejemplo de las &oacute;rdenes que
se necesitan para hacer copias de la primera tabla de montaje (la
m&aacute;s simple):

<pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h</b>
# <b>mt -f /dev/rst0 rewind</b>
</pre>

<p>
Para la segunda tabla (la m&aacute;s avanzada), usar&iacute;a algo
parecido a esto:

<pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h</b>
# <b>mt -f /dev/rst0 rewind</b>
</pre>

<p>
Puede revisar la p&aacute;gina del manual de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">
dump(8)</a> para averiguar qu&eacute; es lo que hace exactamente cada
uno de los par&aacute;metros en la l&iacute;nea de &oacute;rdenes.
Aqu&iacute; tiene una breve descripci&oacute;n de los par&aacute;metros
usados:

<ul>
<li><b>0</b> - Lleva a cabo un nivel 0 de dump, lo coge todo.
<li><b>a</b> - Intenta determinar autom&aacute;ticamente el
tama&ntilde;o de la cinta.
<li><b>u</b> - Actualiza el fichero <i>/etc/dumpdates</i> para indicar
cu&aacute;ndo se realiz&oacute; la &uacute;ltima copia de seguridad.
<li><b>f</b> - Indica qu&eacute; dispositivo de cinta se usar&aacute;
(en este caso <i>/dev/nrst0</i>).
</ul>

<p>
La &uacute;ltima parte indica la partici&oacute;n de la que se
har&aacute; la copia de seguridad (<i>/dev/rsd0a</i>, etc... ).

<p>
La orden <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mt&amp;sektion=1">mt(1)</a>
se usa al final para rebobinar el controlador.  Revise la p&aacute;gina
del manual de mt para ver m&aacute;s opciones (como &quot;eject&quot;).

<p>
Si no est&aacute; seguro de cu&aacute;l es el nombre de su dispositivo
de cinta, use dmesg para localizarlo.  Un ejemplo de entrada del
dispositivo de cinta en dmesg ser&aacute; parecido al siguiente:

<pre>
st0 at scsibus0 targ 5 lun 0: &lt;ARCHIVE, Python 28388-XXX, 5.28&gt;
</pre>

<p>
Es posible que haya notado que al realizar la copia de seguridad, se
accede al controlador de la cinta con el nombre del dispositivo
&quot;nrst0&quot; en lugar de &quot;st0&quot;, que es el nombre que se
ve en dmesg.  Cuando se accede a st0 como nrst0 se est&aacute;
accediendo al mismo controlador f&iacute;sico de la cinta, pero
indicando al controlador que no debe rebobinar al final del proceso y
que acceda al dispositivo en modo virgen.  Para hacer copias de
seguridad de m&uacute;ltiples sistemas de archivos en una sola cinta,
aseg&uacute;rese de usar el dispositivo sin rebobinar;  si usa un
dispositivo de rebobinado (rst0) para hacer copias de seguridad de
m&uacute;ltiples sistemas de archivos, acabar&aacute; anulando el
sistema de archivos anterior cuando el pr&oacute;ximo dump intente
grabar en la cinta.  Puede encontrar una descripci&oacute;n m&aacute;s
elaborada sobre los distintos dispositivos de control de cinta en la
p&aacute;gina del manual de dump.

<p>
Si quiere escribir un peque&ntilde;o gui&oacute;n (<i>script</i>), puede
hacerlo como el siguiente:

<pre>
echo &quot;  Empezando Copia de Seguridad Completa...&quot;
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h
echo
echo -n &quot;  Rebobinando el Dispositivo, por favor espere...&quot;
mt -f /dev/rst0 rewind
echo &quot;Fin.&quot;
echo                      
</pre>

<p>
Si desea programar las copias de seguridad para que se hagan por la
noche o a cualquier otra hora, puede usar
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cron&amp;sektion=8">
cron(8)</a> para que lance el gui&oacute;n de forma autom&aacute;tica.

<p>
Tambi&eacute;n puede serle de ayuda documentar (en un trozo de papel) el
tama&ntilde;o necesario para cada sistema de archivos.  Puede usar la
orden <kbd>df -h</kbd> para determinar cu&aacute;nto espacio est&aacute;
usando cada partici&oacute;n.  Esto le ser&aacute; &uacute;til cuando el
dispositivo falle y necesite recrear su partici&oacute;n en el nuevo
dispositivo.

<p>
Restaurar sus datos tambi&eacute;n le ayudar&aacute; a reducir la
fragmentaci&oacute;n.  Para asegurarse de que tiene todos los ficheros,
la mejor forma de hacer copias de seguridad es reiniciando el sistema en
modo monousuario.  Los sistemas de archivos no necesitan estar montados
para hacer las copias.  Despu&eacute;s de reiniciar no se olvide de
montar la partici&oacute;n ra&iacute;z (/) con permisos de escritura (r)
y lectura (w), o dump fallar&aacute; cuando intente grabar los
&quot;dumpdates&quot;.  Para iniciar en modo monousuario haga lo
siguiente desde el punto de arranque:

<pre>
boot&gt; bsd -s
</pre>

<p>
<h3>Ver el contenido de una copia en cinta:</h3>

<p>
Despu&eacute;s de que haya hecho las correspondientes copias de
seguridad por primera vez, es una buena idea que pruebe su cinta y que
se asegure de que los datos en ella sean los que Vd. esperaba que
fueran.

<p>
Puede usar el siguiente ejemplo para revisar un cat&aacute;logo de
ficheros en una cinta:

<pre>
# <b>/sbin/restore -tvs 1 -f /dev/rst0</b>
</pre>

<p>
Esto har&aacute; que se muestre una lista con los ficheros existentes en
la primera partici&oacute;n de la cinta.  De acuerdo con los ejemplos
anteriores, 1 ser&iacute;a su sistema de archivos ra&iacute;z
(<i><b>/</b></i>).

<p>
Para poder ver el contenido de la segunda partici&oacute;n de la cinta y
enviar la salida a un fichero, use una orden como la siguiente:

<pre>
# <b>/sbin/restore -tvs 2 -f /dev/rst0 > /home/me/list.txt</b>
</pre>

<p>
Si tiene una tabla de particiones como la simple de ejemplos anteriores,
2 ser&iacute;a <i>/usr</i>;  si la tabla es como la m&aacute;s avanzada,
entonces 2 podr&iacute;a ser <i>/var</i> u otro sistema de archivos.  El
n&uacute;mero de secuencia coincide con el orden en el que se graben los
sistemas de archivos en la cinta.

<p>
<h3>Restaurar desde la cinta:</h3>

<p>
El ejemplo que ver&aacute; m&aacute;s adelante podr&iacute;a ser
&uacute;til si su disco fijo fallara totalmente.  En caso de que quiera
restaurar sus sistemas de archivos desde un &uacute;nico fichero de la
cinta, revise la p&aacute;gina del manual de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>
y preste atenci&oacute;n a las instrucciones sobre el modo interactivo.

<p>
Si se ha preparado bien, substituir un disco y restaurar sus datos desde
la cinta puede ser un proceso muy r&aacute;pido.  El disquete de
instalaci&oacute;n/arranque est&aacute;ndar de OpenBSD contiene la
utilidad que se requiere para restaurar, as&iacute; como los binarios
que se requieren para particionar y hacer que pueda arrancar desde su
dispositivo.  En la mayor&iacute;a de los casos, este disquete y su
cinta con la copia de seguridad m&aacute;s reciente ser&aacute; todo lo
que necesite para restaurar el sistema.

<p>
Despu&eacute;s de substituir f&iacute;sicamente el dispositivo de disco
err&oacute;neo, los pasos b&aacute;sicos para restaurar sus datos son
los siguientes:

<ul>
<li>
Inicie desde el disquete de instalaci&oacute;n/arranque de OpenBSD.
Desde el men&uacute; de selecci&oacute;n, escoja Shell.
Prot&eacute;jalo contra la escritura e introduzca su cinta de la copia
de seguridad m&aacute;s reciente en el dispositivo.

<li>
Use la orden
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
para crear una partici&oacute;n primaria de OpenBSD en el nuevo
dispostivo.  Por ejemplo:

<pre>
# <b>fdisk -e sd0</b>
</pre>

<p>
Revise la <a href="#fdisk">secci&oacute;n 14.2</a> sobre fdisk para
m&aacute;s informaci&oacute;n.

<li>
Use la orden 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
para recrear su tabla de particiones de OpenBSD dentro de la
partici&oacute;n primaria de OpenBSD que acaba de crear con fdisk.  Por
ejemplo:

<pre>
# <b>disklabel -E sd0</b>
</pre>

<p>
No se olvide de la partici&oacute;n de <i>swap</i>.  Revise la
<a href="#disklabel">secci&oacute;n 14.1</a> sobre disklabel para
m&aacute;s informaci&oacute;n.

<li>
Use la orden 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&amp;sektion=8">newfs(8)</a>
en cada una de las particiones que acaba de crear, para construir un
sistema de archivos limpio en cada una de ellas.  Por ejemplo:

<pre>
# <b>newfs /dev/rsd0a</b>
# <b>newfs /dev/rsd0h</b>
</pre>

<li>
Monte su reci&eacute;n preparado sistema de archivos ra&iacute;z (/) en
/mnt.  Por ejemplo:

<pre>
# <b>mount /dev/sd0a /mnt</b>
</pre>

<li>
Cambie a ese sistema de archivos ra&iacute;z que acaba de montar y
comience con el proceso de restauraci&oacute;n.  Por ejemplo:

<pre>
# <b>cd /mnt</b>
# <b>restore -rs 1 -f /dev/rst0</b>
</pre>

<li>
Como querr&aacute; poder arrancar desde este nuevo disco, haga lo
siguiente para grabar un nuevo MBR en su dispositivo:

<pre>
# <b>fdisk -i sd0</b>
</pre>

<li>
Adem&aacute;s de grabar un nuevo MBR en el controlador,
necesitar&aacute; instalar bloques de arranque para iniciar desde
&eacute;l.  A continuaci&oacute;n puede ver un breve ejemplo:

<pre>
# <b>cp /usr/mdec/boot /mnt/boot</b>
# <b>/usr/mdec/installboot -v /mnt/boot /usr/mdec/biosboot sd0</b>
</pre>

<li>
Su nuevo sistema de archivos ra&iacute;z en el disco fijo deber&iacute;a
estar lo suficientemente preparado como para que pueda iniciar desde
&eacute;l y continuar restaurando el resto de sus sistemas de archivos.
Como su sistema operativo todav&iacute;a no est&aacute; completo,
aseg&uacute;rese de iniciar la copia de seguridad en modo monousuario.
Desde el punto de pedido de la shell, ejecute las siguientes
&oacute;rdenes para desmontar y parar el sistema:

<pre>
# <b>umount /mnt</b>
# <b>halt</b>
</pre>

<li>
Elimine el disquete de instalaci&oacute;n/arranque del dispositivo y
reinicie el sistema.  Desde el punto de arranque de OpenBSD
<kbd>boot&gt;</kbd>, ejecute la siguiente orden:

<pre>
boot&gt; <b>bsd -s</b>
</pre>

<p>
La orden <kbd>bsd -s</kbd> har&aacute; que el n&uacute;cleo del sistema
inicie en modo monousuario, por lo que s&oacute;lo necesitar&aacute; el
sistema de archivos ra&iacute;z (<i><b>/</b></i>).

<li>
Asumiendo que ha llevado a cabo todos los pasos anteriores correctamente
y que no ha cometido ning&uacute;n error, deber&iacute;a acabar viendo
un punto en el que le pedir&aacute; que introduzca un camino para la
shell o que pulse la tecla <kbd>intro</kbd>.  Pulse
<kbd>&lt;intro&gt;</kbd> si va a usar sh.  A continuaci&oacute;n
tendr&aacute; que volver a montar el sistema de archivos ra&iacute;z en
modo de lectura (r) y escritura (w), al contrario que en modo de
s&oacute;lo lectura como hasta ahora.  Ejecute la siguiente orden:

<pre>
# <b>mount -u -w /</b>
</pre>

<li>
Una vez que lo haya vuelto a montar en modo de lectura y escritura,
puede continuar restaurando sus otros sistemas de archivos.  Por
ejemplo:

<pre>
(tabla de particiones simple)
# <b>mount /dev/sd0h /usr; cd /usr; restore -rs 2 -f /dev/rst0</b>

(tabla de particiones m&aacute;s avanzada)
# <b>mount /dev/sd0d /var; cd /var; restore -rs 2 -f /dev/rst0</b>
# <b>mount /dev/sd0e /home; cd /home; restore -rs 3 -f /dev/rst0</b>
# <b>mount /dev/sd0h /usr; cd /usr; restore -rs 4 -f /dev/rst0</b>
</pre>

<p>
Puede usar &quot;<kbd>restore rvsf</kbd>&quot; en lugar de usar
s&oacute;lo &quot;<kbd>rsf</kbd>&quot;, para ver lo nombres de los
objetos mientras los extrae de la copia de seguridad.

<li>
Por &uacute;ltimo, despu&eacute;s de que acabe de restaurar el resto de
sistemas de archivos al disco, reinicie en modo multiusuario.  Si todo
ha salido como lo ha planeado, su sistema volver&aacute; al estado en el
que se encontraba cuando realiz&oacute; la copia de seguridad, y
volver&aacute; a estar preparado para su uso.
</ul>

<a name="MountImage"></a>
<a name="14.10"></a>
<h2>14.10 - C&oacute;mo montar im&aacute;genes de disco en OpenBSD</h2>

<p>
Para montar una imagen de disco (im&aacute;genes ISO, im&aacute;genes de
disco creadas con ´dd´, etc.. ) en OpenBSD, debe configurar un
dispositivo
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnd&amp;sektion=4">
vnd(4)</a>.  Por ejemplo, si tuviera una imagen ISO ubicada en
<i>/tmp/ISO.image</i>, deber&iacute;a seguir los siguientes pasos para
montar la imagen:

<table border="0" width="650">
        <tr>
                <td nowrap bgcolor="#eeeeee">
<pre>
# <b>vnconfig svnd0 /tmp/ISO.image</b>
# <b>mount -t cd9660 /dev/svnd0c /mnt</b>
</pre>
                </td>
        </tr>
</table>

<p>
Note que, dado que esta imagen es una imagen de CD, debe especificar el
tipo <i>cd9660</i> al montarla.  Esto se debe aplicar a cualquier tipo;
v.g. deber&aacute; usar el tipo <i>ffs</i> cuando monte im&aacute;genes
de disco.

<p>
Para desmontar la imagen use la siguiente orden:

<table border="0" width="650">
        <tr>
                <td nowrap bgcolor="#eeeeee">
<pre>
# <b>umount /mnt</b>
# <b>vnconfig -u svnd0</b>
</pre>
                </td>
        </tr>
</table>

<p>
Para m&aacute;s informaci&oacute;n mire la p&aacute;gina del manual de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&amp;sektion=8">vnconfig(8)</a>

<a name="pciideErr"></a>
<a name="14.11"></a>
<h2>14.11 - &iexcl;Ayuda! &iexcl;da errores con PCIIDE!</h2>

<p>
PCI IDE DMA es inestable en muchas combinaciones de <i>hardware</i>.
Hasta hace poco tiempo, la mayor&iacute;a de sistemas operativos
&laquo;m&aacute;s conocidos&raquo; que aseguraban dar soporte para
transferencias DMA con dispositivos IDE, no ten&iacute;an esa
funcionalidad activada de modo predeterminado.

<p>
OpenBSD es agresivo, e intenta usar el modo DMA m&aacute;s alto que
pueda configurar.  Esto corrompe las transferencias de datos en algunas
configuraciones, por culpa de placas base con <i>chipsets</i>
err&oacute;neos, controladoras err&oacute;neas y, o, ruido en los
cables.  Por suerte, los modos Ultra-DMA protegen las transferencias de
datos con un CRC para detectar la corrupci&oacute;n.  Cuando el CRC
Ultra-DMA falla, OpenBSD muestra un mensaje de error e intenta repetir
la operaci&oacute;n.

<pre>
wd2a:  aborted command, interface CRC error reading fsbn 64 of 64-79 (wd2 bn 127; cn 0 tn 2 sn 1), retrying
</pre>

<p>
Despu&eacute;s de un par de fallos, OpenBSD prueba un modo Ultra-DMA
m&aacute;s bajo, pero m&aacute;s estable.  Si se llega al modo 0
Ultra-DMA, el controlador baja de grado hasta el modo PIO.

<p>
Si OpenBSD no consigue bajar el modo, o si el proceso bloquea la
m&aacute;quina, por favor env&iacute;e un
<a href="../../es/report.html">informe sobre el error</a>.

<a name= "IDEDMA"></a>
<h2>14.12 - Forcing DMA access for IDE disks</h2>

<p>
Con el c&oacute;digo PCI IDE es posible que no se reconozca alg&uacute;n
<i>chipset</i>.  Si esto nos ocurriera ver&iacute;amos un mensaje como
el siguiente:

<blockquote>
<pre>
pciide0: DMA, (unused)
</pre>
</blockquote>

<p>
Si vemos este mensaje podemos obligarle a usar el modo DMA usando 'flags
0x0001' en la entrada pciide del fichero de configuraci&oacute;n del
n&uacute;cleo, de forma que quedara algo como esto:

<blockquote>
<pre>
pciide* at pci ? dev ? function ? flags 0x0001
</pre>
</blockquote>

<p>
Despu&eacute;s de esto, el c&oacute;digo pciide intentar&aacute; usar el
modo DMA tanto si sabe c&oacute;mo hacerlo con nuestro <i>chipset</i>
como si no lo sabe.  Si esto funciona y el sistema logra pasar la
comprobaci&oacute;n de <code>fsck</code> e iniciar, lo m&aacute;s seguro
es que funcione para siempre.  Pero si no funcionara y el sistema se
colgara o hubiera un p&aacute;nico despu&eacute;s del arranque, entonces
no podemos usar el modo DMA (todav&iacute;a, hasta que se a&ntilde;ada
el soporte para ese <i>chipset</i>).  La documentaci&oacute;n para el
<i>chipset</i> de nuestra controladora PCI-IDE, si se tiene, es un buen
comienzo para a&ntilde;adir soporte para el <i>chipset</i> en el
c&oacute;digo PCI-IDE.  O se puede buscar en el sitio del fabricante en
Internet, o ponerse en contacto con &eacute;l.  Si la controladora
PCI-IDE es parte de la placa base, antes ser&aacute; necesario adivinar
qui&eacute;n es el fabricante del <i>chipset</i>.

<p>
Se sabe si el soporte de DMA est&aacute; activado cuando se ve este
mensaje durante el arranque:

<blockquote>
<pre>
cd0(pciide0:1:0): using PIO mode 3, DMA mode 1
</pre>
</blockquote>

<p>
Esto quiere decir que pciide0, canal 1, controladora 0 (que parece ser
un CD-ROM ATAPI) est&aacute; usando transferencias de datos DMA.

<a name="RAID"></a>
<h2>14.13 - Opciones de RAID para OpenBSD</h2>

<p>
RAID (<i>Redundant Array of Inexpensive Disks</i>) ofrece la oportunidad
de usar dispositivos m&uacute;ltiples para obtener un mejor rendimiento,
m&aacute;s capacidad, y/o redundancia de la que se puede obtener de un
&uacute;nico dispositivo.  Aunque una explicaci&oacute;n completa de los
beneficios y riesgos de RAID no entra en los objetivos de esta
secci&oacute;n, hay un par de puntos que son importantes aqu&iacute;:

<ul>
<li>RAID no tiene nada que ver con las copias de seguridad.
<li>Por s&iacute; solo, RAID no elimina el tiempo de ca&iacute;das.
</ul>

<p>
Si es la primera vez que lee informaci&oacute;n sobre RAID, tenga en
cuenta que esto no es un buen comienzo para explorar RAID.

<h3>Opciones de <i>software</i></h3>

<p>
OpenBSD incluye <i>RAIDframe</i>, una soluci&oacute;n de software de
RAID.  Puede encontrar documentaci&oacute;n sobre <i>RAIDframe</i> en
los siguientes sitios:

<ul>
<li><a href="faq11.html#raid">FAQ 11, RAID</a>
<li><a href="http://www.pdl.cmu.edu/RAIDframe/">Sitio principal de
RAIDframe</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;sektion=8">p&aacute;gina del manual de raidctl(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">p&aacute;gina del manual de raid(4)</a>
</ul>

<p>
<!-- XXXexpires - paragraph need rewriting when 3.1 becomes unsupported -->
Desde la versi&oacute;n 3.1 de OpenBSD, se puede replicar la
partici&oacute;n ra&iacute;z directamente usando la opci&oacute;n
&quot;<tt>Autoconfiguration</tt>&quot; de <i>RAIDframe</i>.

<h3>Opciones de <i>hardware</i></h3>

<p>
Muchas <a href="../../es/plat.html">plataformas</a> de OpenBSD incluyen
soporte para varios productos de <i>hardware</i> de RAID.  Las opciones
var&iacute;an seg&uacute;n la plataforma; mire en la p&aacute;gina de
soporte apropiada para cada una
<a href="../../es/plat.html">aqu&iacute;</a>.

<p>
Otra opci&oacute;n disponible para muchas plataformas es la de los
muchos productos que hacen que dispositivos m&uacute;ltiples
act&uacute;en como un &uacute;nico dispositivo IDE o SCSI, y
est&aacute;n conectados en un adaptador IDE o SCSI normal.  Estos
dispositivos pueden funcionar en casi cualquier plataforma de
<i>hardware</i> que disponga de soporte para SCSI o IDE.

<p>
Algunos de los fabricantes de estos productos:

<ul>
<li><a href="http://www.arcoide.com/">Arco</a>
<li><a href="http://www.maxtronic.com/">Maxtronic</a>
<li><a href="http://www.infortrend.com/">Infortrend</a>
</ul>

<p>
(Nota:  &eacute;stos son simplemente productos sobre los que los
usuarios de OpenBSD han informado que utilizan, no es ning&uacute;n tipo
de recomendaci&oacute;n ni es una lista exhaustiva).

<h3>No-opciones</h3>

<p>
Una pregunta formulada a menudo en las
<a href="../../es/mail.html">listas de correo</a> es si &laquo;hay
soporte para las controladoras de IDE RAID Promise o HighPoint&raquo;, y
la respuesta es &laquo;No&raquo;.  Estas tarjetas y <i>chips</i> no son
controladores de <i>hardware</i> de RAID reales, sino <i>software</i> de
RAID de arranque asistido por la BIOS.  Como OpenBSD ya dispone de
soporte para <i>software</i> de RAID independiente del <i>hardware</i>,
no hay un deseo entre los desarrolladores de OpenBSD la
implementaci&oacute;n de un soporte especial para estas tarjetas.

<p>
<font color="#0000e0">
<a href="index.html">[&Iacute;ndice de documentos]</a>
<a href="faq13.html">[Secci&oacute;n 13 - IPsec]</a>
</font>

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../images/back.gif" border="0" alt="[&iacute;ndice]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
Originally [OpenBSD: faq14.html,v 1.83 2003/05/01 01:47:41 nick Exp ]<br>
$Translation: faq14.html,v 1.44 2003/06/22 21:28:32 horacio Exp $<br>
$OpenBSD: faq14.html,v 1.43 2003/06/27 20:55:49 jufi Exp $
</small>
</body>
</html>
