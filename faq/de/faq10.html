<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>10 - Systemverwaltung</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name= "resource-type" content= "document">
<meta http-equiv="Content-Language" content="de">
<meta name= "description"   content= "Die OpenBSD-FAQ-Seite">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "Dieses Dokument ist Copyright 1998-2005 by OpenBSD.">
</head>

<body bgcolor= "#ffffff" text= "#000000">

<a href="../index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">    
</a>
<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ-Index]</a>
<a href= "faq9.html">[Zum Kapitel 9 - Zu OpenBSD migrieren]</a>
<a href= "faq11.html">[Zum Kapitel 11 - Leistungs-Tuning]</a>
</font>

<h1><font color="#e00000">10 - Systemverwaltung</font></h1>
<hr>

<p>
<h3>Inhaltsverzeichnis</h3>
<ul>
<li><a href="#wheel"         >10.1 - Wenn ich mich per su zu root machen
  will, wird mir gesagt, ich sei in der falschen Gruppe.</a>
<li><a href="#DupFS"         >10.2 - Wie kann ich ein Dateisystem
  duplizieren?</a>
<li><a href="#rc"            >10.3 - Wie starte ich Daemonen mit dem
  System? (Überblick über rc(8))</a>
<li><a href="#RelayingDenied">10.4 - Wieso erhalten Benutzer ein
  ,relaying access denied' wenn sie versuchen, von woanders her Mails
  über mein OpenBSD-System zu verschicken?</a>
<li><a href="#POP"           >10.5 - Ich habe POP installiert, erhalte
  aber Fehler, wenn ich versuche, meine Mails per POP abzuholen. Was
  kann ich tun?</a>
<li><a href="#SendmailDNS"   >10.6 - Warum ignoriert Sendmail die
  /etc/hosts-Datei?</a>
<li><a href="#HTTPS"         >10.7 - Einen sicheren HTTP-Server mit
  Hilfe von SSL(8) aufsetzen</a>
<li><a href="#vipw"          >10.8 - Ich habe mit vi(1) Änderungen an
  /etc/passwd gemacht, aber die Änderungen haben keinen Effekt.
  Warum?</a>
<li><a href="#AddDelUser"    >10.9 - Wie fügt man einen Benutzer hinzu?
  Oder wie löscht man einen?</a>
<li><a href="#FTPOnly"       >10.10 - Wie erzeugt man einen Nur-FTP-
  (ftp-only) -Account?</a>
<li><a href="#Quotas"        >10.11 - Wie man ,user disk quotas'
  einrichtet</a>
<li><a href="#Kerberos"      >10.12 - Wie man KerberosV-Client/Server
  einrichtet</a>
<li><a href="#AnonFTP"       >10.13 - Wie man einen Anonymous-FTP-Server
  einrichtet</a>
<li><a href="#ftpchroot"     >10.14 - In ftpd(8) Benutzer in ihre
  Heimatverzeichnisse einsperren.</a>
<li><a href="#Patches"       >10.15 - Patches in OpenBSD einfügen.</a>
<li><a href="#httpdchroot"   >10.16 - Wie geht das mit dem
  chroot()-Apache?</a>
<li><a href="#rootshell"     >10.17 - Ich mag die Standard-Shell von
  root nicht!</a>
<li><a href="#ksh"           >10.18 - Was kann ich noch mit ksh
  machen?</a>
</ul>

<hr>

<p>
<a name= "wheel"></a>
<h2>10.1 - Warum wird mir gesagt, dass ich in der falschen Gruppe wäre,
wenn ich ,su root' versuche?</h2>

<p>
Vorhandene Benutzer müssen per Hand zur Gruppe <kbd>,wheel'</kbd>
hinzugefügt werden.
Dies wird aus Sicherheitsgründen so gemacht und du solltest darauf
achten, wem du diesen Zugriff erlaubst. Unter OpenBSD ist es
Benutzern, die sich in der Gruppe <kbd>wheel</kbd> befinden, erlaubt,
das ,userland'-Programm
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=su&amp;sektion=1">su(1)</a>
zu benutzen, um root zu werden. Benutzer, die nicht in
<kbd>,wheel'</kbd> sind, können nicht su(1) nutzen.
Hier ist ein Beispiel für einen <kbd>/etc/group</kbd>-Eintrag, in dem
der Benutzer <strong>ericj</strong> in die Gruppe <kbd>,wheel'</kbd>
platziert wird.

<p>
Wenn du einen neuen Benutzer mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser&amp;sektion=8">adduser(8)</a>,
hinzufügst, kannst du sie in die Gruppe wheel platzieren, indem du bei
der Frage ,<tt>Invite <i>user</i> into other groups:</tt>" mit wheel
antwortest. Das wird sie in /etc/group einfügen, welche in etwa so
aussehen wird:

<blockquote><pre>
wheel:*:0:root,ericj
</pre></blockquote>

<p>
Wenn du nach einer Möglichkeit suchst, Benutzern eingeschränkten
Zugriff auf die Superuser-Privilegien zu geben, ohne sie in die
Gruppe <kbd>,wheel'</kbd> zu platzieren, verwende
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sudo&amp;sektion=8">sudo(8)</a>.

<p>
<a name= "DupFS"></a>
<h2>10.2 - Wie kann ich ein Dateisystem duplizieren?</h2>

<p>
Um ein Dateisystem zu duplizieren, verwende
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a> und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>.
Um zum Beispiel alles unter dem Verzeichnis <kbd>SRC</kbd> in das
Verzeichnis <kbd>DST</kbd> zu duplizieren, führe folgendes aus:

<blockquote><pre>
# <strong>cd /SRC; dump 0f - . | (cd /DST; restore -rf - )</strong>
</pre></blockquote>

<p>
dump wurde so entworfen, dass es dir reichliche Backupmöglichkeiten
gibt und es könnte viel zu viel sein, wenn du einfach nur einen Teil
(oder das gesamte) Dateisystem duplizieren möchtest. Das Kommando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tar&amp;sektion=1">tar(1)</a>
kann für diese Aufgabe schneller sein. Das Format sieht sehr ähnlich
aus:

<blockquote>
<pre>
# <strong>cd /SRC; tar cf -  . | (cd /DST; tar xpf - )</strong>
</pre>
</blockquote>

<p>
<a name= "rc"></a>
<h2>10.3 - Wie starte ich Daemonen mit dem System? (Überblick über
rc(8))</h2>

<p>
OpenBSD verwendet ein
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&amp;sektion=8">rc(8)</a>-style
,startup'. Dieses verwendet einige Schlüsseldateien für den ,startup'.

<ul>
  <li>/etc/rc - Hauptskript. Sollte nicht verändert werden.
  <li>/etc/rc.conf - Konfigurationsdatei, die von <i>/etc/rc</i> genutzt
  wird, um zu ermittlen, welche Daemonen mit dem System gestartet werden
  sollen.
  <li>/etc/rc.conf.local - Konfigurationsdatei, die du verwenden kannst,
  um Einstellungen in /etc/rc.conf zu überschreiben, so dass du
  /etc/rc.conf selbst nicht verändern musst, was insbesondere für Leute
  angenehm ist, die oft aktualisieren.
  <li>/etc/netstart - Skript, das beim Initialisieren des Netzwerks
  genutzt wird. Sollte nicht verändert werden.
  <li>/etc/rc.local - Skript, das für die lokale Administration genutzt
  wird. Dies ist die Datei, in der neue Daemonen oder hostspezifische
  Informationen gelagert werden sollten.
  <li>/etc/rc.securelevel - Skript, das benötigte Kommandos ausführt,
  bevor das Sicherheitslevel sich verändert. Siehe
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=init&amp;sektion=8">init(8)</a>.
  <li>/etc/rc.shutdown - Skript, das beim Herunterfahren ausgeführt
  wird. Schreibe alles in diese Datei hinein, das vor dem Herunterfahren
  gemacht werden soll. Siehe
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.shutdown&amp;sektion=8">rc.shutdown(8)</a>.
</ul>

<h3>Wie funktioniert rc(8)?</h3>

<p>
Die Hauptdateien, auf die ein Systemadministrator zu achten hat, sind
<i>/etc/rc.conf</i> (oder <i>/etc/rc.conf.local</i>),
<i>/etc/rc.local</i> und <i>/etc/rc.shutdown</i>. Um einen Überblick
darüber zu kriegen, was ausgeführt wird, wenn die rc(8)-Prozedur
läuft, folgt nun eine Aufgabenliste:

<p>
Nachdem der Kernel geladen wurde, wird <i>/etc/rc</i> gestartet:
<ul>
  <li>Dateisysteme werden überprüft. Dies wird übersprungen, wenn die
      Datei /etc/fastboot existiert. Dies ist allerdings keine gute
      Idee.
  <li>Konfigurationsvariablen werden von <i>/etc/rc.conf</i> gelesen
      und danach von <i>/etc/rc.conf.local</i>. Einstellungen in
      rc.conf.local werden die von rc.conf überschreiben.
  <li>Dateisysteme werden gemountet.
  <li>Löscht den Inhalt von <i>/tmp</i> und schützt jegliche
      Editordateien.
  <li>Konfiguriert das Netzwerk per <i>/etc/netstart</i>
  <ul>
    <li>Setzt dein Interface auf ,up'.
    <li>Setzt deinen Hostnamen, Domänennamen, etc.
  </ul>
  <li>Startet Systemdaemonen.
  <li>Führt etliche andere Überprüfungen durch (,quotas', ,savecore',
      etc.)
  <li>Lokale Daemonen werden per <i>/etc/rc.local</i> ausgeführt.
</ul>

<h3>Daemonen und Dienste starten, die mit OpenBSD ausgeliefert
werden</h3>

<p>
Die meisten Daemonen und Dienste, die mit OpenBSD standardmäßig
ausgeliefert werden, können beim Hochfahren ganz einfach durch das
Editieren der <i>/etc/rc.conf</i>-Konfigurationsdatei gestartet werden.
Um zu beginnen, solltest du einen Blick auf die standardmäßige
<a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/rc.conf">/etc/rc.conf</a>-Datei
werfen. Du wirst Zeilen wie diese sehen:

<blockquote><pre>
ftpd_flags=NO           # for non-inetd use: ftpd_flags="-D"
</pre></blockquote>

<p>
Eine Zeile wie diese zeigt, dass ftpd nicht beim Systemstart aktiviert
werden soll (zumindest nicht über rc(8), lese die
<a href="faq10.html#AnonFTP">Anonymous-FTP-FAQ</a>, um mehr darüber zu
erfahren).
Unter allen Umständen hat jede Zeile einen Kommentar, der dir die
Optionen zeigt, die nur für <b>NORMALE</b> Verwendung von diesem Daemon
oder Dienst benötigt werden. Das bedeutet nicht, dass du diesen Daemon
oder Dienst mit diesen Optionen aufrufen musst.
Du kannst immer man(1) verwenden, um zu sehen, wie du diesen Daemon oder
Dienst so starten kannst, wie du möchtest. Hier ist zum Beispiel die
Standardzeile, die zu httpd(8) gehört.

<blockquote><pre>
httpd_flags=NO          # for normal use: "" (or "-DSSL" after reading ssl(8))
</pre></blockquote>

<p>
Hier kannst du offensichtlich erkennen, dass für den normalen Start von
httpd keine Optionen notwendig sind. Daraus folgt, dass eine Zeile wie:
,<b> httpd_flags=""</b>' benutzt werden kann. Um aber httpd mit ssl zu
aktiveren (Siehe auch <a href="#HTTPS">SSL-FAQ</a> oder
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssl&amp;sektion=8">ssl(8)</a>),
solltest du mit einer derartigen Zeile starten: ,httpd_flags="-DSSL"'.

<p>
Eine gute Vorgehensweise ist, niemals <i>/etc/rc.conf</i> selbst zu
bearbeiten. Erstelle stattdessen die Datei <i>/etc/rc.conf.local</i>,
kopiere einfach die Zeilen, die du ändern möchtest, von
<i>/etc/rc.conf</i> und passe sie so an, wie du möchtest. Das macht
zukünftige Upgrades einfacher -- alle Änderungen befinden sich in dieser
einen Datei.

<h3>Lokale Daemonen starten und Konfiguration</h3>

<p>
Für andere Daemonen, die du vielleicht auf deinem System über Ports
oder auf andere Wege installieren willst, solltest du die
<i>/etc/rc.local</i>-Datei verwenden. Ich habe zum Beispiel einen
Daemonen installiert, der unter /usr/local/sbin/daemonx liegt. Ich
möchte, dass dieser beim Hochfahren startet. Ich würde einen Eintrag
wie den folgenden in <i>/etc/rc.local</i> schreiben:

<blockquote><pre>
if [ -x /usr/local/sbin/daemonx ]; then
             echo -n ' daemonx';       /usr/local/sbin/daemonx
fi
</pre></blockquote>

<p>
(Wenn der Daemon sich beim Starten nicht automatisch von der Konsole
löst, denke daran, dass du ein ,&amp;' an das Ende der Kommandozeile
hängen musst.)

<p>
Von nun an wird dieser Daemon beim Booten gestartet. Du wirst in der
Lage sein, jegliche Fehler beim Hochfahren zu sehen, ein normaler Boot
ohne Fehler würde eine Zeile wie die folgende anzeigen:

<blockquote><pre>
Starting local daemons: daemonx.
</pre></blockquote>

<h3>rc.shutdown</h3>

<p>
<i>/etc/rc.shutdown</i> ist ein Skript, das beim Herunterfahren
ausgeführt wird. Alles, was du zuvor erledigt haben möchtest, bevor das
System herunterfährt, sollte in diese Datei geschrieben werden. Falls du
apm hast, kannst du ebenfalls ,powerdown=YES' setzen. Das wird dir das
Äquivalent zu ,shutdown -p' geben.

<p>
<a name= "RelayingDenied"></a>
<h2>10.4 - Wieso erhalten Benutzer ein ,relaying denied' wenn sie
versuchen, von woanders her Mails über mein OpenBSD-System zu
verschicken?</h2>
<p>
Versuch das hier:

<blockquote><pre>
# <strong>cat /etc/mail/sendmail.cf | grep relay-domains</strong>
</pre></blockquote>

<p>
Die Ausgabe könnte wie folgt sein:

<blockquote><pre>
FR-o /etc/mail/relay-domains
</pre></blockquote>

<p>
Wenn diese Datei nicht vorhanden ist, erstelle sie. Du musst die Hosts
mit der folgenden Syntax eintragen, die Mails über dein System senden.

<blockquote><pre>
.domain.com    #Allow relaying for/to any host in domain.com
sub.domain.com #Allow relaying for/to sub.domain.com and any host in that domain
10.2           #Allow relaying from all hosts in the IP net 10.2.*.*
</pre></blockquote>

<p>
Vergesse nicht, ein ,HangUP'-Signal an sendmail zu senden (ein Signal,
das die meistenen Daemonen veranlasst, ihre Konfigurationsdatei erneut
einzulesen):

<blockquote><pre>
# <Strong>kill -HUP `head -1 /var/run/sendmail.pid`</strong>
</pre></blockquote>

<p>

<h3>Weitere Informationen</h3>

<p>
<ul>
<li><a href="http://www.sendmail.org/~ca/email/relayingdenied.html">http://www.sendmail.org/~ca/email/relayingdenied.html</a>
<li><a href="http://www.sendmail.org/tips/relaying.html">http://www.sendmail.org/tips/relaying.html</a>
<li><a href="http://www.sendmail.org/antispam.html">http://www.sendmail.org/antispam.html</a>
</ul>

<p>
<a name= "POP"></a>
<h2>10.5 - Ich habe POP installiert, erhalte aber Fehler, wenn ich
versuche, meine Mails per POP abzuholen. Was kann ich tun?</h2>

<p>
Die meisten Konflikte mit POP sind Probleme mit temporären und
,lock'-Dateien. Wenn dein POP-Server eine Fehlernachricht wie diese
sendet:

<blockquote><pre>
-ERR Couldn't open temporary file, do you own it?
</pre></blockquote>

<p>
Versuche, deine Berechtigungen wie folgt einzurichten:

<blockquote><pre>
permission in  /var
drwxrwxr-x   2 bin     mail     512 May 26 20:08 mail


permissions in  /var/mail
-rw-------   1 username   username        0 May 26 20:08 username
</pre></blockquote>

<p>
Eine andere Sache, die überprüft werden sollte, ist, dass der Benutzer
tatsächlich seine eigene /var/mail-Datei besitzt. Natürlich sollte das
der Fall sein (also, dass /var/mail/joe joe gehört) aber wenn das nicht
richtig eingestellt ist, könnte es das Problem sein!

<p>
Selbstverständlich wird eine Schreibberechtigung der Gruppe mail ein
unwahrscheinliches und obskures Sicherheitsproblem hervorrufen. Es ist
sehr wahrscheinlich, dass du niemals Probleme damit haben wirst. Aber
es könnte sein (insbesondere, wenn du eine sehr beschäftigte Site hast,
ISP, ...)! Es gibt einige POP-Server, die du direkt von der
Ports-Kollektion aus installieren kannst. Wenn möglich, verwende
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=popa3d&amp;sektion=8">popa3d</a>,
das in der OpenBSD-Basisinstallation vorhanden ist.
Oder aber, du könntest einfach die falschen Optionen für deinen
POP-Daemon ausgewählt haben (wie ,dot locking'). Vielleicht musst du
das Verzeichnis wechseln, in dem er ein ,lock in' durchführt (obwohl
das ,locking' dann nur für den POP-Daemon von Bedeutung sein wird).

<p>
<b>PS:</b> Denke daran, dass OpenBSD keine Gruppe namens ,mail' hat. Du
musst diese in deiner <i>/etc/group</i>-Datei erstellen, wenn du sie
brauchst. Ein Eintrag wie:

<blockquote><pre>
mail:*:6:
</pre></blockquote>

<p>
wäre ausreichend.

<a name="SendmailDNS"></a>
<h2>10.6 - Warum ignoriert Sendmail die <tt>/etc/hosts-Datei?</tt></h2>

<p>
Standardmäßig verwendet Sendmail DNS für die Namensauflösung, nicht die
<tt>/etc/hosts</tt>-Datei. Die Vorgehensweise kann durch das Nutzen der
<tt>/etc/mail/service.switch</tt>-Datei geändert werden.

<p>
Wenn du die hosts-Datei vor den DNS-Servern überprüfen willst, erstelle
eine <tt>/etc/mail/service.switch</tt>-Datei, welche folgende Zeile
beinhaltet:

<pre>
     hosts       files dns
</pre>

<p>
Wenn du NUR die hosts-Datei überprüfen willst, verwende die folgende:

<pre>
     hosts       files
</pre>

<p>
Sende Sendmail ein HUP-Signal:

<pre>
     # <b>kill -HUP `head -1 /var/run/sendmail.pid`</b>
</pre>

<p>
und die Änderungen werden wirksam.


<p>
<a name= "HTTPS"></a>
<h2>10.7 - Einen sicheren HTTP-Server mit Hilfe von SSL(8)
aufsetzen</h2>

<p>
OpenBSD wird mit einem SSL-fähigen httpd und RSA-Bibliotheken
ausgeliefert. Für die Verwendung mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=httpd&amp;sektion=8">httpd(8)</a>
musst du zuerst ein Zertifikat erstellen. Dieses wird unter
<i>/etc/ssl/</i> mit dem dazugehörigen Schlüssel unter
<i>/etc/ssl/private/</i> abgelegt.
Die Schritte, die hier gezeigt werden, sind Teil der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssl&amp;sektion=8">ssl(8)</a>-Manualseite.
Greife für weitere Informationen auf diese zurück.
Dieser FAQ-Eintrag zeigt nur, wie man ein RSA-Zertifikat für Webserver
erstellt, nicht ein Zertifikat für einen DSA-Server. Um zu erfahren, wie
man das macht, greife auf die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssl&amp;sektion=8">ssl(8)</a>-Manualseite
zurück.

<p>
Um zu beginnen, musst du deinen Serverschlüssel und dein -zertifikat
unter Verwendung von OpenSSL erstellen:

<div style="margin-left: 2em">
<pre>
# <strong>openssl genrsa -out /etc/ssl/private/server.key 1024</strong>
</pre>
</div>

<p>
Oder, wenn du möchtest, dass dein Schlüssel mit einem Passwort
verschlüsselt wird, das du beim Starten des Servers angeben wirst:

<div style="margin-left: 2em">
<pre>
# <strong>openssl genrsa -des3 -out /etc/ssl/private/server.key 1024</strong>
</pre>
</div>

<p>
Der nächste Schritt ist das Generieren eines ,Certificate Signing
Request', welches genutzt wird, um eine ,Certifying Authority' (CA)
dazu zu bringen, dein Zertifikat zu signieren. Verwende hierfür dieses
Kommando:

<div style="margin-left: 2em">
<pre>
# <strong>openssl req -new -key /etc/ssl/private/server.key -out /etc/ssl/private/server.csr</strong>
</pre>
</div>

<p>
Diese <i>server.csr</i>-Datei kann danach zu einer ,Certifying
Authority' übergeben werden, die den Schlüssel signieren wird. Eine
solche CA ist <b>Thawte Certification</b>, welche unter
<a href="http://www.thawte.com/">http://www.thawte.com/</a> erreicht
werden kann.

<p>
Wenn du dir das nicht leisten kannst oder du das Zertifikat einfach nur
selbst signieren möchtest, kannst du das Folgende nutzen.

<div style="margin-left: 2em">
<pre>
# <strong>openssl x509 -req -days 365 -in /etc/ssl/private/server.csr \
       -signkey /etc/ssl/private/server.key -out /etc/ssl/server.crt</strong>
</pre>
</div>

<p>
Mit <i>/etc/ssl/server.crt</i> und <i>/etc/ssl/private/server.key</i>
an der richtigen Stelle solltest du in der Lage sein,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=httpd&amp;sektion=8">httpd(8)</a>
mit der Option <b>-DSSL</b> zu starten (siehe die
<a href="#rc">Sektion über rc(8)</a> in dieser FAQ), was
HTTPS-Transaktionen mit deiner Maschine über den Port 443 ermöglicht.

<p>
<a name= "vipw"></a>
<h2>10.8 - Ich habe mit vi(1) Änderungen an /etc/passwd gemacht, aber
die Änderungen haben keinen Effekt. Warum?</h2>

<p>
Wenn du <i>/etc/passwd</i> direkt editierst, werden deine Änderungen
verloren gehen. OpenBSD generiert <i>/etc/passwd</i> dynamisch mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pwd_mkdb&amp;sektion=8">pwd_mkdb(8)</a>.
Die Hauptpasswortdatei unter OpenBSD ist <i>/etc/master.passwd</i>.
Laut pwd_mkdb(8),

<blockquote><pre>
FILES
     /etc/master.passwd  current password file
     /etc/passwd         a 6th Edition-style password file
     /etc/pwd.db         insecure password database file
     /etc/pwd.db.tmp     temporary file
     /etc/spwd.db        secure password database file
     /etc/spwd.db.tmp    temporary file
</pre></blockquote>

<p>
In einer traditionellen Unix-Passwortdatei, wie /etc/passwd, ist alles
für jeden auf dem System verfügbar, dazu zählt auch das verschlüsselte
Passwort des Benutzers (und ist somit das Hauptziel für Programme wie
zum Beispiel Crack).
4.4BSD führte die Datei master.passwd ein, welche ein erweitertes Format
hat (mit zusätzlichen Optionen, die über die hinausgehen, die in
/etc/passwd aufgelistet sind) und ist nur von root lesbar. Für
schnelleren Zugriff auf die Daten lesen die Bibliotheksaufrufe, die
auf jene Daten zugreifen, normalerweise /etc/pwd.db und /etc/spwd.db.

<p>
OpenBSD wird mit einem Tool ausgeliefert, mit welchen du deine
Passwortdatei editieren solltest. Es wird vipw(8) genannt.
Vipw verwendet vi (oder deinen bevorzugten Editor, der mit $EDITOR
definiert wird), um /etc/master.passwd zu bearbeiten. Wenn du mit dem
Editieren fertig bist, wird es /etc/passwd, /etc/pwd.db und /etc/spwd.db
anhand deiner Änderungen aktualisieren. Vipw kümmert sich ebenfalls um
das ,locking' dieser Dateien, so dass, falls jemand zur gleichen Zeit
versucht, sie zu editieren, ihm der Zugriff verwehrt wird.

<p>
<a name= "AddDelUser"></a>
<h2>10.9 - Was ist der beste Weg, Benutzer hinzuzufügen oder zu
löschen?</h2>

<p>
OpenBSD bietet zwei Kommandos, um Benutzer auf einfache Weise dem
System hinzuzufügen:

<ul>
<li><a href="#adduser">adduser(8)</a>
<li><a href="#user">user(8)</a>
</ul>

Du kannst Benutzer ebenfalls manuell unter Verwendung von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vipw&amp;sektion=8">vipw(8)</a>
hinzufügen, aber das ist für die meisten Operationen umständlicher.

<a name="adduser"></a>
<p>
Der einfachste Weg, um einen Benutzer unter OpenBSD hinzuzufügen, ist
die Verwendung des
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser&amp;sektion=8">adduser(8)</a>-Skripts.
Du kannst adduser(8) durch das Editieren der <i>/etc/adduser.conf</i>
konfigurieren.
adduser(8) erlaubt Konsistenzüberprüfungen für <i>/etc/passwd</i>,
<i>/etc/group</i> und Shelldatenbanken. Es wird die Einträge und
$HOME-Verzeichnisse für dich erstellen. Es kann sogar eine Nachricht
an die Benutzer zur Begrüßung senden. Hier ist ein Beispielbenutzer,
<b>testuser</b>, der zu einem System hinzugefügt wird.
Er/Sie bekommt das $HOME-Verzeichnis <i>/home/testuser</i>, wird ein
Mitglied der Gruppe <b>guest</b> und bekommt die Shell <i>/bin/ksh</i>.

<blockquote><pre>
# <strong>adduser</strong>
Use option ``-silent'' if you don't want to see all warnings and questions.

Reading /etc/shells
Reading /etc/login.conf
Check /etc/master.passwd
Check /etc/group

Ok, let's go.
Don't worry about mistakes. I will give you the chance later to correct any input.
Enter username []: <b>testuser</b>
Enter full name []: <b>Test FAQ User</b>
Enter shell csh ksh nologin sh [sh]: <b>ksh</b>
Uid [1002]: <b><i>Enter</i></b>
Login group testuser [testuser]: <b>guest</b>
Login group is ``guest''. Invite testuser into other groups: guest no 
[no]: <b>no</b>
Login class auth-defaults auth-ftp-defaults daemon default staff 
[default]: <b><i>Enter</i></b>
Enter password []: <b><i>Type password, then Enter</i></b>
Enter password again []: <b><i>Type password, then Enter</i></b>

Name:        testuser
Password:    ****
Fullname:    Test FAQ User
Uid:         1002
Gid:         31 (guest)
Groups:      guest
Login Class: default
HOME:        /home/testuser
Shell:i      /bin/ksh
OK? (y/n) [y]: <b>y</b>
Added user ``testuser''
Copy files from /etc/skel to /home/testuser
Add another user? (y/n) [y]: <b>n</b>
Goodbye!
</pre></blockquote>

<p>
Um Benutzer zu entfernen, solltest du das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rmuser&amp;sektion=8">rmuser(8)</a>-Werkzeug
nutzen. Dieses wird jegliche Existenz eines Benutzers löschen. Es wird
jegliche
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=crontab&amp;sektion=1">crontab(1)</a>-Einträge
entfernen, sein $HOME-Verzeichnis (wenn es dem Benutzer gehört) und
seine Mails. Natürlich wird es ebenfalls seine <i>/etc/passwd</i>- und
<i>/etc/group</i>-Einträge löschen. Als nächstes folgt ein Beispiel,
in dem der Benutzer, der gerade hinzugefügt wurde, wieder gelöscht wird.
Achte darauf, dass du nach dem Namen gefragt wirst und ob du das
Heimatverzeichnis des Benutzers löschen möchtest oder nicht.

<blockquote><pre>
# <strong>rmuser</strong>
Enter login name for user to remove: <strong>testuser</strong>
Matching password entry:

testuser:$2a$07$ZWnBOsbqMJ.ducQBfsTKUe3PL97Ve1AHWJ0A4uLamniLNXLeYrEie:1002
:31::0:0:Test FAQ User:/home/testuser:/bin/ksh

Is this the entry you wish to remove? <strong>y</strong>
Remove user's home directory (/home/testuser)? <strong>y</strong>
Updating password file, updating databases, done.
Updating group file: done.
Removing user's home directory (/home/testuser): done.
</pre></blockquote>

<a name="user"></a>
<h3>Benutzer mit user(8) hinzufügen</h3>

<p>
Diese Tools sind nicht so interaktiv wie das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser&amp;sektion=8">adduser(8)</a>-Kommando,
wodurch sie einfacher in Skripten genutzt werden können.

<p>
Die gesamte Palette dieser Tools ist:
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=group&amp;sektion=8">group(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=groupadd&amp;sektion=8">groupadd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=groupdel&amp;sektion=8">groupdel(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=groupinfo&amp;sektion=8">groupinfo(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=groupmod&amp;sektion=8">groupmod(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=user&amp;sektion=8">user(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=useradd&amp;sektion=8">useradd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=userdel&amp;sektion=8">userdel(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=userinfo&amp;sektion=8">userinfo(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=usermod&amp;sektion=8">usermod(8)</a>
</ul>

<h4>Benutzer tatsächlich hinzufügen</h4>

<p>
Da user(8) nicht interaktiv ist, ist der einfachste Weg, um auf
effiziente Art und Weise Benutzer hinzuzufügen, das adduser(8)-Kommando.
Das tatsächliche Kommando <i>/usr/sbin/user</i> ist nur eine Oberfläche
für die restlichen <i>/usr/sbin/user*</i>-Kommandos. Daher können die
folgenden Kommandos unter Verwendung von <b>user add</b> oder
<b>useradd</b> hinzugefügt werden; es ist deine Wahl, was du nutzen
willst und ändert nichts an der Tatsache, wie die Kommandos genutzt
werden.

<p>
In diesem Beispiel werden wir den gleichen Benutzer mit den gleichen
Eigenschaften anlegen, wie wir es <a href="#adduser">zuvor</a> gemacht
haben. useradd(8) ist viel einfacher zu nutzen, wenn du die
standardmäßigen Einstellungen vor dem Hinzufügen eines Benutzers weißt.
Diese Einstellungen befinden sich in <i>/etc/usermgmt.conf</i> und
können wie folgt angezeigt werden:

<blockquote><pre>
$ <strong>user add -D</strong>
group           users
base_dir        /home
skel_dir        /etc/skel
shell           /bin/csh
inactive        0
expire          Null (unset)
range           1000..60000
</pre></blockquote>

<p>
Die oben stehenden Einstellungen sind die, die genommen werden, wenn
du keine anderen über die Kommandozeilenoptionen übergibst. In unserem
Fall zum Beispiel möchten wir, dass der Benutzer zur Gruppe
<b>guest</b> statt zur Gruppe <b>users</b> gehört.
Ein weiteres Problem beim Hinzufügen der Benutzer ist, dass Passwörter
in der Kommandozeile angegeben werden müssen. Dabei handelt es sich um
das verschlüsselte Passwort, so dass du zuerst das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=encrypt&amp;sektion=1">encrypt(1)</a>-Werkzeug
nutzen musst, um das Passwort zu erstellen. Zum Beispiel: OpenBSDs
Passwörter werden standardmäßig unter Verwendung des
Blowfish-Algorithmus mit 6 Runden verschlüsselt. Hier ist eine
Beispielzeile, die zeigt, wie man ein verschlüsseltes Passwort
erstellt, das man dann useradd(8) übergibt.

<blockquote><pre>
$ <strong>encrypt -p -b 6</strong>
Enter string:
$2a$06$YOdOZM3.4m6MObBXjeZtBOWArqC2.uRJZXUkOghbieIvSWXVJRzlq
</pre></blockquote>

<p>
Nun, da wir unser verschlüsseltes Passwort haben, sind wir bereit,
den Benutzer hinzuzufügen.

<blockquote><pre>
# <strong>user add -p '$2a$06$YOdOZM3.4m6MObBXjeZtBOWArqC2.uRJZXUkOghbieIvSWXVJRzlq' -u 1002 \
-s /bin/ksh -c "Test FAQ User" -m -g guest testuser</strong>
</pre></blockquote>

<p>
<b>Hinweis:</b> Stelle sicher, dass du ,&nbsp;' (einfache
Anführungszeichen) um die Passwortzeichenkette legst, nicht etwa
&quot;&nbsp;&quot; (doppelte Anführungszeichen), da die Shell diese
vor dem Übergeben an user(8) auswerten würde. Stelle zusätzlich dazu
sicher, dass du Option <b>-m</b> übergibst, wenn du möchtest, dass das
Heimatverzeichnis vom Benutzer angelegt und die Dateien aus
<i>/etc/skel</i> herüberkopiert werden.

<p>
Um zu sehen, ob der Benutzer korrekt angelegt wurde, können wir viele
verschiedene Werkzeuge nutzen. Unterhalb stehen ein paar Kommandos,
du du benutzen kannst, um schnell zu überprüfen, ob alles richtig
gemacht wurde.

<blockquote><pre>
$ <strong>ls -la /home</strong>
total 14
drwxr-xr-x   5 root      wheel   512 May 12 14:29 .
drwxr-xr-x  15 root      wheel   512 Apr 25 20:52 ..
drwxr-xr-x  24 ericj     wheel  2560 May 12 13:38 ericj
drwxr-xr-x   2 testuser  guest   512 May 12 14:28 testuser
$ <strong>id testuser</strong>
uid=1002(testuser) gid=31(guest) groups=31(guest)
$ <strong>finger testuser</strong>
Login: testuser                         Name: Test FAQ User
Directory: /home/testuser               Shell: /bin/ksh
Last login Sat Apr 22 16:05 (EDT) on ttyC2
No Mail.
No Plan.
</pre></blockquote>

<p>
Zusätzlich zu diesen Kommandos bietet user(8) sein eigenes Werkzeug,
um Benutzercharakteristiken anzuzeigen, welches userinfo(8) genannt
wird.

<blockquote><pre>
$ <strong>userinfo testuser</strong>
login   testuser
passwd  *
uid     1002
groups  guest
change  Wed Dec 31 19:00:00 1969
class
gecos   Test FAQ User
dir     /home/testuser
shell   /bin/ksh
expire  Wed Dec 31 19:00:00 1969
</pre></blockquote>

<h4>Benutzer löschen</h4>

<p>
Um Benutzer mit Kommandos der user(8)-Hierarchie zu entfernen, wirst
du userdel(8) nutzen müssen. Dies ist ein sehr einfaches, aber dennoch
sehr nützliches, Kommando. Um den Benutzer zu löschen, der im letzten
Beispiel angelegt wurde, verwende einfach:

<blockquote><pre>
# <strong>userdel -r testuser</strong>
</pre></blockquote>

<p>
Beachte die Option <b>-r</b>, die angegeben werden muss, wenn du
möchtest, dass das Heimatverzeichnis des Benutzers ebenfalls gelöscht
werden soll. Als Alternative dazu kannst du statt <b>-r</b> auch
<b>-p</b> angeben, wodurch der Account des Benutzers gesperrt wird,
aber keine Informationen gelöscht werden.

<p>
<a name= "FTPOnly"></a>
<h2>10.10 - Wie erzeugt man einen Nur-FTP- (ftp-only) -Account?</h2>

<p>
Es gibt ein paar Wege, das zu bewerkstelligen, aber ein sehr
häufig genutzer Weg ist, ,<tt>/usr/bin/false</tt>' in
,<tt>/etc/shells</tt>' einzufügen. Wenn du dann die Shell eines
Benutzers auf ,<tt>/usr/bin/false</tt>' setzt, wird dieser Benutzer
nicht in der Lage sein, sich interaktiv anzumelden, kann aber noch
die FTP-Möglichkeiten nutzen. Du möchtest vielleicht ebenfalls den
Zugriff beschränken, indem du <a href="#ftpchroot">Benutzer unter
ftpd in ihre Heimatverzeichnisse einsperrst</a>.


<p>
<a name= "Quotas"></a>
<h2>10.11 - Quotas einrichten</h2>

<p>
Quotas werden genutzt, um den Speicher auf den Platten zu begrenzen, der
den Benutzern zur Verfügung steht. Das kann insbesondere dann sinvoll
sein, wenn du Ressourcen begrenzen musst. Quotas können für Benutzer
und/oder für Gruppen gesetzt werden.

<p>
Der erste Schritt, um Quotas einzurichten, ist, sicherzustellen, dass
,option QUOTA' sich in deiner
<a href="faq5.html#Options">Kernelkonfiguration</a> befindet. Diese
Option ist im GENERIC-Kernel. Hiernach musst du die Dateisysteme in
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5"><tt>/etc/fstab</tt></a>
markieren, für die Quotas aktiviert sein sollen.
Die Schlüsselwörter <tt>userquota</tt> und <tt>groupquota</tt> sollten
verwendet werden, um jedes einzelne Dateisystem zu markieren, für die
Quotas aktiviert sein sollen. Standardmäßig werden die Dateien
<tt>quota.user</tt> und <tt>quota.group</tt> im ,root' der Dateisysteme
erstellt, um die Quota-Informationen zu erfassen. Dieser Standard kann
geändert werden, indem der Dateiname mit der Quota-Option in
<tt>/etc/fstab</tt> angegeben wird, wie zum Beispiel
,<tt>userquota=/var/quotas/quota.user</tt>'.
Hier ist ein Beispiel für eine <tt>/etc/fstab</tt>, die ein Dateisystem
mit aktivierten userquotas hat und die Quotadatei sich an einer
nicht standardmäßigen Stelle befindet:

<blockquote><pre>
/dev/wd0a / ffs rw,userquota=/var/quotas/quota.user 1 1
</pre></blockquote>

<p>
Jetzt ist es Zeit, um die Quotas für die Benutzer einzurichten. Verwende
hierfür das Werkzeug
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=edquota&amp;sektion=8">edquota(8)</a>.
Ein einfacher Aufruf wäre ,<tt>edquota&nbsp;&lt;user&gt;</tt>'. edquota(8)
wird vi(1) nutzen, um die Quotas zu ändern, es sei denn, die
Umgebungsvariable EDITOR wurde auf einen anderen Editor gesetzt. Zum
Beispiel:

<blockquote><pre>
# <strong>edquota ericj</strong>
</pre></blockquote>

<p>
Dies wird dir eine Ausgabe geben, die ähnlich dieser ist:

<blockquote><pre>
Quotas for user ericj:
/: blocks in use: 62, limits (soft = 0, hard = 0)
        inodes in use: 25, limits (soft = 0, hard = 0)
</pre></blockquote>

<p>
Um Begrenzungen hinzuzufügen, editiere sie, um Resultate
wie diese hier zu erhalten:

<blockquote><pre>
Quotas for user ericj:
/: blocks in use: 62, limits (soft = 1000, hard = 1050)
        inodes in use: 25, limits (soft = 0, hard = 0)
</pre></blockquote>

<p>
Beachte, dass die Quota-Allokierung auf 1-k-Blöcke gesetzt ist.
In diesem Fall wurde das ,softlimit' auf 1000 k gesetzt und das
,hardlimit' auf 1050 k. Ein ,softlimit' ist eine Begrenzung, bei der der
Benutzer lediglich gewarnt wird, dass er sie überschritten hat und
weiterhin über ihr liegt, bis ihre ,grace period' vorbei ist und ihre
Plattennutzung wieder unter diese Grenze reduziert wird. ,Grace periods'
können unter Verwendung der Option <strong>-t</strong> unter Verwendung
von edquota(8) gesetzt werden. Wenn die ,grace period' vorbei ist,
wird das ,softlimit' als ,hardlimit' angesehen. Dies führt normalerweise
zu Allokierungsfehlern.

<p>
Nun, da die Quotas gesetzt sind, musst du die Quotas aktivieren. Um dies
zu tun, verwende
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=quotaon&amp;sektion=8">quotaon(8)</a>.
Zum Beispiel:

<blockquote><pre>
# <strong>quotaon -a</strong>
</pre></blockquote>

<p>
Dies wird durch <tt>/etc/fstab</tt> gehen und alle Dateisysteme mit
Quota-Optionen aktivieren. Nun, da Quotas eingerichtet sind und laufen,
kannst du sie mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=quota&amp;sektion=1">quota(1)</a>.
betrachten. Die Nutzung von einem Kommando wie
,<tt>quota &lt;user&gt;</tt>' gibt dir die Informationen über einen
Benutzer. Wenn es mit keinen Argumenten aufgerufen wird, wird das
quota(1)-Kommando deine Quota-Statistiken ausgeben. Zum Beispiel:

<blockquote><pre>
# <Strong>quota ericj</strong>
</pre></blockquote>

<p>
Wird zu einer Ausgabe führen, die dieser ähnlich ist:

<blockquote><pre>
Disk quotas for user ericj (uid 1001): 
     Filesystem  blocks   quota   limit   grace   files   quota   limit   grace
              /      62    1000    1050              27       0       0        
</pre></blockquote>

<p>
Standardmäßig werden Quotas, die in <tt>/etc/fstab</tt> gesetzt sind,
automatisch beim Hochfahren aktiviert. Um sie abzuschalten, verwende:

<blockquote><pre>
# <strong>quotaoff -a</strong>
</pre></blockquote>

<p>
<a name= "Kerberos"></a>
<h2>10.12 - KerberosV-Clients und -Server einrichten</h2>

<p>
OpenBSD beinhaltet KerberosV als vorinstallierte Komponente des
Standardsystems.

<p>
Für weitere Informationen über KerberosV rufe folgendes Kommando von
deinem OpenBSD-System aus auf:
<pre>
     # <b>info heimdal</b>
</pre>


<p>
<a name= "AnonFTP"></a>
<h2>10.13 - ,Anonymous FTP'-Dienste einrichten</h2>

<p>
,Anonymous FTP' erlaubt Benutzern ohne Accounts, auf Dateien auf deinem
Computer über das ,File Transfer Protocol' zuzugreifen. Dies hier gibt
einen Überblick über das Einrichten eines ,anonymous FTP'-Servers,
dem Aufzeichnen (logging) dieses Servers, etc.

<h3>Den FTP-Account hinzufügen</h3>

<p>
Um beginnen zu können, musst du einen ,ftp'-Account auf deinem System
haben. Dieser Account sollte kein nutzbares Passwort haben. Hier werden
wir das Login-Verzeichnis auf /home/ftp setzen, aber du kannst es
wohin du willst legen. Wenn ,anonymous ftp' genutzt wird, wird der
FTP-Daemon sich selbst in das Heimatverzeichnis des ,ftp'-Users
chrooten. Um mehr hierüber zu erfahren, lese die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftpd&amp;sektion=8">ftp(8)</a>-
und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=chroot&amp;sektion=2">chroot(2)</a>-Manualseiten.
Hier ist ein Beispiel, wie man den Benutzer <i>ftp</i> hinzufügt. Ich
werde das unter Verwendung von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser&amp;sektion=8">adduser(8)</a>
machen.
Wir müssen ebenfalls /usr/bin/false in unsere <i>/etc/shells</i>
hinzufügen, dies ist die ,shell', die wir dem FTP-User zuteilen.
Dies erlaubt ihnen nicht, sich einzuloggen, selbst wenn wir ihm ein
leeres Passwort geben. Um das zu tun, kannst du einfach
<i>echo /usr/bin/false &gt;&gt; /etc/shells</i> ausführen.
Wenn du ebenfalls möchtest, dass diese Shell während der
adduser-Frage auftaucht, musst du <i>/etc/adduser.conf</i> editieren.

<blockquote><pre>
# <strong>adduser</strong>
Use option ``-silent'' if you don't want to see all warnings and questions.

Reading /etc/shells
Reading /etc/login.conf
Check /etc/master.passwd
Check /etc/group

Ok, let's go.
Don't worry about mistakes. I will give you the chance later to correct any input.
Enter username []: <b>ftp</b>
Enter full name []: <b>anonymous ftp</b>
Enter shell csh false ksh nologin sh tcsh zsh [sh]: <b>false</b>
Uid [1002]: <b><i>Enter</i></b>
Login group ftp [ftp]: <b><i>Enter</i></b>
Login group is ``ftp''. Invite ftp into other groups: guest no 
[no]: <b>no</b>
Login class auth-defaults auth-ftp-defaults daemon default staff 
[default]: <b><i>Enter</i></b>
Enter password []: <b><i>Enter</i></b>
Set the password so that user cannot logon? (y/n) [n]: <b>y</b>

Name:        ftp
Password:    ****
Fullname:    anonymous ftp
Uid:         1002
Gid:         1002 (ftp)
Groups:      ftp
Login Class: default
HOME:        /home/ftp
Shell:       /usr/bin/false
OK? (y/n) [y]: <b>y</b>
Added user ``ftp''
Copy files from /etc/skel to /home/ftp
Add another user? (y/n) [y]: <b>n</b>
Goodbye!
</pre></blockquote>

<h3>Verzeichniseinrichtung</h3>

<p>
Neben dem Benutzer wurde hiermit das Verzeichnis <i>/home/ftp</i>
angelegt. Das ist genau das, was wir wollen, aber es müssen einige
Änderungen vorgenommen werden, die wir machen müssen, um es für
,anonymous ftp' bereit zu machen. Es sei wieder erwähnt, dass diese
Änderungen in der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftpd&amp;sektion=8">ftp(8)</a>-Manualseite
beschrieben werden.

<p>
Du <b>musst nicht</b> ein Verzeichnis namens /home/ftp/usr oder
/home/ftp/bin erstellen.
<ul>
<li><i>/home/ftp</i> - Dieses ist das Hauptverzeichnis. Es sollte root
gehören und die Rechte 555 haben.
<li><i>/home/ftp/etc</i> - Dieses ist vollkommen optional und nicht
empfohlen, da es nur dazu dient, Informationen über Benutzer
herauszugeben, die es auf deinem System gibt. Wenn du möchtest, dass
dein ,Anonymous FTP'-Verzeichnis so wirkt, als wenn deine Dateien
echten Benutzern gehören, solltest du /etc/pwd.db und /etc/group in
dieses Verzeichnis kopieren. Dieses Verzeichnis sollte die Rechte 511
haben und die beiden Dateien die Rechte 444. Diese werden benötigt, um
Benutzernamen in Abhängigkeit der Nummern zuzuweisen. Es werden keine
Passwörter in pwd.db gespeichert, die sind all in spwd.db, so dass du
die Datei nicht hineinkopieren solltest.
<li><i>/home/ftp/pub</i> - Dieses ist das Standardverzeichnis, in das
Dateien gelegt werden sollten, die du zur Verfügung stellen willst.
Dieses Verzeichnis sollte ebenfalls die Rechte 555 haben.
</ul>

<p> 
Beachte, dass alle Verzeichnisse ,root' gehören sollten. Hier ist eine
Liste, wie die Verzeichnisse nach der Erstellung aussehen sollten.

<blockquote><pre>
# pwd
/home
# ls -laR ftp
total 5
dr-xr-xr-x  5 root  ftp    512 Jul  6 11:33 .
drwxr-xr-x  7 root  wheel  512 Jul  6 10:58 ..
dr-x--x--x  2 root  ftp    512 Jul  6 11:34 etc
dr-xr-xr-x  2 root  ftp    512 Jul  6 11:33 pub

ftp/etc:
total 43
dr-x--x--x  2 root  ftp    512 Jul  6 11:34 .
dr-xr-xr-x  5 root  ftp    512 Jul  6 11:33 ..
-r--r--r--  1 root  ftp    316 Jul  6 11:34 group
-r--r--r--  1 root  ftp  40960 Jul  6 11:34 pwd.db

ftp/pub:
total 2
dr-xr-xr-x  2 root  ftp  512 Jul  6 11:33 .
dr-xr-xr-x  5 root  ftp  512 Jul  6 11:33 ..
</pre></blockquote>

<h3>Den Server und das Aufzeichnen starten</h3>

<p>
Mit ftpd kannst du dir aussuchen, ob du es von inetd oder aus den
rc-Skripten heraus starten willst. Diese Beispiele demonstrieren, wie
unser Daemon von
<a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/inetd.conf">inetd.conf</a>
aus gestartet wird.
Zuerst müssen wir mit einigen Optionen von ftpd vertraut sein. Die
Standardzeile aus <i>/etc/inetd.conf</i> ist:

<blockquote><pre>
<strong>ftp             stream  tcp     nowait  root    /usr/libexec/ftpd       ftpd -US</strong>
</pre></blockquote>

<p>
Hier wird ftpd mit <i>-US</i> augerufen. Hiermit werden alle
anonymen Verbindungen unter <i>/var/log/ftpd</i> aufgezeichnet und
zusammenwirkende Verbindungen unter <i>/var/run/utmp</i>. Somit können
diese Sitzungen per who(1) angesehen werden. Für einige gilt, dass sie
nur einen ,anonymous'-Server starten wollen und somit ftp für Benutzer
deaktivieren sollten. Rufe hierzu ftpd mit der Option <i>-R</i> auf.
Hier ist eine Zeile, die ftpd so startet, dass nur anonyme Verbindungen
zugelassen werden. Es verwendet ebenfalls <i>-ll</i>, wodurch jede
Verbindung mit syslog aufgezeichnet wird, zusätzlich zu den
FTP-Kommandos get, retrieve, etc.

<blockquote><pre>
<strong>ftp             stream  tcp     nowait  root    /usr/libexec/tcpd       ftpd -llUSA</strong>
</pre></blockquote>

<p>
Hinweis - Leute, die FTP-Server mit HOHER Netzauslastung verwenden,
sollten ftpd nicht von inetd.conf aus aufrufen. Die beste Möglichkeit
ist, die Zeile für ftpd aus inetd.conf zu kommentieren und ftpd von
rc.conf mit der Option <i>-D</i> aus zu starten. Somit wird ftpd als
Daemon gestartet, was weniger zusätzliche Auslastung bewirkt als wenn
der Start von inetd aus erfolgt.
Hier ist eine Beispielzeile, wenn der Start von rc.conf aus erfolgt.

<blockquote><pre>
ftpd_flags="-DllUSA"           # for non-inetd use: ftpd_flags="-D"
</pre></blockquote>

<p>
Dies funktioniert natürlich nur, wenn du ftpd aus <i>/etc/inetd.conf</i>
rausgenommen und inetd veranlasst hast, die Konfigurationsdatei neu
einzulesen.

<h3>Andere relevante Dateien</h3>

<ul>
<li><i>/etc/ftpwelcome</i> - Diese beinhaltet die Willkommensnachricht
für Personen, wenn sie sich mit deinem FTP-Server verbunden haben.
<li><i>/etc/motd</i> - Diese beinhaltet die Nachricht für Personen,
die sich erfolgreich an deinem FTP-Server angemeldet haben.
<li><i>.message</i> - Diese Datei kann in beliebige Verzeichnisse gelegt
werden. Sie wird angezeigt, sobald ein Benutzer in das Verzeichnis
wechselt.
</ul>


<p>
<a name= "ftpchroot"></a>
<h2>10.14 - In ftpd(8) Benutzer in ihre Heimatverzeichnisse
einsperren.</h2>

<p>
Standardmäßig können Benutzer, wenn sie sich über ftp angemeldet haben,
in jedes Verzeichnis auf deinem Dateisystem wechseln, wenn sie die
benötigten Rechte dafür haben.
In einigen Fällen kann es sein, dass das nicht erwünscht ist.
Es ist möglich, einzuschränken, was Benutzer über die FTP-Sitzung
sehen können, indem man sie in ihr Heimatverzeichnis einsperrt.

<p>
Wenn du nur ,chrooted' FTP-Anmeldungen erlauben willst, verwende die
Option <b>-A</b> mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftpd&amp;sektion=8">ftpd(8)</a>.

<p>
Wenn du diese Begrenzung gezielter einsetzen willst, macht OpenBSDs
,<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=login.conf&amp;sektion=5">login
capability infrastructure</a>' zusammen mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftpd&amp;sektion=8">ftpd(8)</a>
das recht einfach.
<p>

Benutzer, die sich in einer Login-Klasse mit der gesetzten Variable
<tt>ftp-chroot</tt> befinden, werden automatisch ,chrooted'.
Zusätzlich kannst du einen Benutzernamen zur Datei <b>/etc/ftpchroot</b>
hinzufügen, damit ,chroot' auch für diese Benutzer genutzt wird.
Ein Benutzer muss nur in einer dieser Orte aufgelistet werden.


<p>
<a name= "Patches"></a>
<h2>10.15 - Patches in OpenBSD einfügen.</h2>

<p>
Selbst unter OpenBSD treten Fehler auf.
Einige Fehler können zu Stabilitätsproblemen führen (z.B. dass etwas
dazu führen kann, dass etwas nicht mehr wie gewünscht funktioniert).
Andere Fehler könnten zu Sicherheitsproblemen führen (wodurch Andere
deinen Computer auf nicht beabsichtigte Weise ,benutzen' können).
Wenn ein kritischer Fehler gefunden wurde, wird die Korrektur in den
<i>-current</i>-Source-Tree hinzugefügt und Patches für die
<a href="faq5.html#Flavors">unterstützten Releases</a> von OpenBSD
bereitgestellt. Diese Patches werden auf der
<a href="../../de/errata.html">Errata-Webseite</a> aufgelistet,
wo sie unter ,common'-Errata, die für alle
<a href="../../de/plat.html">Plattformen</a> gilt, und in Errata
unterteilt, die nur für eine oder mehr, aber nicht für alle,
Plattformen gelten.

<p>
Bedenke jedoch, dass für Neuerungen für OpenBSD keine Patches erstellt
werden, und somit nur für wichtige Stabilitäts- oder
Sicherheitskorrekturen gemacht werden, die sofort auf den betroffenen
Systemen eingespielt werden sollten (was meist NICHT für alle Systeme
gilt, je nach ihrem Anwendungsgebiet).

<p>
Es existieren drei Wege, wie du dein System mit gepatchtem Code
aktualisieren kannst:

<ul>
<li><b>Dein System auf <i>-current</i> upgraden.</b>
Da alle Korrekturen in die Codebasis von <i>-current</i> übernommen
werden, ist das Aktualisieren deines Systems auf den aktuellsten
Snapshot eine gute Möglichkeit, korrigierten Code zu nutzen. Jedoch ist
der Einsatz von <i>-current</i> nicht für jeden geeignet.
<li><b>Dein System auf <a href="../../de/stable.html"><i>-stable</i>
aktualisieren</a>.</b>
Dies wird gemacht, indem du deinen Source-Tree unter Verwendung des
dazu passenden ,<i>-stable</i> branch' herunterlädst oder
aktualisierst, und dann den Kernel und die Dateien vom ,userland'
neukompilierst. Generell ist das die einfachste Möglichkeit, obwohl sie
länger dauern kann (da das gesamte System neukompiliert wird) und ein
vollständiger Source-,checkout' eine lange Zeit in Anspruch nehmen kann,
wenn deine Bandbreite begrenzt ist.
<li><b>Patche, kompiliere und installiere individuelle betroffene
Dateien.</b>
Dies werden wir in unserem Beispiel weiter unten machen.
Obwohl diese Methode weniger Bandbreite und normalerweise auch weniger
Zeit in Anspruch nimmt als ein ,checkout/update' per cvs(1) und das
dazugehörige Kompilieren des Quelltextes, ist diese Methode manchmal
auch die schwierigste, da es keinen allgemeingültigen Instruktionssatz
gibt, den man befolgen könnte.
Manchmal musst du lediglich eine Applikation patchen, neukompilieren
und installieren, manchmal aber auch ganze Sektionen des Trees, wenn
das Problem sich in einer Bibliotheksdatei befindet.
</ul>

Noch einmal: Das Patchen von individuellen Dateien ist nicht immer
einfach, denke also gründlich darüber nach, ob du nicht dem
<a href="../../de/stable.html"><i>-stable</i></a> (oder ,patch')
,branch' von OpenBSD folgen willst.
Das Kombinieren und Anpassen von Patchlösungen kann durchgeführt werden,
wenn man weiß, wie alles funktioniert, aber neue Benutzer sollten eine
Methode auswählen und bei dieser bleiben.

<h3>Wie unterscheiden sich die ,errata'-Patches von dem, was sich im
CVS-Tree befindet?</h3>

<p>
Alle Patches, die auf der
<a href="../../de/errata.html">Errata-Webseite</a> landen, sind Patches,
die direkt auf den Source-Tree vom angegebenen Release abgestimmt sind.
Patches, die für den aktuellen CVS-Tree sind, beinhalten auch andere
Ändungern, die auf einem Release-System nicht gewollt sind.
Dies ist wichtig: Wenn du einen Snapshot installiert hast, einen
,checkout' für den Source-Tree zu der Zeit gemacht hast, als du den
Snapshot heruntergeladen hast, und dann versuchst, einen freigegebenen
Patch zu verwenden, wirst du eventuell feststellen, dass der Patch nicht
anwendbar ist, da der Code sich vermutlich geändert hat.



<h3>Patches anwenden.</h3>

<p>
Patches für das OpenBSD-Betriebssystem werden als ,Unified diffs'
zur Verfügung gestellt, welche Textdateien sind, die die Unterschiede
zum ursprünglichen Quelltext beinhalten. Sie werden <b>NICHT</b> in
Binärform ausgeliefert. Dies bedeutet, dass du, um dein System
patchen zu können, den Quelltext von der <b>RELEASE</b>-Version
vorliegen haben musst.
Generell gilt, dass du den gesamten Source-Tree haben solltest. Wenn
du ein Release von der offiziellen CDROM benutzt, befinden sich die
Source-Trees auf Disc 3, sie können aber auch als Dateien von den
<a href="../../de/ftp.html">FTP-Servern</a> heruntergeladen werden.
Wir nehmen an, dass du ein ,checkout' für den gesamten Tree gemacht
hast.

<p>
Für unser Beispiel hier betrachten wir den Patch 001 für OpenBSD 3.6,
der sich mit dem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=st&amp;sektion=4">st(4)</a>-Treiber
befasst, der für die Verarbeitung von Bandlaufwerken zuständig ist.
Ohne diesem Patch ist das Wiedereinlesen der Daten von Backups recht
schwierig. Leute, die ein Bandlaufwerk nutzen, <i>benötigen</i> diesen
Patch, wobei diejenigen, die kein Bandlaufwerk nutzen, keine besondere
Notwendigkeit haben, diesen zu installieren.
Lass uns einen Blick auf den Patch werfen:

<blockquote><pre>
# <b>more 001_st.patch</b>
Apply by doing:
        cd /usr/src
        patch -p0 < 001_st.patch

Rebuild your kernel.

Index: sys/scsi/st.c
===================================================================
RCS file: /cvs/src/sys/scsi/st.c,v
retrieving revision 1.41
retrieving revision 1.41.2.1
diff -u -p -r1.41 -r1.41.2.1
--- sys/scsi/st.c       1 Aug 2004 23:01:06 -0000       1.41
+++ sys/scsi/st.c       2 Nov 2004 01:05:50 -0000       1.41.2.1
@@ -1815,7 +1815,7 @@ st_interpret_sense(xs)
        u_int8_t skey = sense->flags & SSD_KEY;
        int32_t info;
 
-       if (((sense->flags & SDEV_OPEN) == 0) ||
+       if (((sc_link->flags & SDEV_OPEN) == 0) ||
            (serr != 0x70 && serr != 0x71))
                return (EJUSTRETURN); /* let the generic code handle it */
</pre></blockquote>

Wie du sehen kannst, befindet sich am Anfang vom Patch eine kurze
Einweisung, wie er eingefügt werden kann.
Wir nehmen an, dass du ihn in das Verzeichnis <tt>/usr/src</tt> gelegt
hast, wodurch in diesem Fall folgende Schritte gemacht werden müssen:

<blockquote><pre>
# <b>cd /usr/src</b>
# <b>patch -p0 < 001_st.patch</b>
Hmm...  Looks like a unified diff to me...
The text leading up to this was:
--------------------------
|Apply by doing:
|        cd /usr/src
|        patch -p0 < 001_st.patch
|
|Rebuild your kernel.
|
|Index: sys/scsi/st.c
|===================================================================
|RCS file: /cvs/src/sys/scsi/st.c,v
|retrieving revision 1.41
|retrieving revision 1.41.2.1
|diff -u -p -r1.41 -r1.41.2.1
|--- sys/scsi/st.c      1 Aug 2004 23:01:06 -0000       1.41
|+++ sys/scsi/st.c      2 Nov 2004 01:05:50 -0000       1.41.2.1
--------------------------
Patching file sys/scsi/st.c using Plan A...
Hunk #1 succeeded at 1815.              <i>&lt;-- Look for this message!</i>
done
</pre></blockquote>

Achte auf die obrige Nachricht "<tt>Hunk #1 succeeded</tt>".
Diese weist darauf hin, dass der Patch erfolgreich eingefügt wurde.
Viele Patches sind viel komplexer als dieser hier und werden viele
,hunks' und mehrere Dateien miteinbeziehen, daher solltest du in einem
solchen Fall sicherstellen, dass alle ,hunks' für alle Dateien
erfolgreich waren.
Wenn sie es nicht waren, heißt das normalerweise, dass dein Source-Tree
nicht richtig ist, du den Anweisungen nicht gründlich gefolgt bist,
oder aber der Patch verunstaltet wurde.
Patches sind sehr sensibel gegenüber ,Leerstellen' -- Copy&Paste von
deinem Browser wird oft Tabulatoren in Leerstellen umwandeln oder auf
andere Art und Weise die Leerstellen der Datei modifzieren, wodurch er
nicht eingefügt werden kann.

<p>
An diesem Punkt angekommen kannst du nun wie gewohnt
<a href="faq5.html#Building">den Kernel erzeugen</a>, installieren und
das System neustarten.

<p>
Nicht alle Patches sind für den Kernel.
In einigen Fällen musst du invididuelle Werkzeuge neuerzeugen. In
anderen Fällen musst du alle statisch gelinkten Werkzeuge
neukompilieren, da sich eine Bibliothek änderte.
Folge den Anweisungen am Anfang vom Patch, und wenn du dir unsicher
bist, erstelle das gesamte System neu.

<p>
Patches, die für bestimmte Systeme unbedeutend sind, müssen nicht
mit eingefügt werden -- normalerweise.
Wenn du zum Beispiel kein Bandlaufwerk auf deinem System hattest,
würdest du vom oben angegeben Patch nicht profitieren.
Man nimmt jedoch an, dass die Patches ,in der richtigen Reihenfolge'
eingefügt werden -- es ist möglich, dass ein späterer Patch von einem
vorherigen abhängig ist. Sei dir dessen bewusst, wenn du dich dafür
entscheidest, beim Installieren von Patches ,wählerisch' zu sein, so
dass du, wenn du dir unsicher bist, alle installieren solltest.


<a name="httpdchroot"></a>
<h2>10.16 - Wie geht das mit dem chroot()-Apache?</h2>

<p>
Unter OpenBSD wurde der Apache
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=httpd&amp;sektion=8">httpd(8)</a>
Server standardmäßig
,<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=chroot&amp;sektion=2">chroot(2)</a>ed'.
Obwohl dies ein ungeheurer Sicherheitsvorteil ist, kann das zu Problemen
führen, wenn man nicht darauf vorbereitet ist.

<h3>Was ist ein chroot?</h3>

<p>
Eine
,<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=chroot&amp;sektion=2">chroot(2)</a>ed'
Anwendung wird in ein bestimmtes Verzeichnis eingesperrt und ist nicht
in der Lage, im Rest der Verzeichnisstruktur herumzuwandern, da es das
Verzeichnis als ,<tt>/</tt>' (root-) Verzeichnis sieht.
Im Fall von httpd(8) startet das Programm, öffnet seine Logdateien,
greift auf seine TCP-Ports zu (obwohl es zu diesem Zeitpunkt noch keine
Daten akzeptiert) und liest seine Konfiguration. Als nächstes sperrt es
sich in <i>/var/www</i> ein und lässt seine Privilegien fallen; erst
dann akzeptiert es Anfragen.
Dies bedeutet, dass alle Dateien, die von Apache zur Verfügung gestellt
und benutzt werden, sich im Verzeichnis <i>/var/www</i> befinden müssen.
Dies hilft der Sicherheit ungemein -- sollte es ein Sicherheitsproblem
mit Apache geben, wird der Schaden auf ein einziges Verzeichnis
begrenzt sein, dessen Rechte nur das Lesen erlauben und auch keine
Ressourcen hat, die jemand ausnutzen könnte.

<h3>Was bedeutet das für den Benutzer?</h3>

<p>
Grob gesagt ist chroot(2)ing Apache etwas Neues und wird nicht
standardmäßig unter anderen Betriebssystemen eingesetzt.
Viele Applikationen und Systemkonfigurationsdateien werden in einem
chroot(2) ohne Anpassungen nicht funktionieren.

<ul>
<li><b>Historische Dateisystemlayouts:</b> Server, die von einer
älteren Version von OpenBSD geupgradet wurden, haben eventuell
Dateien im Verzeichnis der Benutzer liegen, welche natürlich nicht
in einer ,chroot(2)ed' Umgebung funktionieren werden, da httpd(8)
das Verzeichnis <i>/home</i> nicht erreichen kann. Administratoren
werden vielleicht ebenfalls feststellen, dass die Partition von
/var/www zu klein ist, um alle Webdateien zu halten. Deine Möglichkeiten
sind zum Einen das Neustrukturieren oder das Abschalten der
chroot(2)-Funktionalität. Du kannst natürlich symbolische Links von
den Heimatverzeichnissen der Benutzer verwenden, die dann auf
Unterverzeichnisse von <i>/var/www</i> verweisen, aber du kannst
NICHT Links unter <i>/var/www</i> nutzen, die auf andere Teile des
Dateisystems verweisen -- dies wird durch das ,chroot(2)ing' verhindert.
Wenn du deinen Benutzern <a href="faq10.html#ftochroot">,chroot(2)ed'
FTP-Zugriff</a> ermöglichen möchtest, musst du daran denken, dass das
dann nicht funktionieren wird, da der FTP-Chroot (wieder einmal)
den Zugriff auf die Ziele der symbolischen Links verhindern wird.
Eine Lösung hierfür ist es, nicht <i>/home</i> als Heimatverzeichnis
für solche Anwender zu benutzen sondern stattdessen etwas wie
<i>/var/www/home</i>.

<li><b>,Log Rotation':</b> Normalerweise werden Logs rotiert, indem
die alten Dateien umbenannt werden, httpd(8) ein SIGUSR1-Signal
gesendet wird, das Apache dazu veranlasst, die alten Dateien zu
schließen und neue zu öffnen. Dies ist nicht länger möglich, da
httpd(8) nicht mehr in der Lage ist, seine eigenen neuen Logdateien
zu öffnen, sobald die Privilegien abgegeben worden sind. Daher muss
httpd(8) beendet und neugestartet werden:

<pre>
     # <b>apachectl stop && apachectl start</b>
</pre>

Es gibt weitere Strategien hierfür, einschließlich die Möglichkeit,
über eine
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pipe&amp;sektion=2">pipe(2)</a>
aufzuzeichnen, und einen externen ,log rotator' auf der anderen Seite
der pipe(2) einzusetzen.

<li><b>Existierende Apache-Module:</b> Fast alle werden geladen,
jedoch können einige nicht richtig in chroot(2) eingesetzt werden und
viele haben Probleme mit
,<tt><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=apachectl&amp;sektion=8">apachectl</a>
restart</tt>'; sie erzeugen einen Fehler, welcher dazu führt, dass
httpd(8) beendet wird.

<li><b>Existierende CGIs:</b> Die meisten werden NICHT ohne weiteres
eingesetzt werden können. Sie benötigen vermutlich Programme oder
Bibliotheken, die sich außerhalb von <i>/var/www</i> befinden. Einige
können durch Kompilieren statisch gelinkt werden (keine Bibliotheken
in anderen Verzeichnissen werden benötigt), die meisten werden behoben
werden können, indem im <i>/var/www</i> die Verzeichnisse mit den
benötigten Dateien der Applikation angelegt werden, wobei dies nicht
so einfach ist, wie es klingt, und daher einiges an Programmierwissen
benötigt -- die meisten Benutzer werden es einfach finden, lediglich
die chroot(2)-Funktionalität zu beenden, bis die CGIs aktualisiert
wurden.

</ul>

In einigen Fällen können die Applikation oder die Konfiguration
geändert werden, damit sie im chroot läuft. In anderen Fällen wirst
du diese Funktionalität einfach unter Verwendung der Option <tt>-u</tt>
mit httpd(8) in der
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&amp;sektion=8">/etc/rc.conf</a></i>
abstellen.

<h3>Beispiel eines ,chroot(2)ing' einer Applikation: wwwcount</h3>
Als ein Beispiel für die Vorgehensweise, die genutzt werden kann, um
eine Applikation zu ,chroot'en, werden wir einen Blick auf wwwcount
werfen, einem einfachen Webseitenzähler, der über die
<a href="faq8.html#Ports">Ports</a> verfügbar ist.
Obwohl dieses ein sehr effektives Programm ist, kennt es nichts über
,chroot(2)ed' Apache und wird in seiner standardmäßigen Konfiguration
nicht ,chroot(2)ed' funktionieren.

<p>
Zuerst werden wir ein <a href="faq8.html#Packages">Package</a> von
<a href="http://www.muquit.com/muquit/software/Count/Count.html">wwwcount</a>
installieren. Wir konfigurieren und testen es und stellen fest, dass
es nicht funktionieren will und dass wir eine Apache-Nachricht erhalten,
die ,Internal Server Error' sagt.

Der erste Schritt ist das Beenden und Neustarten von Apache mit der
Option <tt>-u</tt>, um sicherzustellen, dass das Problem im
,chroot(2)ing' liegt und nicht in der Systemkonfiguration.
<pre>
    # <b>apachectl stop</b>
    /usr/sbin/apachectl stop: httpd stopped
    # <b>httpd -u</b>
</pre>
Hiernach sehen wir, dass der Zähler einwandfrei läuft, zumindest nachdem
wir die Dateirechte umgestellt haben, so dass Apache (und die CGIs, die
er ausführt) in die Dateien schreiben können, die gehalten werden.
Somit haben wir ganz sicher ein Problem mit chroot, so dass wir Apache
wieder beenden und neustarten können, dieses Mal wieder mit
standardmäßigem ,chrooting':
<pre>
    # <b>apachectl stop</b>
    /usr/sbin/apachectl stop: httpd stopped
    # <b>httpd</b>
</pre>

<p>
Ein guter Anfangspunkt wäre anzunehmen, dass wwwcount einige
Bibliotheken und andere Dateien benötigt, die im chroot nicht vorliegen.
Wir können das Kommando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ldd&amp;sektion=1">ldd(1)</a>
benutzen, um alle dynamischen Objektabhängigkeiten festzustellen, die
das CGI hat:
<pre>
# cd /var/www/cgi-bin/
# ldd Count.cgi
Count.cgi:
        Start    End      Type Ref Name
        00000000 00000000 exe   1  Count.cgi
        03791000 237ca000 rlib  1  /usr/lib/libc.so.30.3
        03db4000 03db4000 rtld  1  /usr/libexec/ld.so
</pre>
Ok, hier ist ein Problem, zwei Dateien sind in der chroot(2)-Umgebung
nicht verfügbar. Wir kopieren sie also hinein:
<pre>
    # mkdir -p /var/www/usr/lib /var/www/usr/libexec
    # cp /usr/lib/libc.so.30.3 /var/www/usr/lib
    # cp /usr/libexec/ld.so /var/www/usr/libexec
</pre>
und testen den Zähler wieder.

<p>
Nunja, jetzt läuft das Programm zumindest und gibt uns Fehlermeldungen
direkt: "Unable to open config file for reading".
Fortschritt, aber wir sind noch nicht fertig.
Die Konfigurationsdatei ist normalerweise in
<tt>/var/www/wwwcount/conf</tt>, aber innerhalb der chroot-Umgebung,
wäre das <tt>/wwwcount/conf</tt>.
Unsere Möglichkeiten sind nun entweder das Neukompilieren vom Programm,
so dass es mit den Dateien arbeitet, wo sie jetzt sind, oder aber das
Verschieben der Dateien.
Da wir vom Package aus installiert haben, werden wir die Dateien
verschieben. Um die gleiche Konfig mit sowie ohne chroot(2) verwenden
zu können, benutzen wir einen symbolischen Link:

<pre>
    # mkdir -p /var/www/var/www          
    # cd /var/www/var/www
    # ln -s ../../wwwcount wwwcount
</pre>
Beachte, dass dieser symbolische Link so erstellt wurde, dass er
innerhalb vom chroot läuft. Und wir werden wieder einmal testen ...
und stellen fest, dass es noch ein Problem gibt.
Nun beschwert sich wwwcount darüber, dass es die ,strip image'-Dateien,
die zum Anzeigen von Nachrichten genutzt werden, nicht finden kann.
Nach einer kurzen Suche finden wir heraus, dass sich diese unter
<tt>/usr/local/lib/wwwcount</tt> befinden, so dass wir diese ebenfalls
ins chroot kopieren müssen.
<pre>
    # tar cf - /usr/local/lib/wwwcount | (cd /var/www; tar xpf - )
</pre>
wir testen wieder ... und es läuft!

<p>
In diesem Beispiel war das Programm recht einfach und doch sahen wir
unterschiedliche Arten von Problemen.
Einige Applikationen sind recht einfach und ,chroot(2)ing' macht für sie
Sinn. Andere sind recht komplex und sind die Anstrengungen, sie in ein
chroot zu zwingen, nicht wert, oder aber du wirst den kompletten Nutzen
der chroot(2)-Umgebung verloren haben, wenn du genügend Dateien vom
System kopiert hast. Selbst Applikationen, die so einfach wie diese
sind, müssen auf die Platte schreiben (um den Zähler zu speichern), so
dass einige Vorteile vom chroot(2) verloren gegangen sind. Generell
gilt, dass nur so viele Dateien ins chroot kopiert werden sollten, wie
für das Ausführen der Datei zwingend erforderlich sind.
<i>Nicht jede Applikation kann oder sollte ,chroot(2)ed' werden.</i>


<a name="rootshell"></a>
<!-- XXXversion - root shell is now ksh -->
<h2>10.17 - Ich mag die Standard-Shell von root nicht!</h2>

Die Standard-Shell für <i>root</i> ist unter OpenBSD
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=csh&amp;sektion=1">csh</a>,
vor allem aus geschichtlichen Gründen. Es gibt keine Notwendigkeit, dass
OpenBSD csh(1) für den root-Login hat (aber lese erst weiter, bevor du
sie änderst).

<p>
Einige Benutzer, die von anderen Unix-ähnlichen Betriebssystemen kommen,
finden csh(1) zu gewöhnungsbedürftig und fragen, ob und wie man sie
ändern kann. Es gibt einige wenige Möglichkeiten:

<ul>
<li><b>Melde dich nicht als <i>root</i> an!</b> Neben
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=su&amp;sektion=1">su</a>
und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sudo&amp;sektion=8">sudo</a>
sollte es nur wenige Gründe für Benutzer geben, sich als <i>root</i>
für die meisten Einsatzgebiete nach dem ersten Einrichten anzumelden.

<li><b>Rufe deine Lieblingsshell nach dem Login auf:</b> Wenn du ksh(1)
oder eine andere Shell magst, rufe sie einfach von der Standard-Shell
aus auf.
<li><b>Ändere die Shell von root:</b> Dies kann unter Verwendung von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=chsh&amp;sektion=1">chsh</a> 
oder
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vipw&amp;sektion=8">vipw</a>
gemacht werden.
</ul>

Eine geschichtliche Unix-Richtlinie ist, nur statisch kompilierte Shells
für root zu benutzen, da im Fall des ,single user'-Modus andere als die
root-Partitionen nicht gemountet werden und dynamisch gelinkte Shells
nicht auf die Bibliotheken auf der <tt>/usr</tt>-Partition zugreifen
können. Dies ist kein wirklich schlimmes Problem für OpenBSD, da das
System dich nach einer Shell fragt, wenn es im ,single user'-Modus
angekommen ist und der Standard

<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sh&amp;sektion=1">sh</a>
ist.

Die drei standardmäßigen Shells unter OpenBSD
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=csh&amp;sektion=1">csh</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sh&amp;sektion=1">sh</a>
und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ksh&amp;sektion=1">ksh</a>)
sind alle statisch gelinkt und daher im ,single user'-Modus
einsatzfähig.

<p>
Es wird manchmal gesagt, dass man die Shell von root nicht ändern
sollte, jedoch gibt es unter OpenBSD nichts, was dagegen spricht. Aber
es sei noch einmal gesagt, das ist kein Problem -- logge dich einfach
nicht als root ein.
Tatsächlich gilt für OpenBSD-current, dass die Standard-Shell in ksh
geändert wurde.


<a name="ksh"></a>
<h2>10.18 - Was kann ich noch mit <i>ksh</i> machen?</h2>
Unter OpenBSD ist
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ksh&amp;sektion=1">ksh</a>
<a href="http://web.cs.mun.ca/~michael/pdksh/">pdksh</a>, die ,Public
Domain Korn Shell', und die gleiche Binary wie
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sh&amp;sektion=1">sh</a>.

<p>
Benutzer, die gerne <i>bash</i> benutzen, die oft unter Linux-Systemen
genutzt wird, werden
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ksh&amp;sektion=1">ksh</a>
als recht ähnlich einschätzen. Ksh(1) bietet die meisten häufig
genutzten Funktionalitäten von <i>bash</i>, einschließlich der
Tab-Erweiterung, Kommandozeileneditierung und ,History' über die
Pfeiltasten und STRG+A/STRG+E, um zum Anfang/Ende der Kommandozeile
zu springen. Wenn andere Funktionalitäten der <i>bash</i> benötigt
sind, kann <i>bash</i> selbst entweder über
<a href="faq8.html#Ports">Ports</a> oder
<a href="faq8.html#Packages">Packages</a> installiert werden.

<p>
Der Kommandoprompt von <i>ksh</i> kann auf einfache Weise auf etwas
informativeres geändert werden, weg vom standardmäßigen ,$ ', indem die
Variable <tt>PS1</tt> gesetzt wird. Das Einfügen folgender Zeile:

<blockquote><pre>
export PS1='$PWD $ '
</pre></blockquote>

in deine <tt>/etc/profile</tt> führt beispielsweise zu folgendem
Kommandoprompt:

<blockquote><pre>
/home/nick $
</pre></blockquote>

Siehe dir die Datei
<a href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/src/etc/ksh.kshrc?content-type=text/plain"><tt>/etc/ksh.kshrc</tt></a>
an, in der viele nützliche Funktionalitäten und Beispiele stehen, die
in die <tt>.profile</tt> deines Benutzers geschrieben werden können.

<p>
Beginnend mit OpenBSD 3.7 wurde ksh(1) mit einer Anzahl von ,speziellen
Charakteren' für den primären Promptstring, PS1, verbessert, so dass sie
ähnlich zu denen in bash sind.
Zum Beispiel:
<blockquote>
<tt>\e - </tt>Füge eine ASCII-Escapesequenz ein.<br>
<tt>\h - </tt>Der Hostname ohne Domänenname.<br>
<tt>\H - </tt>Der gesamte Hostname, einschließlich Domänennamen.<br>
<tt>\n - </tt>Füge einen Zeilenumbruch ein.<br>
<tt>\t - </tt>Die aktuelle Zeit im 24-Stunden-Format HH:MM:SS.<br>
<tt>\u - </tt>Der Benutzername vom aktuellen Anwender.<br>
<tt>\w - </tt>Das momente Arbeitsverzeichnis.  $HOME wird als ,~'
dargestellt.<br>
<tt>\W - </tt>Der Basisname vom aktuellen Arbeitsverzeichnis.<br>
</blockquote>

(lese die Manualseite über
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ksh&amp;sektion=1">ksh(1)</a>
für weitere Details!)

<p>
Man könnte folgendes Kommando nutzen:
<blockquote><pre>
export PS1="\n\u@\H\n\w $ "
</pre></blockquote>
um einen recht ausgiebigen aber nützlichen Prompt zu bekommen.


<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ-Index]</a>
<a href= "faq9.html">[Zum Kapitel 9 - Zu OpenBSD migrieren]</a>
<a href= "faq11.html">[Zum Kapitel 11 - Leistungs-Tuning]</a>
</font>
<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt="[back]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br><small>
<!--
Originally [OpenBSD: faq10.html,v 1.114 ]
$Translation: faq10.html,v 1.1 2005/06/09 16:26:00 paldium Exp $
-->
$OpenBSD: faq10.html,v 1.1 2005/06/10 14:25:28 saad Exp $
</small>
</body>
</html>
