<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>6 - Netzwerk</title>
<link rev= "made" href="mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="resource-type" content="document">
<meta http-equiv="Content-Language" content="de">
<meta name="description" content="Die OpenBSD FAQ Seiten - FAQ 6: Netzwerk">
<meta name="keywords" content="openbsd,faq,Netzwerk,DNS,PPTP,NFS,PPP,DHCP,NAT,PF">
<meta name="distribution" content="global">
<meta name="copyright" content="This document copyright 1998-2003 by OpenBSD.">
</head>

<body bgcolor="#ffffff" text="#000000">
<!-- passes validator.w3.org, please keep it this way -->

<img SRC="../../images/smalltitle.gif" ALT="[OpenBSD]" height=30 width=141>
<font color="#0000e0">
<a href="index.html">[FAQ Index]</a>
<a href="faq5.html">[Zu Sektion 5 - Kernel Konfiguration und Festplatten-Setup]</a>
<a href="faq7.html">[Zu Sektion 7 - Tastaturkontrollen]</a>
</font>

<h2><font color="#E00000">6 - Netzwerk</font></h2>
<hr>

<h3>Inhaltsverzeichnis</h3>
<ul>

<li> <a href="#Intro"	>6.0.1 - Bevor wir weiter gehen</a></li>
<li> <a href="#Setup"	>6.1 - Erste Netzwerkeinstellungen</a></li>
<li> <a href="#PF"	>6.2 - Packet Filter (PF)</a></li>
<li> <a href="#NAT"	>6.3 - NAT - Network Address Translation</a></li>
<li> <a href="#DHCP"	>6.4 - DHCP - Dynamic Host Configuration Protocol</a></li>
<li> <a href="#PPP"	>6.5 - PPP - Point to Point Protocol</a></li>
<li> <a href="#Tuning"	>6.6 - Optimieren der Netzwerkparameter</a></li>
<li> <a href="#NFS"	>6.7 - NFS benutzen</a></li>
<li> <a href="#DNS"	>6.8 - DNS - Domain Name Service  - DNS, BIND und named</a>
<li> <a href="#PPTP"	>6.9 - Eine PPTP Verbindung mit OpenBSD aufbauen</a>
<li> <a href="#Bridge"   >6.10 - Aufsetzen einer Bridge mit OpenBSD</a>
</ul>

<hr>
<p>
<a name="Intro"></a>
<a name="6.0.1"></a>
<h2>6.0.1 - Bevor wir weiter gehen</h2>

<p>
F&uuml;r den Rest dieses Dokumentes sei gesagt, da&szlig; es hilfreich
ist, das Kapitel des FAQ <a href="faq5.html">Kernelkonfiguration und Einstellungen</a>
gelesen und zumindest teilweise verstanden zu haben, weiterhin helfen die
Manual Seiten <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a> und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&amp;sektion=1">netstat(1)</a>.
<p>
Wenn du ein Netzwerkadministrator bist und Routingprotokolle aufsetzt
und dein OpenBSD Rechner dein Router wird, dann solltest du dein Wissen
&uuml;ber IP Netzwerke mit 
<a href="http://www.3com.com/other/pdfs/infra/corpinfo/en_US/501302.pdf">
Understanding IP addressing</a>
vertiefen. Dies ist wirklich ein exzellentes Dokument. "Understanding IP addressing" 
beinhaltet grundlegendes Wissen, auf dem man beim IP Netzwerken aufbauen 
kann, insbesondere wenn man mit mehreren Netzwerken arbeitet oder f&uuml;r sie 
verantwortlich ist.
<p>
Wenn du mit Anwendungen wie Web-, FTP- oder Mailserver arbeitest, dann
k&ouml;nntest du viel vom Lesen der entsprechenden 
<a href="http://the.rfceditor.org/rfc.html">RFCs</a>
profitieren. Nat&uuml;rlich kannst du nicht alle lesen. Aber dennoch, lies
jene, die dich interessieren oder die du bei deiner Arbeit brauchen k&ouml;nntest.
Lies nach, wie alles funktionieren sollte. Die RFCs definieren mehrere (tausend)
Standards f&uuml;r Protokolle im Internet und wie sie arbeiten sollten.

<p>
<a name="Setup"></a>
<a name="6.1"></a>
<h2>
6.1 - Erste Netzwerkeinstellungen</h2>

<p>
<a name= "Setup.1"></a>
<a name="6.1.1"></a>
<h3>
6.1.1 - Identifzieren und Einstellen deiner Netzwerkkarten</h3>
Um beginnen zu k&ouml;nnen, mu&szlig;t du zun&auml;chst deine Netzwerkkarte
identifizieren k&ouml;nnen. Bei OpenBSD werden Netzwerkkarten nach ihrem
Typ, nicht nach Verbindungsart benannt. Du kannst sehen, ob deine 
Netzwerkkarte initialisiert wurde, entweder schon beim Booten oder auch 
sp&auml;ter mittels des Befehls 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)</a>. 
Weiterhin kannst du mit dem Befehl 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
deine Karte &uuml;berpr&uuml;fen. Als Beispiel hier die Ausgabe in
dmesg f&uuml;r eine Intel Fast Ethernet Netzwerk-Karte, die als 
Ger&auml;tenamen fxp hat.
<blockquote><pre>
fxp0 at pci0 dev 10 function 0 "Intel 82557" rev 0x0c: irq 5, address 00:02:b3:2b:10:f7
inphy0 at fxp0 phy 1: i82555 10/100 media interface, rev. 4
</pre></blockquote>
Wenn du deinen Ger&auml;te-Namen nicht weisst, sieh bitte in der 
<a href="../../de/plat.html">Liste der unterst&uuml;tzten Hardware</a> 
f&uuml;r deine Plattform nach. Du wirst eine Liste vieler bekannte Karten 
und ihre OpenBSD Ger&auml;te-Namen finden (wie etwa fxp), zusammen mit 
einer Nummer, die vom Kernel zugewiesen wird, und du hast den sogenannten 
"interface Name" (wie z.B. fxp0).
<p>

Du kannst herausfinden, ob deine Netzwerkkarte(n) erkannt wurde(n), indem 
du das 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
Kommando benutzt.
Das folgende Kommando zeigt uns alle Netzwerk-Interfaces im System.
Diese Beispielausgabe zeigt ein physikalisches Ethernet Interface, eine 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp&amp;sektion=4">fxp(4)</a>.

<p>
<blockquote><pre>
$ <b>ifconfig -a</b>
lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 33224
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x4
        inet6 ::1 prefixlen 128
        inet 127.0.0.1 netmask 0xff000000 
lo1: flags=8008&lt;LOOPBACK,MULTICAST&gt; mtu 33224
fxp0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        media: Ethernet autoselect (100baseTX full-duplex)
        status: active
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inet 10.0.0.38 netmask 0xffffff00 broadcast 10.0.0.255
        inet6 fe80::202:b3ff:fe2b:10f7%fxp0 prefixlen 64 scopeid 0x1
pflog0: flags=0&lt;&gt; mtu 33224
sl0: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt; mtu 296
sl1: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt; mtu 296
ppp0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500
ppp1: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500
tun0: flags=10&lt;POINTOPOINT&gt; mtu 3000
tun1: flags=10&lt;POINTOPOINT&gt; mtu 3000
enc0: flags=0&lt;&gt; mtu 1536
bridge0: flags=0&lt;&gt; mtu 1500
bridge1: flags=0&lt;&gt; mtu 1500
vlan0: flags=0&lt;&gt; mtu 1500
vlan1: flags=0&lt;&gt; mtu 1500
gre0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1450
gif0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif1: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif2: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif3: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
</pre></blockquote>

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a> 
gibt uns eine Menge mehr Informationen, als wir zu diesem Zeitpunkt 
ben&ouml;tigen. Nat&uuml;rlich sehen wir trotzdem unser Interface. Im 
obigen Beispiel ist die Netzwerkkarte bereits konfiguriert. Das ist 
offensichtlich, da auf fxp0 bereits ein IP Netzwerk konfiguriert ist, 
sprich die Werte &quot;inet 10.0.0.38 netmask 0xffffff00 broadcast 
10.0.0.255&quot;. 
Ausserdem sind die <strong>UP</strong> und <strong>RUNNING</strong> 
Flags gesetzt.

<p>
Schlussendlich f&auml;llt auf, das standardm&auml;ssig eine Menge mehr 
Interfaces aktiviert sind. Dies sind virtuelle Interfaces, die verschiedene 
Funktionen haben. Informationen dazu findest du auf den folgenden man 
pages:

<!-- XXXrelease -->
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lo&amp;sektion=4">lo</a> - Loopback Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflog&amp;sektion=4">pflog</a> - Packet Filter Logging Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sl&amp;sektion=4">sl</a> - SLIP Network Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=4">ppp</a> - Point to Point Protokoll
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tun&amp;sektion=4">tun</a> - Tunnel Network Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=enc&amp;sektion=4">enc</a> - Encapsulating Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4">bridge</a> - Ethernet Bridge Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vlan&amp;sektion=4">vlan</a> - IEEE 802.1Q Encapsulation Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gre&amp;sektion=4">gre</a> - GRE/MobileIP Encapsulation Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gif&amp;sektion=4">gif</a> - Generic IPv4/IPv6 Tunnel Interface
</ul>

Der 1. Schritt zur Konfiguration deiner Netzwerkkarte ist das Erstellen
der <b>/etc/hostname.xxx</b> Datei, wobei der Name deiner Karte den Platz
von xxx einnehmen sollte. Aus der Information der obigen Beispiele w&uuml;rde
der Name <b>/etc/hostname.fxp0 </b>lauten. Das Layout dieser Datei sollte
einfach so aussehen: <br>

<blockquote><pre>
address_family address netmask broadcast [weitere Optionen]
</pre></blockquote>
(Viel mehr Details zu dieser Datei findest du in der 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5">hostname.if(5)</a> man page.)

Eine typische Interface-Konfigurationsdatei f&uuml;r eine IPv4 Addresse 
w&uuml;rde so aussehen:
<blockquote><pre>
$ <b>cat /etc/hostname.fxp0
</b>inet 10.0.0.38 255.255.255.0 NONE
</pre></blockquote>

<p>
Du solltest auch den media type f&uuml;r Ethernet angeben, wenn du z.B. den
100baseTX full-duplex Modus erzwingen willst.
</p>

<blockquote><pre>
inet 10.0.0.38 255.255.255.0 NONE media 100baseTX mediaopt full-duplex
</pre></blockquote>

(Auf keinen Fall solltest du das tun, wenn nicht beide Seiten der 
Verbindungen auf Voll-Duplex gestellt sind ! Wenn du keine besonderen 
Anforderungen hast, kannst du diese media settings einfach ignorieren.)

<p>
Oder vielleicht willst du auch spezielle flags f&uuml;r ein einzelnes 
Interface benutzen. Das Format der Datei &auml;ndert sich dabei nicht 
besonders!
</p>

<blockquote><pre>
$ <strong>cat /etc/hostname.vlan0</strong>
inet 172.21.0.0 255.255.255.0 NONE vlan 2 vlandev fxp1
</pre></blockquote>

<p>
Der n&auml;chste Schritt ist das Einstellen deines Standard-Gateways (default gateway).
Dazu trag einfach die IP deines Gateways in die Datei <b>/etc/mygate</b> ein. 
Dies erlaubt das Aktivieren deines Gateways beim Starten. Jetzt solltest 
du deine Nameserver eintragen und die Datei <b>/etc/hosts</b> einrichten. 
F&uuml;r die Nameserver ben&ouml;tigst du eine Datei namens 
<b>/etc/resolv.conf</b>. Mehr &uuml;ber das Format dieser Datei findest 
du in der 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&amp;sektion=5&amp;format=html">resolv.conf(5)</a>
Manual Seite. F&uuml;r den Normalgebrauch ist hier ein Beispiel, in dem
deine Nameserver 125.2.3.4 und 125.2.3.5 sind. Du geh&ouml;rst zur Domain
&quot;deinedomaene.com&quot;.
</p>

<blockquote><pre>
$ <b>cat /etc/resolv.conf
</b>search deinedomaene.com
nameserver 125.2.3.4
nameserver 125.2.3.5
lookup file bind
</pre></blockquote>

<p>
Jetzt kannst du entweder rebooten oder das <b>/etc/netstart</b> Script
ausf&uuml;hren, indem du (als root) folgendes eingibst:
</p>

<blockquote><pre>
# <b>sh /etc/netstart
</b>writing to routing socket: File exists
add net 127: gateway 127.0.0.1: File exists
writing to routing socket: File exists
add net 224.0.0.0: gateway 127.0.0.1: File exists
</pre></blockquote>

<p>
Dabei werden ein paar Fehlermeldungen ausgegeben. Indem du dieses Skript ausf&uuml;hrst, 
versuchst du ein paar Sachen zu konfigurieren, die bereits konfiguriert sind. 
Daher existieren bereits bereits einige der Routen in der kernel routing table. 
Von hier ab sollte dein System laufen und online sein. Du kannst hier erneut mit 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a> 
pr&uuml;fen, ob deine Interfaces richtig konfiguriert wurden.
Deine Routen kannst via
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&amp;sektion=1">netstat(1)</a> oder 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=route&amp;sektion=8">route(8)</a> 
&uuml;berpr&uuml;fen.
Wenn du Probleme mit dem Routing hast, m&ouml;chtest du vielleicht
das -n Flag f&uuml;r route(8) benutzen, dass die IP-Adressen ausgibt, statt 
einen DNS Lookup zu machen, und den Hostnamen anzuzeigen.
Hier ist ein Beispiel mit beiden Kommandos:
</p>

<blockquote><pre>
$ <strong>netstat -rn</strong>
Routing tables

Internet:
Destination        Gateway            Flags     Refs     Use    Mtu  Interface
default            10.0.0.1           UGS         0       86      -  fxp0
127/8              127.0.0.1          UGRS        0        0      -  lo0
127.0.0.1          127.0.0.1          UH          0        0      -  lo0
10.0.0/24          link#1             UC          0        0      -  fxp0
10.0.0.1           aa:0:4:0:81:d      UHL         1        0      -  fxp0
10.0.0.38          127.0.0.1          UGHS        0        0      -  lo0
224/4              127.0.0.1          URS         0        0      -  lo0

Encap:
Source             Port  Destination        Port  Proto SA(Address/SPI/Proto)
$ <strong>route show</strong>
Routing tables

Internet:
Destination      Gateway            Flags
default          10.0.0.1           UG
127.0.0.0        LOCALHOST          UG
localhost        LOCALHOST          UH
10.0.0.0         link#1             U
10.0.0.1         aa:0:4:0:81:d      UH
10.0.0.38        LOCALHOST          UGH
BASE-ADDRESS.MCA LOCALHOST          U
</pre></blockquote>

<p>
<a name= "Setup.2"></a>
<a NAME="6.1.2"></a>
<h3>
6.1.2 - Einrichten deines OpenBSD Rechners als Gateway</h3>
<p>
Dies sind nur die grundlegende Informationen, um deinen OpenBSD Rechner als
Gateway (auch Router genannt) einzurichten. Wenn du OpenBSD als Router
im Internet verwenden willst, solltest du auch die unten folgenden Packet Filter
Instruktionen beachten, um potentiell sch&auml;dliche IP Daten zu blockieren.
Auch solltest du wegen der Knappheit an 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4">IPv4</a> 
Adressen die Informationen bez&uuml;glich Network Address Translation beachten, 
um deinen IP Adressbereich zu schonen.
</p>

<p>
Der GENERIC Kernel hat bereits die F&auml;higkeit f&uuml;r IP Forwarding,
aber dies mu&szlig; erst eingeschaltet werden. Du solltest dies mit 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
tun. Um diese &Auml;nderung permanent einzutragen, mu&szlig;t du die Datei
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5">/etc/sysctl.conf</a>
editieren. F&uuml;ge einfach folgende Zeile in diese Konfigurationsdatei
ein.
</p>

<blockquote><pre>
net.inet.ip.forwarding=1
</pre></blockquote>

<p>
Ohne Reboot kannst du dies auch direkt mit 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a> 
durchf&uuml;hren. Beachte aber, da&szlig; diese &Auml;nderung nach einem Reboot weg ist und
dass der folgende Befehl als root ausgef&uuml;hrt werden mu&szlig;.
</p>

<blockquote><pre>
# <b>sysctl -w net.inet.ip.forwarding=1
</b>net.inet.ip.forwarding: 0  -&gt; 1
</pre></blockquote>

<p>
Nun modifiziere die Routen der anderen Hosts. Es gibt viele verschiedene
M&ouml;glichkeiten, OpenBSD als Router einzusetzen, z. B. mittels Software
wie <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=routed&amp;sektion=8">routed(8)</a>,
<a href="http://www.gated.org">gated</a>, <a href="http://www.mrtd.net">mrtd</a>, 
und <a href="http://www.zebra.org">zebra</a>.
OpenBSD hat Unterst&uuml;tzung
in der ports Kollektion sowohl f&uuml;r gated, zebra als auch mrtd. OpenBSD unterst&uuml;tzt
mehrere T1, HSSI, ATM, FDDI, Ethernet und serielle (PPP/SLIP) Schnittstellen.
</p>

<p>
<a name= "Setup.3"></a>
<a NAME="6.1.3"></a>
<h3>
6.1.3 - Einrichten von Aliases auf deiner Netzwerkkarte</h3>
<p>
OpenBSD hat einen einfachen Mechanismus, um IP Aliase f&uuml;r deine Netzwerk-Karten
zu setzen. Dazu musst du einfach die Datei
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5"><i>/etc/hostname.&lt;if&gt;</i></a>
editieren. Sie wird beim Booten vom
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&amp;sektion=8">/etc/rc(8)</a> Skript gelesen,
das ein Teil der <a href="../faq10.html#rc">rc startup
Hierarchie</a> ist. F&uuml;r dieses Beispiel nehmen wir an, der User hat ein Interface
<b>dc0</b>  und befindet sich im Netzwerk 192.168.0.0. Weitere wichtige Informationen:
</p>

<ul>
<li>
IP f&uuml;r dc0 ist 192.168.0.2</li>
<li>
NETMASK ist 255.255.255.0</li>
</ul>

<p>
Ein paar Bemerkungen zu Aliasen: Bei OpenBSD verwendet man nur den Adapternamen. 
Es gibt keine Unterschiede zwischen dem ersten und dem zweiten Alias. 
Daher mu&szlig; man sie nicht - wie in einigen anderen Betriebssystemen - 
als dc0:0, dc0:1 bezeichnen.
Wenn du dich auf einen speziellen IP Alias beziehst oder einen hinzuf&uuml;gst, 
dann nimm "<tt>ifconfig int alias</tt>" anstelle nur "<tt>ifconfig int</tt>" 
auf der Befehlszeile. Du kannst Aliase mit "<tt>ifconfig int delete</tt>" 
l&ouml;schen. 
<p>

Angenommen du verwendest mehrere IP Adressen im selben IP Subnetz mit Aliases, 
dann ist die Netzmaskeneinstellung f&uuml;r jeden Alias 255.255.255.255.
Sie m&uuml;ssen nicht der Netzmaske der ersten IP der Netzwerkkarte folgen. 
In diesem Beispiel <i>/etc/hostname.dc0</i> werden zwei Aliase zur Netzwerkkarte 
dc0 hinzugef&uuml;gt, die als 192.168.0.2 mit Netzmaske 255.255.255.0 
konfiguriert wurde.

<blockquote><pre>

# <b>cat /etc/hostname.dc0</b>
inet 192.168.0.2 255.255.255.0 media 100baseTX
inet alias 192.168.0.3 255.255.255.255 
inet alias 192.168.0.4 255.255.255.255 
</pre></blockquote>


<p>
Wenn du einmal diese Datei erstellt hast, ben&ouml;tigst du einen Reboot,
um die &Auml;nderung automatisch durchf&uuml;hren. Du kannst aber auch
die Aliase manuell mit 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
hochbringen. F&uuml;r den ersten Alias geht das so:
</p>


<blockquote><pre>
# <b>ifconfig dc0 inet alias 192.168.0.3 netmask 255.255.255.255</b>
</pre></blockquote>

<p>
Um die Aliases zu sehen:
</p>

<blockquote><pre>
$ <b>ifconfig -A</b>
dc0: flags=8863&lt;UP,BROADCAST,NOTRAILERS,RUNNING,SIMPLEX,MULTICAST&gt;
        media: Ethernet manual
        inet 192.168.0.2  netmask 0xffffff00 broadcast 192.168.0.255
        inet 192.168.0.3 netmask 0xffffffff broadcast 192.168.0.3
</pre></blockquote>

<p>
<a NAME="6.2"></a>
<a name= "PF"></a>
<h2>6.2 - Packet Filter (PF)</h2>
<!-- XXXrelease -->
<p>

<h4>Hinweis:  Ab OpenBSD 3.2 sind die Funtionen von <i>/etc/nat.conf</i>
in <i>/etc/pf.conf</i> eingebaut worden, die beiden Dateien somit 
verschmolzen. 
</h4>

<p>
Die neue
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5"><i>/etc/pf.conf</i></a>
Datei hat vier Teile:

<ul>
<li><b>Options:</b> Verschiedene Optionen, um das Verhalten von PF zu kontrollieren.
<li><b>Scrub:</b> &Uuml;berarbeitung von Paketen zur Normalisierung und Defragmentierung.
<li><b><a href="#NAT">NAT and Redirection Rules:</a></b> NAT erlaubt 
  den Zugang von vielen Maschinen durch eine IP-Adresse. Redirection erlaubt
  hereinkommende Anfragen an eine bestimmte Maschine hinter dem NAT weiterzuleiten.
<li><b>Filter Rules:</b> Erlaubt das selektive Filtern oder Blocken von Paketen, die 
   &uuml;ber eines der Interfaces laufen.
</ul>

Keine dieser Sektionen muss existieren, aber wenn, dann m&uuml;ssen sie
in der oben genannten Reihenfolge sein.


<p>
Das Packet Filter Subsystem wurde erstellt, um zwei Dinge zu tun: die Rechte von
Forwarding auf Paketlevel zu setzen und zu &uuml;berpr&uuml;fen (Paketfilter)
und das mapping von Hosts/Subnetzen zu einer Reihe von externen Adressen zu steuern
(NAT).
Die Konfigurationsdateien f&uuml;r diese zwei Dienste sind
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5">/etc/pf.conf(5)</a></i> 
und 
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nat.conf&amp;sektion=5">/etc/nat.conf(5)</a></i>.

<p>
Um diese Dienste auf deinem System zu starten, musst du die Datei
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&amp;sektion=8">/etc/rc.conf(8)</a></i>
editieren und die Zeile wie folgt setzen:
</p>

<blockquote><pre>
pf=YES
</pre></blockquote>

<p>
Wenn du NAT benutzt, musst du h&ouml;chstwahrscheinlich auch den
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
Wert <tt>net.inet.ip.forwarding</tt> auf 1 setzen. Das kannst du machen, indem die
relevanten Zeilen in der Datei
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5">/etc/sysctl.conf(5)</a></i>
&auml;nderst und deinen Computer rebootest.

<p>
Wenn du Packet Filter in deinen Kernel einkompiliert hast, aber es nicht in deiner
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&amp;sektion=8">/etc/rc.conf(8)</a></i>
Datei aktiviert hast, kannst du das mit dem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pfctl&amp;sektion=8">pfctl(8)</a> Befehl
nachholen.
<p>

<blockquote><pre>
# <b>pfctl -R /etc/pf.conf</b>
# <b>pfctl -N /etc/nat.conf</b>
# <b>pfctl -e</b>
</pre></blockquote>

Die erste Zeile setzt den Filter mittels <i>/etc/pf.conf</i> und die zweite
aktivert das NAT mit den Regeln aus <i>/etc/nat.conf</i> (mehr zu NAT sp&auml;ter
in <a href="#NAT">Sektion 6.3, NAT</a>), und zuletzt aktiviert die letzte Zeile
PF.
</p>
Das kann man auch in einer einzigen Zeile kombinieren.

<blockquote><pre>
# <strong>pfctl -R /etc/pf.conf -N /etc/nat.conf -e</strong>
</pre></blockquote>

<p>
Wenn du &Auml;nderungen an <i>/etc/pf.conf</i> vornimmst, nachdem du
PF gestartet hast, kannst du deine Regeln neu laden, indem du die passende
Datei neu l&auml;dst:
<blockquote><pre>
# <b>pfctl -R /etc/pf.conf</b>
</pre></blockquote>

<p>
Dieses Dokument wird einige grundlegende
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5">pf.conf(5)</a>
und <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nat.conf&amp;sektion=5">nat.conf(5)</a> 
Konfigurationen weiter unten behandeln.  Du kannst dir auch das <a href="#sample_pf.conf">resultierende 
ruleset</a> ansehen, mit all den Anpassungen, die unten im Details erkl&auml;rt sind.
Weitere Packet Filter Informationen finden sich auf der
<a href="http://www.benzedrine.cx/pf.html">Packet Filter web site</a> 
und im
<a href="http://www.inebriated.demon.nl/pf-howto/">Packet Filter HOWTO</a>. 

<p>
<h3>Packet Filter</h3>

<p>
Um den Packet Filter beim Booten zu aktivieren, musst du
<i>/etc/rc.conf</i> so anpassen, dass dann <tt>pf=YES</tt> enthalten ist. Packet Filter (pf)
wird von <i>/etc/pf.conf</i> kontrolliert, das beim Booten gelesen wird. 
Eine detailliertere Erkl&auml;rung bekommt man hier:
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5">pf.conf(5)</a>. 
In den folgende Beispielen wird <tt>fxp0</tt> das externe Interface zum Internet hin
darstellen. Abh&auml;ngig von deinen Netzwerkkarten in deinem Computer wird
das bei dir nat&uuml;rlich anders sein. Diese Regeln gehen von einer full-time 
Internetverbindung aus, wie man sie z.B. bei einem Webserver hat.
<p>

Packet Filter Regeln werden sequentiell vom Anfang bis zum Schluss abgearbeitet; 
das hilft jedes Paket beim Passieren jeder Regel zu beobachten, bevor es
dann seinen Zielort erreicht.

<p>Z. B. erlauben die Standardregeln, da&szlig; alle Pakete rein und raus
d&uuml;rfen:

<blockquote><pre>
pass out all 
pass in all
</pre></blockquote>

Das ist die Kurzform von:
<blockquote><pre>
pass in from any to any
pass out from any to any
</pre></blockquote>

was man auch auffassen kann als &quot;lasse alle hereinkommenden Pakete von jeder Quelle 
zu jedem Ziel passieren&quot;, mit einem eingebauten &quot;auf jedem Interface (was immer 
angenommen wenn kein Interface sepzifiziert wird) f&uuml;r jede Adress-Familie
, <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inet&amp;sektion=4">inet (v4)</a> oder <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inet6&amp;sektion=4">inet6 (v6)</a>&quot;.
<p>
Das ist nat&uuml;rlich noch kein wirklicher Filter. N&uuml;tzlichere Filter basieren auf 
der Address-Familie (IPv4 oder IPv6), Protokoll(en) 
und Port(s), die von den Diensten genutzt werden, die gefiltert werden sollen.
Jedes der in 
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=protocols&amp;sektion=5">/etc/protocols(5)</a></i>
aufgef&uuml;hrten Protokolle kann entweder mit Namen oder Nummer angegeben werden, wir werden
uns allerdings nur mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcp&amp;sektion=4">tcp(4)</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=udp&amp;sektion=4">udp(4)</a> und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp&amp;sektion=4">icmp(4)</a>
befassen.

<p>
Nun nehmen wir mal an, wir wollten keinerlei eingehende Verbindung zum
TCP Port 3306 (MySQL) zulassen, weil die Datenbank nur von
localhost aus erreichbar sein soll. Unser "ruleset" w&uuml;rde dann wie folgt aussehen:
<ul>
pass out all
pass in all
block in on fxp0 inet proto tcp from any to any port 3306
</ul>

Das bedeutet &quot;blocke alle hereinkommenden IPv4 (inet) Pakete von jeder Quelle
zu jeglichem Ziel mit dem Zielport 3306.&quot;  Es ist notwendig, dass du bei jedem
port-basiertem Filter ein Protokoll angibst und die Adress-Familie spezifizierst.
Dienste, die in der Datei
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=services&amp;sektion=5">/etc/services(5)</a>
definiert sind, kannst du auch einfach bei ihrem Namen nennen, wie z.B. <em>www</em>
oder <em>mysql</em>.
Ein Paket, das in Richtung des TCP Port 3306 auf Interface 
<tt>fxp0</tt> hereinkommt, wird die erste &quot;pass in&quot; Regel noch passieren, und
dann von der &quot;block 
in port 3306&quot; Regel geblockt werden. Wenn du die Reihenfolge deiner "incoming" Regeln 
umgedreht hast (denke immer daran, die Reihenfolge ist wichtig):

<blockquote><pre>
pass out all
block in on fxp0 inet proto tcp from any to any port 3306
pass in all
</pre></blockquote>

Pakete, die an den TCP Port 3306 adressiert sind, w&uuml;rden dann passieren, da die letzte Regel
es allen Paketen erlaubt, den Filter zu passieren. Es ist wichtig, dass im Auge zu behalten,
wenn man Filter-Regeln schreibt:
<b>Die letzte passende Regel gibt den Ausschlag</b>.

<p>
Nat&uuml;rlich gibt es jeder Regel eine Ausnahme, so auch hier. Die <em>quick</em> 
Option z.B. l&auml;sst das Paket schickt das Paket gem&auml;ss der ersten daf&uuml;r passenden 
Regel weiter. Sehen wir uns mal unser obiges, fehlerhaftes Beispiel an, wenn wir
<em>quick</em> zur &quot;block in&quot; Regel hinzuf&uuml;gen:

<blockquote><pre>
pass out all
block in quick on fxp0 inet proto tcp from any to any port 3306
pass in all
</pre></blockquote>

<p>
Ein Paket, dass an unseren Host und den TCP Port 3306 adressiert ist, trifft zuerst auf die
&quot;block in quick&quot; Regel und wird sofort verworfen. Alle Pakete, die an andere Ports
oder Protokolle adressiert sind, finden keine passende Regel, bis sie unsere 
&quot;pass in&quot; Regel erreichen, die allen Paketen das Passieren gestattet.
<p>

<b>Standardm&auml;&szlig;iges Ablehnen</b>
<p> 

Die sicherste Paketfilter "policy" ist ein standardm&auml;ssiges Ablehnen.
Jeglicher Traffic, der nicht explizit erlaubt ist, wird abgelehnt.
Diese Policy ist bedeutend sicherer als jeden einzelnen zu sch&uuml;tzenden Dienst abzusichern, 
erlaubt kleinere Regelwerke, und sch&uuml;tzt auch vor einem m&ouml;glicherweise falsch
konfiguriertem Dienst, der f&auml;lschlicherweise vergessen wurde.
<p>

Sehen wir uns nun ein weiteres Beispiel-Regelwerk (ruleset) Zeile f&uuml;r Zeile an.
Hier ein Beispiel f&uuml;r einen Webserver mit einer Standard-Ablehnungs-Policy, die
SSH Verbindungen zul&auml;sst (zum Administrieren) und Verbindungen auf http (port 80) und https 
(port 443).

<blockquote><pre>
block in on fxp0 from all
pass  in on fxp0 inet proto tcp from any to any port 22
pass  in on fxp0 inet proto tcp from any to any port 80
pass  in on fxp0 inet proto tcp from any to any port 443
pass out on fxp0 from all
</pre></blockquote>

<p>
Das wir eingehende Verbindungen von &uuml;berall zu den Ports
22(ssh), 80(http) und 443(https) erlauben. Alle anderen Verbindungsversuche
wurden fallengelassen, und alle ausgehenden Verbindungen erlaubt. 
Das ist schon ein recht strenges Regelwerk. Aber was, wenn nur interne
Hosts aus deinem 1.1.1.0 Address-Block Zugriff auf SSH haben sollen, aber
HTTP und HTTPS von &uuml;berall aus erreichbar sein sollen ?

<blockquote><pre>
block in on fxp0 from all
pass  in on fxp0 inet proto tcp from 1.1.1.0/24 to any port 22
pass  in on fxp0 inet proto tcp from any to any port 80
pass  in on fxp0 inet proto tcp from any to any port 443
pass out on fxp0 from all
</pre></blockquote>
Recht nett, aber wenn nur eine einzige Machine (1.1.1.1) den Webserver
administrieren darf? In diesem Fall &auml;ndern wir dies:
<blockquote><pre>
pass  in on fxp0 inet proto tcp from 1.1.1.0/24 to any port 22
</pre></blockquote>
in:
<blockquote><pre>
pass  in on fxp0 inet proto tcp from 1.1.1.1/32 to any port 22
</pre></blockquote>
<p>

<b>Beispielregeln</b>
<p>
Hier sind einige gute Regeln, die fast jeder gebrauchen kann (Mit der Annahme, dass
fxp0 das externe Interface mit der Anbindung ins Internet ist). Zuerst schaffen
einen einfachen Schutz gegen "address spoofing". Diese Adressen sollten normalerweise 
nicht im Internet herumfliegen, und wenn doch, ist das nicht gut, also 
blocken wir sie:
<blockquote><pre>
block out quick on fxp0 inet from any to { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 } to any
block out quick on fxp0 inet from any to { 127.0.0.0/8, 192.168.0.0/16, \ 
172.16.0.0/12, 10.0.0.0/8 }
</pre></blockquote>

Unser Regelwerk sieht schon recht gut aus; wenn wir alles zusammentun, sieht
das ganze wie folgt aus:

<blockquote><pre>
# adress spoofing wird geblockt
block in quick on fxp0 inet from { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 } to any
block out quick on fxp0 inet from any to { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 }
 
# nur unsere Administrationsmaschine darf sich auf ssh verbinden
pass in quick on fxp0 inet proto tcp from 1.1.1.1/32 to any port 22
 
# andere duerfen http und https erreichen
pass in quick on fxp0 inet proto tcp from any to any port 80
pass in quick on fxp0 inet proto tcp from any to any port 443
 
# den Rest mit einem pauschalen block ausschliessen
block in quick on fxp0 from any to any
 
# und ausgehenden Traffic rauslassen
pass out on fxp0 from any to any
</pre></blockquote>
 
<b>Packet Logging</b>
<p>Nun, dies ist zwar schon recht gut, aber es k&ouml;nnte besser sein.
Was, wenn wir z.B. alle Verbindungsversuche zu Port 22(ssh) loggen wollten,
die von unserer Firewall blockiert werden? Einfach - daf&uuml;r hat Packet Filter 
das <em>log</em> Stichwort:

<blockquote><pre>
pass in quick on fxp0 inet proto tcp from 1.1.1.1/32 to any port 22
block in log quick on fxp0 inet proto tcp from any to any port 22
</pre></blockquote>

Diese Regel wird erlauben, da&szlig; sich unser Administrationsrechner
auf Port 22 verbinden darf, aber alle anderen Verbindungsversuche auf Port
22 ablehnt und aufzeichnet.

Pakete, die geloggt wurden (also die mitprotokolliert worden sind) werden 
zum pflog0 Interface gesendet, das wiederum vom
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8">pflogd(8)</a>,
&uuml;berwacht wird, der normalerweise die Pakete im
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcpdump&amp;sektion=8">tcpdump(8)</a>
Bin&auml;rformat in die Datei <i>/var/log/pflog</i> schreibt. Der pflogd(8) wird 
standarm&auml;ssig in
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&amp;sektion=8">/etc/rc(8)</a></i>
gestartet, wenn pf in
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&amp;sektion=8">/etc/rc.conf(8)</a></i>.
eingeschaltet ist.
Lesen kannst du diese Logfiles wie folgt:
<blockquote><pre>
# <b>tcpdump -n -e -ttt -r /var/log/pflog</b>
</pre></blockquote>

Man sollte wissen, dass die Benutzung von tcpdump KEINE real-time Anzeige der pflog Datei 
erm&ouml;glicht. Die kann man aber wie folgt bekommen:

<blockquote><pre>
# <b>tcpdump -i pflog0</b>
</pre></blockquote>

Man k&ouml;nnte tcpdump auch benutzen, um den Focus beim Debugging zu sch&auml;rfen:
<blockquote><pre>
# <b>tcpdump -e -i pflog0 port 80</b>
</pre></blockquote>

Wenn man das eingibt, hat das KEINEN Einfluss auf die Daten, die in die Datei
<i>/var/log/pflog</i> geschrieben werden.  
<p>

Wenn man seine Logdateien untersucht, sollte man besondere Aufmerksamkeit 
auf das "verbose protocol decoding" von tcpdump richten (wird mittels der -v 
Kommandzeilen Option aktiviert). Tcpdump's protocol decoder haben keine
perfekte Sicherheitshistorie.  Zumindest in der Theorie ist ein 
verz&ouml;gerter Angriff &uuml;ber die "partial packet payloads" denkbar,
der vom Logging-Device aufgezeichnet wird.
<p>
Auch wer &uuml;berhaupt Zugriff auf die Logs hat, sollte man genau pr&uuml;fen. Pflogd
greift sich 96 Bytes des Paketes und loggt es. Zugriff auf die Logs kann teilweisen
Zugriff auf sensible Teile von Paketen bedeuten (wie z.B. bei
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=telnet&amp;sektion=1">telnet(1)</a> oder
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftp&amp;sektion=1">ftp(1)</a> Logins).

<p>
<b>Packet Logging mittels syslog</b>
<p>
In vielen Situationen ist es w&uuml;nschenswert, die Firewall-Logs im
ASCII Format zu haben und/oder sie an einen remote logging Server zu senden.
All das kann man mittels 2 kleinen Shell-Skripten und geringf&uuml;gigen
&Auml;nderungen an den OpenBSD-Konfigurationsdateien erreichen.

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=syslogd&amp;sektion=8&amp;manpath=OpenBSD+3.2">Syslogd(8)</a>
ist der Standard-Daemon f&uuml;r das logging, er loggt in ASCII und ist 
auch in der Lage, die Logs an einen anderen, entfernten Log-Server zu 
senden.

<p>
Zuerst m&uuml;ssen wir einen User namens <em>pflogger</em> mit einer 
.nologin. Shell erzeugen. 
Der einfachste Weg dazu ist
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser&amp;sektion=8&amp;manpath=OpenBSD+3.2">adduser(8)</a>.

<p>
Nach dem Erzeugen des Users <em>pflogger</em> erzeuge die folgenden
zwei Skripte:

<p>
<i>/etc/pflogrotate</i>

<blockquote><pre>
FILE=/home/pflogger/pflog5min.$(date "+%Y%m%d%H%M")
kill -ALRM $(cat /var/run/pflogd.pid)
if [ $(ls -l /var/log/pflog | cut -d " " -f 8) -gt 24 ]; then
        mv /var/log/pflog $FILE
        chown pflogger $FILE
        kill -HUP $(cat /var/run/pflogd.pid)
fi
</pre></blockquote>


<p>
<i>/home/pflogger/pfl2sysl</i>

<blockquote><pre>
#!/bin/sh
# feed rotated pflog file(s) to syslog
for logfile in /home/pflogger/pflog5min* ; do
        tcpdump -n -e -ttt -r $logfile | logger -t pf -p local0.info
        rm $logfile
done
</pre></blockquote>

<p>
Editiere den cron job f&uuml;r den User <em>root</em>

<blockquote><pre>
# <b>crontab -u root -e</b>
</pre></blockquote>

<p>
und f&uuml;ge die folgende zwei Zeilen ein:

<blockquote><pre>
# rotate pf log file every 5 minutes
0-59/5 *       *       *       *       /bin/sh /etc/pflogrotate
</pre></blockquote>

<p>
Erzeuge einen cron job f&uuml;r den User <em>pflogger</em>

<blockquote><pre>
# <b>crontab -u pflogger -e</b>
</pre></blockquote>

<p>
und f&uuml;ge die folgende zwei Zeilen ein:

<blockquote><pre>
# feed rotated pflog file(s) to syslog
0-59/5 *       *       *       *       /bin/sh /home/pflogger/pfl2sysl
</pre></blockquote>

<p>
F&uuml;ge die folgende Zeile in <i>/etc/syslog.conf</i> ein:

<blockquote><pre>
local0.info    /var/log/pflog.txt
</pre></blockquote>

<p>
Wenn du zu einem entfernten Log-Server loggen willst, musst du ausserdem
folgende Zeile einf&uuml;gen:

<blockquote><pre>
local0.info    @syslogger
</pre></blockquote>

<p>
und stelle sicher, dass der Host <i>syslogger</i> in der Datei
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hosts&amp;sektion=5&amp;manpath=OpenBSD+3.2">
/etc/hosts(5)</a> definiert wurde.

<p>
Alle geloggten Pakete werden nun nach <i>/var/log/pflog.txt</i> gesendet.
Wenn man die zweite Zeile hinzuf&uuml;gt, werden sie alle zum entfernten
Logging Host <i>syslogger</i> geschickt.

<p>
<i>/etc/pflogrotate</i> verarbeitet nun und l&ouml;scht dann <i>/var/log/pflog</i>,
so dass eine Rotation von <i>pflog</i> mittels
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newsyslog&amp;sektion=8&amp;manpath=OpenBSD+3.2">
newsyslogd(8)</a> nicht mehr notwendig und daher abgeschaltet werden sollte.
Trotzdem ersetzt <i>/var/log/pflog.txt</i> <i>/var/log/pflog</i> und 
seine Rotation sollte daher aktiviert werden.
&Auml;ndere <i>/etc/newsyslog.conf</i> wie folgt:

<blockquote><pre>
#/var/log/pflog        600     3       250     *       ZB      /var/run/pflogd.pid
/var/log/pflog.txt     600     7       *       24
</pre></blockquote>

<p>
Pf wird nun im ASCII-Format nach /var/log/pflog.txt loggen. Wenn es so 
in <em>/etc/syslog.conf</em> konfiguriert ist, wird es das Logfile
auch zu einem anderen Log-Server schicken.
Das Logging geht nicht sofort los, sondern es dauert etwa 5-6 Minuten
(dem cron-Job-Intervall) bis die geloggten Pakete in der Datei
erscheinen.

<p>
<b>Multiple Protokolle</b>
<p>
Was aber, wenn wir Verbindungen zu einem Dienst erlauben wollen, der
&uuml;ber mehrere Protokolle l&auml;uft, wie z.B. BIND, der TCP und 
UDP benutzt ?
Mit Packet Filter kannst du mehrere Regeln zu einer zusammenfassen
(mehr dazu sp&auml;ter): 
<blockquote><pre>
# Passierenlassen von DNS traffic f&uuml;r BIND
pass in quick on fxp0 inet proto { tcp, udp } from any to any port 53
</pre></blockquote>

Beachte die Spaces (Leerzeichen) auf beiden Seiten der '{ }' Zeichen. Das
ist viel netter, als die Variante, die du sonst benutzen m&uuml;sstest:

<blockquote><pre>
pass in quick on fxp0 inet proto tcp from any to any port 53
pass in quick on fxp0 inet proto udp from any to any port 53
</pre></blockquote>



<p>
<a name="normalization"></a>
<b>Packet Normalization</b>
<p> 
Packet Normalization bedeutet das erneute Zusammenf&uuml;gen von 
fragmentierten Paketen und das Leeren der IP Options.
Einige BSs und Applikationen haben Schwierigkeiten mit anormalen und
fragmentierten Paketen, und daher ist es im allgemeinen richtig und gut
Pakete von den Filter-Regeln normalisieren zu lassen.
Das macht man mit Hilfe der <b>scrub</b> Direktive, die man wie folgt benutzt:
<blockquote><pre>
scrub in all
</pre></blockquote>
Das f&uuml;gt dem System eine minimale zus&auml;tzliche Last hinzu, 
und verlangt ein wenig Speicher, um die Paket-Fragmente zu cachen. 
Die Vorteile von Packet Normalization wiegen diesen kleinen Nachteil
jedoch fast jedesmal aus.

<p>
<b>IP Optionen</b>

<p>
PF blockt standardm&auml;ssig Pakete, deren IP Optionen gesetzt sind. Das kann die Arbeit
von &quot;OS fingerprinting&quot; Werkzeugen wie nmap erschweren.
Wenn du eine Anwendung hast, die das Passierenlassen solcher Pakete erfordert, wie z.B.
multicast oder IGMP, kannst du die
<b>allow-opts</b>
Direktive benutzen:

<blockquote><pre>
pass in quick on fxp0 all allow-opts
</pre></blockquote>

<p>
<b>TCP Flags, bestehende Verbindungen und keep state</b>
<p>
Packet Filter kann also Pakete auf Basis von TCP flags filtern und 
kann bereits bestehende Verbindungen verfolgen und den Status
der Verbindungen ebenso. Es wird also empfohlen, dass alle User, die
Paketen auf Basis von TCP flags filtern wollen, die Rolle jedes einzelnen
flags auch wirklich verstehen.
Wenn du z.B. alle Pakete ablehnen willst, die die FIN, URG, und PSH 
flags gesetzt haben (wie z.B. ein nmap OS fingerprinting Versuch) 
k&ouml;nntest du dazu ein Regel wie diese hier verwenden:

<blockquote><pre>
block in quick on fxp0 inet proto tcp from any to any flags FUP/FUP
</pre></blockquote>

(Danke an <a href="mailto:halogen@nol.net">Kyle Hargraves</a> f&uuml;r
diesen Tip)

Der n&auml;chste coole Trick von Packet Filter ist seine F&auml;higkeit,
sich den Zustand eine Verbindung zu merken (sog. stateful filtering). 
Den "state" (Status) zu verwalten oder zu halten, wurde zum Beispiel 
als &quot;nichts sagen, bis man angesprochen wird&quot; beschrieben, 
oder in anderen Worten: sobald eine Verbindung einmal hergestellt wurde, 
m&uuml;ssen Pakete nicht mehr die ganzen Regeln passieren.
Das ist ein sehr m&auml;chtiges Feature, das es erlaubt viel einfachere
und dennoch sicherere Regeln zu schreiben.

<p>
Als Beispiel sehen wir uns mal an, wie wir "state" in unser bisheriges Regelwerk einbauen 
k&ouml;nnen (na, schon verwirrt?). Zur Wiederholung: Wir erlauben administrativen Zugriff
aus unserem Class C-Netz auf port 22 (ssh) und erlauben hereinkommenden Web-Traffic auf den
Port 80(http) und 442 (https). Alles andere wird abgeblockt. Was aber, wenn ich z.B.
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh&amp;sektion=1">ssh(1)</a>
vom Webserver wonaders hin machen will ?
Was, wenn ich 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lynx&amp;sektion=1">lynx(1)</a> 
benutzen muss, um etwas in den FAQs nachzulesen ? Nunja, das kann ich 
zun&auml;chst nicht, weil ich ja allen einkommenden Traffic bis auf die
angebenen Ports geblockt habe. W&auml;hrend das nat&uuml;rlich das sicherste ist,
ist es mit Sicherheit auch ziemlich unbequem.
Indem man die Worte 
<em>keep state</em> in unsere &quot;pass 
out&quot; Regel einf&uuml;gt, erlauben wir automatisch, dass eingehende Pakete,
die Antworten auf unsere ausgehenden Verbindungsaufbauten sind, passieren d&uuml;rfen,
wie z.B. beim Web-Browsen. Denke daran, wir m&uuml;ssen nicht angeben, f&uuml;r welches
Protokoll wir "keep state" einbauen.

<blockquote><pre>
block in  on fxp0 inet proto tcp all
pass  in  on fxp0 inet proto tcp from 1.1.1.0/24 to any port 22 keep state
pass  in  on fxp0 inet proto tcp from any to any port 80 keep state
pass  in  on fxp0 inet proto tcp from any to any port 443 keep state
pass  out on fxp0 inet proto tcp all keep state
</pre></blockquote>
<p>
Diese kleine &Auml;nderung wird die Flexibilit&auml;t und Sicherheit unseres
Regelwerkes erheblich erh&ouml;hen: Zum Beispiel erlauben wir im Regelwerk
oben allen TCP traffic zu den Ports 80 &amp; 442. Das k&ouml;nnen wir noch 
weiter einschr&auml;nken. Um den Aufbau einer TCP Verbindung zu erlauben,
m&uuml;ssen wir nur den anf&auml;nglichen Handshake zulassen; nachdem
das geschehen ist, k&ouml;nnen wir den Traffic zu diesem Port blocken und
es "keep state" &uuml;berlassen, die Verbindung zu managen.
Um den anf&auml;nglichen Handshake zuzulassen brauchen wir nur Pakete
mit gesetztem SYN-Flag und nicht gesetztem ACK-Flag zuzulassen.
Dadurch, das wir nur Pakete durchlassen, die nur das SYN Flag gesetzt haben,
verhinden wir auch viele Formen des Portscanning. Flags S/SA bedeutet:
Von den Flags S (SYN) und A (ACK) darf nur S gesetzt sein. Andere Flags werden
nicht betrachtet.
Die Regeln sehen jetzt wie folgt aus:
<blockquote><pre>
block in  on fxp0 inet proto tcp all
pass  in  on fxp0 inet proto tcp from 1.1.1.0/24 to any port 22 \
       flags S/SA keep state
pass  in  on fxp0 inet proto tcp from any to any port 80 \
       flags S/SA keep state
pass  in  on fxp0 inet proto tcp from any to any port 443 \
       flags S/SA keep state
block out on fxp0 inet proto tcp all
pass  out on fxp0 inet proto tcp all flags S/SA keep state
</pre></blockquote>

<p>
F&uuml;hren wir jetzt alle Dinge zusammen, indem wir alle bisherigen
Regeln einfach in ein einziges Regelwerk umwandeln.
Dieses Regelwerk wird IPv4 unterst&uuml;tzen, die Standard-Regel wird 
zun&auml;chst alles abblocken, Management-Verbindungen aus dem internen
Netzwerk (via SSH) erlauben und ebenso hereinkommenden Traffic zu den Ports
80 (http) und 443(hhtps). Es wird auch nicht routbare gespoofte
IP Adressen abblocken, und alle Pakete verwerfen, die zu fragmentiert sind,
um sie zu untersuchen. Ein recht gutes Setup f&uuml;r einen 
&ouml;ffentlichen Webserver. Und so k&ouml;nnte
<i>/etc/pf.conf</i> aussehen:
<blockquote><pre>
# Aufr&auml;umen von fragmentierten und abnormalen Paketen
scrub in all

# Das Spoofen nicht-routbarer Addressen verhindern
block in quick on fxp0 inet from { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 } to any
block out quick on fxp0 inet from any to { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 }

# Standardm&auml;ssig alles verbieten, was nicht sp&auml;ter explizit
# erlaubt wird.
block in on fxp0 all

# Andere d&uuml;rfen http und https benutzen
pass in on fxp0 inet proto tcp from any to any port 80 \
       flags S/SA keep state
pass in on fxp0 inet proto tcp from any to any port 443 \
       flags S/SA keep state

# Ausgehender Traffic darf raus und es wird ein "state" dabei erzeugt 
# Alle Protokolle einschliesslich TCP, UDP und ICMP d&uuml;rfen raus und
# erzeugen einen "state", so das externe DNS-Server auf unsere DNS-Requests 
# (UDP) antworten k&ouml;nnen.
block out on fxp0                 all
pass  out on fxp0 inet proto tcp  all flags S/SA keep state
pass  out on fxp0 inet proto udp  all            keep state
pass  out on fxp0 inet proto icmp all            keep state
</pre></blockquote>

<p>
Obwohl das schon ganz gut aussieht, erlaubt es Packet Filter,
einige Dinge zu tun und zu nutzen, die deine 
<i>pf.conf</i> Datei besser lesbar machen und leichter zu pflegen.
</p>

<p>
<b>Sets</b>
<p>


Sets sind n&uuml;tzliche "shortcuts" zum Schreiben einfacher und sauberer 
Regel in PF.  Was w&auml;re, zum Beispiel, wenn du Verbindungen zu einem Dienst
erlauben musst, der auf verschiedenen Protokollen l&auml;uft, wie etwa BIND,
der TCP und UDP benutzt ?
<blockquote><pre>
pass in quick on fxp0 inet proto { tcp, udp } from any to any port 53
</pre></blockquote>
Beachte die Spaces auf beiden Seiten der '{ }' Klammern. 
</p>
<p>
Gruppen von IPs, die irgendwie miteinander in Beziehung stehen, k&ouml;nnen ebenfalls
in sets zusammengefasst werden, die &uuml;berall benutzt werden k&ouml;nnen, wo man
auch eine einzelne IP benutzen kann. Nehmen wir als Beispiel unsere anti-spoofing
Regeln von oben:
<blockquote><pre>
# Erlaube niemandem nicht-routebare Addressen zu spoofen
block in quick on fxp0 inet from { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 } to any
block out quick on fxp0 inet from any to { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 }
</pre></blockquote>

<p>
<b>Variablen-Auswertung</b>
</p>
<p>
Ein Problem der obigen Beispiel-<i>pf.conf</i>Datei ist, dass du eine Menge Zeilen
auswechseln musst, sobald du deine Netzwerkkarte oder IP-Adresse &auml;ndern musst.
Das kann man durch Variablen-Asuwertung vermindern:

<blockquote><pre>
NoRouteIPs="{ 127.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, 10.0.0.0/8 }"
ExtIF="fxp0"
block in quick on $ExtIF from $NoRouteIPs to any
block out quick on $ExtIF from any to $NoRouteIPs
</pre></blockquote>
</p>
 
<p>
<a name="sample_pf.conf"></a>
<b>Alles zusammengenommen</b>
</p>
<p>
F&uuml;gen wir nun alles zusammen und betrachten die Eleganz der Datei:
<blockquote><pre>
# Sinnvolle Variablen definieren
ExtIF="fxp0"              # External Interface
IntNet="1.1.1.0/24"       # Our internal network
NoRouteIPs="{ 127.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, 10.0.0.0/8 }"
Services="{ www, https }"
 
# Aufr&auml;umen bei fragmentierten und unnormalen Paketen
scrub in all
 
# Keine nicht-routbaren Addressen erlauben
block in  quick on $ExtIF from $NoRouteIPs to any
block out quick on $ExtIF from any to $NoRouteIPs
 
# standardm&auml;ssig alle einkommenden Pakete blocken, mit Ausnahmen jener,
# die explizit erlaubt sind
block in on $ExtIF all
 
# Andere d&uuml;rfen HTTP und HTTPS benutzen
pass in quick on fxp0 from any to any port = 80 flags S/SA
pass in quick on fxp0 from any to any port = 443 flags S/SA

pass  in on $ExtIF inet proto tcp from any to any port $Services \
       flags S/SA keep state
 
# und ausgehender Traffic darf raus, 
# alle Protokolle, einschliesslich TCP, UDP und ICMP, es wird ein "state",
# erzeugt, so dass externe DNS Server auch auf unsere DNS Anfragen antworten k&ouml;nnen (UDP).
block out on $ExtIF                 all
pass  out on $ExtIF inet proto tcp  all flags S/SA keep state
pass  out on $ExtIF inet proto udp  all            keep state
pass  out on $ExtIF inet proto icmp all            keep state
</pre></blockquote>
</p>
 
<p>
Wenn du Probleme bekommst, wirst du vermutlich gerne das Logging bei bestimmten Regeln 
aktivieren, um effektiv deine Probleme l&ouml;sen zu k&ouml;nnen, wie z.B.:
<blockquote><pre>
pass in log quick on fxp0 proto tcp from 1.1.1.0/24 to any port 22
</pre></blockquote>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8">pflogd(8)</a> schreibt Logeintr&auml;ge in <i>/var/log/pflog</i>.
Denke daran, dass <i>/var/log/pflog</i> eine Bin&auml;r-Datei ist, und von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcpdump&amp;sektion=8">tcpdump(8)</a> gelesen werden
soll, NICHT direkt von Menschen.
</p>
<p>
Wenn du die Konfigurationsdatei ver&auml;nderst, so dass jetzt in das Logfile geschrieben wird, denke daran,
dass du <b>pfctl -R /etc/pf.conf</b> durchf&uuml;hren musst, damit die &Auml;nderung auch wirksam wird !
</p>
 
<p>
<a name="6.3"></a>
<a name="NAT"></a>
<h2>6.3 - NAT</h2>
<!-- XXXrelease -->

<p>
<h4>Hinweis: Ab OpenBSD 3.2 sind die NAT Funktionen in die Datei
<i>/etc/pf.conf</i> integriert und nicht mehr in der separaten 
Datei <i>/etc/nat.conf</i>, die noch in OpenBSD 3.0 und 3.1
genutzt wurde.</h4>


<p>
<h5>Hinweis: Packet Filter ist das Filtersystem in OpenBSD 3.0 und h&ouml;her.
Wenn du nach der IPF/IPNAT FAQ f&uuml;r OpenBSD 2.9 und vorher
suchst, klicke <a href="../faqipf.html">hier</a>.</h5>

<a name="nat1.0"></a>
<h3><u>6.3.1 NAT Einf&uuml;hrung</u></h3>

<a name="nat1.1"></a>
<b>Kapiteleinf&uuml;hrung</b>

<p>
Gem&auml;&szlig; <a HREF="http://www.geektools.com/rfc/rfc1631.txt">RFC 1631</a> 
bietet NAT einen einfachen Weg, um interne Netzwerke auf eine einzige routebare 
(&quot;reale&quot;) Internetadresse umzulegen. 
Dies ist sehr n&uuml;tzlich, wenn man nicht f&uuml;r jeden Rechner des 
internen Netzwerkes eine offizielle Adresse zugewiesen bekommen hat.
Wenn man ein privates/internes Netzwerk besitzt, dann kann man diese 
(in <A HREF="http://www.geektools.com/rfc/rfc1918.txt">RFC 1918</a> 
definierten) Adressbereiche benutzen:
<P>

10.0.0.0/8 (10.0.0.0 - 10.255.255.255)<br>
172.16.0.0/12 (172.16.0.0 - 172.31.255.255)<br>
192.168.0.0/16 (192.168.0.0 - 192.168.255.255)<br>

<p>
Es wird angenommen, dass der User bereits eine OpenBSD-Maschine mit zwei
Netzwerkkarten installiert und eingerichtet hat (eine
hin zum Internet und die anderen f&uuml;r das lokale Netzwerk).

<p>
<a name="nat1.3"></a>
<b>Konfiguration</b>

<p>
Als Beispiel nehmen wir das unten beschriebene System. Dein Setup
wird h&ouml;chstwahrscheinlich davon abweichen, sei also sehr
vorsichtig damit, einfach irgendetwas von hier abzutippen und
dann zu erwarten, dass das auch funktioniert.

<ul>
Intel EtherExpress Pro/100 <b>fxp0</b>
verbunden mit dem EXTERNEN LAN (oder WAN)
<b>IP Addresse: </b>24.5.0.5
<b>Netmaske: </b>255.255.255.0

Compaq Netelligent 10/100Mb <b>tl0</b>
Verbunden mit dem INTERNEN LAN
<b>IP Addresse: </b>192.168.1.1
<b>Netmaske: </b>255.255.255.0
</ul>
<br>
<b>Externe, Internet-routebare IP (vom ISP bereitgestellt, in diesem 
Beispiel ein Kabelmodemprovider)<br></b>
<ul>
<b>IP Addresse: </b>24.5.0.5
<b>Netmaske: </b>255.255.255.0
<b>Gateway: </b>24.5.0.1
</ul>
<br>
<b>LAN - Lokales Netzwerk</b><br>
<ul>
In diesem Beispiel-Szenario werden die Rechner im LAN das IP 
Adressierungsschema 192.168.1.xxx (wobei xxx eine eindeutige Nummer 
darstellt) verwenden. 
Es kann eine gro&szlig;e Anzahl verschiedener Betriebssysteme im internen 
LAN wie Windows 98, Windows NT, OpenBSD und Linux geben, aber das 
Betriebssystem des Client ist wirklch keine Sache des NAT.
F&uuml;r dieses Beispiel wird der Rechner im LAN die IP Adresse 
192.168.1.40 annehmen.
</ul>
<br>
<b>Diagramm der Konfiguration</b>
<blockquote><pre>
+-----+              +---------+         +----------+
| Hub |--------- tl0 |   NAT   | fxp0 ----| Internet |
+-----+              +---------+         +----------+
  | |
  | +-- Rechner A
  +---- Weitere Rechner 

                              +-------------------------+
                              |         LEGENDE         |
                              +-------------------------+
                              |  NIC fxp0 - 24.5.0.5     |
                              |  NIC tl0 - 192.168.1.1  |
                              |Rechner A - 192.168.1.40 |
                              +-------------------------+

</pre></blockquote>
</ul>

<br>
<a name="nat2.0"></a>
<h3><u>6.3.2 Network Address Translation</u></h3>
<br>

<a name="nat2.1"></a>
<b>Einf&uuml;hrung zu NAT</b>

<p>
Jede Station im Internet ben&ouml;tigt eine einzigartige IP Addresse. 
Zumindest mit IPv4 gibt es ziemlich begrenzte Anzahl von einzigartigen
und verf&uuml;gbaren IP-Adressen, und als Ergebnis davon sind sie nicht
frei erh&auml;ltlich. Die meisten Low-Cost ISPs begrenzen daher eine Site
mit 1 bis 30 Adressen, und obwohl Organisationen mit gr&ouml;sserem
Budget sich gr&ouml;ssere Bl&ouml;cke leisten k&ouml;nnen, ist es in den
meisten F&auml;llen ohne grossen Vorteil aber mit h&ouml;herem Risiko
verbunden, jeden Computer mit einer individuellen Adresse 
im Internet zu haben.
</p>
<p>
Network Address Translation, oder NAT, (auch bekannt als &quot;IP 
Masquerading&quot; wenn du aus einem Linux-Hintergrund kommst) erlaubt 
es mehreren Computern, sich &quot;hinter&quot; einer (oder einer kleinen 
Anzahl von) IP Addressen zu verbergen. Jeder &quot;interne&quot; 
Computer hat eine lokal zugewiesene, unregistrierte IP Addresse 
(gem&auml;&szlig; <a href="http://www.geektools.com/rfc/rfc1918.txt">RFC 1918</a>), 
und alle benutzen gleichzeitig die gleiche externe IP Addresse.
</p>

<p>
NAT arbeitet auf ziemlich einfache Weise. Wenn ein Rechner im LAN
sich mit einem Rechner im Internet verbinden will, sendet er ein TCP Paket 
mit einer Verbindungsanfrage. Innerhalb des TCP Paketdatenkopfes 
(&quot;headers&quot;) steht die Rechner IP Adresse (hier 192.168.1.40) und 
die erw&uuml;nschte Server IP Adresse (z. B. 123.45.67.89). Die Maschine 
mit NAT f&auml;ngt das TCP Paket ab und &auml;ndert die Rechner IP Adresse 
in die Adresse des Rechners, der mit dem Internet verbunden ist 
(z. B. 24.5.0.5). Dies t&auml;uscht den Server eigentlich, indem es ihn 
glauben macht, da&szlig; die Verbindung vom NAT Rechner und nicht vom 
eigentlichen Client kommt. Der Server schickt dann die Antworten 
zur&uuml;ck zum NAT Rechner. Wenn der NAT Rechner die Antwort erh&auml;lt, 
dann &uuml;bersetzt er die Zieladresse zur&uuml;ck von seiner eigenen 
IP zu der vom Client und schickt das Paket an den Client weiter. Der 
Client bekommt von alledem nichts mit und die vorget&auml;uschte 
Internetverbindung ist f&uuml;r den Benutzer und seine Anwendung 
total transparent.
</p>

<p>
Das folgende Beispiel zeigt NAT noch ein bi&szlig;chen deutlicher:
</p>

<blockquote><pre>
Client ----------------- tl0 [ NAT ] fxp0 ---------- Internet Host
192.168.1.40 --- 192.168.1.1 [ NAT ] 24.5.0.5 --- 123.45.67.89

AUSGEHENDES TCP Paket                   AUSGEHENDES TCP Paket
Von: 192.168.1.40   &gt;&gt;=== NAT ===&gt;&gt;     Von: 24.5.0.5
Nach: 123.45.67.89                      Nach: 123.45.67.89

INCOMING TCP Paket                     EINGEHENDES TCP Paket
Von:  123.45.67.89 			 Von:  123.45.67.89
Nach: 192.168.1.40   &lt;&lt;=== NAT ===&lt;&lt;     Nach: 24.5.0.5
</pre></blockquote>

<br>
<a name="nat2.2"></a>
<b>Warum NAT verwenden</b>

<p>
In meiner neuen Wohnung bekam ich ein Kabelmodem und somit ein kleines 
Problem. Wie k&ouml;nnen meine Zimmerkameraden Internetanschlu&szlig; 
bekommen, wenn 
das Kabelmodem in meinem Zimmer steht? Ich hatte ein paar Alternativen 
wie zus&auml;tzliche IP Adressen kaufen, einen Proxyserver aufsetzen 
oder eben NAT einsetzen. 
(La&szlig; dich nicht vom Kabelmodembeispiel t&auml;uschen: NAT ist 
f&auml;hig, ein gro&szlig;es Netzwerk mit hunderten oder auch tausenden 
Computern zu maskieren!)
</p>

<p>
Es gibt viele Gr&uuml;nde, warum ich NAT aufsetzen wollte. Nummer eins: 
Geld sparen. Zwei Zimmerkameraden in meinem Haus haben ihre eigenen PCs 
und ich besitze insgesamt 3 Computer. Mein ISP erlaubt nur drei IP 
Adressen pro Haushalt. D. h., da&szlig; wir nicht genug IPs h&auml;tten, 
um jedem Rechner Internetzugang zu verschaffen.
</p>

<p>
Mit NAT hat jeder Rechner eine eindeutige (interne) IP Adresse, aber 
alle teilen sich eine IP Adresse von meinem ISP. Die Kosten sinken.
</p>

<br>
<a name="nat2.4"></a>
<b>Setup</b>

<p>
Damit NAT auf deinem OpenBSD Rechner l&auml;uft, mu&szlig;t du zun&auml;chst 
PF aktivieren. Dies geschieht einfach, indem du die unten angef&uuml;hrten 
Dateien editierst (&auml;ndere die Dateien gem&auml;&szlig; den folgenden Optionen):
</p>

<p>
<b>/etc/rc.conf</b> (diese Datei wird beim Booten f&uuml;rs Starten von Diensten gelesen)
</p>

<blockquote><pre>
pf=YES<br>
</pre></blockquote>

<p>
<b>/etc/sysctl.conf</b>
</p>

<blockquote><pre>
net.inet.ip.forwarding=1
</pre></blockquote>

<p>
Nachdem diese &Auml;nderungen durchgef&uuml;hrt wurden, ist der Rechner endlich f&uuml;r die 
Konfiguration von NAT bereit.
</p>

<br>
<a name="nat2.5"></a>
<b>Konfiguration</b>

<p>
Der erste Schritt ist die Konfiguration der PF Regeldatei
(<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+3.1">/etc/pf.conf</a></i>).
Daf&uuml;r werden wir in diesem Dokument jeglichen Datenverkehr durch diese Firewall passieren 
lassen. Die Datei sollte so aussehen:
</p>

<blockquote><pre>
pass in all
pass out all
</pre></blockquote>

<p>
Siehe wiederum <a href="#PF">FAQ 6, Packet Filter</a> f&uuml;r weitere Informationen.
</p>

<p>
Die NAT Konfigurationsdatei 
(<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nat.conf&amp;sektion=5&amp;manpath=OpenBSD+3.1">/etc/nat.conf</a></i>)
folgt einer sehr einfachen Syntax.
Um obige Konfiguration fortzusetzen, sollte die Datei die folgenden Eintr&auml;ge enthalten: 
</p>

<blockquote><pre>
nat on fxp0 from 192.168.1.0/24 to any -&gt; 24.5.0.5
</pre></blockquote>

<p>
Hier eine Erkl&auml;rung f&uuml;r die obigen Zeilen.
</p>

<dl>
<strong>"nat"</strong>
<p>
Das zeigt an, dass du eine NAT Regel aufsetzt.
</p>
</dl>

<dl>
<strong>"fxp0"</strong>
<p>
Die Netzwerkkarte, die mit dem Internet verbunden ist.
</p>
</dl>

<dl>
<b>"192.168.1.0/24"</b>
<p>
Die IP Adresse und Netzmaske (die Netzmaske ist im
CIDR Format). Kombiniert besagen sie, da&szlig; "jede IP Adresse von 
192.168.1.1 bis 192.168.1.254" umgelegt werden soll. 
</p>
</dl>

<dl>
<b>"24.5.0.5"</b>
<p>
Auf diese IP Adresse sollen die LAN IP Adressen umgelegt werden.
</p>
</dl>

<p>
<a name="nat2.6"></a>
<b>Betrieb</b>

<p>
Ist die Konfiguration erst einmal komplett, dann gibt es zwei 
M&ouml;glichkeiten, um NAT zu aktivieren. Die erste (und beste), ist, 
wenn m&ouml;glich, deinen OpenBSD Rechner zu rebooten.
Dies geschieht mit dem Befehl "<i>reboot</i>"
</p>

<p>
Wenn du NAT von der Kommandozeile starten willst, dann benutze die folgenden
Befehle:
</p>

<blockquote><pre>
# <b>pfctl -N /etc/nat.conf</b>
# <b>pfctl -e</b>
</pre></blockquote>

<p>
Die erste Zeile dient dazu einen Satz von NAT Regeln in PF zu laden
(und jegilche alten Regeln zu l&ouml;schen), die zweite Zeile schaltet
PF ein. Trotzdem ist ein Reboot der bessere Test, um einfach 
sicherzustellen, dass auch dann alles glatt l&auml;uft.
</p>


<p>
<b>NB:</b> Um die NAT Einstellungen neu zu laden (im Falle, da&szlig; du die 
Datei editiert hast, aber nicht rebooten willst), mu&szlig;t du nur den ersten
Befehl wiederholen. Die Einstellungen werden neu geladen. 
</p>

<br>
<a name="nat3.0"></a>
<h3><u>6.3.3 NAT Grundwissen</u></h3>

<br>
<a name="nat3.1"></a>
<b>&Uuml;berpr&uuml;fen des NAT Status</b>

<p>
Um herauszufinden, was NAT tut oder um sicherzustellen, da&szlig; die 
gew&uuml;nschten Einstellungen auch in Kraft sind, kannst du die "-ss" Option 
verwenden. Diese Option listet alle Einstellungen und laufende Sitzungen:
</p>

<blockquote><pre>
# pfctl -ss
TCP  192.168.1.40:2132 -&gt; 24.5.0.5:53136 -&gt; 65.42.33.245:22       TIME_WAIT:TIME_WAIT
TCP  192.168.1.40:2492 -&gt; 24.5.0.5:55011 -&gt; 65.42.33.245:22       ESTABLISHED:ESTABLISHED
UDP  192.168.1.40:2491 -&gt; 24.5.0.5:60527 -&gt; 24.2.68.33:53       2:1
</pre></blockquote>

<p>
Erkl&auml;rungen (nur die erste Zeile, die anderen sind entsprechend):
</p>

<ul>
<b>"192.168.1.40:2132"</b>
<p>
Dies zeigt dir die IP Adresse (192.168.1.40) des LAN Rechners, der NAT 
benutzt. Die Portnummer (2132) der Verbindung wird anschlie&szlig;end 
gezeigt.
</p>
</ul>

<ul>
<b>"24.5.0.5:53136"</b>
<p>
Dies zeigt, da&szlig; die Verbindung via der Adresse 24.5.0.5 und
der Portnummer 53136 ins Internet geht.
</p>
</ul>

<ul>
<b>"65.42.33.245:22"</b>
<p>
IP Adresse und Port zu dem verbunden worden ist.
</p>
</ul>

<ul>
<b>"TIME_WAIT:TIME_WAIT"</b>
<p>
Der Status, in dem sich die Verbindung, nach Glauben von PF, befindet.
</p>
</ul>

<a name="nat3.2"></a>
<b>Probleme mit FTP und NAT</b>

<p>
Es gibt ein paar Einschr&auml;nkungen bei NAT, die am h&auml;figsten
anzutreffende ist bei FTP. Man kann FTP in zwei Weisen benutzen:
aktiv oder passiv. Von diesen beiden wird passiv allgemein als die
sicherere angesehen.
</p>
<p>
Wenn ein User bei aktivem FTP sich mit einem entfernten FTP-Server 
verbindet und Informationen oder eine Datei anfordert, sendet der FTP
Client dem Server eine zuf&auml;llige Port-Nummer, auf die sich der 
FTP-Server beim Client verbindet um dort die Information hinzuschicken.
Das ist ein Problem f&uuml;r all die User, die aus dem LAN eine 
FTP-Verbindung aufbauen wollen. Wenn der FTP-Server seine Daten senden
will, verbindet er sich mit einem zuf&auml;lligen Port auf der
externen Netzwerk-Karte. Die NAT-Maschine empf&auml;ngt die Daten, hat
aber kein Mapping daf&uuml;r, und liefert das Paket nicht aus, sondern
verwirft es.
</p>
<p>
Mit passivem FTP (dem Standard mit dem OpenBSD <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftp&amp;sektion=1">ftp(1)</a>
Client) fragt der Client den Server nach einem zuf&auml;lligen Port, auf dem
der Server in Erwartung der Datenverbindung lauschen wird. Der Server 
informiert den Client &uuml;ber den ausgew&auml;hlten Port, und der Client
verbindet sich dorthin, um Daten zu &uuml;bertragen. Dummerweise ist das nicht
immer m&ouml;glich oder w&uuml;nschenswert.
ftp(1) benutzt diesen Modus standardm&auml;ssig; um aktives FTP zu erzwingen
benutze die -A Option von ftp, oder schalte den passiven Modus mit folgendem
Befehl 
</dt></dl>
am ftp&gt; prompt
</p>
ab:
<dl><dt>
<pre>passive off
</pre>
<P>

Packet Filter bietet eine weitere L&ouml;sung f&uuml;r diese Situation, 
umleiten von FTP Traffic durch einen FTP Proxy-Server, ein Prozess, der 
deinen FTP-Traffic durch die Filter "leitet". Der FTP-Proxy, der von 
OpenBSD und PF genutzt wird, ist
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftp-proxy&amp;sektion=8&amp;manpath=OpenBSD+3.1">ftp-proxy(8)</a>.
Um ihn zu aktivieren, musst du sowas wie das hier in deine 
<i>/etc/nat.conf</i> Datei tun:
<blockquote><pre>
rdr on tl0 proto tcp from any to any port 21 -&gt; 127.0.0.1 port 8021
</pre></blockquote>
Eine Kurzerkl&auml;rung dieser Zeile ist: "Verkehr auf dem inneren 
Interface wird auf den Proxy-Server umgeleitet, der auf dieser Maschine
auf dem Port 8081 l&auml;uft." 
</p>
<P>
Dazu muss der Proxy-Server nat&uuml;rlich gestartet werden und auf der  
OpenBSD Maschine laufen, das macht man, indem man die folgende Zeile in 
die 
<i>/etc/inetd.conf</i> einf&uuml;gt:
<blockquote><pre>
127.0.0.1:8081 stream tcp nowait root /usr/libexec/ftp-proxy ftp-proxy
</pre></blockquote>
und entweder das System neu botet, oder dem 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inetd&amp;sektion=8">inetd(8)</a>.
ein 'HUP' Signal schickt.
Ein Weg dazu ist das folgende Kommando:
<blockquote><pre>
kill -HUP `cat /var/run/inetd.pid`
</pre></blockquote>
Du musst sicherstellen, dass der FTP-Proxy auf Port 8081 l&auml;uft, dem 
selben Port an den das rdr Statement FTP Traffic sendet. Die Wahl von 
Port 8081 ist zuf&auml;llig, obwohl 8081 eine gute Wahl ist, da er 
nicht f&uuml;r andere Anwndungen belegt ist.
</p>

<br>
<a name="nat3.3"></a>
<b>Datenverkehr umleiten</b>

<p>
F&uuml;r manche Anweungen ist es notwendig, ein- oder ausgehenden 
Verkehr umzuleiten f&uuml;r ein bestimmtes Protokoll und/oder einen 
bestimmten Port zu einer bestimmten Maschine hinter dem Filtersystem 
umzuleiten.
Ein Beispiel daf&uuml;r ist ein Rechner im LAN, der einen Webserver
beinhaltet, der von aussen erreichbar sein muss. Ein Beispiel w&auml;re 
ein Webserver in deinem interne Netzwerk, der von aussen erreichbar 
sein muss, (oder nat&uuml;rlich der bereits erw&auml;hnte FTP-Proxy(8)).
Eingehende Verbindungen zu deiner g&uuml;ltigen Internetadresse 
k&ouml;nnen keine Verbindung herstellen, es sei denn, auf der
NAT Box l&auml;uft auch ein Webserver. Daher benutzen wir die
NAT 'rdr' Direktive in der Regeldatei, um festzulegen, wohin
eine bestimmte Verbindung hingeleitet werden soll.
</p>

<p>

F&uuml;r unser Beispiel nehmen wir an, da&szlig; ein Webserver im LAN mit 
der IP Adresse 192.168.1.80 existiert. Die NAT Regeldatei ben&ouml;tigt 
eine neue Direktive. F&uuml;ge eine Zeile wie folgende in 
<i>/etc/nat.conf</i> ein: 
</p>

<blockquote><pre>
rdr on fxp0 proto tcp from any to any port 80 -&gt; 192.168.1.80 port 80
</pre></blockquote>

<p>
Die Erkl&auml;rung:
</p>

<ul>
<b>"rdr"</b>
<p>
Diesen Befehl gibst du NAT: NAT soll eine Verbindung umleiten. 
</p>
</ul>


<ul>
<b>"on fxp0"</b>
<p>
Die mit dem Internet verbundene Netzwerkkarte. 
</p>
</ul>

<ul>
<b>"from any to any"</b>
<p>
Das gibt an, welche IP Addressen umgelitet werden sollen (von jeder, die 
auf fxp0 hereinkommt, so wie oben beschrieben, zu jeder Ziel-IP)
</p>
</ul>

<ul>
<b>"port 80"</b>
<p>
Der hereinkommende Port (80), der umgeleitet werden soll. Die Zahl 
"80" mu&szlig; nicht explizit benutzt werden. Du kannst auch 
"port www" verwenden. Wenn du den Namen anstelle der Nummer verwendest, 
dann m&uuml;ssen auch Name und die korrespondierende Zahl in der 
Datei /etc/services existieren.
</p>
</ul>

<ul>
<b>"192.168.1.80 port 80"</b>
<p>
Die IP Addresse der Maschine im LAN, zu der Pakete umgeleitet werden 
sollen. Denk daran, dass der Ziel-Port NICHT dem port entsprechen muss,
auf dem das Paket hereinkommt. Das folgende ist beispielsweise
sowohl korrekt, als auch potentiell n&uuml;tzlich:
<pre>
rdr on fxp0 proto tcp from any to any port 8080 -&gt; 192.168.1.35 port 80
</pre>
Diese Zeile lenkt hereinkommende Verbindungen auf Port 8080 zu einem
Webserver auf dessen Port 80 um, der im internen Netzwerk l&auml;uft.
</p>
</ul>

<p>
Danach lade die NAT Regeln neu und die Umleitungen werden sofort in Kraft treten.
</p>
<p>
<b>Verneinung</b>
</p>
<p>
Manchmal muss man Ausnahmen f&uuml;r eine NAT oder Umleitungs-Regel
festlegen. Hier ein Beispiel: AOL Instant Messenger ist bekannt daf&uuml;r
, dass er sich &uuml;ber jeden verf&uuml;gbaren Port durch eine
Firewall schleicht. Du kannst entdecken, dass sich der FTP-Proxy nicht 
mit dem AIM vertr&auml;gt, sobald der sich den Port 21 aussucht.
Wenn du das auch als schlecht betrachtest (viele Leute verbringen
jede Menge Zeit damit AIM zu blocken!), kannst du die IP-Adressen
der AIM-Server einfach vom Traffic ausnehmen, der von deiner FTP-Proxy
Zeile umgeleitet wird. Das geht etwa wie folgt:
<blockquote><pre>
rdr on tl0 proto tcp from any to ! 64.12.163.199 port 21 -&gt; 127.0.0.1 port 8021
</pre></blockquote>
Interpretation: Leite eingehenden Traffic auf tl0 Richtung Port 21 um, aber
NICHT von 64.12.163.199 (die AIM Server. mit denen die User Probleme hatten)
zu localhost port 8081 (wo sinnvollerweiser der FTP-Proxy wartet).  
Leider gibt es recht viele AIM-Server, wenn dich diese Anwendung interessiert,
wirst du ein wenig mit den IP-Adressen herumpobieren m&uuml;ssen
(64.12.0.0/16 k&ouml;nnte produktiver sein, aber auch einige Nicht-AOL-Sites
treffen). 
</p>

<br>
<a name="nat3.4"></a>
<b>NAT versus Proxy</b>

<p>
Der Unterschied zwischen NAT und einem applikationsbasierten Proxy liegt darin,  
da&szlig; die Proxysoftware als Mittelsmann zwischen Internet und den im LAN 
verbundenen Rechnern agiert. Nur mu&szlig; f&uuml;r jede Anwendung und 
Internetverbindung ein daf&uuml;r geeigneter Proxy bereitstehen. Nicht alle 
Anwendungen k&ouml;nnen dies (vor allem Spiele nicht). 
NAT "mapped" dein internes Netzwerk transparent, sodass es mit dem Internet 
verbunden ist. Der einzige Sicherheitsvorteil von Proxysoftware gegen&uuml;ber 
NAT ist, da&szlig; die Proxysoftware sicherheitstechnisch im Vorteil ist, wenn 
man den Inhalt filtern kann; z. B. Makroviren f&uuml;r Windowsrechner filtert, 
oder gegen Buffer-overflows sch&uuml;tzt, udgl. Diese Filter zu administrieren 
bedeutet viel Arbeit.
</p>

<p>
<a name="nat3.5"></a>
<b>Redirection und reflection</b>

<p>
Oft werden redirection Regeln benutzt, um hereinkommende Verbindungen vom
Internet zu einem lokalen Server mit privater Adresse im LAN umzuleiten, 
wie etwa hier:

<pre>
rdr on $ext_if proto tcp from any to $ext_if port 80 -&gt; $server port 80
</pre>

<p>
Wenn aber die redirection Regel von einem Client aus dem LAN getestet
wird, bemerkt man, dass sie nicht funktioniert.
Der Grund ist, dass redirection Regeln nur f&uuml;r Regeln gelten,
die auch &uuml;ber das entsprechende Interface hereinkommen ($ext_if, 
das externe Interface, in diesem Fall).
Sich mit der externen Adresse der Firewall von einem Host aus dem
LAN zu verbinden, heisst aber nicht zwangsl&auml;ufig, dass die Pakete
auch durch das externe Interface kommen.
Der TCP/IP stack auf der Firewall vergleicht die Zieladresse des 
einkommenden Paketes mit seiner eigenen Adresse und Aliasen und 
entdeckt Verbindungen zu sich selbst, sobald sie das interne Interface
passiert haben. Solche Pakete gehen physikalisch nicht durch das externe 
Interface, und der Stack simuliert das auch in keiner Weise.
pf sieht diese Pakete nie auf dem externen Interface, und daher
greift die redirection Regel auch nicht.

<p>
Eine zweite redirection Regel f&uuml;r das interne Interface einzuf&uuml;gen
hat nicht fen gew&uuml;nschten Effekt.
Wenn der lokale Client sich zur externen Addresse der Firewall verbindet,
kommt das erste Paket des TCP handshake bei der Firewall durch das interne
Interface an.
Die redirection Regel greift und die Ziel-Adresse wird mit der des internen
Servers ersetzt. Das Paket wird &uuml;ber das interne Interface weitergeleitet,
und erreich den internen Server.
Aber die Quell-Adresse wurde nicht ver&auml;ndert, und enth&auml;lt somit
immernoch die lokale Adresse, somit sendet der Server seine Antwort
direkt daran. Die Firewall bekommt die Antwort nie zu Gesicht, und hat
daher keine Chance, die &Auml;nderung sauber durchzuf&uuml;hren.
Der Client hingegen erh&aulm;lt eine Antwort von einer Maschine, die
er nie erwartet hat, und verwirft das Paket, der TCP handshake 
schl&auml;gt fehl, und keine Verbindung kann zustande kommen.

<p>
Trotzdem ist es oft w&uuml;schenswert f&uuml;r die Clients aus dem LAN
sich transparent mit dem selben internen Server als externe Clients zu 
verbinden.
F&uuml;r dieses Problem gibt es mehrere L&ouml;sungen.

<p>
<b>Split horizon DNS</b>
<p>
Es ist m&ouml;glich, DNS-Server zu konfigurieren, dass die Anfragen
lokaler Clients anders beantwortet werden, als die externer Clients,
und zwar so, dass die internen Clients auch die interne Adresse
des Servers erhalten.
Sie verbinden sich direkt mit dem Server, ohne &uuml;berhaupt
mit der Firewall in Ber&uuml;hrung zu kommen.
Das reduziert den lokalen Traffic, da die Pakete ja gar nicht
mehr bis zur Firewall m&uuml;ssen.

<p>
<b>Den Server in ein separates lokales Netzwerk stellen</b>
<p>
Ein zus&auml;tzliches Netzwerk-Interface einzubauen und den lokalen 
Server in ein eigenes, daf&uuml;r gedachtes Netzwerk (DMZ) zu stellen,
erlaubt das Umleiten der Verbindungen von lokalen Clients in der selben
Weise wie das Umleiten externer Verbindungen.
Die Benutzung verschiedener Netzwerke hat verschiedene Vorteile,
einschliesslich der Verbesserung der Sicherheit durch die Isolierung
des Servers von den anderen Maschinen.
Sollte der Server (der ja in unserem Fall aus dem Internet erreichbar
ist) jemals kompromittiert werden, kann er die lokalen Clients nicht
direkt erreichen, da alle Verbindungen durch die Firewall gehen 
m&uuml;ssen.

<p>
<b>TCP proxying</b>
<p>
Ein generischer TCP Proxy kann auf der Firewall aufgesetzt werden, der
entweder auf dem Port lauscht, der weitergeleitet werden soll oder der die
Verbindungen auf dem internen Interface umlenkt.
Wenn sich ein lokaler Client mit der Firewall verbindet, akzeptiert der
Proxy die Verbindung, &ouml;ffnet eine zweite Verbindung, und zwar hin 
zum Server, und leitet dann die Daten zwischen den beiden Verbindungen
jeweils weiter.

<p>
Einfache Proxies kann man mittels 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inetd&amp;sektion=8">inetd(8)</a>
und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nc&amp;sektion=1">nc(1)</a>
erzeugen.
Der folgende <i>/etc/inetd.conf</i> Eintrag erzeugt einen horchenden Socket,
der an die loopback-Adresse und Port 5000 gebunden ist.
Die Verbindungen werden nach Port 80 auf dem Server 192.168.1.10 weitergeleitet.

<pre>
127.0.0.1:5000 stream tcp wait nobody /usr/bin/nc nc -w 20 192.168.1.10 80
</pre>

<p>
Die folgende redirection Regel leitet von port 80 auf dem internen Interface
an den Proxy weiter:

<pre>
rdr on $int_if proto tcp from $int_net to $ext_if port 80 -&gt; 127.0.0.1 port 5000
</pre>

<p>
<b>RDR und NAT Kombination</b>
<p>
Mit einer zus&auml;tzlichen NAT-Regel auf dem internen Interface kann die
fehlende Adress-Umsetzung, die oben beschrieben wurde, erg&auml;nzt werden. 

<pre>
rdr on $int_if proto tcp from $int_net to $ext_if port 80 -&gt; $server
no nat on $int_if proto tcp from $int_if to $int_net
nat on $int_if proto tcp from $int_net to $server port 80 -&gt; $int_if
</pre>

<p>
Das f&uuml;hrt dazu, dass der erste Paket vom Client erneut
&uuml;bersetzt wird, wenn es durch das interne Interface 
zur&uuml;ckgeschickt wird, wobei die Quell-Adresse des Clients mit
der internen Adresse der Firewall ersetzt wird.
Der interne Server wird dann an die Firewall seine Antwort schicken,
die dann mittels NAT und RDR wiederum an den Client weiterleitet.
Dieses Konstrukt ist recht komplex, das es zwei separate states f&uuml;r
jede solche Verbindung erzeugt.
Man muss sicherstellen, dass die NAT Regel keinen anderen Teil der Pakete
betrifft, zum Beispiel Verbindungen von externen Clients (durch andere
Weiterleitungen) oder der Firewall selbst.
Bedenke, dass die obige rdr Regel den TCP/IP Stack dazu veranlasst, Pakete, die
auf dem inneren Interface ankommen, so zu sehen, dass sie eine Zieladresse
aus dem inneren Netzwerk haben.
Um zu verhindern, dass der Stack ICMP redirect messages versendet (und damit
dem Client erz&auml;hlt, dass sein Ziel direkt erreichbar ist, und daher die
reflection kaputtmacht), schalte redirects auf dem Gateway mittels 

<pre>
# <strong>sysctl -w net.inet.ip.redirect=0</strong>
</pre>

ab.
Im allgemeinen sollten man eine der anderen genannten L&ouml;sungen 
vorziehen.

<p>
<a name="nat4.0"></a>
<b>6.3.4 Links und Querverweise</b>

<p>
OpenBSD Dateien:
<ul>
<li>/etc/nat.conf - NAT Regeldatei
<li>/etc/rc.conf - muss man editieren, damit NAT und PF beim Booten gestartet werden
<li>/etc/sysctl.conf - editieren, damit IP Forwarding aktiviert wird
</ul>
</p>

<p>
NAT Internet Links:
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nat.conf&amp;sektion=5&amp;manpath=OpenBSD+3.1">nat.conf man page</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pfctl&amp;sektion=8&amp;manpath=OpenBSD+3.1">pfctl man page</a>
<li><a href="http://www.geektools.com/rfc/rfc1631.txt">http://www.geektools.com/rfc/rfc1631.txt</a>
</ul>
<p>

<br>

<p> 
<a name= "DHCP"></a>
<a name= "6.4"></a> 
<h2>6.4 - DHCP</h2> 
</p>

<h3>6.4.1 DHCP Klient</h3>
<p>Um den DHCP Klient 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient&amp;sektion=8">dhclient(8)</a>
zu benutzen, der Teil von OpenBSD ist, editiere /etc/hostname.xl0
(wenn deine Hauptethernetkarte xl0 ist. Deine kann ep0 oder fxp0 oder 
irgendeine andere sein!). 
Alles, was du in dieser Datei zu schreiben hast, ist 'dhcp'.
<pre>
     # <b>echo xl1 xl2 xl3 &gt;/etc/dhcpd.interfaces</b>
</pre>
Dies wird OpenBSD veranlassen, den DHCP Klient automatisch beim Booten zu 
starten.  OpenBSD wird sich seine IP Adresse, sein Standardgateway und seine 
DNS Server vom DHCP Server besorgen.  
<p>
Wenn du den DHCP Klient von der Befehlszeile starten willst, stelle sicher, 
da&szlig; /etc/dhclient.conf existiert, dann versuche:
<PRE>
# <strong>dhclient fxp0</strong>
</pre>
Wobei fxp0 die Netzwerkkarte ist, auf der du DHCP empfangen willst.
<P>Wie du auch immer dhclient startest, du kannst die /etc/dhclient.conf Datei 
immer so editieren, da&szlig; dein DNS <b>nicht</b> erneuert wird aufgrund 
der neuen DNS Informationen, indem du die 'request' Zeilen auskommentierst 
(Es gibt Beispiele in den Standardeinstellungen, aber du mu&szlig;t die 
Standardeinstellungen von dhclient &uuml;berschreiben.). 
<pre>
request subnet-mask, broadcast-address, time-offset, routers,
      domain-name, domain-name-servers, host-name, lpr-servers, ntp-servers;
</pre>
und dann <b>entferne</b> domain-name-servers.  Nat&uuml;rlich kannst du auch 
hostname oder andere Einstellungen entfernen.
<P>
<h3>6.4.2 DHCP Server</h3>

Wenn du OpenBSD als DHCP Server 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd&sektion=8">dhcpd(8)</a>,
einstetzen willst, 
editiere /etc/rc.conf. Setze dhcpd_flags="-q" anstelle von dhcpd_flags=NO.
Und die Netzwerkkarten, auf denen dhcpd(8) <b>lauschen</b> soll, stehen in /etc/dhcpd.interfaces.
<pre>
# <strong>echo xl1 xl2 xl3 &gt;/etc/dhcpd.interfaces</strong>
</pre>
Dann editiere /etc/dhcpd.conf.
Die Optionen sind selbsterkl&auml;rend.
<pre>
        option  domain-name "xyz.mil";
        option  domain-name-servers 192.168.1.3, 192.168.1.5;

        subnet 192.168.1.0 netmask 255.255.255.0 {
                option routers 192.168.1.1;

                range 192.168.1.32 192.168.1.127;
        }
</pre>
<p>
Dies teilt deinen DHCP Klienten mit, da&szlig; die an DNS Anfragen 
anzuh&auml;ngende Dom&auml;ne xyz.mil ist (d. h., wenn der Benutzer schreibt 
'telnet joe', dann wird an joe.xyz.mil gesendet). Es wird auf die DNS Server 
192.168.1.3 und 192.168.1.5 verwiesen. F&uuml;r Hosts, die sich im selben 
Netzwerk wie die Netzwerkkarte des OpenBSD Rechners befinden, welche im 
192.168.1.0/24 Adressbereich liegt, wird der DHCP Server ihnen eine IP Adresse 
zwischen 192.168.1.32 und 192.168.1.127 und als Standardgateway 192.168.1.1 zuweisen.
<p>
Wenn du den dhcpd(8) von der Befehlszeile starten willst, nachdem du /etc/dhcpd.conf 
editiert hast, versuche:
<PRE>
    # <b>dhcpd -q fxp0</b>
</PRE>
Wobei <tt>fxp0</tt> die Netzwerkkarte ist, auf der DHCP serviert werden soll. 
Die <tt>-q</tt> Option setzt die Ausgabe von dhcpd(8) auf ruhig, ansonsten ist sie sehr 
ausf&uuml;hrlich.
<P>
Wenn du DHCP Dienste f&uuml;r einen Windows Rechner bereitstellst, dann willst 
du vielleicht auch eine 'WINS' Serveradresse liefern.
Daf&uuml;r f&uuml;ge einfach die folgenden Zeilen zu deiner /etc/dhcpd.conf:
<pre>
option	netbios-name-servers	192.168.92.55;
</pre>
(wobei <tt>192.168.92.55</tt> die IP deines Windows oder Samba Servers ist.)
Siehe auch 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcp-options&sektion=5">dhcp-options(5)</a>
f&uuml;r weitere Optionen, die 
deine DHCP Klienten w&uuml;nschen.
<p>
<a name= "6.5"></a>
<h2>6.5 - PPP </h2>
</p>

Das "Point-to-Protocol" wird verwendet, um eine Verbindung zu deinem ISP mit 
deinem Modem herzustellen. OpenBSD bietet daf&uuml;r 2 M&ouml;glichkeiten.

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppd&sektion=8">pppd(8)</a>
- der Kernel PPP D&auml;mon.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&sektion=8">ppp(8)</a>
- der Userland PPP D&auml;mon. 
</ul>

<p>
Den ersten, den wir behandeln, wird der Userland PPP D&auml;mon sein. Um zu 
beginnen, ben&ouml;tigen wir einige einfache Informationen &uuml;ber deinen ISP. 
Hier eine Liste hilfreicher Informationen, die du brauchen wirst.
</p>

<ul>
<li>Die Einwahlnummer deines ISP
<li>Deinen Nameserver 
<li>Deinen Benutzernamen und Password
<li>Dein Gateway
</ul>

<p>
Einige von diesen ben&ouml;tigst du nicht unbedingt, aber sie w&auml;ren hilfreich. 
Der Userland PPP D&auml;mon benutzt die Datei 
<a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.conf.sample">/etc/ppp/ppp.conf</a> als
seine Konfigurationsdatei. Es gibt viele hilfreiche Dateien in <b>/etc/ppp</b>, 
die verschiedene Einstellungen f&uuml;r verschiedene Situationen zeigen. Du solltest 
dir dieses Verzeichnis ansehen und es durchforsten.
</p>

<p>
Solltest du keinen GENERIC Kernel verwenden, dann stelle sicher, da&szlig; du 
folgende Zeile in deiner Kernelkonfigurationsdatei hast:
</p>

<blockquote><pre><strong>
pseudo-device   tun             2
</strong></pre></blockquote>

<h3>Erste Einstellungen - f&uuml;r PPP(8)</h3>

<p>
Die ersten Einstellungen f&uuml;r den Userland PPP D&auml;mon bestehen im Erstellen 
deiner <b>/etc/ppp/ppp.conf</b> Datei. Diese Datei existiert nicht 
standardm&auml;&szlig;ig, aber du kannst einfach <b>/etc/ppp/ppp.conf.sample</b> 
editieren, um deine eigene <b>ppp.conf</b> Datei zu kreieren. Hier werde ich mit 
dem einfachsten und gebr&auml;chlichsten Einstellungen beginnen.
Hier eine schnelle <b>ppp.conf</b> Datei, die uns einfach zu deinem ISP verbindet 
und die Standardrouten und Nameserver setzt. F&uuml;r diese Datei brauchst du nur 
die Telefonnummer deines ISP sowie deinen Benutzernamen und dein Passwort.
</p>

<blockquote><pre>
default:
set log Phase Chat LCP IPCP CCP tun command     
set device /dev/cua01                           
set speed 115200     
set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \"\" AT OK-AT-OK ATE1Q0 OK\\dATDT\\T TIMEOUT 40 CONNECT"
</pre></blockquote>

<p>
Der Absatz unter der <b>default:</b> Bezeichnung wird jedes Mal ausgef&uuml;hrt. 
Hier stehen alle wichtigen Informationen. Mit &quot;set log&quot; stellen wir die 
Loglevel ein. Um dies zu &auml;ndern, siehe 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&sektion=8">ppp(8)</a>
f&uuml;r weitere Info. Unsere Schnittstelle 
wird mit &quot;set device&quot; eingestellt. Dies ist die Schnittstelle, mit der das 
Modem verbunden ist. In diesem Beispiel h&auml;ngt das Modem auf COM Port 2. Daher 
wird COM Port 1 auf /dev/cua00 gesetzt. Mit &quot;set speed&quot; setzen wird die 
Geschwindigkeit unserer Dialup Verbindung und mit &quot;set dial&quot; setzen wir unsere 
Dialup Parameter, mit denen wir die timeout Zeit, usw. setzen k&ouml;nnen. Diese Zeile 
sollte eigentlich ziemlich genau so, wie sie jetzt ist, bleiben.
</p>

<p>
Nun k&ouml;nnen wir die ISP spezifischen Informationen eintragen. Wir tun dies, indem 
wir unter <b>default:</b> einen weiteren Absatz hinzuf&uuml;gen. Dieser kann als alles 
benannt werden, am einfachsten nimmst du den Namen deines ISP. Hier werde ich 
<b>myisp:</b> als Verweis auf unseren ISP nehmen. Hier ist ein einfaches Beispiel, 
das alles beinhaltet, um uns zu verbinden.
<p>

<blockquote><pre>
myisp:
set phone 1234567   
set login "ABORT NO\\sCARRIER TIMEOUT 5 ogin:--ogin: ppp word: ppp"
set timeout 120   
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
add default HISADDR 
enable dns
</pre></blockquote>

<p>
Hier stehen alle wichtigen Informationen f&uuml;r unseren spezifischen ISP. Die erste 
Option &quot;set phone&quot; setzt die Telefonnummer deines ISP. &quot;set login&quot; 
setzt unsere login-Optionen. Hier haben wir die timeout auf 5 gesetzt, was bedeutet, 
da&szlig; wir unseren login-Versuch nach 5 Sekunden abbrechen, wenn wir kein 
Tr&auml;gersignal bekommen. Ansonsten wird er auf &quot;login:&quot; warten und dann 
deinen Benutzernamen und Passwort senden. In diesem Beispiel ist unser username = ppp 
und das Password = ppp. Diese Werte m&uuml;ssen ge&auml;ndert werden. Die Zeile 
&quot;set timeout&quot; setzt den Idle timeout f&uuml;r die gesamte Verbindungsdauer auf 120 
Sekunden. Die &quot;set ifaddr&quot; Zeile ist ein bi&szlig;chen schwieriger. Hier ist 
eine genauere Erkl&auml;rung.
</p>

<blockquote><pre>
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
</pre></blockquote>

<p>
Die obigen Zeile folgt dem Format von 
&quot;<b>set ifaddr [meineAdr[/nn] [seineAdr[/nn] [netzmaske [startAdr]]]]</b>&quot;. 
Daher ist die erste spezifizierte IP diejenige, die wir als unsere IP wollen. Wenn du 
eine statische IP Adresse hast, dann kannst du sie hier einsetzen. In unserem Beispiel 
benutzen wir /0, was besagt, da&szlig; kein Bits von dieser IP Adresse &uuml;bereinstimmen 
mu&szlig; und der gesamte Ausdruck ersetzt werden kann. Die zweite IP behandelt die von 
uns erwartete IP unserer Gegenstelle. Wenn du sie wei&szlig;t, dann kannst du sie hier 
angeben. Wiederum wissen wir nicht in unserer Zeile, welche IP dies wird, also lassen 
wir sie um wieder mitteilen. Die dritte Option ist unsere Netzmaske, hier auf 
255.255.255.0 gesetzt. Wenn startAdr spezifiziert ist, dann wird diese anstelle von 
meineAdr w&auml;hrend der initialen IPCP Verhandlung; aber es wird nur eine Adresse aus 
dem meineAdr-Adressbereich akzeptiert. 
</p>

<p>
Die n&auml;chste Option &quot;add default HISADDR&quot; setzt unsere Standardroute 
zu deren IP. Dies ist 'klebrig', d. h falls deren IP sich &auml;ndern sollte, dann 
wird unsere Route auch automatisch upgedatet. Mit &quot;enable dns&quot; teilen wir 
unserem ISP mit, unsere Nameserveradresse zu authentifizieren. Tu dies NICHT, wenn du 
deinen eigenen lokalen DNS laufen hast, da PPP dies umgehen wird, indem es einige 
Zeilen in /etc/resolv.conf schreibt.
</p>

<h3>PPP(8) verwenden</h3>

<p>
Nun, da wir unsere <b>ppp.conf</b> Datei fertig eingerichtet haben, k&ouml;nnen wir 
beginnen, eine Verbindung zu unserem ISP aufzubauen. Hier einige Details &uuml;ber 
h&auml;ufig verwendete Parameter.
</p>

<ul>
<li><b>ppp -auto myisp</b> - Startet PPP, konfiguriert deine Schnittstellen und 
wird dich mit deinem ISP verbinden und dann in den Hintergrund verschwinden.
<li><b>ppp -ddial myisp</b> - &Auml;hnlich wie -auto, aber wenn deine Verbindung 
abbricht, wird PPP versuchen, sich erneut zu verbinden.
</ul>

<p>
Mit dem Aufruf von <b>/usr/sbin/ppp</b> ohne Optionen kommst du in den interaktiven 
Modus. Hier kannst du direkt mit dem Modem interagieren, was sich hervorragend eignet, 
um Probleme in deiner <b>ppp.conf</b> Datei zu debuggen.
</p>

<h3>ppp(8) Extras</h3>

<p>
In einigen Situationen m&ouml;chstest du Befehle ausf&uuml;hren, wenn die 
Verbindung gerade errichtet oder beendet wurde. F&uuml;r diese F&auml;lle gibts es zwei 
Dateien, die du kreieren kannst: <b>/etc/ppp/ppp.linkup</b> und 
<b>/etc/ppp/ppp.linkdown</b>.
Beispielskonfigurationen kannst du hier finden:
</p>

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkup.sample">ppp.linkup</a>
<li><a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkdown.sample">ppp.linkdown</a>
</ul>

<p>
Weitere Informationen findest du im
<a href="http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/userppp.html">FreeBSD Handbook entry on User PPP</a>. 
</p>

<p>
<a name= "Tuning"></a>
<a name= "6.6"></a>
<h2>6.6 - Netzwerkparameter tunen</h2>
<!-- XXXrelease -->

<H3>6.6.1 - Wie kann ich den Kernel einstellen, damit es eine h&ouml;here
Anzahl an Verbindungsversuchen und l&auml;ngere Timeouts f&uuml;r TCP Sitzungen
gibt?</h3>
Du solltest dies normalerweise nur verwenden, wenn du Routing- oder
Verbindungsprobleme hast. Nat&uuml;rlich sollten - um die beste Wirkung zu
erzielen - beide Seiten der Verbindung dieselben Werte verwenden.
<P>
Um dies zu tunen, verwende <tt>sysctl</tt> und erh&ouml;he die Werte von:
<pre>
net.inet.tcp.keepinittime
net.inet.tcp.keepidle
net.inet.tcp.keepintvl
</pre>
Mittels <tt>sysctl -a</tt> kannst du die derzeitigen Werte dieser (und vieler
anderer) Parameter sehen. Um einen Wert zu ver&auml;ndern, verwende 
<tt>sysctl -w</tt>, wie z. B. <tt>sysctl -w net.inet.tcp.keepidle=28800</tt>.  

<h3>6.6.2 - Wie kann ich "directed broadcasts" aktivieren?</h3>
Normalerweise willst du dies nicht tun.  Dies erlaubt jemand, Datenverkehr zu
der broadcast Adresse deines verbundenen Netzwerkes zu schicken, wenn du deinen 
OpenBSD Rechner als Router verwendest.<P>
Aber manchmal kann dies (in geschlossenen Netzwerken) n&uuml;tzlich sein,
vor allem wenn man &auml;ltere Implementierungen des NetBIOS Protokolles
verwendet.
Wiederum mit sysctl.  <tt>sysctl -w net.inet.ip.directed-broadcast=1</tt> 
aktiviert dies.  Beachte aber <a href="http://www.netscan.org">Smurfangriffe</a>, 
wenn du wissen willst, warum dies standardm&auml;&szlig;ig nicht aktiviert ist.

<H3>6.6.3 - Der Kernel soll Ports nicht dynamisch allozieren</h3>
Auch daf&uuml;r gibt es einen eigenen sysctl Befehl.  Siehe 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&apropos=0&sektion=8&format=html">sysctl(8)</a>:
<PRE>
Setze die Liste der reservierten TCP ports, die nicht dynamisch vom
Kernel vergeben werden sollen. Das kann man benutzen, um daemons davon
abzuhalten, einen speziellen port zu benutzen, den ein anderes Programm
braucht, damit es funktionieren kann. Listen-Elemente k&ouml;nnen
mit Kommata und/oder Leerzeichen getrennt werden.

#  <strong>sysctl -w  net.inet.tcp.baddynamic=749,750,751,760,761,871</strong>

Es ist ebenso m&ouml;glich ports aus der aktuellen Liste hinzuzuf&uuml;gen 
oder zu entfernen.

 #  <strong>sysctl -w net.inet.tcp.baddynamic=+748</strong>
 #  <strong>sysctl -w net.inet.tcp.baddynamic=-871</strong>
</pre>

<p>
<a name= "NFS"></a>
<a name="6.7"></a>
<h2>6.7 - Einfache NFS Anleitung</h2>
</p>

<p>NFS, oder Network File System (Netzwerkdateisystem), wird verwendet, um 
ein Dateisystem &uuml;ber das Netzwerk zu verwenden. Du solltest vorher noch 
folgende Manualseiten lesen, bevor du versuchst, einen eigenen NFS Server 
aufzusetzen:

<p>

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nfsd&sektion=8">nfsd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mountd&sektion=8">mountd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&sektion=5">exports(5)</a>
</ul>

<p>
Dieses Kapitel zeigt die Schritte, um ein einfaches NFS System aufzusetzen: 
Ein Server im LAN und Klienten im LAN, die NFS verwenden. Es behandelt nicht, 
wie man NFS sicher macht. Wir nehmen an, da&szlig; du bereits Paketfilterung 
oder irgendeinen anderen Firewallschutz eingerichtet hast, damit von 
au&szlig;erhalb nicht auf NFS zugegriffen werden kann.
Wenn du Zugriff via NFS von au&szlig;erhalb erlauben willst und sensible Daten 
dort gespeichert hast, dann empfehlen wir dir w&auml;rmstens den Gebrauch von 
<A HREF="../faq13.html">IPsec</a>.  Ansonsten k&ouml;nnen andere Leute 
m&ouml;glicherweise deinen NFS Datenverkehr sehen. Jemand k&ouml;nnte auch 
vort&auml;uschen, die IP Adresse zu sein, der du Zugriff auf den NFS Server 
l&auml;&szlig;t. Es gibt mehrere Angriffe, die m&ouml;glich sind. Wenn IPsec 
richtig konfiguriert ist, dann sch&uuml;tzt es gegen die Art von Angriffen. 
<P>
Noch eine wichtige Anmerkung wegen Sicherheit. F&uuml;ge niemals ein 
Dateisystem zu /etc/exports ohne eine Liste mit Rechnern, die explizit 
Zugriff haben sollen. Ohne einer solchen Liste, die ein bestimmtes Verzeichnis 
mounten k&ouml;nnen, kann jeder, der den Rechner erreichen kann, deine NFS 
exports mounten.
</p>

<p>
NFS h&auml;ngt von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=portmap&amp;sektion=8">portmap(8)</a>
ab, bevor es funktionieren kann. Portmap(8) ist ab OpenBSD 3.2 
standardm&auml;ssig abgeschaltet, du musst es also in
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&amp;sektion=8">rc.conf(8)</a>
wieder einschalten, indem du die <tt>portmap</tt> Zeile wie folgt &auml;nderst:

<blockquote><pre>
portmap=YES
</pre></blockquote>
und ein Reboot ist notwendig, damit die &Auml;nderung wirksam wird.

<p>
Der Server hat die IP <b>10.0.0.1</b>. Dieser Server soll nur NFS f&uuml;r 
Rechner innerhalb dieses Netzwerkes bereitstellen. Der erste Schritt ist 
deine <i>/etc/exports</i> Datei zu erstellen. Diese Datei listet die 
Dateisysteme auf, die du &uuml;ber NFS freigeben willst, und definiert, wer 
auf sie zugreifen darf. Es gibt viele Optionen, die du in deiner 
<i>/etc/exports</i> Datei haben kannst, und am besten ist, du liest 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&sektion=5">exports(5)</a>
F&uuml;r dieses Beispiel sieht <i>/etc/exports</i> so aus:
</p>

<blockquote><pre>
#
# NFS exports Database
# See exports(5) for more information.  Be very careful, misconfiguration
# of this file can result in your filesystems being readable by the world.
/work -alldirs -ro -network 10.0.0 -mask 255.255.255.0
</pre></blockquote>

<p>
D.h., da&szlig; das lokale Dateisystem <b>/work</b> via NFS zug&auml;nglich 
gemacht wird. <b>-alldirs</b> bedeutet, da&szlig; Klienten jedes Verzeichnis 
unter dem <b>/work</b> Mount-point mounten k&ouml;nnen. <b>-ro</b> bedeutet,  
da&szlig; nur Leseberechtigung gestattet wird. Die letzten zwei Argumente 
bedeuten, da&szlig; nur Klienten innerhalb des 10.0.0.0 Netzwerkes mit einer 
Netzmaske von 255.255.255.0 dieses Dateisystem mounten d&uuml;rfen. Dies ist 
wichtig f&uuml;r einige Server, die von verschiedenen Netzwerken 
zug&auml;nglich sind.
</p>

<p> Ist einmal deine <i>/etc/exports</i> Datei eingerichtet, kannst du 
weitergehen und deinen NFS Server aufsetzen. Du solltest zuerst sicherstellen, 
da&szlig; deine Kernelkonfiguration die Optionen NFSSERVER &amp; NFSCLIENT 
enth&auml;lt. (Der GENERIC Kernel beinhaltet diese Optionen.) Dann 
solltest du <strong>nfs_server=YES</strong> in <i>/etc/rc.conf</i> eintragen. 
Dies wird sowohl nfsd(8) und mountd(8) starten, wenn du rebootest.
Nun kannst du fortschreiten und die Dienste selber starten. Diese Dienste 
m&uuml;ssen als root gestartet werden und du mu&szlig;t sicherstellen, 
da&szlig; portmap(8) auf deinem System l&auml;uft. Hier ein Beispiel von 
nfsd(8), der sowohl mit TCP als auch mit UDP bedient mittels 4 Diensten. 
Du solltest eine angemessenene Anzahl von NFS Serverdiensten einsetzen, um 
die maximale Anzahl von gleichzeitigen Klientenanfragen, die du bedienen 
willst, zu bewerkstelligen.

<P>

<blockquote><pre>
# <strong>/sbin/nfsd -tun 4</strong>
</pre></blockquote>

<p>
Du mu&szlig;t nicht nur den nfsd(8) Server starten, sondern auch mountd(8). 
Dies ist der Dienst, der eigentlich die Mountanfragen auf NFS bedient. Um 
mountd(8) zu starten stelle sicher, dass eien leere mountdtab Datei
existiert, und starte den Daemon:
<p>

<blockquote><pre>
# <strong>echo -n &gt;/var/db/mountdtab</strong>
# <strong>/sbin/mountd</strong>
</pre></blockquote>

<P>
Wenn du &Auml;nderungen an /etc/exports durchf&uuml;hrst, w&auml;hrend 
NFS bereits l&auml;uft, mu&szlig;t du mountd dies mitteilen, indem du den 
Dienst neu startest!

<UL><PRE>
# <strong>kill -HUP `cat /var/run/mountd.pid`</strong>
</pre></blockquote>

<P>

<h3>NFS Status &uuml;berpr&uuml;fen</h3>

<p>
Um zu &uuml;berpr&uuml;fen, ob alle Dienste laufen und bei RPC registriert 
sind, verwende rpcinfo(8). 
<p>

<blockquote><pre>
$ <strong>rpcinfo -p 10.0.0.1</strong>
   program vers proto   port
    100000    2   tcp    111  portmapper
    100000    2   udp    111  portmapper
    100005    1   udp    633  mountd
    100005    3   udp    633  mountd
    100005    1   tcp    916  mountd
    100005    3   tcp    916  mountd
    100003    2   udp   2049  nfs
    100003    3   udp   2049  nfs
    100003    2   tcp   2049  nfs
    100003    3   tcp   2049  nfs
</pre></blockquote>

<p> F&uuml;r den Normalgebrauch gibt es ein paar Hilfsprogramme, mit denen 
du den Status von NFS &uuml;berpr&uuml;fen kannst. Eines ist 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=showmount&sektion=8">showmount(8)</a>
das dir anzeigt, was und wer gerade mountet. Dann gibt es auch noch nfsstat(8),
das genauere Statistiken anzeigt. F&uuml;r showmount(8), versuche 
<b>/usr/bin/showmount -a host</b>. Z. B.:

<P>

<blockquote><pre>
$ <strong>/usr/bin/showmount -a 10.0.0.1</strong>
All mount points on 10.0.0.1:
10.0.0.37:/work
</pre></blockquote>

<h3>NFS Dateisysteme mounten</h3>

<p>
NFS Dateisysteme sollten mittels mount(8) geladen werden, oder genauer 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount_nfs&sektion=8">mount_nfs(8)</a>.
Um ein Dateisystem /work von Host 10.0.0.1 auf dem lokalen Dateisystem /mnt 
zu laden, tue folgendes (NB: du mu&szlig;t nicht IP Adressen verwenden, mount 
wird Hostnamen aufl&ouml;sen):
<p>

<blockquote><pre>
# <strong>mount -t nfs 10.0.0.1:/work /mnt</strong>
</pre></blockquote>

<P>
Damit dein System dies beim Hochfahren wieder tut, f&uuml;ge folgendes zu 
deiner <i>/etc/fstab</i>:
<P>

<UL><PRE>
10.0.0.1:/work /mnt nfs rw 0 0
</pre></blockquote>

<P>
Es ist wichtig, da&szlig; du <tt>0 0</tt> am Ende dieser Zeile verwendest, 
damit dein Rechner nicht versucht, das NFS Dateisystem beim Hochfahren mit 
fsck zu &uuml;berpr&uuml;fen!!!! Die anderen Sicherheitsoptionen wie noexec, 
nodev und nosuid, sollten auch immer - wenn anwendbar - verwendet werden. 
Z. B.:
<P>

<UL><PRE>
10.0.0.1:/work /mnt nfs rw,nodev,nosuid 0 0
</pre></blockquote>

<P>
Mit diesen Optionen k&ouml;nnen keine Ger&auml;te oder setuid Programme auf 
dem NFS Server Sicherheitsma&szlig;nahmen auf dem NFS Klient untergraben. 
Wenn du keine Programme auf diesem NFS Dateisystem auf dem NFS Klient 
ausf&uuml;hren willst, f&uuml;ge noexec hinzu:

<p>
<a name= "DNS"></a>
<a name="6.8"></a>
<h2>6.8 - Domain Name Service  - DNS, BIND und named</h2>
</p>

<h3>6.8.1 Was ist DNS?</h3>

<p>
Domain Name Service bietet die M&ouml;glichkeit, Name-zu-IP Adresse 
Aufl&ouml;sung und IP Adresse-zu-Namen Aufl&ouml;sung auf eine Anfrage zu 
generieren. Deine OpenBSD Installation ist standardm&auml;&szlig;ig als DNS 
Klient, aber nicht als DNS Server konfiguriert. D.h., deine OpenBSD 
Installation kann eine DNS Anfrage an einen Domain Name Server f&uuml;r die
Adresse einer Maschine stellen, aber sie kann nicht selbst solche DNS 
Anfrage beantworten, bis du dies nicht selbst so konfigurierst.</p>

<p>
Meine OpenBSD Maschine ist derzeit mit dem Internet durch meinen ISP verbunden, 
so da&szlig; ich mit 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nslookup&sektion=8">nslookup(8)</a>
DNS Anfragen ausf&uuml;hren kann:
</p>

<blockquote><pre>
$ <strong>nslookup www.openbsd.org</strong>
Server:  ns4.us.prserv.net
Address:  165.87.201.244

Non-authoritative answer:
Name:    www.openbsd.org
Address:  129.128.5.191
</pre></blockquote>

<p>
<b>165.87.201.244</b> ist der Nameserver, der geantwortet hat, weil es der 
Nameserver ist, den mein ISP mir zu meinem Konto zugeteilt hat und in 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&sektion=5">/etc/resolv.conf</a>
eingetragen ist. Aber die Antwort war nicht authoritativ. F&uuml;r eine 
authoritative Antwort m&uuml;ssen wir den DNS Server f&uuml;r
die <i>openbsd.org</i> Dom&auml;ne finden und ihn nach der Adresse von 
<i>www.openbsd.org</i> fragen:
</p>

<blockquote><pre>
# Identifiziere die Nameserver f&uuml;r openbsd.org
# mit der Hilfe des Nameservers meines ISP.
$ <strong>nslookup -type=NS openbsd.org</strong>
Server:  ns4.us.prserv.net
Address:  165.87.201.244

Non-authoritative answer:
openbsd.org     nameserver = cvs.openbsd.org
openbsd.org     nameserver = gandalf.sigmasoft.com
openbsd.org     nameserver = cs.colorado.edu
openbsd.org     nameserver = ns.appli.se
openbsd.org     nameserver = zeus.theos.com

Authoritative answers can be found from:
cvs.openbsd.org internet Adresse = 199.185.137.3
gandalf.sigmasoft.com   internet Adresse = 198.144.202.98
cs.colorado.edu internet address = 128.138.243.151
ns.appli.se     internet address = 194.198.196.230
zeus.theos.com  internet address = 199.185.137.1

# Verwende die gefundenen Informationen, um eine Anfrage 
# f&uuml;r eine authoritative Aufl&ouml;sung zu stellen:
# befrage zeus.theos.com.
$ <strong>nslookup www.openbsd.org zeus.theos.com</strong>
Server:  zeus.theos.com
Adresse:  199.185.137.1

Name:    www.openbsd.org
Address:  129.128.5.191
</pre></blockquote>

<p>
Auf <i>zeus.theos.com</i> l&auml;ft OpenBSD und ist korrekt als DNS server 
f&uuml;r die <i>openbsd.org</i> Dom&auml;ne konfiguriert.
</p>

<a name="DNS.1.1"></a>
<a name="6.8.1.1"></a>
<h3>6.8.1.1 Wo kann ich alles &uuml;ber DNS und seine Implementationen unter 
OpenBSD lernen?</h3>

<ul>
<li>Siehe die RFCs <a href="http://www.faqs.org/rfcs/rfc1033.html">1033</a>, 
<a href="http://www.faqs.org/rfcs/rfc1034.html">1034</a> und 
<a href="http://www.faqs.org/rfcs/rfc1035.html">1035</a> f&uuml;r weitere 
Informationen &uuml;ber DNS zu erhalten.</li>
<li>Lies das O'Reilly Associates Buch <i><a href="../../de/books.html#6">DNS and BIND</a> </i>.</li>
<li>Lies die <a href="http://www.openbsd.org/cgi-bin/man.cgi">OpenBSD Manualseiten</a> 
vorallem die Seiten von</li>
      <ul>
       <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&sektion=1">dig(1)</a>
       <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nslookup&sektion=8">nslookup(8)</a>
       <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gethostbyname&sektion=3">gethostbyname(3)</a>
       <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=named&sektion=8">named(8)</a>
       <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolver&sektion=3">resolver(3)</a>
       <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolver&sektion=5">resolver(5)</a>
      </ul>
</ul>

<p>
Der <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&sektion=1">dig(1)</a>
Befehl ist besonders n&uuml;tzlich, weil er eine Dom&auml;ne befragen kann 
und Informationen zur&uuml;ckliefert, die einem Format unterliegen, das 
BIND Konfigurationsdateien sehr &auml;hnlich ist. Du kannst mit 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&sektion=1">dig(1)</a>
Nameserver untersuchen, von denen du wei&szlig;t, da&szlig; sie richtig 
funktionieren, und sie mit deinen Einstellungen vergleichen.
</p>

<h3>6.8.2 Mu&szlig; meine Maschine ein Domain Name Server sein?</h3>

<p>
Wenn du dir nicht sicher bist, ob dein Rechner die Rolle eines DNS Server 
spielen soll, dann konfiguriere ihn nicht als solchen. Die OpenBSD Installation
konfiguriert nicht standardm&auml;&szlig;ig deine Maschine als einen Domain 
Name Server, obwohl alle notwendigen Dateien daf&uuml;r installiert werden. 
F&uuml;r die meisten Arbeitsplatzrechner gen&uuml;gt die 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hosts&sektion=5">/etc/hosts</a>
Datei, um IP Adressen lokaler Rechner zu benennen und die 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&sektion=5">/etc/resolv.conf</a>
Datei, um die DNS Server im Intranet oder Internet einzustellen.
</p>

<p>
Aber wenn du vielleicht doch deinen Rechner als Domain Name Server 
konfigurieren mu&szlig;t:
<ul>
<li>Wenn du ein IP LAN betreibst, f&uuml;r das du nicht auf jedem Rechner 
die "hosts" Dateien mit den lokalen IP Adressen. In so einem Fall kannst du 
deinen OpenBSD Rechner als DNS Server konfigurieren und Anfragen der anderen 
Maschinen aus deinem LAN bedienen.</li>
<ul>
<li><b>Anmerkung:</b> Es gibt keine praktische Einschr&auml;kung bzgl. der 
Anzahl von DNS Servern in einem LAN. Einige oder alle Maschinen im LAN 
k&ouml;nnen DNS Dienste anbieten, wenn sie so konfiguriert sind. Ob einige 
dieser Server als authoritativ von au&szlig;erhalb deines LANs betrachtet 
werden (oder sie &uuml;berhaupt au&szlig;erhalb deines LANs bekannt sind), 
ist ein Konfigurationsfaktor, der typischerweise eine Ebene oberhalb deines 
LANs in der Dom&auml;nenhierarchie bestimmt wird.</li>
</ul>
<li>Wenn du ein IP LAN mit Rechnern hast, die auch via DNS von Rechnern 
anderer IP LANs und WANs auffindbar sein sollen.</li>
<li>Wenn du Schwierigkeiten hast, lokale Rechnernamen auf eine IP Adresse 
aufzul&ouml;sen oder andere lokale Namen zu IP Adressen, obwohl du korrekte 
<i>/etc/hosts</i> und <i>/etc/resolv.conf</i> Dateien hast (z.B.: Netscape 
auf OpenBSD hat manchmal dieses Verhalten, weil es seinen eigenen DNS 
Aufl&ouml;ser verwendet, anstatt einfach <i>gethostbyname(3)</i> zu 
ben&uuml;tzen, um IP Adressen nachzusehen.)</li>
</ul>

<p>
Eine weitere &Uuml;berlegung ist die Ausf&uuml;hrungsgeschwindigkeit. 
Da die Namensaufl&ouml;sung ein iterativer Prozess ist, in dem der Nameserver 
wiederholende Anfragen an andere Nameserver in entfernten Dom&auml;nen 
stellt, kann die Namensaufl&ouml;sung l&auml;nger dauern, wenn du eine 
Modemverbindung ins Internet hast und deinen DNS Server nach anderen, 
entfernten IP Adressen auf der Modemleitung befragst (die ihrerseits wieder 
andere entfernte DNS Server befragen), als wenn du den Nameserver deines ISP 
befragst (der wahrscheinlich eine schnellere Verbindung zu entfernten 
Nameservern hat). 
</p>

<h3>6.8.3 Was sind die Softwarekomponenten der DNS Server?</h3>

<ul>
<li>named <i>("name daemon")</i></li>
<li>Konfigurationsdateien in der Verzeichnishierarchie unter 
<i>/var/named/</i></li>
</ul>

<h4>6.8.3.1 Welche Versionen von BIND werden unterst&uuml;tzt?</h4>
<!-- XXXchanges - changes with OpenBSD 3.3 -->

<p>
BIND ist der Name einer Spezifikation eines Dom&auml;nennamensservers mit 
einem bestimmten Verhalten. Die DNS Komponenten ergeben gemeinsam 
die Implementation von BIND. 
</p>

<p>
Es gibt drei getrennte BIND Specifikationen:
<ol>
<li>BIND 4</li>
<li>BIND 8</li>
<li>BIND 9</li>
</ol>

<p>
Standardm&auml;ssig unterst&uuml;tzt OpenBSDs <b>named</b> BIND 4.x.

<h4>6.8.3.2 Welche Alternativen zu der Standard-BIND 4.x-Implementation 
gibt, um DNS Dienste bereitzustellen?</h4>
<!-- XXXexpires - goes away when 3.2 becomes unsupported -->

<ul>
<li>Die BIND 9.x Implementation ist in <i>/usr/ports/net/bind9</i>.(Siehe <a href="../../de/ports.html">ports</a>)
</ul>

<h5>6.8.3.2.1 <u>Sicherheitsanmerkung</u></h5>

<p>
Wenn du diese alternativen Implementationen von DNS Diensten in betracht 
ziehst, dann stellst du einen kritischen Netzwerkdienst zur Verf&uuml;gung, 
dessen Software nicht dem selben Niveau an &Uuml;berpr&uuml;fung wie durch
<a href="../../de/security.html">Sicherheit</a> dem <b>named</b> name daemon in 
der Basisinstallation zu Teil wurde. Dies ist eine signifikante &Uuml;berlegung,
da, falls ein DNS Server kompromittiert wird, die Klients zu 
betr&uuml;gerischen Webseiten umgeleitet werden k&ouml;nnen.
</p>

<h3>6.8.4 Wieviel mu&szlig; ich installieren?</h3>

<p>
Wenn die standardm&auml;ssige Netzwerkinstallation korrekt bei der 
Installation von OpenBSD eingerichtet hast, dann ist bereits alles 
installiert. Du mu&szlig;t nur mehr den Nameserverdienst ("<tt>named</tt>") 
konfigurieren.
</p>

<h3>6.8.5 Wie konfiguriere ich DNS?</h3>
<!-- XXXchanges - changes with OpenBSD 3.3 -->

<p>
Du konfigurierst OpenBSD DNS, indem du Dateien editierst und/oder erstellst, 
die den Nameserverdienst <tt>named</tt> steuern. Diese Dateien liegen 
standardm&auml;&szlig;ig im Verzeichnis <i>/var/named</i> und dessen 
Unterverzeichnisse, haupts&auml;chlich in der Datei 
<i>/var/named/named.boot</i>, das die Initialisierungsdatei f&uuml;r 
<b>named</b> ist. Weiterhin gibt es ein paar andere notwendige 
Konfigurationsschritte in <i>/etc</i>.
</p>

<p>
In diesem Dokument werden wir den Nameserverdienst auf <i>nemo.yewtopia.com</i>
konfigurieren, der der prim&auml;re Nameserver f&uuml;r die (sehr kleine!) 
Dom&auml;ne <i>yewtopia.com</i> sein wird. Die Adresse von 
<i>nemo.yewtopia.com</i> ist <i>192.168.1.9</i>. Zwei andere Maschinen 
befinden sich im selben Subnet, <i>crater.yewtopia.com </i> auf 192.168.1.1 
und <i>earhart.yewtopia.com</i> auf 192.168.1.2.
</p>

<h4>6.8.5.1 Konfiguration in <i>/var/named</i></h4>
<!-- XXXchanges - changes with OpenBSD 3.3 -->

<h5>6.8.5.1.1 <i>/var/named/named.boot</i></h5>

<blockquote><pre>
; tell what subdir has the lookup database files
directory       /namedb

; type    domain                source host/file
; type    domain   source host/file backup file
cache     .       root.cache
primary   0.0.127.IN-ADDR.ARPA  localhost.rev

; example primary server config:
primary  yewtopia.com yewtopia
primary  1.168.192.IN-ADDR.ARPA yewtopia.rev
</pre></blockquote>

<p>
Dies teilt dem Initialisierungsproze&szlig; mit, in welchem Unterverzeichnis 
und unter welchem Dateinamen die Konfigurationsdateien f&uuml;r 
<i>yewtopia.com</i> zu finden sind. 

<h5>6.8.5.1.2 <i>/var/named/namedb/localhost.rev</i></h5>

<blockquote><pre>
; Reverse lookup f&uuml;r localhost interface
@       IN      SOA     nemo.yewtopia.com.  your_id.nemo.yewtopia.com.  (
                                14      ; Serial
                                3600    ; Refresh
                                900     ; Retry
                                3600000 ; Expire
                                3600 )  ; Minimum
        IN      NS      nemo.yewtopia.com.
1       IN      PTR     localhost.yewtopia.com.
</pre></blockquote>

<h5>6.8.5.1.3 <i>/var/named/namedb/yewtopia</i></h5>

<blockquote><pre>
; yewtopia.com domain database
@      IN      SOA     nemo.yewtopia.com.  your_id.nemo.yewtopia.com.  (
                                14      ; Serial
                                3600    ; Refresh
                                900     ; Retry
                                3600000 ; Expire
                                3600 )  ; Minimum
                     IN      NS      nemo.yewtopia.com.

; Addresses
localhost.yewtopia.com.      IN A    127.0.0.1
crater.yewtopia.com.         IN A    192.168.1.1
earhart.yewtopia.com.        IN A    192.168.1.2
nemo.yewtopia.com.           IN A    192.168.1.9
</pre></blockquote>

<h5>6.8.5.1.4 <i>/var/named/namedb/yewtopia.rev</i></h5>

<blockquote><pre>
; yewtopia domain reverse lookup database
@      IN      SOA     nemo.yewtopia.com.  your_id.nemo.yewtopia.com.  (
                                14      ; Serial
                                3600    ; Refresh
                                900     ; Retry
                                3600000 ; Expire
                                3600 )  ; Minimum
1.168.192.in-addr.arpa. IN      NS      nemo.yewtopia.com.

; Addresses
1.1.168.192.in-addr.arpa. IN PTR crater.yewtopia.com.
2.1.168.192.in-addr.arpa. IN PTR earhart.yewtopia.com.
9.1.168.192.in-addr.arpa. IN PTR nemo.yewtopia.com.
</pre></blockquote>

<h4>6.8.5.2 Konfiguration in <i>/etc</i></h4>

<h5>6.8.5.2.1 <i>/etc/resolv.conf</i></h5>
<p>
Stelle sicher, da&szlig; <i>/etc/resolv.conf</i> nun auf die Dom&auml;ne 
des lokalen Rechners (anstatt auf, z. B., den Nameserver deines ISPs) zeigt, 
so da&szlig; die Namensaufl&ouml;sungsanfragen auch wirklich zu dem 
<b>named</b> geschickt werden, den du konfiguriert hast!
</p>

<blockquote><pre>
domain yewtopia.com
lookup file bind
</pre></blockquote>

<h4>6.8.5.2.2 <i>/etc/hosts</i></h4>

<p>
Wenn du vorher die Adressen von diversen Rechnern zu der <i>/etc/hosts</i> 
Datei hinzugef&uuml;gt hattest, dann solltest du in Betracht ziehen, deine 
<i>/etc/hosts</i> Datei wieder auf Standardgr&ouml;&szlig;e zu k&uuml;rzen: 
</p>

<blockquote><pre>
# Host addresses
127.0.0.1       localhost       localhost.localdomain
192.168.1.9     nemo            nemo.yewtopia.com
</pre></blockquote>

<p>
Damit <b>named</b> nicht zugunsten von (m&ouml;glicherweise veralteten) 
Adressen in der <i>/etc/hosts</i> Datei &uuml;bergangen wird. <u>Stelle 
sicher, da&szlig; du zumindest den Standardeintrag<i>localhost</i></u> 
hast, oder dein Netzwerk wird nicht richtig starten!! Auch <i>nemo</i> 
mu&szlig; in seiner eigenen hosts-Datei aufscheinen, oder du wirst eine 
(eher harmlosen) Fehlermeldung zu Bootzeit bemerken,  wenn <i>/etc/netstart</i>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=route&sektion=8">route(8)</a>
aufruft, um <i>nemo</i> hinzuzuf&uuml;gen (dessen Name in <i>/etc/myname</i> 
aufscheint).
</p>

<h4>6.8.5.3 Mittels <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&sektion=1">dig(1)</a>
die Ergebnisse untersuchen.</h4>

<blockquote><pre>
$ <strong>dig @nemo.yewtopia.com yewtopia.com any any</strong>

; &lt;&lt;&gt;&gt; DiG 2.2 &lt;&lt;&gt;&gt; @nemo.yewtopia yewtopia any any
; (1 server found)
;; res options: init recurs defnam dnsrch
;; got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 59904
;; flags: qr rd ra; Ques: 1, Ans: 2, Auth: 0, Addit: 1
;; QUESTIONS:
;;      yewtopia.com, type = ANY, class = ANY

;; ANSWERS:
yewtopia.com.   3600    SOA    nemo.yewtopia.com.  your_id.nemo.yewtopia.com. (
                        14      ; serial
                        3600    ; refresh (1 hour)
                        900     ; retry (15 mins)
                        3600000 ; expire (41 days 16 hours)
                        3600 )  ; minimum (1 hour)
yewtopia.com.   3600    NS      nemo.yewtopia.com.

;; ADDITIONAL RECORDS:
nemo.yewtopia.com.  3600    A       192.168.1.9

;; Total query time: 4 msec
;; FROM: nemo to SERVER: nemo.yewtopia.com  192.168.1.9
;; WHEN: Tue May  2 23:47:19 2000
;; MSG SIZE  sent: 25  rcvd: 102
</pre></blockquote>

<h3>6.8.6 Wie kann ich DNS starten und stoppen?</h3>

<h4>6.8.6.1 DNS starten</h4>

<p>
Der Nameserverdienst <b>named</b> wird beim Systemstart von 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&sektion=8">/etc/rc</a>
gestartet, wenn die folgende Zeile (standardm&auml;&szlig;ig vorhanden) sich 
in <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&sektion=8">/etc/rc.conf</a>
befindet.
</p>

<blockquote><pre>
named_flags=NO          # f&uuml;r normal use: ""
</pre></blockquote>
 
<p>
ver&auml;ndere in
</p>

<blockquote><pre>
named_flags=""          # f&uuml;r normal use: ""
</pre></blockquote>

<p>
Beachte auch diese Zeilen in /etc/rc.conf:
</p>

<blockquote><pre>
named_user=named                # Named should not run as root unless neccesary
named_chroot=/var/named         # Where to chroot named if not empty
</ul></pre>

<p>
Diese Standardeinstellungen werden f&uuml;r beinahe alle Installationen 
korrekt sein.
</p>

<p>
Um <b>named</b> h&auml;ndisch zu starten, verwende den 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ndc&sektion=8">ndc(8)</a>
Befehl. Z. B.:
</p>

<blockquote><pre>
# <strong>ndc start</strong>
          oder
# <strong>ndc reload</strong>
</pre></blockquote>

<h4>6.8.6.2 DNS Stoppen</h4>

<p>
Der beste Weg, um den Nameserverdienst zu stoppen, ist den 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ndc&sektion=8">ndc(8)</a>
Befehl zu verwenden. Z. B.:
</p>

<blockquote><pre>
# <strong>ndc stop</strong>
</pre></blockquote>

<p>
Wenn dies fehlschl&auml;gt, finde die Proze&szlig;-ID von named und 
verwende den 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=kill&sektion=1">kill(1)</a>
Befehl, um diesen Proze&szlig; zu beenden. Die PID f&uuml;r <b>named</b>, 
solange er l&auml;uft, kannst du in der ersten Zeile der Datei 
<i>/var/named/named.pid</i> finden.
</p>

<blockquote><pre>
# <strong>cat /var/named/named.pid</strong>
4608
named -t /var/named -u named
# <strong>kill -KILL 4608</strong>
</pre></blockquote>

<h4>6.8.6.3 Restarting DNS with an altered configuration</h4>

<p>
<h3>6.8.7 How do I block AXFR queries? </h3>
<p>
Beispiel:
<blockquote><pre>
garden:/home/jeremy$<strong>  host -l openssh.com</strong>
openssh.com.            NS      zeus.theos.com.
openssh.com.            NS      cvs.openbsd.org.
openssh.com.            NS      gandalf.sigmasoft.com.
openssh.com.            NS      cs.colorado.edu.
openssh.com.            NS      ns.appli.se.
openssh.com.            A       199.185.137.4
cvs.openssh.com.        A       199.185.137.4
localhost.openssh.com.  A       127.0.0.1
</pre></blockquote>
<p>
Diese Information ist n&uuml;tzlich f&uuml;r das Debuggen von DNS, aber in manchen F&auml;llen willst du diesen
Output nicht in aller Welt zeigen.
Wenn du klassenloses in-addr(rfc2317) f&uuml;r reverse benutzt, k&ouml;nnte 'host -l' jede Domain anzeigen, die
dein System hostet!
Dies kann man einfach mit der 'allow-transfer' Formulierung in deinem zone file verhindern.
<br><br>
Wenn du Bind8 benutzt, musst du die Hosts spezifizieren, denen du den "Zonen-Transfer" erlauben willst, und zwar in deinen
individuellen Zone Datei(en):
<blockquote><pre>
zone "foo.com" in {
        type master;
        file "directory/zonefile";
        allow-transfer {
          127.0.0.1;
          10.0.0.6;
          10.0.255.12;
        };
};
</pre></blockquote>
Du kannst auch Transfers f&uuml;r alle Domains stoppen, indem du /var/named.conf anpasst und und den 'allow-transfer' Parameter 
zur options Sektion der Konfigurationsdatei hinzuf&uuml;gst:
<blockquote><pre>
   options {
        allow-transfer { 127.0.0.1; };
    };
</pre></blockquote>
Die Bind8 Methode funktioniert auch mit Bind9.<br>
Bei Bind 4 (Standard in OpenBSD) kannst du /var/named/named.boot anpassen und die 'xfrnets' Option nutzen.<br>
xfrnets 209.142.221.5 12.7.96.7
; type    domain                source host/file                backup file
cache     .                                                     root.cache
primary   0.0.127.IN-ADDR.ARPA  localhost.rev
</pre></blockquote><br>
Bind 4 erlaubt Transfers von ganzen Klassen, ist also nicht so exakt.
Typischerweise sind die einzigen Hosts, die Transfers durchf&uuml;hren m&uuml;ssen deine DNS Slaves und Hosts 
von denen du vielleicht 'debug'en  willst (127.0.0.1 ist meist ein guter Host, dem man Transfers erlauben sollte!)
AXFR queries zu blocken f&uuml;gt einen zus&auml;tzlichen Level an Privatsphere ein, kann aber ein sinnvolles DNS 
debugging behindern.
(Danke an <a href=mailto:ntang@nachtwache.org>Nicholas Tang</a> f&uuml;r diesen Tip)
</p>

<h3>6.8.8 Was hast du mir nicht &uuml;ber das Aufsetzen von DNS erz&auml;hlt?</h3>
Es gibt eine Menge von Dingen, die ich dir nicht erz&auml;hlt habe, z.B. 
wie man DNS so aufsetzt, dass Anfragen f&uuml;r Intranet Domains, die von 
der root der Domain-Hierarchie aus nicht sichtbar sind, zu Servern innerhalb deines Unternehmens weitergeleitet werden.
Lies die <a href="#DNS.1.1">empfohlenen Dokumente</a>, um mehr Informationen &uuml;ber DNS zu erhalten.
</p>

<p>
<a name= "PPTP"></a>
<a name="6.9"></a>
<h2>6.9 - Eine PPTP Verbindung mit OpenBSD aufsetzen</h2>
</p>

<p>
<strong>HINWEIS:</strong> Dies bezieht sich nicht auf <strong>ALLE</strong> ADSL Provider, aber viele der Informationen k&ouml;nnen aus diesem Setup 
&uuml;bernommen werden. Dieses Setup funktioniert auf jeden Fall bei <a href="http://www.inode.at">Inode</a>, einem ADSL Provider in &Ouml;sterreich.
</p>

<p>
Als Anfang musst du pptp installiert haben. Der Port befindet sich unter
<i>/usr/ports/net/pptp</i>. Lies <a href="../faq8.html#Ports">FAQ 8, 
Ports</a> um mehr Informationen &uuml;ber den OpenBSD ports tree zu 
bekommen.
</p>

<p>
Wegen des Konflikts der "Im-Kernel" 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gre&sektion=4">gre(4)</a>
Unterst&uuml;tzung und pptp wirst du deinen Kernel neu kompilieren 
m&uuml;ssen und die Unterst&uuml;tzung f&uuml;r gre(4) entfernen m&uuml;ssen.
</p>

<blockquote>Patch, um die GRE(4) Unterst&uuml;tzung zu entfernen.
<pre>
Index: GENERIC
===================================================================
RCS file: /cvs/src/sys/conf/GENERIC,v
retrieving revision 1.86
diff -u -r1.86 GENERIC
--- GENERIC     14 Mar 2002 00:42:25 -0000      1.86
+++ GENERIC     17 May 2002 01:52:17 -0000
@@ -87,7 +87,7 @@
 pseudo-device  enc     1       # option IPSEC needs the encapsulation interface
 pseudo-device  bridge  2       # network bridging support
 pseudo-device  vlan    2       # IEEE 802.1Q VLAN
-pseudo-device  gre     1       # GRE encapsulation interface
+#pseudo-device gre     1       # GRE encapsulation interface
 #pseudo-device strip   1       # Starmode Radio IP interface

 pseudo-device  pty     64      # pseudo-terminals
</pre></blockquote>

<p>
Um deinen Kernel neu zu kompilieren mache einen "check out" von OpenBSD 
via cvs (siehe die <a href="../../de/stable.html">OpenBSD Stable</a> 
Webseite) , benutze den folgenden Patch, und baue einen neuen Kernel 
wie unter <a href="faq5.html#Building">FAQ 5, Building a kernel</a>.
</p>

<p>
Nachdem du das <b>pptp</b> package und einen neuen Kernel installiert hast,
musst du ein paar Dateien f&uuml;r deine neue Verbindung editieren.
Diese packages benutzen das standarm&auml;ssige OpenBSD 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&sektion=8">ppp(8)</a>
wenn du dich also mit ppp(8) auskennst, kommt dir vieles bekannt vor. 
Siehe auch <a href="#Setup">FAQ 6, Setup</a>.
</p>

<ul>
<li>1 - /etc/ppp/options
<li>2 - /etc/ppp/pap-secrets
</ul>

<p>
F&uuml;r eine <i>/etc/ppp/options</i> Datei wird ein Setup wie das unten vermutlich alles notwendige tun:
</p>

<blockquote><pre>
# <strong>cat /etc/ppp/options</strong>
name "LOGINNAME"
noauth
noipdefault
defaultroute
debug
</pre></blockquote>

<p>
<tt>LOGINNAME</tt> sollte mit deiner User-ID ersetzt werden.
</p>

<p>
In <i>/etc/ppp/pap-secrets</i> geh&ouml;rt eine Zeile wie diese hier:

<blockquote><pre>
# <strong>cat /etc/ppp/pap-secrets</strong>
LOGINNAME 10.0.0.138 PASSWORD
</pre></blockquote>

<p>
Wobei LOGINNAME deine User-ID und PASSWORD dein Password ist. 10.0.0.138 ist die zugewiesene IP deines Modems im Falle, dass du ADSL nutzt, etc. 
Stelle sicher, dass diese Datei nur von root gelesen werden kann (mode 600).
</p>

<h3>6.9.1 - Deinem Network Interface eine Adresse zuweisen</h3>

<p>
Im obigen Beispiel hatte unser Modem eine vorkonfigurierte Adresse von 10.0.0.138. Jetzt m&uuml;ssen wir UNSEREM Interface noch eine Adresse zuweisen.
Es ist am besten eine IP zu w&auml;hlen, die nahe an der deines MODEMS liegt, oder einfach die statische Adresse zu benutzen, die dir zugewiesen wurde.
Mehr dar&uuml;ber, wie man Interfaces IP-Adressen zuweist, kannst du in <a href="#6.1">FAQ 6.1</a> lesen.
</p>

<p>
Wenn dein Interface eingerichtet ist, solltest du eine pptp Verbindung mit dem Kommando 

<blockquote><pre>
# <strong>/usr/local/sbin/pptp 10.0.0.138 &amp;</strong>
</pre></blockquote>

aufbauen k&ouml;nnen.
<p>
Da hier auch der "in-house" OpenBSD ppp(8) benutzt wird, werden hier zwei Prozesse gestartet. Du kannst pptp beenden, indem du diesen beiden Prozesse
killst:
</p>

<blockquote><pre>
# <strong>kill -9 [pid of pppd]</strong>
$ <strong>kill -9 [pid of pptp]</strong>
</pre></blockquote>

Wir empfehlen <tt>/var/log/messages</tt> in einem weiteren Terminalfenster zu &ouml;ffnen, um m&ouml;gliche Probleme zu erkennen.

<blockquote><pre>
# <strong>tail -f /var/log/messages</strong>
</pre></blockquote>
</p>

<p>
Wir schlagen vor, die Startsequenz in <i>/etc/rc.local</i> unterzubringen, so dass bei jedem reboot die Verbindung automatisch 
aufgebaut wird.
</p>



<a name= "Bridge"></a>
<h2>6.10 - Aufsetzen einer Bridge mit OpenBSD</h2>

Eine <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4">Bridge</a>
ist ein Link zwischen zwei oder mehr separaten Netzwerken. Anders als 
ein Router reisen Pakete durch die Bridge "unsichtbar" -- logisch 
erscheinen die beiden Netzwerksegmente als eines f&uuml;r Rechner auf 
beiden Seiten der Bridge. Die Bridge wird nur Pakete weiterleiten, die 
auch von einem Segment in das andere m&uuml;ssen, sie bieten also
auch einen einfachen Weg den Traffic in einem komplexen Netzwerk zu 
reduzieren  und erlauben trotzdem den Zugriff jedes Rechners zu jedem
anderen, falls n&ouml;tig.

<p>
Denk daran, dass aufgrund dieser "unsichtbaren" Natur ein Interface in 
einer Bridge eine IP-Adresse haben kann, aber nicht muss. Wenn sie eine
hat, hat die Karte effektiv zwei Betriebsmodi, n&auml;mlich eine
als Teil der Bridge, die andere als normale, stand-alone Netzwerk-Karte.
Wenn keine der Karten eine IP-Adresse hat, wird die Bridge einfach
Netz-Daten verschieben, aber nicht von extern administrierbar 
oder wartbar sein (was auch ein Feature sein kann).

<h3>Ein Beispiel einer Bridge Anwendung</h3>
Eines meiner Computer Racks hat eine Anzahl alter Systeme, von denen keines
eine eingebaute 10BASE-TX Netzwerk-Karte hat. W&auml;hrend sie alle einen 
AUI oder AAUI Stecker haben, sind die Transceiver auf Koax beschr&auml;nkt.
Eine der Maschinen in diesem Rack ist ein OpenBSD-basierender 
Terminal-Server, der dauerhaft eingeschaltet und auch immer mit einem
High-Speed-Netzwerk verbunden ist. Das Hinzuf&uuml;gen  einer zweiten 
Netzwerk-Karte mit einem Koax-Port erlaubt mir, diese Maschine als Bridge 
in das Koax-Netzwerk zu benutzen.

<p>
Dieses System hat jetzt zwei Netzwerk-Karten (NICs), eine Intel EtherExpress/100
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp&amp;sektion=4"><tt>fxp0</tt></a>)
und eine 3c590-Combo Karte 
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&amp;sektion=4"><tt>ep0</tt></a>)
f&uuml;r den Koax Port. <tt>fxp0</tt> ist der Link in mein restliches 
Netzwerk und wird daher eine IP-Adresse haben, <tt>ep0</tt> macht nur
Bridging und hat daher keine.
Maschinen, die an das Koax-Segment angeschlossen sind, sollen genauso
kommunizieren, als wenn sie im Rest meines Netzwerkes w&auml;ren.
Wie also bewerkstelligen wir das ?

<p>
Die Datei <tt>hostname.fxp0</tt> enth&auml;lt die Konfigurationsdaten 
f&uuml;r die <tt>fxp0</tt> Karte.  Diese Maschine soll DHCP machen,
also sieht die Datei etwa so aus:

<blockquote>
<pre>
$ <b>cat /etc/hostname.fxp0</b>
dhcp NONE NONE NONE NONE
</pre>
</blockquote>

Noch keinerlei &Uuml;berraschungen

<p>
Die <tt>ep0</tt> Karte ist ein wenig anders, wie du dir denken kannst:
<blockquote>
<pre>
$ <b>cat /etc/hostname.ep0</b>
up media 10base2
</pre>
</blockquote>

Hier sagen wir dem System, es m&ouml;ge das Interface mittels 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
aktivieren und auf 10BASE-2 (Koax) setzen. Keine IP Addresse oder &auml;hnliche 
Information muss f&uuml;r dieses Interface spezifiziert werden. Die 
Optionen, die von der <tt>ep</tt> Karte akzeptiert werden, sind
detailliert in der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&amp;sektion=4">man
page</a> aufgef&uuml;hrt.

<p>
Jetzt m&uuml;sen wir die Bridge aufsetzen. Bridges werden durch die Existenz einer Datei
namens
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridgename.if&amp;sektion=5"><tt>bridgename.bridge0</tt></a>. 
initialisiert. Hier ist zum Beispiel ein Datei f&uuml;r meine Situation:

<blockquote>
<pre>
$ <b>cat /etc/bridgename.bridge0</b>
add fxp0
add ep0
up
</pre>
</blockquote>

Das sagt aus, es soll eine Bridge aus zwei NICs aufgesetzt und aktiviert 
werden, fxp0 und ep0.
Es ist egal, in welche Reihenfolge die Karten aufgef&uuml;hrt werden.
Denke daran, die Bridge ist symmetrisch -- Pakete fliessen ja in beide
Richtungen.

<p>
Das war es!  Reboote, und du wirst eine funktionierende Bridge haben.

<h3>Filtern auf der Bridge</h3>
W&auml;hrend es sicher auch eine Menge Anwendungen f&uuml;r eine 
solch einfache Bridge gibt, ist es doch wahrscheinlich, dass du
etwas mit den ganzen Paketen TUN willst, w&auml;hrend sie durch deine Bridge
laufen. Wie zu erwarten, kann man
<a href="#PF">Packet Filter</a> dazu benutzen, den Traffic einzuschr&auml;nken,
 der durch deine Bridge fliesst.

<p>
Denke daran, dass wegen der Natur der Bridge die gleichen Daten
&uuml;ber beide Interfaces fliessen, aber du nur auf einem Interface 
zu filtern brauchst. Deine "Pass all" Statements w&uuml;rden dann
wie folgt aussehen:

<blockquote>
<pre>
pass in  on ep0  any
pass out on ep0  any
pass in  on fxp0 any
pass out on fxp0 any
</pre>
</blockquote>

Sagen wir nun, ich wollte den Traffic filtern, der diesen alten Maschinen
trifft. Ich m&ouml;chte, dass nur Web und SSH-Traffic zu Ihnen durchkommt.
In diesem Fall lassen wir jeglichen Traffic nach draussen zu, filtern aber
auf dem fxp0 Interface, indem wir keep state f&uuml;r die Antwort-Daten
benutzen:

<blockquote>
<pre>
# Pass all traffic through ep0
pass in quick on ep0 all
pass out quick on ep0 all

# Block fxp0 traffic
block in  on fxp0 all
block out on fxp0 all

pass in quick on fxp0 proto tcp from any to any port {22, 80} \
     flags S/SA keep state
</pre>
</blockquote>

Denke daran, dass diese Regelwerk jeglichen Netzwerk-Verkehr
mit Ausnahme von hereinkommendem HTTP und SSH-Traffic zur Bridge selbst und
den Maschinen "dahinter" verhindert. Andere Resultate werden erzielt,
wenn man auf dem anderen Interface filtert.

<p>
Um die Bridge zu &uuml;berwachen und zu kontrollieren, benutze das 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=brconfig&sektion=8">brconfig(8)</a>
Kommando, mit dem man eine Bridge auch nach dem Booten erzeugen kann.

<h3>Tips zum Bridging</h3>
<ul>
<li>Es wird W&Auml;RMSTENS empfohlen, nur auf einem Interface zu filtern.
Wenn es auch m&ouml;glich ist, auf beiden zu filtern, muss man das vorher 
jedoch sehr gut verstanden haben.

<li>Durch die Benutzung der <i>blocknonip</i> Option von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=brconfig&sektion=8">brconfig(8)</a>
oder in 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridgename.if&sektion=5">bridgename.bridge0</a>,
kannst du jeglichen nicht-IP Traffic (wie etwa IPX oder NETBEUI) davon 
abhalten, sich um deine Filter herumzustehlen. Das kann in einigen Situationen
sehr wichtig sein, aber du solltest wissen, dass Bridges f&uuml;r jeglichen
Traffic funktionieren, nicht nur f&uuml;r IP.

<li>F&uuml;r Bridging m&uuml;ssen die NICs im "Promiscuous mode" sein -- sie
lauschen einfach am GESAMTEN Netzwerk-Verkehr, nicht nur an dem, der
an das Interface gerichtet ist. Das hat einen h&ouml;heren Load f&uuml;r 
CPU und Bus zur Folge, als man denkt. Einige NICs funktionieren leider
nicht sauber in diesem Modus, der TI ThunderLAN Chip
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tl&sektion=4">tl(4)</a>)
ist leider so ein Beispiel, der nicht als Teil einer Bridge funktioniert.
</ul>


<p>
<font color= "#0000e0">
<a href="index.html">[FAQ Index]</a>
<a href= "faq5.html">[Zu Kapitel 5 - Kernelkonfiguration]</a>
<a href= "faq7.html">[Zu Kapitel 7 - Tastatureinstellungen]</a>
</font>
</p>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt= "[zur&uuml;ck]"></a>
<a href= "mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<br>
Originally [OpenBSD: faq6.html,v 1.168 ]
<br>
$Translation: faq6.html,v 1.70 2003/04/09 18:38:29 jufi Exp $
</small>
<br>
<small>$OpenBSD: faq6.html,v 1.54 2003/04/27 11:40:31 jufi Exp $</small>
</p>
</body>
</html>
