<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>11 - Das X Window System</title>

<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<link rev="made" href="mailto:www@openbsd.org">
<meta name="resource-type" content="document">
<meta name="description" content="the OpenBSD FAQ page">
<meta name="keywords" content="openbsd,faq">
<meta name="distribution" content="global">
<meta name="copyright" content="This document copyright 1998-2006 by OpenBSD.">
</head>

<body bgcolor="#ffffff" text="#000000">

<a href="../../de/index.html">
<img alt="[OpenBSD]" src="../../images/smalltitle.gif" border="0" height="30" width="141">
</a>
<p>
<font color="#0000e0">
<a href="index.html">[FAQ-Index]</a>
<a href="faq10.html">[Zum Kapitel 10 - Systemverwaltung]</a>
<a href="faq12.html">[Zum Kapitel 12 - Hardware- und plattformspezifische Fragen]</a>
</font>

<h1><font color="#e00000">11 - Das X Window System</font></h1>
<hr>

<p>
<h3>Inhaltsverzeichnis</h3>
<ul>
<li><a href="#Intro">11.1 - Einführung in X</a>
<li><a href="#ConfigX">11.2 - Konfiguration von X</a>
<li><a href="#amd64i386">11.3 - Konfiguration von X auf amd64 und
    i386</a>
<li><a href="#StartingX">11.4 - X starten</a>
<!-- li><a href="#TuningRes">11.9 - Deine Monitorauflösung
    unter X optimieren</a -->
</li>
</ul>

<hr>

<p>
<a name="Intro"></a>
<h2>11.1 - Einführung in X</h2>

Das X Window System (manchmal nur »X« oder fälschlicherweise »X Windows«
genannt) ist die Umgebung, die Grafikanwendungen unter OpenBSD und
anderen Unix-basierten Systemen benötigte Funktionen anbietet. X
selbst stellt aber nur wenig bereit: Man muss ebenfalls einen »Window
Manager« haben, um eine Benutzerschnittstelle zu schaffen. Das meiste
der sogenannten »Personality« von X wird vom Windowmanager ausgehen
statt von X selbst. OpenBSD wird mit einer freien Version des
Windowmanagers
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fvwm&amp;sektion=1">fvwm(1)</a>
ausgeliefert. Wenn du möchtest, kannst du auch einen der anderen
Windowmanager verwenden, die als <a href="faq15.html">Packages</a>
bereitgestellt werden. Verwende das Suchwort »<tt>window manager</tt>«,
um eine Liste der vielen verfügbaren Windowmanager zu erhalten.

<p>
X wird als »Client-Server«-strukturiertes Protokoll aufgefasst,
obwohl die Terminologie manchmal etwas verwirrend ist.
Der Computer, der die Grafik auf dem Bildschirm anzeigt, ist der
»X-Server«. Die Anwendung, die dem X-Server mitteilt, was auf
dem Bildschirm angezeigt werden soll, ist der »X-Client«, selbst
wenn es sich hierbei um einen leistungsstärkeren Computer in einem
Rechenzentrums handelt. Dieses Modell kann genutzt werden, um
rechenintensive Anwendungen (X-Clients) auf sehr leistungsstarken
Maschinen auszuführen, die den X-Server als Benutzerschnittstelle
verwenden, der auf einer kleinen und stromsparenden Maschine auf
deinem Schreibtisch läuft.

<p>
Es ist möglich, X-Clients auf einem System auszuführen, das über
keine grafische Ausgabemöglichkeit verfügt. Man könnte zum
Beispiel eine Anwendung (den X-Client) auf einer mvme88k
ausführen und die Ausgabe auf einem Bildschirm einer Alpha anzeigen
lassen (der X-Server). Da X ein klar definiertes und
plattformübergreifendes Protokoll ist, ist es sogar möglich, eine
X-Anwendungen auf einer (beispielsweise) Solaris-Maschine auszuführen
und auf einer OpenBSD-Maschine anzeigen zu lassen.

<p>
Der Client und der Server können auch auf dem gleichen System laufen.
Im Rest dieses Kapitels gehen wir hiervon aus.

<h3>11.1.1 - Wieviel Rechenleistung benötige ich, um X verwenden zu
können?</h3>
X selbst ist ein recht großes Programm, sodass ein schneller Rechner
bestens geeignet ist, wenn du es regelmäßig an- und ausstellst. Wenn
es aber erst einmal läuft, dann reicht auch ein sehr bescheidener
Rechner. Um stotternde Bildschirmausgaben zu verhindern, musst du auf
einigen Plattformen sogar auf X zurückgreifen. Solche Plattformen, zu
denen auch <a href="../../de/sparc.html">sparc</a> und
<a href="../../de/sparc64.html">sparc64</a> gehören, wurden für eine
grafische Oberfläche entworfen, sodass die Konsole selbst nur sehr
schlechte Resultate liefert.

<p>
Soweit zur Grundlage. X wird normalerweise gestartet, um X-Anwendungen
aufrufen zu können. Einige X-Applikationen sind sehr genügsam, andere
scheinen sich hingegen alle Rechenleistung und verfügbaren RAM unter
den Nagel zu reißen. Selbstverständlich gibt es auch Leute, die X
verwenden, um eine große Anzahl
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=xterm&amp;sektion=1">xterm(1)</a>s
aufzurufen - hierfür reicht auch sehr schlichte Hardware.

<h3>11.1.2 - Kann ich auch Grafiken ohne X verwenden?</h3>
Angenommen dir genügen
<a href="http://en.wikipedia.org/wiki/ASCII_Art">ASCII-Grafiken</a>
nicht, so musst du auf eine Art von Framebuffer-Konsolentreibern
zurückgreifen. Einige Betriebssysteme stellen diese zur Verfügung,
doch gibt es momentan keine für OpenBSD. Unter den Entwicklern hat
auch niemand großes Interesse daran.

<a name="ConfigX"></a>
<h2>11.2 - Konfiguration von X</h2>
Die Konfiguration von X unterscheidet sich deutlich zwischen den
einzelnen Plattformen. In allen Fällen gibt es aber Anleitungen und
andere plattformspezifische Informationen in
<tt>/usr/X11R6/README</tt>, die auf einem installierten System
vorgefunden werden kann.


<p>
Viele Plattformen benötigen den X-Aperturetreiber
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=xf86&amp;sektion=4">xf86(4)</a>,
der direkten Zugriff auf den Speicher und die Ein-/Ausgabeports
des VGA-Boards und der PCI-Konfigurationsregister ermöglicht, was für
die X-Server eine Voraussetzung ist. Dieser Treiber muss aktiviert
werden, bevor er genutzt werden kann - entweder indem mit »Yes« auf
die Frage

<blockquote><pre>
Do you expect to run the X window System [no]
</pre></blockquote>

geantwortet wird (diese ist während der Installation zu sehen) oder
indem man <tt>machdep.allowaperture</tt> in der
<tt>/etc/sysctl.conf</tt> auf einen der Plattform entsprechenden
Wert setzt (dieser darf nicht 0 sein) und neustartet, da diese
Sysctl aus Sicherheitsgründen nach dem Bootvorgang nicht mehr geändert
werden kann. Die Verwendung des Treibers zieht Sicherheitsbedenken
nach sich. Du solltest ihn nicht aktivieren, wenn du nicht unbedingt
auf ihn angewiesen bist.


<h3>11.2.1 - alpha</h3>
<a
href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/xenocara/distrib/notes/README.alpha"
>/usr/X11R6/README</a> für alpha.

<p>
Setze <tt>machdep.allowaperture=1</tt> in <tt>/etc/sysctl.conf</tt>.

<p>
Die TGA- und einige VGA-Karten werden unterstützt. Es sollte keine
weitere Konfiguration notwendig sein.

<h3>11.2.2 - amd64</h3>
<a href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/xenocara/distrib/notes/README.amd64"
>/usr/X11R6/README</a> für amd64.

<p>
Setze <tt>machdep.allowaperture=2</tt> in <tt>/etc/sysctl.conf</tt>.

<p>
X wird auf amd64 meist erfolgreich automatisch konfiguriert, so
dass in den meisten Fällen keine weitere Konfiguration notwendig ist.
Sollte weitere Konfiguration benötigt werden, rufe
<a href="#amd64i386">X&nbsp;-configure</a> wie weiter
<a href="#amd64i386example">unten</a> beschrieben auf.

<h3>11.2.3 - armish</h3>
Es stehen keine X-Server bereit, nur X-Clients.

<h3>11.2.4 - hp300</h3>
<a href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/xenocara/distrib/notes/README.hp300"
>/usr/X11R6/README</a> für hp300.

<h3>11.2.5 - hppa</h3>
Es stehen keine X-Server bereit, nur X-Clients.

<h3>11.2.6 - i386</h3>
<a href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/xenocara/distrib/notes/README.i386"
>/usr/X11R6/README</a> für i386.

<p>
Setze <tt>machdep.allowaperture=2</tt> in <tt>/etc/sysctl.conf</tt>.

<p>
Aufgrund der unglaublich vielen verfügbaren Grafikkarten, Mäusen,
Tastaturen und anderer Hardware kann die Konfiguration auf einem
i386-System recht abenteuerlich sein. Abenteuerlich genug, um diesem
Thema eine <a href="#amd64i386">separate Sektion</a> zu widmen.

<p>
Zum Glück ist es meist gar nicht so schlimm wie es im ersten Augenblick
scheint - in vielen Fällen »funktionierts einfach«, wenn man »startx«
eingibt. In diesen Fällen wird deine Hardware erfolgreich erkannt und
ausgewertet; X läuft ohne Probleme.


<h3>11.2.7 - landisk</h3>
Es stehen keine X-Server bereit, nur X-Clients.

<h3>11.2.8 - luna88k</h3>
Es stehen keine X-Server bereit, nur X-Clients.

<h3>11.2.9 - mac68k</h3>
<a href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/xenocara/distrib/notes/README.mac68k"
>/usr/X11R6/README</a> für mac68k.

<p>
Mac68k-Systeme »funktionieren einfach« mit X, sodass keine
Konfiguration benötigt wird.

<p>
Maus: Die standardmäßige Macintosh-Maus hat nur eine Taste. Dies
stellt ein Problem dar, denn X geht von einer Dreitasten-Maus aus.
Einige Mäuse von Drittanbietern haben eine zweite Taste, die auch
mit X funktioniert. Falls dies nicht möglich ist, wirf einen Blick
auf die Xmac68k(1)-Seite für weitere Informationen über die Emulation
von Maustasten.


<h3>11.2.10 - macppc</h3>
<a href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/xenocara/distrib/notes/README.macppc"
>/usr/X11R6/README</a> für macppc.

<p>
Setze <tt>machdep.allowaperture=2</tt> in <tt>/etc/sysctl.conf</tt>.

<p>
Unterstützte Macintosh-PPC-Systeme können auf zwei unterschiedliche
Weisen verwendet werden:
»beschleunigt« oder »Framebuffer« (unbeschleunigt).

<p>
Im »Framebuffer«-Modus wird das System mit 8 Bits pro Pixel arbeiten
und die Videoauflösung wird von der Macintosh-Umgebung geregelt. Das
bedeutet, dass du eine kleine MacOS-Partition auf deiner Platte
belassen möchtest, um von dort aus diese Einstellungen anzupassen.
Dieser Modus hat den Vorteil, dass er »einfach funktioniert«, doch
kann es frustrierend einschränkend sein (zum Beispiel setzt eine
Änderung der Auflösung einen Boot von MacOS voraus).

<p>
Wenn dein Macintosh ein ATI-basiertes Videosystem hat, kannst du es
mit einem beschleunigten X-Server verwenden. Dieser liefert bessere
Geschwindigkeiten und mehr Kontrolle in deiner OpenBSD-Umgebung.
Die NVIDIA-Grafikkarten einiger macppc-Systeme werden auch in vielen
Fällen funktionieren. Die README-Datei beinhaltet Details über die
Konfiguration des beschleunigten Treibers - verwende erst einmal die
Beispieldatei dort.

<p>
Während die README-Datei detailliert auf die Verwendung der Standardmaus
von Apple mit nur einer Taste unter X eingeht, wird dir dringend dazu
geraten, dir einfach eine USB-Maus eines Drittanbieters zu kaufen -
es sei denn, du verwendest einen Laptop.


<h3>11.2.11 - mvme68k</h3>
Es stehen keine X-Server bereit, nur X-Clients.

<h3>11.2.12 - mvme88k</h3>
Es stehen keine X-Server bereit, nur X-Clients.

<h3>11.2.13 - sgi</h3>
Es stehen keine X-Server bereit, nur X-Clients.

<h3>11.2.14 - sparc</h3>
<a href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/xenocara/distrib/notes/README.sparc"
>/usr/X11R6/README</a> für sparc.

<p>
Mit nur einem unterstützten Framebuffer wird keine Konfiguration
benötigt. Wenn du eine Multihead-Konfiguration verwenden möchtest,
wirf einen Blick auf die zuvor genannte README-Datei für weitere
Details.

<p>
Die Auflösung wird von der Firmware eingestellt, bevor OpenBSD bootet.

<h3>11.2.15 - sparc64</h3>
<a href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/xenocara/distrib/notes/README.sparc64"
>/usr/X11R6/README</a> für sparc64.

<p>
Unter diesen Maschinen gibt es viele Variationen, sodass du wissen
musst, welchen Bustyp dein System verwendet (PCI oder SBus), an
welcher Schnittstelle deine Maus angeschlossen ist (zstty, com oder
USB/PS2) und welche Grafikkarte du hast. Beginne mit der
<tt>xorg.conf</tt>-Datei in der <tt>README</tt>. Modifiziere sie
entsprechend deiner Hardware und deinen Bedürfnissen. <i>Erwarte nicht,
dass die Beispieldatei ohne Anpassung auf deiner Maschine läuft!</i>

<h3>11.2.16 - vax</h3>
<a href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/xenocara/distrib/notes/README.vax"
>/usr/X11R6/README</a> für vax.

<p>
Der X-Server funktioniert momentan nur auf VAXstation-4000-Modellen mit
einem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lcg&amp;sektion=4&amp;arch=vax">lcg(4)</a>-
oder
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lcspx&amp;sektion=4&amp;arch=vax">lcspx(4)</a>-Framebuffer.

<h3>11.2.17 - zaurus</h3>
<a href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/xenocara/distrib/notes/README.zaurus"
>/usr/X11R6/README</a> für zaurus.

<p>
Es wird keine Konfiguration benötigt, X »funktioniert einfach«.


<p>
<a name="amd64i386"></a>
<h2>11.3 - Konfiguration von X auf amd64 und i386</h2>
Aufgrund der großen Hardwareauswahl für diese Plattformen ist die
Konfiguration recht »knifflig«.

<h3>11.3.1 - Konfiguration von X.Org</h3>
X.Org hat erhebliche Verbesserungen vorgenommen, sodass ihre Server
»einfach funktionieren«. In vielen Fällen funktioniert es sogar ohne
<tt>/etc/X11/xorg.conf</tt>-Datei. Aber leider nicht immer - und
manchmal muss man Dinge trotzdem anpassen.

<p>
Es gibt zwei Programme, die für eine pseudo-automatische Erstellung
der Konfigurationsdatei für X.Orgs i386-X-Server genutzt werden können.
Leider gibt es für keines der beiden Programme Garantie, dass eine
einsetzbare xorg.conf-Datei erzeugt wird.


<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=Xorg&amp;sektion=1">Xorg(1)</a>
im »X -configure«-Modus gestartet wird alle verfügbaren
Grafiktreibermodule laden, nach Hardware suchen und (basierend auf
der gefundenen Hardware) eine xorg.conf-Datei schreiben. Vielleicht
funktioniert sie nicht, doch selbst dann ist es eine gute Grundlage,
um eigene Änderungen vorzunehmen, statt eine Datei vollkommen selbst
schreiben zu müssen.

<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=xorgconfig&amp;sektion=1">xorgconfig</a>
ist ein weiteres Programm, mit dem man interaktiv eine xorg.conf-Datei
erstellen kann - eine vollständig textbasierte Anwendung.

</ul>

Zusätzlich zu den genannten Anwendungen gibt es eine weitere
zeitaufwendige Methode, X zu konfigurieren: Verwende eine Suchmaschine
deiner Wahl und sieh nach, ob jemand anderes bereits dein Problem
gelöst hat. Obwohl dies keine so schlechte Idee ist, wird auf diese
Methode nicht weiter eingegangen.

<p>

<a name="amd64i386example"></a>
<h3>11.3.2 - Unsere Beispielmaschine</h3>
Als Demonstration, wie man X einrichtet, werden wir ein altes
System mit einem Celeron 400 MHz und einem AGP-Steckplatz verwenden.
Bei der Grafikkarte handelt es sich um eine alte AGP-Karte, die wie
folgt in der Dmesg aufgelistet wird:

<blockquote><pre>
vga1 at pci1 dev 0 function 0 "3DFX Interactive Banshee" rev 0x03
</pre></blockquote>

Dies war einmal eine Highend-Grafikkarte mit 16 MB RAM, doch wird
sie heutzutage von »gängigen« Betriebssystemen fast nicht mehr
unterstützt. Des Weiteren wird ein Sony Multiscan G400 19" CRT als
Monitor angeschlossen. Es wäre schön, wenn dieser Monitor bei einer
Auflösung von 1280x1024, einer angenehmen Bildwiederholrate und
24 Bit Farbtiefe genutzt werden kann.

<p>
Nachdem OpenBSD mit X installiert wurde (wir haben sichergestellt,
dass der Aperturetreiber im Kernel aktiviert wurde) werfen wir zuerst
einen Blick auf die automatische Erkennung und Konfiguration von X.Org
- vielleicht haben wir Glück. So, wir loggen uns einfach ein und rufen
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=startx&amp;sektion=1">startx(1)</a>
auf. Der Bildschirm wird für ein paar Momente schwarz, dann erhalten
wir den »Schachbrett«-Hintergrund von X, den »X«-Cursor und ein
xterm-Fenster.

<p>
Es funktioniert!

<p>
Mehr oder weniger. Obwohl das System voll einsatzfähig ist, scheint es
keine Funktionalitäten des Monitors erkannt zu haben und läuft auf
einer eindeutig zu niedrigen Auflösung (640x480). Wir hoffen mal, dass
wird das noch besser hinbekommen - damit meine ich sehr viel besser.
Das heißt also, dass wir unsere eigene xorg.conf-Datei erstellen müssen.

<p>
Wir verwenden die »X -configure«-Methode, um eine Grundlage für unsere
<tt>xorg.conf</tt>-Datei zu schaffen. Du musst folgenden Befehl als
root ausführen:
<blockquote><pre>
# <b>X -configure</b>
 [...]
Your xorg.conf file is /root/xorg.conf.new

To test the server, run 'X -config /root/xorg.conf.new'
</pre></blockquote>

Im Übrigen muss die Meldung ernst genommen werden - verwende den
vollständigen Pfad zu deiner <tt>xorg.conf.new</tt>-Datei, selbst wenn
du dich im gleichen Verzeichnis befindest. Wenn du dies nicht machst,
dann wird
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=X&amp;sektion=7">X(7)</a>
die Datei nicht finden und ohne weiteren Kommentar die
Standardkonfiguration verwenden, die nicht im Geringsten etwas mit
deiner aktuell bearbeiteten Konfiguration zu tun haben muss.
Dies kann die Fehlersuche später deutlich vereinfachen. Vertrau uns
einfach.

<p>
Wir führen also aus, was uns gesagt wird:
<blockquote><pre>
# <b>X -config /root/xorg.conf.new</b>
</pre></blockquote>

Alles was wir kriegen ist ein schwarzes Bild.
Dabei hat es so gut angefangen ...

<p>
Nun ist ein guter Zeitpunkt gekommen, um über die unterschiedlichen
Möglichkeiten zu sprechen, X zu beenden, wenn es auf diese Weise
gestartet wurde. Nach Vorzug sortiert sind es:
<ul>
<li><b>STRG-ALT-Backspace</b>: Dies wird X hoffentlich sofort
terminieren - mit samt allen X-Anwendungen, die momentan laufen.
Selbstverständlich werden während der Konfiguration keine Anwendungen
laufen, sodass dies kein Problem darstellen wird (genau genommen ist
es zu diesem Zeitpunkt die <i>beste</i> Möglichkeit, X zu beenden).
<li><b>Mit SSH auf den Rechner zugreifen</b> und
»<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pkill&amp;sektion=1">pkill</a>
Xorg« aufrufen. Dies könnte den X-Prozess beenden und dich zurück auf
eine funktionierende Konsole befördern.
<li><b>Mit SSH auf den Rechner zugreifen</b> und ihn neustarten.
<li><b>Reset oder Runterfahren.</b> Manchmal gibt es wirklich keinen
anderen Ausweg. Ja, es ist grundsätzlich eine gute Idee, X konfiguriert
zu haben, bevor du wichtige Anwendungen auf deinem System ausführst.
Manchmal kann es vorkommen, dass eine schlechte X-Konfiguration die
gesamte Maschine in die Knie zwingt, sodass nur noch aus- und wieder
anstellen das Problem beheben kann.
</ul>

Zum Glück verrichtet STRG-ALT-Backspace erfolgreich seine Dienste und
wir befinden uns wieder in der Kommandozeile. Nun müssen wir
herausfinden, was fehlgeschlagen ist. Zuerst sollten wir nachsehen, was
Xorg über die Hardware denkt. Das können wir in der Datei
<tt>/var/log/Xorg.0.log</tt> nachlesen. In diesem Fall denkt X, dass
alles einwandfrei läuft - keine offensichtlich schwerwiegenden
Fehler werden in der Logdatei aufgeführt (Zeilen, die mit
»<tt>EE</tt>« beginnen, sind Fehler).

<p>
An dieser Stelle kommt unser Wissen über die Hardware ins Spiel. Wenn
wir das System an einen anderen Monitor anschließen, während ein
schwarzes Bild angezeigt wird, gibt er uns eine
»Sync. out of Range«-Meldung auf dem Bildschirm aus. Offensichtlich
scheint die Konfiguration von X nicht mit diesem Monitor zu
funktionieren. Eventuell läuft diese Konfiguration auf KEINEM Monitor,
wenn ein Videomodus ausgewählt wurde, der mit der Karte nicht zusammen
funktioniert (beachte bitte, dass X sich am Chip auf der Karte
und dessen Leistung orientiert - nicht daran, wie der Hersteller die
Komponenten zusammengestellt hat). Unterschiedliche Monitore werden
verschieden reagieren, wenn die Rate falsch ist. Einige werden
versuchen, das Bild anzuzeigen, andere werden in den Energiesparmodus
wechsel, andere schreckliche Geräusche von sich geben und wieder
andere werden hilfreiche Meldungen auf dem Bildschirm angeben. Dieser
Bildschirm scheint zu keiner der zuvor genannten Arten gehören. Wir
merken uns einfach, diesen Monitor NIE wieder für grundlegende
X-Konfigurationen zu verwenden.

<p>
Während wir durch die erstellte xorg.conf.new-Datei gehen, sehen wir
folgenden Eintrag:
<blockquote><pre>
Section "Monitor"
        #DisplaySize      370   270     # mm
        Identifier   "Monitor0"
        VendorName   "SNY"
        ModelName    "SONY CPD-G400"
 ### Comment all HorizSync and VertSync values to use DDC:
        HorizSync    30.0 - 107.0
        VertRefresh  48.0 - 120.0
        Option      "DPMS"
EndSection
</pre></blockquote>

Zum Testen werden wir einen DDC-Monitor (»Data Display Channel« - damit
kann der Monitor dem Computer und der Grafikkarte mitteilen, wozu er
in der Lage ist) verwenden und sehen, was geschieht. Dieses Mal erhalten
wir wieder das Schachbrettmuster von X und einen beweglichen Cursor. Das
ist alles, was wir von X erwarten, wenn wir es so aufrufen (wir beenden
X mit dem STRG-ALT-Backspace-Trick von vorhin). Es ist (wieder) eine
niedrige Auflösung, doch es funktioniert. Wir können also davon
ausgehen, dass wir ein Raten- und Auflösungsproblem haben. Wir werden
zuerst die »HorizSync«- und »VertRefresh«-Zeilen wiederherstellen,
da wir die Spezifikationen des Monitors im Internet gefunden und
überprüft haben.

<p>
Wir werden nun versuchen, Xorg auf eine bestimmte Auflösung zu trimmen
und zu sehen, ob wir damit Glück haben. In <tt>Section "Screen"</tt>
der xorg.conf-Datei werden wir ein paar Zeilen hinzufügen, die hier
fett gedruckt sind:

<blockquote><pre>
Section "Screen"
        Identifier "Screen0"
        Device     "Card0"
        Monitor    "Monitor0"
<b>        DefaultDepth   24</b>
        SubSection "Display"
                Viewport   0 0
                Depth     1
        EndSubSection
        SubSection "Display"
                Viewport   0 0
                Depth     4
        EndSubSection
        SubSection "Display"
                Viewport   0 0
                Depth     8
        EndSubSection
        SubSection "Display"
                Viewport   0 0
                Depth     15
        EndSubSection
        SubSection "Display"
                Viewport   0 0
                Depth     16
        EndSubSection
        SubSection "Display"
                Viewport   0 0
                Depth     24
<b>                Modes	"1280x1024"</b>
        EndSubSection
EndSection
</pre></blockquote>

Diese beiden Änderungen teilen X mit, dass wir eine Farbtiefe von
24 Bit verwenden möchten und für 24 Bit Farbtiefe eine Auflösung
von 1280x1024. Da keine andere Auflösung unter »Depth 24« aufgelistet
ist, wird das System dazu gezwungen sein, diese Auflösung zu
verwenden.

<p>
Wir testen die neue Konfiguration und ... ERFOLG!
Wir scheinen ein schönes und hoch auflösendes Display zu besitzen.
Beachte, dass wir NUR ein Schachbrettmuster (das sehr gut geeignet ist,
um die Qualität deines Bildschirms zu prüfen und um LCDs zu kalibrieren
[»<a href="http://www.openbsd.org/cgi-bin/cvsweb/xenocara/data/bitmaps/root_weave">root
weave</a>«]) und einen beweglichen Cursor erwarten. An diesem Punkt
erwarten wir noch keine voll einsatzfähige Oberfläche.

<p>
Nun werden wir die xorg.conf-Datei installieren, sodass wir den
alltäglichen Aufruf von X testen können.

<blockquote><pre>
# cp xorg.conf.new /etc/X11/xorg.conf
</pre></blockquote>

Wir können nun versuchen, X mit dem normalen startx(1)-Kommando zu
starten. Es funktioniert!

<p>
Es wäre auch nicht schlecht, zu überprüfen, ob es sich wirklich um
die Auflösung und Farbtiefe handelt, die wir angestrebt haben. Das
ganze soll selbstverständlich auch mit einer angenehmen
Bildwiederholrate angezeigt werden. Wir können dies mit den Kommandos
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=xrandr&amp;sektion=1">xrandr(1)</a>
und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=xdpyinfo&amp;sektion=1">xdpyinfo(1)</a>
überprüfen. Neben anderen Informationen liefert xdpyinfo(1):
<blockquote><pre>
    [...]
screen #0:
  print screen:    no
  dimensions:    1280x1024 pixels (433x347 millimeters)
  resolution:    75x75 dots per inch
  depths (7):    24, 1, 4, 8, 15, 16, 32
  root window id:    0x44
  depth of root window:    24 planes
    [...]
</pre></blockquote>

Die Antwort ist also »ja, wir verwenden 1280x1024 mit einer Tiefe von
24 Ebenen (Bits).«

<p>
Folgende Ausgabe liefert xrandr(4):
<blockquote><pre>
 SZ:    Pixels          Physical       Refresh
*0   1280 x 1024   ( 433mm x 347mm )  *85   75   60
 1   1280 x 960    ( 433mm x 347mm )   85   60
    [...]
</pre></blockquote>

Das sagt uns, dass wir mit einer Bildwiederholrate von 85 Hz arbeiten.
Die meisten Anwender empfinden dies als eine sehr angenehme Einstellung.

<p>
<h3>11.3.3 - Was ist, wenn es nicht so »einfach« ist?</h3>
Manchmal passen Dinge einfach nicht zusammen. Hier sind ein paar Tipps.

<ul>
<li>Lies die Manualseite des X-Servers, den du einsetzt. In unserem
Beispiel können wir aus der <tt>/var/log/Xorg.0.log</tt>-Datei
entnehmen, dass wir TDFX als Treiber verwenden. Wir sollten also in
der <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=tdfx&amp;sektion=4">tdfx(4)</a>-Manualseite
nachsehen. Dort wirst du meistens Tipps, Einschränkungen und
Konfigurationsoptionen für deine Grafikkarte finden. Diese variieren
aber von Treiber zu Treiber, sodass du nicht davon ausgehen solltest,
nicht weiter auf die Manualseite angewiesen zu sein, nur weil du bereits
eine andere gelesen hast.

<li>Probiere unterschiedliche Monitore aus. Wie wir in unserem
Beispiel gelernt haben, liefern unterschiedliche Monitor verschiedene
Lösungsansätze.

<li>Teste den
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vesa&amp;sektion=4">vesa(4)</a>-X-Treiber.
Dieser ist zwar aus Geschwindigkeitsgründen definitiv eine »letzte
Möglichkeit«, doch funktioniert er mit den meisten Grafikkarten -
selbst mit denen, die über keinen »besseren« Treiber für den X-Server
verfügen.

<li>Teste unterschiedliche Hardware. Wenn du über mehrere Grafikkarten
verfügst, probiere ein paar andere.


</ul>

<a name="StartingX"></a>
<h2>11.4 - X starten</h2>
Es gibt zwei übliche Wege, X auszuführen:

<h3>11.4.1 - nach Bedarf:</h3>
Melde dich wie gewöhnlich an einer Konsole an und führe dann
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=startx&amp;sektion=1">startx(1)</a>
aus.

<h3>11.4.2 - boote direkt in X:</h3>
Dies wird mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=xdm&amp;sektion=1">xdm(1)</a>
realisiert, dem X Display Manager.
xdm(1) wird als root ausgeführt (normalerweise über
<a href="faq10.html#rc">rc</a>) und zeigt einen Anmeldeprompt an.
Nach erfolgreicher Anmeldung wird eine X-Sitzung für diesen Benutzer
erstellt. Wenn diese X-Sitzung beendet werden soll (zum Beispiel über
STRG-ALT-Backspace), wird xdm(1) wieder die Kontrolle übernehmen und
den Benutzer erneut nach seinen Anmeldedaten fragen. Aus diesem Grund
sollte xdm(1) NICHT von <tt>/etc/rc.conf.local</tt> aus aufgerufen
werden, bis du dir sicher bist, dass X so läuft wie du es dir gedacht
hast - ansonsten wird deine Maschine sehr schlecht zu warten sein!
(Schlimmster Fall: Boote in den Singleuser-Modus als hättest du
<a href="faq8.html#LostPW">dein Passwort vergessen</a> und editiere
die xdm_flags-Zeile deiner <tt>/etc/rc.conf.local</tt>-Datei.)

<p>
Auf einigen Plattformen musst du das für die Konsolen zuständige
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=getty&amp;sektion=8">getty(8)</a>
deaktivieren, um xdm(1) starten zu können.


<p>
<!-- a name= "TuningRes"></a>
<h2>11.9 - Deine Monitorauflösung unter X optimieren</h2>

<i>Hinweis: Die meisten Benutzer müssen sich NICHT um die Erstellung einer
ModeLine in modernen Versionen von X sorgen.
TROTZDEM: Manchmal ist es in ungewöhnlichen Situationen notwendig.</i>

<p>
Es ist durchaus mit vielen Multisyncmonitoren möglich, einen X-Server
in einer akzeptablen Auflösung zum Laufen zu kriegen. Mit den
Standardkonfigurationswerkzeugen xorgconfig oder XF86Setup ist es aber
recht schwierig, ein gutes Ergebnis zu erhalten. Einer der
schmerzvolleren Punkte ist es, deinen Monitor zur gewünschten Auflösung
zu bewegen und dann eine vertikale Scanrate von mindestens 72 - 75 Hz zu
bekommen; eine Rate, bei der das Bildschirmgeflacker wesentlich geringer
sichtbar für das menschliche Auge ist. Was passiert aber, wenn du die
vertikale Scanfate sehr niedrig einstellst? So könntest du den
Bildschirm zum Beispiel ohne Flackern auf Video filmen - aber auch dazu
sind die Methoden mit den Standardwerkzeugen von X eher nicht intuitiv.

<p>
Schlussendlich ist es bei den Auflösungen
(800x600, 1024x768, 1152x900,1280x1024), die die meisten Leute heute
mit preiswerten VGA-Monitoren benutzen (zumindest mit neueren Modellen)
bestens möglich, vertikale Wiederholungsraten von 85 Hz und mehr
zu bekommen, um ein wirklich klares und ansehnliches Bild zu erhalten.
Der X-Server hat einen Mechanismus, der dir erlaubt, im Detail
den Grafikmodus zu beschreiben, den du benutzen willst: Dies nennt
sich ModeLine. Eine ModeLine hat vier Sektionen: eine einzelne Nummer
für die Pixelclock, vier Nummern für horizontales Timing, vier Nummern
für vertikales Timing und eine optionale Sektion mit einer Liste der
Flags für weitere Charakteristika wie etwa den Modus (z.&nbsp;B.
Interlace, DoubleScan und weitere&nbsp;... mehr Details gibt es in der
xorg.conf(5)-Manualseite)

<p>
Das Erzeugen einer ModeLine ist eine schwarze Kunst. Glücklicherweise
gibt es mehrere Skripte, die das für dich erledigen können.
Eines davon ist
<a href="http://koala.ilog.fr/cgi-bin/nph-colas-modelines">
Colas XFree86 ModeLine Generator</a>.  Ein weiteres ist
<a href="http://xtiming.sourceforge.net/">The XFree86 Modeline
Generator</a>, der bei SourceForge gehostet wird. Es gibt weitere bei
<a href="http://freshmeat.net/search/?q=modeline">Freshmeat</a>.
Bevor du diese ModeLinegeneratoren benutzen kannst, musst du die
vertikalen und horizontalen Syncgrenzen für deinen Monitor herausfinden.
Diese Angaben finden sich oftmals im Handbuch oder auf der Webseite des
Monitorherstellers. Wenn du sie dort nicht finden kannst, suche einfach
im Web nach deinem Modell und Hersteller. Viele Leute waren so
freundlich, Listen mit den entsprechenden Angaben zu erstellen.

<p>
Sagen wir zum Beispiel, du hättest einen Dell-D1226H-Monitor. Du hast
auf Dells Website herausgefunden, dass er einen Bereich von 30 - 95 kHz
horizontal und 50 - 160 Hz vertikal hat. Besuche die
ModeLinegeneratorseite und gib diese Informationen ein. Als nächstes
musst du die minimale vertikale Scanrate eingeben, die du haben
willst. Jede Rate ab 72 Hz und größer sollte im Allgemeinen wenig
flackern. Je mehr, desto besser wird das Bild.

<p>
Mit all diesen Informationen wird das Skript eine ModeLine für jede
mögliche 4x3-Auflösung generieren, die dein Monitor unterstützen
kann. Wenn jemand die Dell-Spezifikationen von oben und eine minimale
vertikale Rate von 75 Hz eingibt, gibt das Skript etwas ähnliches wie
das Folgende aus:

<pre>
ModeLine "320x240" 20.07 320 336 416 448 240 242 254 280 #160Hz
ModeLine "328x246" 20.86 328 344 424 456 246 248 260 286 #160Hz
...
ModeLine "816x612" 107.39 816 856 1056 1136 612 614 626 652 #145Hz
ModeLine "824x618" 108.39 824 864 1064 1144 618 620 632 658 #144Hz
ModeLine "832x624" 109.38 832 872 1072 1152 624 626 638 664 #143Hz
...
ModeLine "840x630" 109.58 840 880 1080 1160 630 632 644 670 #141Hz
ModeLine "848x636" 110.54 848 888 1088 1168 636 638 650 676 #140Hz
...
ModeLine "1048x786" 136.02 1048 1096 1336 1432 786 788 800 826 #115Hz
ModeLine "1056x792" 136.58 1056 1104 1344 1440 792 794 806 832 #114Hz
ModeLine "1064x798" 137.11 1064 1112 1352 1448 798 800 812 838 #113Hz
...
ModeLine "1432x1074" 184.07 1432 1496 1816 1944 1074 1076 1088 1114 #85Hz
ModeLine "1576x1182" 199.86 1576 1648 2008 2152 1182 1184 1196 1222 #76Hz
ModeLine "1584x1188" 198.93 1584 1656 2016 2160 1188 1190 1202 1228 #75Hz
</pre>

<p>
Dieser Monitor gibt nun vor, 1600x1200 @ 75 Hz machen zu können.
Das Skript sagt aber nicht, dass das innerhalb der 75 Hz sei.
Wenn du also exakt 1600x1200 haben willst, geh ein wenig mit deiner
minimalen vertikalen Rate herunter. (Hier z.&nbsp;B. kannst du bis
70 Hz heruntergehen)

<pre>
ModeLine "1592x1194" 197.97 1592 1664 2024 2168 1194 1196 1208 1234 #74Hz
ModeLine "1600x1200" 199.67 1600 1672 2032 2176 1200 1202 1214 1240 #74Hz
ModeLine "1608x1206" 198.65 1608 1680 2040 2184 1206 1208 1220 1246 #73Hz
ModeLine "1616x1212" 197.59 1616 1688 2048 2192 1212 1214 1226 1252 #72Hz
ModeLine "1624x1218" 199.26 1624 1696 2056 2200 1218 1220 1232 1258 #72Hz
ModeLine "1632x1224" 198.15 1632 1704 2064 2208 1224 1226 1238 1264 #71Hz
ModeLine "1640x1230" 199.81 1640 1712 2072 2216 1230 1232 1244 1270 #71Hz
ModeLine "1648x1236" 198.64 1648 1720 2080 2224 1236 1238 1250 1276 #70Hz
</pre>

<p>
Hier sehen wir, dass der Monitor tatsächlich 1600x1200 @ 74 Hz macht,
wenn die Bandbreite (dot clock) auf 200 MHz begrenzt ist. Setze die
Bandbreite gemäß der Grenzen, die vom Monitor definiert werden.

<p>
Nachdem du einmal die ModeLines hast, schreibe sie in deine
/etc/X11/xorg.conf-Datei. Kommentiere die alten ModeLines aus, sodass
du sie noch benutzen kannst, falls die neuen nicht funktionieren.
Als nächstes wähle aus, mit welcher Auflösung du nun arbeiten willst.
Als erstes musst du nun herausfinden, ob X im beschleunigten Modus
läuft oder nicht (das tut es mit den meisten Grafikkarten), sodass
du auch weißt, welche <tt>"Screen"</tt>-Sektion der xorg.conf-Datei du
modifizieren musst. Alternativ kannst du selbstverständlich einfach alle
Screensektionen modifizieren.

<pre>
Section "Screen"
   Driver          "Accel"
   Device          "Primary Card"
   Monitor         "Primary Monitor"
   DefaultColorDepth 32
   SubSection "Display"
      Depth        32
      Modes        "1280x1024" "1024x768"
   EndSubSection
</pre>

<p>
Die erste Auflösung nach dem "Modes"-Stichwort ist die Auflösung,
in der X startet. Mit dem Drücken von STRG-ALT-NUMMERN_BLOCK_MINUS oder
STRG-ALT-NUMMERN_BLOCK_PLUS kannst du zwischen den hier aufgeführten
Auflösungen hin- und herschalten. Gemäß der Angaben oben wird X
versuchen, im 32-Bit-Modus zu starten (wegen der
DefaultColorDepth-Direktive - ohne sie würde X im 8-Bit-Modus
starten). Die erste Auflösung, die versucht wird, ist 1280x1024 (es
wird einfach der Reihenfolge in der Modeszeile gefolgt). Denke daran,
dass »1280x1024« einfach ein Label für die Werte in der ModeLine ist.

<p>
Du solltest wissen, dass das ModeLinegeneratorskript Optionen hat, um
seine Timings für ältere oder kleinere Monitore etwas zu lockern, und
dass es die Möglichkeit hat, ModeLines für spezielle Monitore
anzubieten. Abhängig davon, was für eine Hardware du hast, ist sie
vielleicht nur schwer mit den Standardoptionen zu betreiben. Wenn das
Bild zu groß, zu breit oder zu klein ist oder nicht genügend
horizontal oder vertikal gekippt ist und die Monitorkontrollen zur
Kompensierung nicht ausreichen, kann man mittels xvidtune(1) die
ModeLine besser dem Monitor anpassen.

<p>
In den meisten modernen Monitoren gibt es kein festes Limit der
Bandbreite, daher ist sie auch oftmals nicht in den Spezifikationen
aufgeführt. Aber je mehr du in der Bandbreite nach oben gehst, desto
verschwommener wird das Bild. Du könntest also zum Testen die
Bandbreite deiner Grafikkarte (auch dotclock genannt) eingeben (so
kannst du deinen Monitor nicht beschädigen) und Schritt für Schritt in
Bandbreite heruntergehen, bis du ein schönes, klares Bild hast.

<p>
Wenn dir das unnötig kompliziert erscheint, liegt das daran,
dass es genau das ist. X.Org kümmert sich darum und macht diesen
Prozess bedeutend einfacher, da es viele eingebaute Modi hat und außerdem
in der Lage ist, Angaben aus vielen Plug-and-play-DDC- und
-DDC2-Monitoren auszulesen.

<p>
Du kannst das »Colas XFree86 ModeLine Generator script« hier
herunterladen:
<a href="http://koala.ilog.fr/ftp/pub/Klone/">http://koala.ilog.fr/ftp/pub/Klone/</a>.
Du brauchst den Kloneinterpreter und musst ihn kompilieren. Er ist als
<tt>lang/klone</tt> in den Ports. Die Skripte existieren im Verzeichnis
scripts der Klonedistribution. (Der Port installiert sie nach
/usr/local/lib/klone/scripts.)

<p>
Es sind zwei Versionen des Skriptes dabei: die erste ist eine
CGI-Version, die identisch zu der obigen Webseite ist, die zweite ist
eine Nicht-CGI-Version, die deine komplette X.org-Datei nimmt, die
Monitorspezifikationen dekodiert, die du in xorgconfig/XF86Setup
eingegeben hast (Hast du eigentlich die echten Spezifikationen für
deinen Monitor eingegeben, oder die generischen benutzt?) und passt die
existierenden ModeLines an.

<p -->
<font color= "#0000e0">
<a href= "index.html">[FAQ-Index]</a>
<a href= "faq10.html">[Zum Kapitel 10 - Systemverwaltung]</a>
<a href= "faq12.html">[Zum Kapitel 12 - Hardware- und plattformspezifische Fragen]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt="[back]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: faq11.html,v 1.74 ]<br>
$Translation: faq11.html,v 1.31 2008/03/04 23:03:08 paldium Exp $<br>
-->
$OpenBSD: faq11.html,v 1.29 2008/03/09 13:37:12 tobias Exp $
</small>
</body>
</html>
