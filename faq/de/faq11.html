<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>11.0 - Performance Tuning</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta http-equiv="Content-Language" content="de">
<meta name= "description"   content= "Die OpenBSD FAQ Seiten - FAQ 11: Performance Tuning">
<meta name= "keywords"      content= "openbsd,faq,performance,tuning ">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2002 by OpenBSD.">
</head>

<body bgcolor= "#ffffff" text= "#000000">

<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif">
<p>
<h2><font color="#e00000">11.0 - Performance Tuning</font></h2>
<hr>

<p>
<blockquote>
<h3>Inhaltsverzeichnis</h3>
</blockquote>
<ul>
<li><a href="#Network">11.1 - Netzwerk</a></li>
<li><a href="#Disk"   >11.2 - Festplatten I/O</a></li>
<!-- li><a href="#kmem"   >11.3 - Tuning kmem</a></li -->
<li><a href="#HW"     >11.4 - Hardware Auswahl</a></li>
<li><a href="#Async"  >11.5 - Wieso benutzen wir keine async mounts?</a></li>
<li><a href="#XF86"   >11.6 - Tunen deiner Monitorauflösung unter XFree86</a></li>
</ul>
<hr>

<p>
Wenn du einen vielbesuchten Server, ein Gateway oder eine Firewall administrierst, 
möchtest oder musst du vielleicht einige der standardmässigen 
Parameter anpassen, um eine optimale Performance zu erhalten.
Die <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=options&amp;sektion=4">options(4)</a> 
man page berichtet über die angebotenen Kerneloptionen. Diese Optionen werden in der 
Kernel-Konfigurationsdatei plaziert, bevor du einen eigenen Kernel kompilierst. 
Mehr Details dazu erhälst du in der <a href="faq5.html">FAQ 5</a>.
<p>
<a name= "Network"></a>
<a name= "11.1"></a>
<h2>11.1 - Netzwerk</h2>

<p>
Ein Parameter, der bei einem besonders belasteten Server, Gateway oder 
Firewall vielleicht angepasst werden muss, ist NMBCLUSTERS.  Er 
kontrolliert die Grösse der kernel mbuf cluster map. Wenn du Meldungen
wie "mb_map full" auf deinem Computer bekommst, musst du die Werte für
diesen Parameter vergrössern. Wenn ohne ersichtlichen Grund der 
Traffic auf einem Netzwerk aufhört, kann das ebenfalls ein Zeichen
für zu kleine NMBCLUSTERS sein.  Ein sinnvoller Wert beim i386 port 
mit mindestens 100Mbps ethernet Interfaces (egal wieviele davon
die Maschine hat) ist 8192.  

<blockquote>
<strong>
option NMBCLUSTERS=8192<BR>
</strong>
</blockquote>
Die Standard-Anzahl von NMBCLUSTERS variiert von Plattform zu Plattform, 
und reicht von 256 bis 2048.  Sie werden in einer plattform-abhängigen 
Header-Datei gesetzt, es sei denn, sie werden von einer "option"-Zeile 
in einer Kernel-Konfigurations-Datei überschrieben.

<p>
<a name= "Disk"></a>
<a name= "11.2"></a>
<h2>11.2 - Festplatten I/O</h2>

<p>
Festplatten I/O Geschwindigkeit ist ein wichtiger Faktor in der 
Gesamtgeschwindigkeit deines Computers. Sie wird umso wichtiger,
wenn dein Computer eine Multi-User-Umgebung beheimatet
(User aller Arten, von solchen, die sich einloggen, bis zu denen
die Serverdienste nutzen). Datenspeicher brauchen ständige 
Aufmerksamkeit. Insbesondere, wenn deine Partition überläuft,
oder deine Platten versagen. OpenBSD kennt verschiedene Optionen, um
die Geschwindigkeit deiner Festplattenoperationen zu erhöhen
und Fehlertoleranz zu bieten.

<blockquote>
Inhaltsverzeichnis
</blockquote>
<ul>
	<li><a href="#ccd">CCD</a> - Concatenated Disk Driver.
	<li><a href="#raid">RAID</a>
	<li><a href="#buf">Filesystem Buffer</a>
	<li><a href="#softu">Soft Updates</a>
	<li><a href="#maxvnodes">Grösse des namei() cache</a>
</ul>

<p>
<a name="ccd"></a>
<H3>11.2.1 - CCD</H3>
<blockquote>
<p>
Die erste Option ist die Benutzung des 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccd&amp;apropos=0&amp;sektion=4&amp;format=html">ccd(4)</a>, 
des Concatenated Disk Driver.
Das erlaubt dir, mehrere Partitionen in eine virtuelle Platte zu verwandeln 
(und damit kannst dafür sorgen, dass mehrere Festplatten wie eine 
einzige aussehen). Dieses Konzept ist ähnlich wie das von LVM
(logical volume management), das in mehreren kommerziellen Unix-Arten
zu finden ist. 
<p>
Wenn du GENERIC benutzt, ist ccd bereits eingeschaltet (in
<tt>/usr/src/sys/conf/GENERIC</tt>).  Wenn du einen veränderten
Kernel benutzt, musst du es vielleicht wieder in deine Kernel-Konfiguration
einfügen. Wie auch immer, auf jeden Fall muss sich eine
Zeile wie die folgende in deiner Konfigurationsdatei befinden:

<p>
<pre>
     <strong>pseudo-device   ccd     4       # concatenated disk devices</strong>
</pre>

<p>
Das obige Beispiel gibt die bis zu 4 ccd Devices (virtuelle Platten).
Jetzt musst du festlegen, welche Partitionen auf deinen realen Festplatten
du in den ccd einbinden willst. Benutze disklabel, um diese
Partitionen als 'ccd'-Typ zu markieren. Auf einigen Architekturen
erlaubt dir disklabel das vielleicht nicht. In diesem Fall markiere sie
einfach als 'ffs'. 
<p>
Wenn du ccd dazu benutzt, um mittels striping Performance zu gewinnen, solltest du wissen,
dass du keine optimale Performance bekommst, bis du das gleiche Festplatten-Modell mit den 
gleichen disklabel Einstellungen benutzt.
<P>
Editiere /etc/ccd.conf, bis sie etwa so aussieht :
(Mehr Informationen über das Konfigurieren von ccd findest du unter
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccdconfig&amp;apropos=0&amp;sektion=8&amp;format=html">ccdconfig(8)</a>)
<blockquote>
<pre>
# Configuration file for concatenated disk devices
#
# ccd   ileave  flags   component devices
ccd0   16      none    /dev/sd2e /dev/sd3e
</pre>
</blockquote>
Um die Änderungen wirksam zu machen, führe das hier aus:
<blockquote>
<pre>
# ccdconfig -C
</pre></blockquote>
Solange /etc/ccd.conf existiert, wird sich ccd automatisch beim Booten 
konfigurieren.
Jetzt hast du eine neue Festplatte, ccd0, eine Kombination von /dev/sd2e und /dev/sd3e.
Benutze disklabel einfach wie gewöhnlich, um die Partition oder 
Partitionen zu erzeugen, die du benutzen willst. Nutze erneut die 'c' 
Partition nicht, um darauf irgendetwas zu speichern. Stelle sicher, dass 
deine benutzten Partitionen mindestens einen Zylinder vom Anfang
der Disc weg ist.
</blockquote>
<br>

<a name="raid"></a>
<H3>11.2.2 - RAID</H3>
<blockquote>
<p>
Eine weitere Lösung ist <a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;apropos=0&amp;sektion=4&amp;format=html">raid(4)</a>,
wofür du <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;apropos=0&amp;sektion=8&amp;format=html">raidctl(8)</a>
nutzen musst, um deine RAID Geräte zu kontrollieren. OpenBSD's RAID basiert auf 
Greg Oster's <a href="http://www.cs.usask.ca/staff/oster/raid.html">NetBSD port</a>
der CMU
<a href="http://www.pdl.cmu.edu/RAIDframe/">RAIDframe</a> Software.
OpenBSD hat Unterstützung für die RAID-Level
0, 1, 4, und 5.
<p> 
Für RAID muss, wie auch bei ccd, Unterstützung
im KERNEL sein.
Diese Treiber-Unterstützung für RAID ist im Gegensatz zu ccd allerdings nicht 
im GENERIC-Kernel enthalten, also muss sie extra in deinen Kernel
einkompiliert werden (RAID-Unterstützung vergrössert deinen
i386 Kernel um gute 500k!)
</p>

<p>
<blockquote>
<pre>
<strong>pseudo-device   raid   4       # RAIDframe disk device</strong>
</pre>
</blockquote>
<P>
Ein RAID aufzusetzen ist mit einigen Betriebssystemen verwirrend und 
schmerzhaft, um es sanft auszudrücken. Nicht jedoch mit RAIDframe.
Lies die 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;apropos=0&amp;sektion=4&amp;format=html">raid(4)</a> und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;apropos=0&amp;sektion=8&amp;format=html">raidctl(8)</a>
man pages für die kompletten Details. Es gibt dafür viele 
Optionen und mögliche Konfiguationen, und ein detaillierter Überblick 
sprengt den Rahmen dieses Dokumentes.
</blockquote>
<BR>

<a name="buf"></a>
<H3>11.2.3 - Filesystem Buffer</H3>
<blockquote>
Fileserver, die noch Speicher überhaben, können die BUFCACHEPERCENT 
erhöhen. Das heisst, welcher Prozentsatz deines RAM als 
"file system buffer" (Dateisystem-Puffer) genutzt werden soll.
Diese Option wird vielleicht geändert, wenn der Unified Buffer Cache 
komplett und ein Teil von OpenBSD ist. In der Zwischenzeit solltest du 
eine Zeile wie diese zu deiner Kernel-Konfiguration hinzufügen, 
um BUFCACHEPERCENT zu erhöhen:
</blockquote>

<p>
<blockquote>
<strong>option	BUFCACHEPERCENT=30</strong><BR>
</blockquote>
<blockquote>
<p>
Natürlich kannst du ihn auch auf 5 Prozent setzen (dem Standard) oder auch so hoch
wie 50 Prozent (oder auch mehr.)
</blockquote>
<br>

<a name="softu"></a>
<H3>11.2.4 - Soft Updates</H3>
<blockquote>
Ein weiteres Tool zum Erhöhen der Systemgeschwindigkeit sind Soft Updates.
Eine der langsamsten Operationen im traditionellen BSD Dateisysteme ist 
das Updaten der Metainfos (was unter anderem immer dann geschieht, wenn 
du Dateien oder Verzeichnisse erzeugst oder löschst.) Soft Updates
versucht die Metainfo im RAM upzudaten, statt jedes einzelne Metainfo-Update 
auf die Platte zu schreiben. Ein weiterer Nebeneffekt ist, dass die 
Metainfos auf der Festplatte immer auf dem aktuellen Stand sind. Das heisst, 
ein Systemcrash sollte kein
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)</a>
beim folgende Booten benötigen, sondern eine einfache 
Hintergrund-Version von fsck, die Änderungen an den Metainfos im RAM macht
(a la softupdates). Das heisst, dass Reboots viel schneller sind, da 
nicht mehr auf fsck gewartet werden muss! (OpenBSD hat dieses Feature 
leider noch nicht.) Mehr über Soft Updates findest du im 
<a href="../faq14.html#SoftUpdates">Soft Updates FAQ</a> Eintrag.
</blockquote>
<BR>

<a name="maxvnodes"></a>
<H3>11.2.5 - Grösse des namei() cache</H3>
<DL>
<DD>
<p>
Hinweis: Vorher hat die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=options&amp;sektion=4&amp;format=html">options(4)</a>
manual page empfohlen, die <TT>NVNODE=integer</TT> Kernel Option zu setzen. Das wird nicht mehr
empfohlen; du solltest stattdessen das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>
Kommando benutzen. 
</p>
<p>
Die name-to-inode Übersetzung (a.k.a., <!-- need to write the manual
page first... <a href="">namei(3)</a> --> namei()) cache kontrolliert die Geschwindigkeit
der pathname zu
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inode&amp;sektion=5&amp;format=html">inode(5)</a>
Übersetzung. Standardmässig hat dieser Cache <TT>NPROC * (80 + NPROC / 8)</TT> 
Einträge. <TT>NPROC</TT> ist auf <TT>20 + 16 * MAXUSERS</TT> gesetzt; in der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=config&amp;sektion=8&amp;format=html">config(8)</a>
manual page steht eine Erklärugn der <TT>maxusers</TT> Kernel-Konfigurations-Parameter.
Ein sinnvoller Weg zum Herausfinden der passenden Grösse des Cache 
wäre, eine große Anzahl von namei() cache misses vorrausgesetzt, die man mit einem 
Tool wie   
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=systat&amp;sektion=1&amp;format=html">systat(1)</a> 
messen könnte, wäre eine Untersuchung des momentanen 
berechneten Wertes mittels
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a>,
(das diesen Parameter "<TT>kern.maxvnodes</TT>" nennt) und diesen Wert zu 
vergössern, bis sich entweder die namei() cache hit rate verbessert,
oder es bewiesen ist, dass das System nicht wesentlich von einer
Erhöhung der Grösse des namei() cache profitiert. Nachdem der 
Wert gestgestellt wurde, kannst du ihn für die nächsten 
Systemstarts mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5&amp;format=html">sysctl.conf(5)</a>
setzen.
</DD>
</DL>
<BR>

<p>
<!-- a name= "kmem"></a>
<a name= "11.3"></a>
<h2>11.3 - Tuning kmem</h2>
</p>
This was moved to the <a href="faq11-2.5.html#11.2">OpenBSD 2.5 information section</a>.
<br>
<p -->
<a name= "HW"></a>
<a name= "11.4"></a>
<h2>11.4 - Hardware Auswahl</h2>
<i>(Hinweis - diese Sektion dreht sich fast ausschliesslich um die i386 oder PC Architektur.
Andere Architekturen geben dir sozusagen keine so grosse Auswahl!)</i>
<P>
Die Performance deiner Anwendungen hängt stark von deinem 
Betriebssystem und den Fähigkeiten ab, die es bereitstellt. Das mag
ein Grund dafür sein, dass du OpenBSD benutzt.
Die Performance deiner Anwendungen hängt aber auch stark von deiner 
Hardware ab.
Für viele Leute ist das Preis-Leistungs-Verhältnis eines 
brandneuen PC mit einem Intel Pentium IV oder AMD Athlon Prozessors viel
besser als das Preis-Leistungs-Verhältnis einer Sun UltraSparc 60!
Der Preis von OpenBSD ist natürlich unschlagbar.
<P>
Wenn du einen neuen PC kaufen willst, ob nun in einem Komplettangebot,
oder Einzelteil für Einzelteil, solltest du sicherstellen, dass du 
unbedingt nur zuverlässige Teile bekommst. In der Welt der PCs ist 
das leichter gesagt als getan. 
<b>Schlechte oder sonstige unzuverlässige oder unpassende Teile
können dazu führen, dass OpenBSD schlecht läuft und oft
abstürzt</b>.  Der beste Rat, den wir geben können, ist, vorsichtig 
zu sein, und Marken und Teile zu kaufen, die von jemandem empfohlen werden,
dem du trauen kannst. Wenn du nur auf den Preis eines PCs achtest, wirst 
du wahrscheinlich auch an Qualitält verlieren!
<P>
Es gibt ein paar Dinge, die dir helfen können, die maximale 
Performance aus deiner Hardware zu holen:
<UL>
<LI>Benutze mehrere Festplatten.
<P>Statt nur eine 20GB Platte zu kaufen, kaufe mehrere 9GB Platten. Wenn 
das auch mehr kostet, wird es doch die Last auf mehrere Spindeln verteilen,
und somit die Zeitspanne verringern, die ein Datenzugriff benötigt.
Ausserdem kannst du mit mehreren Platten auch mehr Zuverlässigkeit
und schnelleren Datenzugriff mit RAID bekommen.
<p>
<LI>Benutze SCSI, wenn du hohe Festplatten-IO-Geschwindigkeit brauchst.
<P>IDE Festplatten laufen normalerweise mit 5400 RPM bis 7200 RPM.  
Selbst bei hochwertigen IDE Platten ist es manchmal zu viel verlangt, wenn
man mehr als 15 bis 20 MB pro Sekunde an Datendurchsatz von einer einzelnen
Platte verlangt. Mit hochwertigen SCSI-Platten (10k RPM oder 15k RPM)
kannst du mehr Durchsatz bekommen. 
Im Gegensatz dazu ist es eine Verschwendung von Geld, wenn du mittlere oder
langsame SCSI-Platten benutzt, da dann IDE die gleiche oder bessere Leistung
bringt.
<P>Wenn du einen Server baust, und mehr als 20 GB Plattenplatz brauchst, 
solltest du über SCSI nachdenken. IDE beschränkt dich auf zwei
Platten pro Controller. Gleichzeitige Zugriffe auf diese Platten haben
vermutlich einen negativen Effekt auf die I/O Performance dieser 
Platten. Mit Wide SCSI kannst du 15 Platten pro Controller anschliessen,
und es hat bessere Unterstützung für gleichzeitigen Zugriff 
als IDE.
<P>
<li>Benutze SDRAM statt DRAM.
<P>
Diese Option trift fast nur auf PCs zu. Bei den meisten anderen Architekturen
hast du keinerlei Auswahl welche Art von RAM du benutzen kannst. Bei den
meisten PCs schon. Mit SDRAM bekommst du eine bessere Performance als mit
DRAMs (SIMMs). Wenn dein System RDRAM unterstützt, oder vielleicht
DDR oder eine andere neue Art von RAM bist du sogar noch besser dran..  
<P>
<li>Benutze ECC oder parity RAM.
<P>
Parity fügt einen Mechanismus hinzu, der prüft, ob die Daten im 
RAM noch in Ordnung sind. ECC baut das noch dahingehend aus, dass es 
versucht, Fehler bei einzelnen Bits automatisch zu korrigieren. 
Diese Option gibt es wieder fast nur bei PCs. Die meisten anderen 
Architekturen brauchen einfach ECC oder parity RAM. Einige nicht-PC-Computer
booten nicht einmal mit nicht-parity-RAM. 
Wenn du kein ECC/parity RAM benutzt, kann es zu Daten-Korrumpierung und
anderen Abnormitäten kommen. Einige Herstelle von "billigem  PC RAM"
stellen nicht einmal eine ECC-Variante her! Das hilft dir, sie zu vermeiden!
PC Hersteller verkaufen oftmals mehrere Produktlinien, in "Server" und
"Workstations" aufgeteilt. Die Server haben parity (und jetzt ECC) seit 
vielen Jahren beinhaltet. Unix-Workstation-Hersteller benutzen parity 
(und nun ECC) seit vielen Jahren in all ihren Produktlinien.
<P>
<LI>Vermeide ISA-Karten.
<P>
Während die meisten Leute ISA-Karten schon deshalb meiden, weil
sie veraltet und zudem noch schwer zu konfigurieren sind, gibt es aber
trotzdem noch eine ganze Menge davon. Wenn du den ISA Bus für deine
Festplatte oder Netzwerk-Karte benutzt (oder noch schlimmer, für beides)
denke daran, dass der ISA Bus vermutlich ein Flaschenhals ist. Wenn du
Geschwindigkeit brauchst, benutze PCI. Natürlich gibt es noch 
zahllose ISA-Karten, die einfach gut funktionieren. Unglücklicherweise 
sind das meist Sound-Karten oder solche für serielle Ports.
<P>
<LI> Vermeide billige PCI Netzwerk-Karten.
<P>
OpenBSD unterstützt eine ganze Menge von billigen PCI Netzwerk-Karten.  
Diese Karten funktionieren prima in einfachen Heim-Systemen, oder 
solchen mit wenig oder moderater Netzwerk-Last im Geschäfts-
oder Forschungs-Bereich. Aber, wenn du hohen Durchsatz brauchst, und
wenig Belastung deines Servers, bist du mit einer 
Qualitäts-Netzwerk-Karte besser dran. Unglücklicherweise
sind einige Serien von teuren Marken-Herstellern (wie die 3com XL Serie) 
nicht besser als die billigen Karten.
Ein echter Favorit unter den 10/100Mbps Netzwerk-Karten ist dagegen die 
Intel EtherExpress PRO/100.
<P>
</ul>
<br>
<p>
<a name= "Async"></a>
<a name= "11.5"></a>
<h2>11.5 - Wieso benutzen wir keine async mounts?</h2>
<p>
Frage: "Ich gebe einfach ein "mount -u -o async /"ein, was ein Paket, was ich 
brauche, benutzbar macht. 
(das darauf besteht alle paar Momente ein paar hundert Dateien zu ändern.)

Wieso wird asynchrones mounting abgelehnt und ist nicht standardmässig 
aktiviert (wie in manchen anderen Unixen) ? Wäre das nicht ein 
einfacherer, und daher auch sichererer Weg, die Performance mancher 
Applikation zu erhöhen ?"
</p>
<p>
Antwort: "Asynchrone mounts sind tatsächlich schneller als synchrone 
mounts, aber sie sind unsicherer. Was passiert im Falle eine Stromausfalls?
Oder bei einem Hardwareproblem ? Die Suche nach Geschwindigkeit darf nicht
auf Kosten von Stabilität und Zuverlässigkeit des Systems gehen.
Siehe auch die man page von
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;apropos=0&amp;sektion=8&amp;format=html">mount(8)</a>."
</p>
<pre>
	     async   All I/O to the file system should be done asynchronously.
		     This is a dangerous flag to set since it does not guaran-
		     tee to keep a consistent file system structure on the
		     disk.  You should not use this flag unless you are pre-
		     pared to recreate the file system should your system
		     crash.  The most common use of this flag is to speed up
		     restore(8) where it can give a factor of two speed in-
		     crease.
</pre>
<p>
Auf der anderen Seite, wenn du sowieso nur mit temporären Daten 
umgehst, die du nach einem Crash wieder rekonstruieren kannst, kannst du
mehr Geschwindigkeit erhalten, indem du eine separate Partition nur für 
diese Daten benutzt, die asynchron gemountet ist. Tue das aber <i>nur</i>,
wenn dir der Verlust aller Daten in der Partition nach irgendeinem
Problem nichts ausmacht. Daher sind
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=mfs&amp;sektion=8">mfs(8)</a>
Partitionen asynchron gemountet, weil sie ja nach jedem Reboot sowieso
gelöscht und neu erzeugt werden.
</p>
<br>
<p>
<a name= "XF86"></a>
<a name= "11.6"></a>
<h2>11.6 - Tunen deiner Monitorauflösung unter XFree86</h2>
<p>
Es ist durchaus mit vielen multi-Sync-Monitoren möglich, einen X 
Server in einer azeptablen Auflösung zum Laufen zu kriegen.
Mit den Standard-Konfigurations-Werkzeugen xf86config oder XF86Setup ist
es aber recht schwierig, ein gutes Ergebnis zu erhalten. Einer der 
schmerzvolleren Punkte ist es, deinen Monitor zur gewünschten
Auflösung zu bewegen, und dann eine vertikale Scan-Rate von
mindestens 72-75 Hz zu bekommen, eine Rate, bei der das Bildschirmgeflacker
wesentlich geringer sichtbar für menschliche Augen ist.
Was passiert aber, wenn du die vertikale Scan-Rate sehr niedrig einstellst?
So könntest du den Bildschirm zum Beispiel ohne Flackern auf Video
filmen, aber auch dazu sind die Methoden mit den Standard-Werkzeugen von
XFree86 eher nicht-intuitiv.
<P>
Schlussendlich ist es bei den Auflösungen, 
(800x600, 1024x768, 1152x900,1280x1024), die die meisten Leute heute 
mit preiswerten VGA-Monitoren benutzen (zumindest mit neueren Modellen)
bestens möglich, vertikale Wiederholungsraten von 85 Hz und mehr 
zu bekommen, um ein wirklich klares und ansehnliches Bild zu erhalten.
Der XFree86 X Server hat einen Mechanismus, der dir erlaubt, im Detail
den Grafik-Modus zu beschreiben, den du benutzen willst, dies nennt
sich ModeLine. Eine ModeLine hat vier Sektionen, eine einzelne Nummer 
für die Pixel Clock, vier Nummern für horizontales Timing,
vier Nummern für vertikales Timing, und eine optionale Sektion
mit einer Liste von Flags für weitere Charakteristika wie etwa 
den Modus (z.B. Interlace, DoubleScan, und weitere.. mehr Details
gibt es in der XF86Config(5) manual page)
<P>
Das Erzeugen einer ModeLine ist eine schwarze Kunst.. Glücklicherweise
gibt es mehrere Skripte, die das für dich erledigen können.
Eines davon ist der <a href="http://www-sop.inria.fr/cgi-bin/koala/nph-colas-modelines">
Colas XFree86 ModeLine Generator</a>.  Ein weiteres ist der 
<a href="http://xtiming.sourceforge.net/">The XFree86 Modeline Generator</a>
, der bei SourceForge gehostet wird, und es gibt weitere bei
<a href="http://freshmeat.net/search/?q=modeline">Freshmeat</a>.
Bevor du diese ModeLine-Generatoren benutzen kannst, musst du die 
vertikalen und horizontalen sync Limits für deinen Monitor herausfinden.
Diese Angaben finden sich oftmals im Handbuch, oder auf der Webseite des
Monitor-Herstellers. Wenn du sie dort nicht finden kannst, suche einfach im Web nach
deinem Modell und Hersteller, viele Leute waren so freundlich, Listen
mit den entsprechenden Angaben zu erstellen.
<P>
Sagen wir zum Beispiel, du hättest einen Dell D1226H Monitor.  Du hast auf
Dell's Website herausgefunden, das er einen Bereich  von 30-95 kHz horizontal 
und 50-160 Hz vertikal hat. Besuche die ModeLine Generator Page,
und gib diese Informationen ein. Als nächstes musst du die minimale
vertical scan rate eingeben, die du haben willst. Jede Rate ab 72 Hz und 
grösser sollte im allgemeinen wenig flackern. Je mehr, desto besser 
wird das Bild.
<P>
Mit all diesen Informationen wird das Skript eine ModeLine für jede
mögliche 4x3 Auflösung generieren, die dein Monitor unterstützen
kann. Wenn jemand die Dell Spezifikationen von oben und eine minimale vertikale
Rate von 75 Hz eingibt, gibt das Skript etwas ähnliches wie das folgende
aus:
<P>
<PRE>
ModeLine "320x240" 20.07 320 336 416 448 240 242 254 280 #160Hz
ModeLine "328x246" 20.86 328 344 424 456 246 248 260 286 #160Hz
...
ModeLine "816x612" 107.39 816 856 1056 1136 612 614 626 652 #145Hz
ModeLine "824x618" 108.39 824 864 1064 1144 618 620 632 658 #144Hz
ModeLine "832x624" 109.38 832 872 1072 1152 624 626 638 664 #143Hz
...
ModeLine "840x630" 109.58 840 880 1080 1160 630 632 644 670 #141Hz
ModeLine "848x636" 110.54 848 888 1088 1168 636 638 650 676 #140Hz
...
ModeLine "1048x786" 136.02 1048 1096 1336 1432 786 788 800 826 #115Hz
ModeLine "1056x792" 136.58 1056 1104 1344 1440 792 794 806 832 #114Hz
ModeLine "1064x798" 137.11 1064 1112 1352 1448 798 800 812 838 #113Hz
...
ModeLine "1432x1074" 184.07 1432 1496 1816 1944 1074 1076 1088 1114 #85Hz
ModeLine "1576x1182" 199.86 1576 1648 2008 2152 1182 1184 1196 1222 #76Hz
ModeLine "1584x1188" 198.93 1584 1656 2016 2160 1188 1190 1202 1228 #75Hz
</PRE>
<P>
Dieser Monitor gibt nun vor, 1600x1200 @ 75 Hz machen zu können, 
aber das Skript sagt nicht, dass das innerhalb der  75 Hz sei.
Wenn du also exakt 1600x1200 haben willst, geh ein wenig mit deiner
minimalen vertikalen Rate herunter.. (Hier z.B. kannst du bis
70 Hz heruntergehen)
<Pre>
ModeLine "1592x1194" 197.97 1592 1664 2024 2168 1194 1196 1208 1234 #74Hz
ModeLine "1600x1200" 199.67 1600 1672 2032 2176 1200 1202 1214 1240 #74Hz
ModeLine "1608x1206" 198.65 1608 1680 2040 2184 1206 1208 1220 1246 #73Hz
ModeLine "1616x1212" 197.59 1616 1688 2048 2192 1212 1214 1226 1252 #72Hz
ModeLine "1624x1218" 199.26 1624 1696 2056 2200 1218 1220 1232 1258 #72Hz
ModeLine "1632x1224" 198.15 1632 1704 2064 2208 1224 1226 1238 1264 #71Hz
ModeLine "1640x1230" 199.81 1640 1712 2072 2216 1230 1232 1244 1270 #71Hz
ModeLine "1648x1236" 198.64 1648 1720 2080 2224 1236 1238 1250 1276 #70Hz
</PRE>
<P>
Hier sehen wir, dass der Monitor tatsächlich 1600x1200 @ 74 Hz macht,
wenn die dot clock (Bandbreite) auf 200MHz begrenzt ist. Setze die Bandbreite
gemäss der Grenzen, die vom Monitor definiert werden.
<P>
Nachdem du einmal die ModeLines hast, schreibe sie in deine /etc/XF86Config Datei. 
Kommentiere die alten ModeLines aus, so dass du sie noch benutzen kannst, 
falls die neuen nicht funktionieren.
Als nächstes wähle aus, mit welcher Auflösung du nun 
arbeiten willst. Als erstes musst du nun herausfinden, ob X im "accelerated mode"
läuft, oder nicht (das tut es mit den meisten Grafik-Karten), so dass 
du auch weisst, welche <TT>"Screen"</tt> Sektion der XF86Config-Datei du 
modifizieren musst. Alternativ kannst du natürlich einfach alle Screen-Sektionen
modifizieren.
<PRE>
Section "Screen"
   Driver          "Accel"
   Device          "Primary Card"
   Monitor         "Primary Monitor"
   DefaultColorDepth 32
   SubSection "Display"
      Depth        32
      Modes        "1280x1024" "1024x768"
   EndSubSection
</PRE>
Die erste Auflösung nach dem "Modes" Stichwort ist die Auflösung,
in der X startet. Mit dem Drücken von CTRL-ALT-KEYPAD MINUS oder CTRL-ALT-KEYPAD
PLUS kannst du zwischen den hier aufgeführten Auflösungen hin-
und herschalten. Gemäss der Angaben oben wird X versuchen im 32-Bit-Modus 
(wegen der DefaultColorDepth Direktive, ohne sie würde X im 8-Bit-Modus 
starten.) Die erste Auflösung, die versucht wird, ist 1280x1024 (es
wird einfach der Reihenfolge in der 'Modes'-Zeile gefolgt.)  Denke daran, dass
"1280x1024" einfach ein Label für die Werte in der ModeLine ist.
<P>
Du solltest wissen, dass das ModeLine Generator-Skript Optionen hat, um seine
Timings für ältere oder kleinere Monitore etwas zu lockern, und
dass es die Möglichkeit hat, ModeLines für spezielle Monitore
anzubieten. Abhängig davon, was für eine Hardware du hast, ist sie
vielleicht nur schwer mit den Standard-Optionen zu betreiben. Wenn das 
Bild zu gross ist, zu breit oder zu klein, oder nicht genügend 
horizontal oder vertikal gekippt ist, und die Monitor-Kontrollen zur
Kompensierung nicht ausreichen, kann man mittels xvidtune(1) die ModeLine 
besser dem Monitor anpassen.
<P>
In den meisten modernen Monitoren gibt es kein fixes Limit der Bandbreite,
daher ist sie auch oftmals nicht in den Spezifikationen aufgeführt.
Aber je mehr du in der Bandbreite nach oben gehst, desto  verschwommener
wird das Bild. Du könntest also zum Testen die Bandbreite deiner Grafikkarte
(auch "dotclock" genannt) eingeben (so kannst du deinen Monitor nicht
beschädigen) und Schritt-für-Schritt in BW heruntergehen, bis du
ein schönes, klares Bild hast.
<P>
Wenn dir das unnötig kompliziert erscheint, liegt das daran,
dass es genau das ist. XFree86 4.0 kümmert sich darum, und macht diesen
Prozess bedeutend einfacher, da es viele eingebaute Modi hat, und ausserdem
in der Lage ist, Angaben aus vielen "plug and play" DDC und DDC2 
Monitoren auszulesen.
<P>
Du kannst das "Colas XFree86 ModeLine Generator script" hier herunterladen:
<a href="http://koala.ilog.fr/ftp/pub/Klone/">http://koala.ilog.fr/ftp/pub/Klone/</a>.
Du brauchst den Klone Interpreter, und musst ihn kompilieren. Er ist in als
<tt>lang/klone</tt> in den ports. Die Skripte existieren im "scripts" 
Verzeichnis der Klone Distribution.  (Der port installiert sie nach
/usr/local/lib/klone/scripts.)
<P>
Es sind zwei Versionen des Skriptes dabei, die erste ist eine CGI Version 
die identisch zu der obigen Webseite ist. Die zweite ist eine nicht-CGI-Version
die deine komplette XF86Config-Datei nimmt, dekodiere die Monitor-Spezifikationen,
die du in xf86config/XF86Setup eingegeben hast (Hast du eigentlich die echten
Spezifikationen für deinen Monitor eingegeben, oder die generischen
benutzt?) und passe die existierenden ModeLines an.
<p>
<font color= "#0000e0">
<a href= "index.html">[Back to Main Index]</a>
<a href= "../faq10.html">[To Section 10.0 - System Administration]</a>
<a href= "faq12.html">[To Section 12.0 - Für fortgeschrittene Users]</a>
</font>
</p>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt="[back]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
Originally [OpenBSD: faq11.html,v 1.29 ]
<br>
$Translation: faq11.html,v 1.6 2004/10/29 21:28:08 jufi Exp $
<br></small>
<small>$OpenBSD: faq11.html,v 1.6 2004/10/29 21:31:33 jufi Exp $</small>
</body>
</html>
