<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>14 - Platten Einrichtung</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta http-equiv="Content-Language" content="de">
<meta name= "description"   content= "Die OpenBSD-FAQ-Seite">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2005 by OpenBSD.">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<style type="text/css">
  <!--
  pre { margin-left: 20px; }
  -->
</style>
</head>

<body bgcolor= "#ffffff" text= "#000000">

<a href="../../de/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">
</a>
<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ Index]</a>
<a href= "../faq13.html">[Zum Kapitel 13 - Multimedia]</a>
</font>

<h1><font color="#e00000">14 - Platten Einrichtung</font></h1><hr>

<h3>Inhaltsverzeichnis</h3>
<ul>
<li><a href="#disklabel"  >14.1 - Benutzung von OpenBSDs disklabel(8)</a>
<li><a href="#fdisk"      >14.2 - Benutzung von OpenBSDs fdisk(8)</a>
<li><a href="#NewDisk"    >14.3 - Hinzufügen von weiteren Festplatten unter
    OpenBSD</a>
<li><a href="#SwapFile"   >14.4 - Wie man in eine Datei swappt</a>
<li><a href="#SoftUpdates">14.5 - Soft Updates</a>
<li><a href="#Boot386"    >14.6 - Wie bootet OpenBSD/i386?</a>
<li><a href="#LargeDrive" >14.7 - Welche Probleme treten bei großen
    Festplatten mit OpenBSD auf?</a>
<li><a href="#InstBoot"   >14.8 - Installieren von Bootblocks - i386
    spezifisch</a>
<li><a href="#Backup"     >14.9 - Sich auf das Schlimmste vorbereiten:
    Backups und Wiederherstellen von Band.</a>
<li><a href="#MountImage" >14.10 - Diskimages unter OpenBSD mounten</a>
<li><a href="#pciideErr"  >14.11 - Hilfe! Ich erhalte Fehler mit IDE DMA!</a>
<li><a href="#RAID"       >14.13 - RAID Optionen unter OpenBSD</a>
<li><a href="#NegSpace"   >14.14 - Warum sagt mir <tt>df(1)</tt>, dass ich
    mehr als 100% von meiner Platte belegt habe?</a>
<li><a href="#OhBugger"   >14.15 - Partitionen wiederherstellen, nachdem
    das disklabel gelöscht wurde</a>
<li><a href="#foreignfs"  >14.16 - Kann ich auf Daten zugreifen, die auf
    anderen Dateisystemen als FFS liegen?</a>
<li><a href="#flashmem"   >14.17 - Kann ich ein Gerät mit Flashspeicher
    unter OpenBSD benutzen?</a>

</ul>
<hr>

<a name="disklabel"></a>
<h2>14.1 - Benutzung von OpenBSDs disklabel(8)</h2>
<h3>Inhaltsverzeichnis</h3>

<ul>
<li><a href="#disklabel.1">Was ist disklabel(8)?</a>
<li><a href="#disklabel.2">disklabel(8) während der OpenBSD Installation</a>
<li><a href="#disklabel.3">Gebräuchliche Verwendungen von disklabel(8).</a>
</ul>

   
<a name="disklabel.1"></a>
<h3>Was ist disklabel(8)?</h3>
  
<p>
Lese zunächst die 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
Manual Seite.

<p>
Disklabels werden erzeugt, um ein effizientes Interface zwischen deiner
Festplatte und den Festplattentreibern, die im Kernel enthalten sind, zu
erzeugen. Labels enthalten bestimmte Informationen über deine Festplatte,
wie z.B. die Plattengeometrie und Informationen über deine Dateisysteme. Dies
wird dann vom ,bootstrap' Programm benutzt, um die Festplatte zu laden und um
zu wissen, wo auf der Platte die Dateisysteme sind. Labels werden auch
zusammen mit den Dateisystemen benutzt, um eine effizientere Umgebung
zu erzeugen. Tiefergehende Informationen über disklabel gibt es in der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=5">disklabel(5)</a>
Manual Seite.

<p>
Zusätzlich führt die Benutzung von disklabel zur Überwindung
der Architekturgrenzen beim Partitionieren von Festplatten. Auf i386 kann man
z.B. nur 4 primäre Partitionen haben. (Partitionen, so wie sie andere
Betriebssysteme wie Windows NT oder DOS sehen.) Mit 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
benutzt du eine dieser ,primären' Partitionen, die dann *alle* deine OpenBSD
Partitionen enthält (z.B. ,swap', ,/', ,/usr' und ,/var'). Und du hast noch 3
weitere für andere Betriebssysteme über!

<a name="disklabel.2"></a>
<h3>disklabel(8) während der OpenBSD Installation</h3>

<p>
Einer der Hauptteile der OpenBSD Installation ist das erstmalige Erzeugen
der Labels. Das kommt (für i386 Benutzer) direkt nach der Benutzung von
<a href="#fdisk">fdisk(8)</a>.
Während der Installation benutzt du disklabel, um deine separaten Labels zu
erzeugen, die deine separaten Mount Points enthalten. Während der Installation
kannst du mittels 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a> 
deine Mount Points setzen, aber das ist eigentlich nicht nötig, da du deine
Änderungen später sowieso bestätigen musst. Aber es macht deine Installation
schon etwas geradliniger.

<p>
Da das während der Installation geschieht, hast du noch keine funktionierenden
Labels und sie müssen erst erzeugt werden. Das erste Label, das du erzeugst,
ist das Label ,a'. Das SOLLTE das Label sein, auf dem dann / gemountet wird.
Die empfohlenen Partitionen und ihren Größen kannst du dir unter
<a href="faq4.html#SpaceNeeded">FAQ4, Wieviel Platz brauche ich für eine
OpenBSD Installation?</a> ansehen. Für Server wird empfohlen,
zumindest diese Labels separat zu halten. Für Desktop User reicht vermutlich
ein einzelner Mountpoint /. Wenn du deine root-Partition (,a' Label)
erzeugst, denk dran, dass du in jedem Fall noch ETWAS Platz für dein
Swap Label benötigst. Jetzt kennst du die Grundlagen und daher geben wir
hier jetzt mal ein Beispiel für das Benutzen von disklabel. In diesem
ersten Beispiel wird angenommen, dass OpenBSD das einzige Betriebssystem
auf diesem Computer ist und eine vollständige Installation gemacht
wird.

<pre>

If this disk is shared with other operating systems, those operating systems
should have a BIOS partition entry that spans the space they occupy completely.
For safety, also make sure all OpenBSD file systems are within the offset and
size specified in the 'A6' BIOS partition table.  (By default, the disklabel
editor will try to enforce this).  If you are unsure of how to use multiple
partitions properly (ie. separating /,  /usr, /tmp, /var, /usr/local, and other
things) just split the space into a root and swap partition for now.

# using MBR partition 3: type A6 off 63 (0x3f) size 4991553 (0x4c2a41) 

Treating sectors 63-16386300 as the OpenBSD portion of the disk.
You can use the 'b' command to change this.

Initial label editor (enter '?' for help at any prompt)
&gt; <b>d a</b>
&gt; <b>a a</b>
offset: [63] <b>&lt;Enter&gt;</b>
size: [16386237] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <b>&lt;Enter&gt;</b>
mount point: [none] <b>/</b>
fragment size: [1024] <b>&lt;Enter&gt;</b>
block size: [8192] <b>&lt;Enter&gt;</b>
cpg: [16] <b>&lt;Enter&gt;</b>
&gt; <b>a b</b>
offset: [131103] <b>&lt;Enter&gt;</b>
size: [16255197] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [swap] <b>&lt;Enter&gt;</b>
</pre>

<p>
An diesem Punkt hast du eine 64MB root Partition erzeugt, die mit / gemountet
wird und eine 64Meg Swap Partition. In diesem Fall startet der Offset bei
Sektor 63. So willst du es haben. Wenn es bei der Größe angekommen ist,
wird dir Disklabel die Größen in Sektoren angeben, du musst aber die Größen
nicht ebenfalls im gleichen Format eingeben. Wie im Beispiel oben kannst du
Größen zum Beispiel so eingeben: <i>64 Megabytes = 64M</i> und
<i>2 Gigabytes = 2G</i>. Disklabel wird dann einfach auf den naheliegendsten
Zylinder runden. Im obigen Beispiel kann man auch sehen, dass disklabel annimmt,
dass Label ,b' Swapbereich sein wird. Das ist eine korrekte Annahme,
da im GENERIC Kernel Swap auf Label ,b' festgelegt ist, und daher solltest
du dieser Richtlinie ebenfalls folgen und ,b' als Swapbereich benutzen. 

<p>
Das nächste Beispiel wird dich durch die Erzeugung zweier weiterer Labels
führen. Im Übrigen kann das keine komplette Installation sein, da die Größe
dieser beiden Partitionen nicht ausreicht, um OpenBSD komplett zu
installieren. Das Erzeugen dieser ganzen Partitionen dient nur zur
Wiederholung und Vertiefung. 

<pre>
&gt; <b>a d</b>
offset: [262143] <b>&lt;Enter&gt;</b>
size: [16124157] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <b>&lt;Enter&gt;</b>
mount point: [none] <b>/tmp</b>
fragment size: [1024] <b>&lt;Enter&gt;</b>
block size: [8192] <b>&lt;Enter&gt;</b>
cpg: [16] <b>&lt;Enter&gt;</b>
&gt; <b>a e</b>
offset: [393183] <b>&lt;Enter&gt;</b>
size: [15993117] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <b>&lt;Enter&gt;</b>
mount point: [none] <b>/var</b>
fragment size: [1024] <b>&lt;Enter&gt;</b>
block size: [8192] <b>&lt;Enter&gt;</b>
cpg: [16] <b>&lt;Enter&gt;</b>
</pre>

<p>
Im obigen Beispiel fallen dir vermutlich zwei Dinge auf. Zum einen, dass der
Offset, der als nächstes an der Reihe ist, automatisch für dich errechnet
wird. Wenn du eine solche Installation machst, musst du dich mit dem Ändern
der Offsets nicht herumschlagen. Ein weiterer Unterschied, der dir vielleicht
auffällt, ist, dass Label ,c' übersprungen wurde. Das ist aber Absicht, und
zwar deshalb, weil Label ,c' die ganze Festplatte repräsentiert. Aus diesem
Grund solltest du Label ,c' vollkommen in Ruhe lassen.

<p>
Sind deine Label erst einmal alle erzeugt, ist alles, was noch nötig ist,
die Label auf die Festplatte zu schreiben und einfach mit dem
Installationsprozess fortzufahren. Um alles zu schreiben und disklabel zu
beenden (und mit der Installation weiterzumachen), tippe folgendes:

<pre>
&gt; <b>w</b>
&gt; <b>q</b>
</pre>

<p>

<a name="disklabel.3"></a>
<h3>Gebräuchliche Verwendungen von disklabel(8)</h3>

<p>
Wenn dein System erst einmal installiert ist, solltest du disklabel nicht
mehr allzuoft benutzen müssen. Aber du kannst es gebrauchen, wenn du z.B.
Festplatten hinzufügen willst, welche entfernen willst oder auch einfach
umstrukturieren möchtest. Eines der ersten Dinge, die du dann machst, ist,
dir den momentanen gültigen Disklabel anzusehen. Und das geht so:

<pre>
# <b>disklabel wd0</b> &gt;----- Oder was du dir auch immer für eine Platte ansehen willst

# using MBR partition 3: type A6 off 64 (0x40) size 16777152 (0xffffc0)
# /dev/rwd0c:
type: ESDI
disk:
label: TOSHIBA MK2720FC
flags:
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 2633
total sectors: 2654064
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # milliseconds
track-to-track seek: 0  # milliseconds
drivedata: 0 

16 partitions:
#        size   offset    fstype   [fsize bsize   cpg]
  a:  2071440    65583    4.2BSD     1024  8192    16   # (Cyl.   65*- 2120)
  b:    65520       63      swap                        # (Cyl.    0*- 65)
  c:  2654064        0    unused        0     0         # (Cyl.    0 - 2632)
  j:   512001  2137023    4.2BSD     1024  8192    16   # (Cyl. 2120*- 2627*)
</pre>

<p>
Der obige Befehl zeigt dir einfach den existierenden Disklabel und stellt
sicher, dass du nichts kaputt machst oder durcheinanderbringst. (Was wir
alle von Zeit zu Zeit mal brauchen.) Um aber Veränderungen durchzuführen,
musst du die -E Option wie folgt mit angeben:

<pre>
# <b>disklabel -E wd0</b>
</pre>

<p>
Das wird dich an einen Prompt bringen, und zwar den selben, den du
schon während der OpenBSD Installation benutzt hast. Das wahrscheinlich
wichtigste Kommando an diesem Prompt ist ,?'. Das erzeugt nämlich eine
Liste mit möglichen Optionen für Disklabel. Mit Hilfe von ,M' kannst du
dir sogar die gesamte 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
Manual Seite ansehen. Von diesem Prompt aus wirst du dein gesamtes
Hinzufügen, Löschen und Ändern der Partitionen vornehmen. Zusätzliche
Informationen gibt es in der 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
Manual Seite.

<a name="fdisk"></a>
<h2>14.2 - Benutzung von OpenBSDs fdisk(8)</h2>
Um sicher zu sein, lese zuerst die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
Manual Seite.

<p>
Fdisk ist ein Programm, das bei der Wartung deiner Partitionen
helfen soll. Dieses Programm wird auch bei der Installation benutzt, um
deine OpenBSD Partition einzurichten (diese Partition kann <u>mehrere</u>
Labels enthalten, jedes mit Dateisystemen/Swap/etc.). Es kann den Platz auf
deiner Festplatte aufteilen und eine Partition als aktiv markieren. Dieses
Programm wird für gewöhnlich im ,single user' Modus benutzt (boot -s).
Fdisk setzt auch den MBR auf deinen verschiedenen Festplatten.

<p>
Für Installationszwecke braucht man meistens nur <b>EINE</b> OpenBSD
Partition und benutzt dann disklabel, um Swap und Dateisysteme darauf zu
installieren.

<p>
Um dir nur deine Partitionstabelle mit fdisk anzugucken, verwende:

<pre># <b>fdisk fd0</b><br>
</pre>

<p>
Was dann eine ähnliche Ausgabe wie diese hier erzeugt:

<pre>
Disk: sd0       geometry: 553/255/63 [8883945 Sectors]
Offset: 0       Signature: 0xAA55
         Starting       Ending       LBA Info:
 #: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
*0: A6    3   0  1 -  552 254 63 [       48195:     8835750 ] OpenBSD
 1: 12    0   1  1 -    2 254 63 [          63:       48132 ] Compaq Diag.
 2: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
 3: 00    0   0  0 -    0   0  0 [           0:           0 ] unused
</pre>

<p>
In diesem Beispiel betrachten wir die Ausgabe des ersten SCSI Laufwerks.
Wir können die OpenBSD Partition (A6) und ihre Größe sehen. Der * sagt uns,
dass die OpenBSD Partition eine bootfähige Partition ist.

<p>
Im vorherigen Beispiel haben wir uns die Informationen nur angesehen. Was aber,
wenn wir unsere Partitionstabelle verändern wollen? Nun, dazu müssen wir
zunächst das <b>-e</b> Flag benutzen. Das bringt uns dann zu einer
Kommandozeile, die uns mit fdisk interagieren lässt.

<pre>
# <b>fdisk -e wd0</b>
Enter 'help' for information
fdisk: 1&gt; <b>help</b>
        help            Command help list
        manual          Show entire OpenBSD man page for fdisk
        reinit          Re-initialize loaded MBR (to defaults)
        setpid          Set the identifier of a given table entry
        disk            Edit current drive stats
        edit            Edit given table entry
        flag            Flag given table entry as bootable
        update          Update machine code in loaded MBR
        select          Select extended partition table entry MBR
        print           Print loaded MBR partition table
        write           Write loaded MBR to disk
        exit            Exit edit of current MBR, without saving changes
        quit            Quit edit of current MBR, saving current changes
        abort           Abort program without saving current changes
fdisk: 1&gt;
</pre>

<p> 
Es ist absolut sicher, in fdisk ein wenig rumzuwandern und zu probieren,
solange man <b>N</b> auf die Frage antwortet, ob die Änderungen
abgespeichert werden sollen und *NICHT* das <b>write</b> Kommando benutzt.

<p>Hier ist eine Übersicht über die Kommandos, die man nach der Eingabe des
<b>-e</b> Flags benutzen kann.

<ul>
<li><b>help</b>  Zeige eine Liste der Kommandos an, die fdisk im
interaktiven ,edit' Modus versteht.
<li><b>reinit</b>  Initialisiere die momentane im Speicher befindliche
Kopie des Bootblocks.
<li><b>disk</b>  Zeige die momentane Plattengeometrie an, die fdisk
herausgefunden hat. Du bekommst eine Möglichkeit sie zu ändern, wenn du willst.
<li><b>setpid</b> Ändere eine Partitionsidentifizierung des angegebenen
Partitionstabellen Eintrages. Dieses Kommando ist insbesondere nützlich,
um eine existierende Partition OpenBSD wieder zugänglich zu machen.
<li><b>edit</b>  Ändere eine ausgewählte Plattengeometrie in der Kopie
des momentanen Bootblocks.  Das geschieht entweder im BIOS ,geometry' Modus
oder in Sektor-Offsets und Größen.
<li><b>flag</b>  Den jetzigen Partitionstabelleneintrag bootfähig machen.
Nur ein Eintrag zur Zeit kann bootbar sein. Wenn du von einer erweiterten
Partition booten willst, musst du auch den entsprechenden Eintrag als
bootfähig markieren.
<li><b>update</b>  Bringe den Maschinencode in der Speicherkopie des
momentanen Bootblocks auf aktuellen Stand.
<li><b>select</b>  Wähle und lade den Bootblock, auf den der Eintrag der
erweiterten Partitionstabelle im momentanen Bootblock zeigt.
<li><b>print</b>  Gebe die momentan im RAM befindlichen und gewählte
Kopie des Bootblocks und seinen MBR auf dem Bildschirm aus.
<li><b>write</b>  Schreibe die RAM-Version des Bootblocks auf
die Platte. Du wirst um eine Bestätigung gebeten.
<li><b>exit</b>  Verlasse den momentanen Level von fdisk, kehre entweder
zur vorher gewählten Kopie eines Bootblocks im RAM zurück oder verlasse
das Programm, wenn es keinen gibt.
<li><b>quit</b>  Verlasse den momentanen Level von fdisk, kehre entweder
zur vorher gewählten Kopie eines Bootblocks im RAM zurück oder verlasse
das Programm, wenn es keinen gibt. Anders als exit schreibt diese Variante
den modifizierten Block auf die Platte.
<li><b>abort</b>  Verlasse das Programm ohne Änderungen zu speichern.
</ul>

<a name="NewDisk"></a>
<h2>14.3 - Hinzufügen von weiteren Festplatten unter OpenBSD</h2>

<p>
Nun, nachdem du deine Festplatte <b>SAUBER</b> eingebaut hast, musst du 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
(<i> nur i386 </i>) und auch
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
verwenden, um deine Festplatte unter OpenBSD benutzen zu können. 

<p>
Die i386 Leute starten mit fdisk. Andere Architekturen können das einfach
ignorieren. In dem Beispiel weiter unten werden wir dem System ein drittes
SCSI Laufwerk hinzufügen.
<pre>
# <b>fdisk -i sd2</b>
</pre>
Das wird die "echte" Partitionstabelle der Festplatte für eine 
ausschließliche Benutzung von OpenBSD initialisieren.
Als nächstes musst du ein Disklabel dafür erzeugen.
Das wird wohl etwas verwirrend wirken.
<pre>
# <b>disklabel -e sd2</b>

<i>(der Bildschirm wird leer, dein $EDITOR erscheint)</i>
type: SCSI
<i>...bla...</i>
sectors/track: 63
total sectors: 6185088
<i>...bla...</i>
16 partitions:
#        size   offset    fstype   [fsize bsize   cpg]
  c:  6185088        0    unused        0     0         # (Cyl.    0 - 6135)
  d:  1405080       63    4.2BSD     1024  8192    16   # (Cyl.    0*- 1393*)
  e:  4779945  1405143    4.2BSD     1024  8192    16   # (Cyl. 1393*- 6135)
</pre>

Zunächst einmal ignoriere die ,c' Partition, sie ist immer da und
Programme wie disklabel benötigen sie, um zu funktionieren!
,fstype' für OpenBSD ist 4.2BSD. ,total sectors' ist die gesamte
Größe der Festplatte. Nehmen wir an, es handelt sich um eine 3 Gigabyte
Festplatte. Drei Gigabytes in der Sprache der Festplattenhersteller sind
3000 Megabytes.  Dividiere also 6185088/3000 (benutze
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bc&amp;sektion=1">bc(1))</a>.
Du erhältst 2061. Um jetzt Partitionsgrößen für a, d, e, f, g, ... zu
erstellen, rechne einfach X*2061, um X Megabytes Platz auf dieser Partition
zu erhalten. Der Offset für deine erste Partition sollte derselbe sein, wie
unter "sectors/track" vorher in disklabels Ausgabe angegeben. Bei uns ist es
63. Der Offset für jede Partition ist hinterher eine Kombination aus der
Größe und dem Offset jeder anderen Partition (mit Ausnahme der C Partition,
da sie keine Rolle in dieser Gleichung spielt).

<p>
Wenn du aber nur eine Partition auf deiner Festplatte brauchst, zum
Beispiel, wenn du das ganze Ding nur zum Ablegen von Webseiten oder einem
Heimatverzeichnis oder etwas anderem nutzen willst, nimm einfach die gesamte
Größe der Platte und ziehe die Sektoren pro Spur davon ab.
6185088-63 = 6185025.  Deine Partition ist

<pre>
    d:  6185025       63    4.2BSD     1024  8192    16 
</pre>

<b>Wenn dir das alles unnötig komplex erscheint, kannst du disklabel -E
benutzten, um den selben Patitionierungsmodus zu erhalten, den du auf
deiner Installationsdisk hattest!</b>
Dort kannst du "96M" benutzen, um "96 Megabytes" anzugeben.  (Oder, wenn
deine Festplatte groß genug ist, 96G für 96 Gigabytes!) Unglücklicherweise
benutzt der -E Modus die BIOS Plattengeometrie und nicht die reale, und
oft sind die beiden nicht deckungsgleich. Um dieses Problem zu umgehen,
tippe ,g d' für ,geometry disk'. (Andere Möglichkeiten sind ,g b' für
,Geometry BIOS' und ,g u' für ,geometry user' oder einfach das, was das
Label gesagt hat, bevor disklabel irgendwelche Änderungen gemacht hat.)

<p>
Das war eine Menge.  Aber du bist noch nicht fertig.  
Zuletzt musst du noch das Dateisystem auf der Festplatte mittels
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&amp;sektion=8">newfs(8)</a>
erzeugen.

<pre>
# <b>newfs sd2a </b>
</pre>

<p>
Oder wie auch immer deine Festplatte nach dem OpenBSD
Plattennummerierungs-Schema heißen mag. (Siehe einfach in der Ausgabe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)</a>
nach, um zu sehen, wie die Platte von OpenBSD benannt wurde.)

<p>
Nun überleg dir, wohin du deine gerade neu geschaffene Partition mounten
willst. Sagen wir einfach mal /u.  Daher erzeuge zunächst einmal /u. Dann
mounte sie.

<pre>
# <b>mount /dev/sd2a /u</b>
</pre>

<p>
Zuletzt musst du sie noch zu
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a>
hinzufügen.

<pre>/dev/sd2a /u ffs rw 1 1</pre>

<p>
Was aber, wenn du ein existierendes Verzeichnis, wie zum Beispiel /usr/local
auslagern willst? Mounte die neue Platte unter /mnt und benutze <tt>cpio
-pdum</tt>, um /usr/local in das /mnt Verzeichnis zu kopieren. Passe die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a>
Datei so an, dass die /usr/local Partition nun /dev/wd1a ist
(deine frisch formatierte Partition). Beispiel:

<pre>
<b>/dev/sd2a /usr/local ffs rw 1 1</b>
</pre>

<p>
Reboote in den ,single user' Modus mit <b>boot -s</b>, verschiebe
das existierende /usr/local nach /usr/local-backup (oder lösche es gleich,
wenn du mutig bist) und erzeuge ein leeres Verzeichnis /usr/local.
Dann starte das System neu und voila, die Dateien sind da!


<a name="SwapFile"></a>
<h2>14.4 - Wie man in eine Datei swappt</h2>

<p>
(Hinweis: wenn du in eine Datei swappen willst, weil du immer 
&quot;virtual memory exhausted&quot; Fehler bekommst, solltest du lieber
versuchen, deine ,per-process limits' zu erhöhen und zwar mit
cshs <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=unlimit&amp;sektion=1">unlimit(1)</a>
oder auch mit
shs <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ulimit&amp;sektion=1">ulimit(1)</a>.)

<p>
In eine Datei zu swappen benötigt keinen angepassten Kernel, obwohl das
weiterhin gemacht werden könnte, zeigt dir diese FAQ, wie man den
Swapbereich auf beide Arten hinzufügen kann.

<h3>In eine Datei swappen. </h3>

<p>
In eine Datei zu swappen ist der einfachste und schnellste Weg, um 
zusätzlichen Swap zu bekommen. Die Datei darf aber nicht auf einem
Dateisystem mit SoftUpdates liegen (was ja standardmäßig deaktiviert ist).
Für den Anfang findest du erstmal heraus, wieviel Swap du momentan hast
und wieviel du davon benutzt, und das geht einfach mit dem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=swapctl&amp;sektion=8">swapctl(8)</a>
Werkzeug. Zum Beispiel mit diesem Kommando:

<pre>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
</pre>

<p>
Das zeigt alle Geräte, die momentan für das swappen benutzt werden,
und ihre momentane Statistik an. Im obigen Beispiel gibt es nur ein Gerät
namens &quot;swap_device&quot;. Das ist der vordefinierte Bereich auf der
Platte, der für das Swappen benutzt wird. (Wird im Übrigen als Partition
,b' bei Disklabels angezeigt) Wie du auch sehen kannst, wird das Gerät
zur Zeit nicht sonderlich belastet oder vielmehr benutzt. Aber für den Zweck
dieses Dokumentes tun wir einfach so, als wenn noch weitere 32MB benötigt
werden würden.

<p>
Der erste Schritt, um eine Datei als Swapbereich zu nutzen, ist, die
Datei zu erzeugen. Am besten macht man das mit Hilfe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&amp;sektion=1">dd(1)</a>.
Hier ist ein Beispiel, das die 32M große Datei <i>/var/swap</i> erzeugt.

<pre>
$ <b>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</b>
32768+0 records in
32768+0 records out
33554432 bytes transferred in 20 secs (1677721 bytes/sec)
</pre>

<p>
Nachdem das erledigt ist, können wir jetzt das Swappen auf dieses Device
richten. Benutze einfach das folgende Kommando, um das Swappen auf
dieses Device zu lenken

<pre>
$ <b>sudo chmod 600 /var/swap</b>
$ <b>sudo swapctl -a /var/swap</b>
</pre>

<p>
Jetzt müssen wir noch prüfen, ob sie auch korrekt zu unserer Liste der
Swap-Devices hinzugefügt wurde.

<pre>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
/var/swap        65536        0    65536     0%    0
Total           131056        8   131048     0%
</pre>

<p>
Jetzt, da die Datei erzeugt wurde und in sie hinein geswappt wird, musst
du noch eine Zeile in deine <i>/etc/fstab</i> Datei hineinschreiben, so
dass die Datei beim nächsten Booten auch benutzt wird. Wenn diese Zeile
nicht hinzugefügt wird, wird dieses Swap-Device eben nicht konfiguriert.

<pre>
$ <b>cat /etc/fstab</b>
/dev/wd0a / ffs rw 1 1
/var/swap /var/swap swap sw 0 0
</pre>

<h3>Swappen über ein vnode Device</h3>

<p>
Dies ist eine dauerhaftere Lösung, um mehr Swapbereich zu erhalten.
Um in eine Datei zu swappen, erzeuge zunächst einen Kernel mit vnd0c als
Swap. Wenn du wd0a als root Dateisystem hast, und wd0b als bisherigen Swap, 
benutze diese Zeile in deiner Kernel Konfigurationsdatei (wenn du dir
nicht sicher bist, siehe dir das Kapitel "Einen neuen Kernel kompilieren"
in dieser FAQ an): 

<pre>
config          bsd     root on wd0a swap on wd0b and vnd0c dumps on wd0b
</pre>

<p>
Nachdem das erledigt ist, muss die Datei erzeugt werden, in die geswappt
werden soll. Du solltest dies mit dem selben Kommando wie in den vorherigen
Beispielen machen.

<pre>
$ <b>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</b>
32768+0 records in
32768+0 records out
33554432 bytes transferred in 20 secs (1677721 bytes/sec)
</pre>

<p>
Da deine Datei jetzt an ihrem Platz ist, musst du die Datei in deine
<i>/etc/fstab</i> eintragen. Hier ist eine Beispielzeile, mit der man
dieses Device beim Booten als Swap benutzt.

<pre>
$ <b>cat /etc/fstab</b>
/dev/wd0a / ffs rw 1 1
/dev/vnd0c none swap sw 0 0 
</pre>

<p>
An diesem Punkt muss dein Computer neu gebootet werden, so dass die
Änderungen am Kernel Effekt haben. Nachdem das passiert ist, ist es an
der Zeit, das Gerät als Swap zu konfigurieren. Dazu wirst du
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&amp;sektion=8">vnconfig(8)</a>
benutzen.

<pre>
$ <b>sudo vnconfig -c -v vnd0 /var/swap</b>
vnd0: 33554432 bytes on /var/swap
</pre>

<p>
Als letzten Schritt musst du den Swap auf diesem Gerät noch einschalten.
Wir machen das genau wie in dem Beispiel oben mit swapctl(8). Und zuletzt
prüfen wir wieder, ob es auch korrekt in unsere Liste der Swap Devices
eingetragen wurde. 

<pre>
$ <b>sudo swapctl -a /dev/vnd0c</b>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
/dev/vnd0c       65536        0    65536     0%    0
Total           131056        8   131048     0%
</pre>



<a name="SoftUpdates"></a>
<h2>14.5 - Soft Updates</h2>


<p>
Soft Updates basieren auf einer Idee, die von
<a href="http://www.ece.cmu.edu/~ganger/papers/CSE-TR-254-95/">Greg Ganger
und Yale Patt</a> vorgeschlagen wurde, und wurden für FreeBSD von
<a href="http://www.mckusick.com/softdep/">Kirk McKusick</a> entwickelt.
SoftUpdates erzwingen eine gewisse Reihenfolge der Buffer Cache Operationen,
was die Anforderungen für das Entfernen des FFS Codes ermöglicht, der für
das synchrone Schreiben von Verzeichniseinträgen zuständig ist. Daher
konnte ein großer Geschwindigkeitsanwachs in der Leistung der Schreibzugriffe
auf Platten festgestellt werden.

<p>
Um Softupdates aktivieren zu können, muss in deinen Kernel folgende Option

<p>
<b>option FFS_SOFTUPDATES</b>
<p>
einkompiliert sein, dies ist bereits in GENERIC eingetragen.

<p>
Die Aktivierung von Soft Updates muss mit einer mount-zeit Option
ausgeführt werden. Wenn eine Partition mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>
gemountet wird, kannst du angeben, dass du Soft Updates auf dieser Partition
aktivieren möchtest. Unten ist ein Beispiel
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a></i>
Eintrag, der eine Partition <i>sd0a</i> hat, die wir mit Soft Updates
gemountet haben möchten.

<pre>
/dev/sd0a / ffs rw,softdep 1 1
</pre>

<p>
Hinweis für Sparc Anwender: Aktiviere Soft Updates nicht auf sun4 oder
sun4c Maschinen. Diese Architekturen unterstützen nur eine sehr begrenzte
Menge an Kernelspeicher und können diese Funktion nicht verwenden. Trotzdem
sind sun4m Maschinen in Ordnung.

<a name="Boot386"></a>
<h2>14.6 - Wie bootet OpenBSD/i386?</h2>
Der Bootprozess für OpenBSD/i386 ist nicht einfach und verstehen, wie es
funktioniert, kann brauchbar sein, um ein Problem zu lösen, wenn Dinge
nicht laufen. Es existieren vier Schlüsselmomente im Bootprozess:
<ol>
<li><b><i>Master Boot Record (MBR):</i></b> Der Master Boot Record ist der
erste physikalische Sektor (512 Bytes) auf der Platte.
Er beinhaltet die primäre Partitionstabelle und ein kleines Programm, um
den Partition Boot Record (PBR) zu laden.
Bedenke, dass in einigen Umgebungen der Begriff "MBR" verwendet wird, um
nur auf den Code Teil dieses ersten Blockes auf der Platte zu verweisen,
statt auf den gesamten ersten Block (einschließlich der Partitionstabelle).
Es ist äußerst wichtig, die Bedeutung von "initialize the MBR" zu verstehen
-- in der Terminologie von OpenBSD würde es den gesamten MBR Sektor neu
schreiben, nicht nur den Code, so wie es auf anderen Systemen der Fall
sein könnte. Du wirst das nur selten machen wollen.
Verwende stattdessen fdisk(8)s "-u" Kommandozeilen Option
("<tt>fdisk -u wd0</tt>").

<p>
Während OpenBSD einen MBR beinhaltet, wirst du nicht gezwungen, ihn zu
verwenden, da so gut wie jeder MBR OpenBSD booten kann.
Der MBR wird von dem fdisk(8) Programm verändert, welches verwendet wird um
die Partitionstabelle zu editieren und ebenfalls um den MBR Code auf die
Platte zu installieren.

<p>
OpenBSDs MBR kündigt sich selbst mit der Meldung an:
<pre>
    Using drive 0, partition 3.
</pre>
die die Platte und Partition anzeigt, von der er den PBR laden wird.
Zusätzlich zu dem Offensichtlichen, zeigt sie ebenfalls einen angehängten
Punkt ("."), welcher darauf deutet, dass diese Maschine in der Lage ist,
LBA Übersetzung zum Booten zu verwenden. Wenn die Maschine nicht in der
Lage ist, LBA Übersetzung zu verwenden, wäre der obige Punkt mit einem
Semikolon (";") ausgewechselt worden, das auf CHS Übersetzung deutet:
<pre>
    Using Drive 0, Partition 3;
</pre>
Bedenke, dass der angehängte Punkt oder das angehängte Semikolon als ein
Indikator für den "neuen" OpenBSD MBR angesehen werden kann, der mit
OpenBSD 3.5 eingeführt wurde.

<li><b><i>Partition Boot Record (PBR):</i></b>
Der Partition Boot Record, auch der PBR oder
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8&amp;arch=i386">biosboot(8)</a>
(benannt nach dem Namen der Datei, der den Code beinhaltet) genannt wird,
ist der erste physikalische Sektor der OpenBSD Partition auf der Platte.
Der PBR ist der "first-stage Bootloader" für OpenBSD.
Er wird vom MBR Code geladen und hat die Aufgabe, den OpenBSD ,second-stage'
Bootloader
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">boot(8)</a>
zu laden.
Wie der MBR ist auch der PBR eine sehr kleine Sektion von Code und Daten,
insgesamt nur 512 Bytes.
Das ist nicht genug, um eine vollständig Dateisystem-bewusste
Applikation zu laden, so dass, statt den PBR <tt>/boot</tt> auf der
Platte ausfindig machen zu lassen, die BIOS-verfügbare Stelle von
<tt>/boot</tt> physikalisch in den PBR während der Installation
eingetragen wird.

<p>
Der PBR wird von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=installboot&amp;sektion=8&amp;arch=i386">installboot</a>
installiert, das
<a href="faq14.html#InstBoot">später in diesem Dokument</a> genauer
beschrieben wird.
Der PBR kündigt sich selbst mit der Meldung an:
<pre>
    Loading...
</pre>
die einen Punkt für jeden Dateisystemblock anzeigt, den er versucht
auszulesen. Ebenfalls zeigt der PBR an, ob er LBA oder CHS zum Laden
verwendet, wenn er CHS Übersetzung verwendet, zeigt er eine Nachricht
mit einem Semikolon an:
<pre>
    Loading;...
</pre>
Das ältere (vor v3.5) biosboot(8) zeigte die Nachricht "<tt>reading
boot...</tt>" an.

<li><b><i>Second Stage Bootloader, <tt>/boot</tt>:</i></b> <tt>/boot</tt> wird
vom PBR geladen und hat die Aufgabe, auf das OpenBSD Dateisystem durch das
BIOS der Maschine zuzugreifen und den aktuellen Kernel ausfindig zu machen
und zu laden. boot(8) übergibt ebenfalls verschiedene Optionen und
Informationen an den Kernel.
<p>
boot(8) ist ein interaktives Programm. Nachdem es geladen ist, versucht es,
<tt>/etc/boot.conf</tt> ausfindig zu machen und zu laden, wenn sie existiert
(was auf einer standardmäßigen Installation nicht der Fall sein muss) und
verarbeitet sämtliche Kommandos in ihr. Wenn es durch
<tt>/etc/boot.conf</tt> nicht anders angeordnet wurde, gibt es dem Benutzer
einen Prompt aus:

<pre>
     probing: pc0 com0 com1 apm mem[636k 190M a20=on]
     disk: fd0 hd0+
     >> OpenBSD/i386 BOOT 2.06
     boot>
</pre>
Es gibt dem Benutzer (standardmäßig) fünf Sekunden lang die Möglichkeit,
andere Aufgaben auszuführen, aber wenn keine vor dem Ablauf der Zeit
eingegeben wurde, startet es sein normales Verhalten: den Kernel, <tt>bsd</tt>,
von der root Partition der ersten Festplatte laden.
Der second-stage Bootloader untersucht (examines) deine Systemhardware durch
das BIOS (da der OpenBSD Kernel noch nicht geladen ist).
Oben kannst du ein paar Dinge sehen, die er gesucht und gefunden hat:
<ul>
<li><b>pc0</b> - Die Standard-Tastatur und Bildschirmausgabe eines i386 Systems.
<li><b>com0, com1</b> - Zwei serielle Schnittstellen
<li><b>apm</b> - Advanced Power Management BIOS Funktionen
<li><b>636k 190M</b> - Die Menge vom herkömmlichen (unterhalb von 1M) und
erweiterten (überhalb von 1M) Speicher, den er gefunden hat
<li><b>fd0 hd0+</b> - Die BIOS Laufwerke, die er gefunden hat, in diesem
Fall ein Floppy und ein Festplatten Laufwerk.
</ul>

Das ,+' Zeichen nach "hd0" zeigt an, dass das BIOS <tt>/boot</tt> mitgeteilt
hat, dass diese Festplatte über LBA angesprochen werden kann.
Wenn eine erstmalige Installation ausgeführt wird, siehst du ab und zu einen
,*' nach einer Festplatte -- dies deutet auf eine Platte hin, die so scheint,
als wenn sie kein OpenBSD Disklabel beinhaltet.

<li><b><i>Kernel: <tt>/bsd</tt></i>:</b> Dies ist das Ziel des Bootprozesses,
den OpenBSD Kernel in den RAM zu laden und sauber auszuführen.
Wenn der Kernel einmal geladen wurde, kann OpenBSD direkt auf die Hardware
zugreifen, nicht mehr durch das BIOS.

</ol>

So, der Anfang vom Start des Bootprozesses könnte wie folgt aussehen:
<blockquote><pre>
Using drive 0, partition 3.                      <b><i>&lt;- MBR</i></b>
Loading....                                      <b><i>&lt;- PBR</i></b>
probing: pc0 com0 com1 apm mem[636k 190M a20=on] <b><i>&lt;- /boot</i></b>
disk: fd0 hd0+
>> OpenBSD/i386 BOOT 2.06
boot>
booting hd0a:/bsd 4464500+838332 [58+204240+181750]=0x56cfd0
entry point at 0x100120

[ using 386464 bytes of bsd ELF symbol table ]
Copyright (c) 1982, 1986, 1989, 1991, 1993       <b><i>&lt;- Kernel</i></b>
        The Regents of the University of California.  All rights reserved.
Copyright (c) 1995-2003 OpenBSD.  All rights reserved.  http://www.OpenBSD.org

OpenBSD 3.7 (GENERIC) #50: Sun Mar 20 00:01:57 MST 2005
   ...
</pre></blockquote>


<h3>Was kann fehlschlagen</h3>
<ul>
<li><b>Schlechter/ungültiger/inkompatibler MBR:</b>
Normalerweise hat eine gebrauchte Festplatte irgendeinen MBR Code installiert,
aber wenn die Platte neu ist oder von einer anderen Plattform übernommen wurde
UND du nicht mit "Yes" auf die "Use entire disk" Frage vom
<a href="faq4.html#Disks">Installationsprozess</a> geantwortet hast, kann es
sein, dass du mit einer Platte ohne gültigem MBR da stehst und daher nicht
in der Lage sein wirst zu Booten, obwohl sie eine gültige Partitionstabelle hat.

<p>
Du kannst den OpenBSD MBR auf deine Festplatte unter Verwendung vom fdisk
Programm installieren. Boote dein Installationsmedium, wähle "Shell" aus, um
auf den Kommando-Prompt zu gelangen:

<pre>
    # <b>fdisk -u wd0</b>
</pre>

Du kannst auch einen spezifischen MBR auf deine Platte mit fdisk installieren:
<pre>
    # <b>fdisk -u -f /usr/mdec/mbr wd0 </b>
</pre>

das die Datei <tt>/usr/mdec/mbr</tt> als deinen System-MBR installieren wird.
Diese bestimmte Datei einer standardmäßigen OpenBSD Installation ist ebenfalls
der standardmäßige MBR, der in fdisk integriert wurde, aber jeder andere MBR
könnte hier angegeben werden.

<li><b>Ungültige <tt>/boot</tt> Ortsangabe im PBR installiert:</b>
Wenn installboot(8) den Partition Boot Record installiert, schreibt er die
Blocknummer und den Offset von <tt>/boot</tt>s Inode in den PBR.
Daher wird das Löschen oder Ersetzen von <tt>/boot</tt>, ohne
<a href="faq14.html#InstBoot">installboot(8)</a> erneut auszuführen, dein
System in eine Situation versetzen, in der es nicht mehr booten kann, da der
PBR laden wird, auf was auch immer die Inode zeigt, die angegeben wurde,
was vermutlich nicht mehr der erhoffte second-stage Bootloader sein wird!

Seit <tt>/boot</tt> unter Verwendung von BIOS Aufrufen ausgelesen wird, waren
ältere Versionen vom PBR sehr sensibel auf BIOS Plattenübersetzungen.
Wenn du die Plattengeometrie (z.B., wenn du die Platte aus einem Computer
genommen hast, der CHS Übersetzung verwendet hat, und es in einen steckst,
der LBA Übersetzung verwendet oder sogar die Übersetzungsoption im BIOS
geändert hast) geändert hast, wird es <i>für das BIOS so wirken</i>, als
wenn sie an einem anderen Ort liegen würde (es muss auf einen anderen
nummerischen Block zugegriffen werden, um die gleichen Daten von der Platte
zu erhalten), so dass du installboot(8) erneut ausführen musst, bevor das
System neugestartet werden kann.
Der neue (von OpenBSD 3.5 und später) PBR ist sehr viel tolleranter im Bezug
auf Übersetzungsänderungen.
</ul>

Da der PBR sehr klein ist, ist die Anzahl von Fehlermeldungen sehr begrenzt
und recht kryptisch. Typische Nachrichten sind:

<ul>
<li><b>ERR R</b> -- Das BIOS gab einen Fehler zurück, als es versucht hat,
einen Block von der Platte zu lesen.
Es bedeutet meistens genau das, was es aussagt: von deiner Platte konnte
nicht gelesen werden.
<li><b>ERR M</b> -- Eine ungültige
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=magic&amp;sektion=5">magic(5)</a>
Nummer wurde aus dem second-stage Bootloader Header gelesen.
Dies bedeutet normalerweise, dass, was auch immer eingelesen wurde, NICHT
<tt>/boot</tt> war, was darauf hinweist, dass installboot(8) nicht korrekt
ausgeführt wurde, die /boot Datei geändert wurde oder du die Fähigkeit deines
BIOS erschöpft hast, um von einer <a href="#LargeDrive">großen Platte</a> zu
lesen.

</ul>
Andere Fehlermeldungen werden in der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8">biosboot(8)
Manual Seite</a> ausführlich besprochen.

Für weitere Informationen über den i386 Bootprozess, siehe
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot_i386&amp;sektion=8&amp;arch=i386">boot_i386(8)</a>
<li><a href="http://www.ata-atapi.com/hiw.htm">http://www.ata-atapi.com/hiw.htm</a>
  Hale Landis' "How it Works" documents.
</ul>

<a name="LargeDrive"></a>
<h2>14.7 - Welche Probleme treten bei großen Festplatten mit OpenBSD auf?</h2>

<p>
OpenBSD unterstützt ein individuelles Dateisystem von bis zu
2<sup>31</sup>-1, oder 2,147,483,647, Sektoren und da jeder Sektor 512 Bytes
groß ist, ist das ein kleiner Betrag unterhalb von 1T.

<p>
Natürlich sind die Fähigkeit eines Dateisystems und die Fähigkeit einer
bestimmten Hardware zwei unterschiedliche Dinge.
Eine neue 250G IDE Festplatte wird nicht mit älteren (vor >137G Standard)
Interfaces funktionieren und einige sehr alte SCSI Adapter sind bekannt dafür,
dass sie Probleme mit moderneren Laufwerken haben und einige alte BIOSe
werden hängen, wenn sie einer modern-bestückten Festplatte begegnen.
Du musst die Fähigkeiten deiner Hardware natürlich respektieren.

<h3>Partitionsgröße und Lokalitätsbegrenzungen</h3>
Leider ist die volle Funktionalität des OS nicht verfügbar, bis NACHDEM das
OS in den Speicher geladen wurde.
Der Bootprozess verwendet (und ist daher auch darauf beschränkt) die Boot ROM
des Systems.

<p>
Aus diesem Grund muss die /bsd Datei (der Kernel) innerhalb des vom boot ROM
adressierbarem Bereich liegen.
Das bedeutet für einige ältere i386 Systeme, dass die root Partition
vollständig innerhalb der ersten 504M liegen muss, aber neuere Computer können
diese Grenze bei 2G, 8G, 32G, 128G oder mehr haben.
Es ist ebenfalls sinnvoll zu erwähnen, dass viele relativ neue Computer, die
Laufwerke mit mehr als 128G Speicher unterstützen tatsächlich eine BIOS
Begrenzung für die ersten 128G für das Booten haben.
Du kannst diese Systeme mit großen Laufwerken betreiben, aber deine root
Partition muss innerhalb der ersten 128G liegen.

<p>
Bedenke, dass es möglich ist, ein 40G Laufwerk in einen alten 486er einzubauen
und auf diesem OpenBSD mit einer großen Partition zu installieren und zu
denken, dass du erfolgreich die vorherige Regel gebrochen hast. Trotzdem
kann es dich auf einem höchst unangenehmen Weg verfolgen:

<ul>
 <li>Du installiert eine 40G / Partition. Es funktioniert, da das Basis OS
und alle seine Dateien (einschließlich /bsd) innerhalb der ersten 504M liegen.
 <li>Du benutzt das System und endest mit mehr als 504M Dateien auf ihm.
 <li>Du aktualisiert und erstellst deinen eigenen Kernel, was auch immer, und
   kopierst deinen neuen /bsd über den alten.
 <li>Du startest neu.
 <li>Du bekommst eine Meldung wie "ERR M" oder andere Probleme während dem
   Booten.
</ul>
<p>
Warum? Weil, wenn du eine neue /bsd Datei "über" die alte kopierst,
überschreibt sie nicht die alte, ihr wird einem neuen Ort auf der Platte
zugewiesen, möglicherweise außerhalb der 504M Grenze, die das
BIOS hat. Der Bootloader wird nun nicht mehr in der Lage sein, die /bsd Datei
zu erhalten und das System hängt.

<p>
Um OpenBSD zum Booten zu bringen, müssen die Bootloader (biosboot(8) und
<tt>/boot</tt> im Falle von i386) und der Kernel (<tt>/bsd</tt>) innerhalb
des Bereiches sein, den die Boot ROM unterstützt und innerhalb ihrer
eigenen Fähigkeiten.
Um sicher zu gehen, ist die Regel einfach:

<p>
<b>Die gesamte root Partition muss innerhalb des BIOS (oder Boot ROM)
vom Computer adressierbaren Speicher liegen.</b>

<p>
Einige nicht-i386 Anwender denken, dass sie dies nicht betrifft, jedoch
haben die meisten Plattformen eine Art Begrenzung des ROMs bezüglich der
Plattengröße. Herauszufinden, wie groß diese Begrenzung denn nun tatsächlich
ist, kann schwer sein.

<p>
Dies ist ein weiterer guter Grund <a href="faq4.html#SpaceNeeded">deine
Festplatte zu partitionieren</a>, statt nur eine große Partition zu
verwenden.

<h3>fsck(8) Zeit- und Speicheranforderungen</h3>
Eine weitere Überlegung mit großen Dateisystemen ist die Zeit und der
Speicher, die benötigt werden, um as Dateisystem nach einem Crash oder
einer Stromunterbrechung einem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)</a>
zu unterziehen.
Man sollte nicht ein 120G Dateisystem auf ein System mit 32M RAM setzen und
erwarten, dass es fsck(1) erfolgreich nach einem Crash ausführt.
Eine grobe Richtlinie ist, dass das System zumindest 1M Arbeitsspeicher für
jedes 1G des Plattenspeichers haben sollte, um erfolgreich fsck gegen die
Platte auszuführen. Die benötigte Zeit, um fsck gegen ein Laufwerk auszuführen
kann ein Problem werden, sobald das Dateisystem an Größe gewinnt.

<a name="InstBoot"></a>
<h2>14.8 - Installieren von Bootblocks - i386 spezifisch</h2>

<p>
Ältere Versionen von MS-DOS können nur mit Festplattengeometrien von 1024
Zylindern oder weniger klarkommen.  Da nahezu alle modernen Betriebssysteme
mehr als 1024 Zylinder haben, haben die meisten SCSI BIOS Chips (die auf
den SCSI Controller Karten) und IDE BIOSe (was Teil des restlichen PC BIOS
ist) eine Option, manchmal auch als Grundeinstellung, die wirkliche Geometrie
in etwas zu übersetzen, mit dem MS-DOS umgehen kann. Wie dem auch sei, nicht
alle BIOS Chips "übersetzen" die Geometrie in der selben Weise. Wenn du dein
BIOS wechselst (entweder mit einem neuen Motherboard oder einem neuen SCSI
Controller), und das neue benutzt eine andere "übersetzte" Geometrie, wirst
du nicht in der Lage sein, den ,second stage' Bootloader zu laden (und kannst
daher den Kernel auch nicht laden) (Das liegt daran, dass der ,first stage'
Bootloader eine Liste der Blöcke enthält, die /boot in der "übersetzten"
Geometrie enthalten.) Falls du IDE Platten benutzt und du Änderungen an
deinen BIOS Einstellungen machst, kannst du seine Übersetzung ebenfalls
(ungewollt) ändern. (die meisten IDE BIOSe bieten 3 verschiedene
Übersetzungen.) Um deinen Bootblock zu reparieren, damit du normal booten
kannst, stecke einfach eine Bootfloppy in dein Diskettenlaufwerk und gib
am Bootprompt "b hd0a:/bsd" ein, um ihn zu zwingen, von der ersten
Festplatte zu booten (und nicht von der Floppy).
Deine Maschine sollte normal booten. Jetzt musst du die erste Stufe des
Bootloaders auf den neuen Stand bringen. (Und dazu passend den Bootblock
schreiben.) <br> Unser Beispiel geht davon aus, dass deine Bootdisk sd0
ist (bei IDE wäre es wd0, etc..):

<pre>
# <b>cd /usr/mdec; ./installboot /boot biosboot sd0</b>
</pre>

<p>
Wenn eine neuere Version von bootblocks benötigt wird, wirst du diese selber
kompilieren müssen. Und das geht so:

<pre>
# <b>cd /sys/arch/i386/stand/</b>
# <b>make &amp;&amp; make install </b>
# <b>cd /usr/mdec; cp ./boot /boot</b>
# <b>./installboot /boot biosboot sd0</b> (oder wie deine Festplatte auch immer heißen mag)
</pre>

<a name="Backup"></a>
<h2>14.9 - Sich auf das Schlimmste vorbereiten: Backups und Wiederherstellen
von Band.</h2>

<h3>Einführung:</h3>

<p>
Wenn du so etwas wie einen Produktionsserver laufen lassen willst, ist es
ratsam, irgendeine Form von Backup zu haben, für den Fall, dass eine deiner
Festplatten versagt oder einen Crash hat.

<p>
Diese Information wird dir helfen, die Standard-Werkzeuge
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>/<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>
zu benutzen, die als Teil von OpenBSD ausgeliefert werden. Ein
fortgeschritteneres Werkzeug ist
,<a href="http://www.amanda.org">Amanda</a>', das über
<a href="faq1.html#Ports">Ports</a> verfügbar ist und auch mehrere
Server auf ein Bandlaufwerk sichern kann. In den meisten Umgebungen sind
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>/<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>
aber ausreichend. Wenn du aber mehrere Maschinen sichern willst,
ist Amanda auf jeden Fall einen Blick wert.

<p>
Die Beispiele in diesem Dokument benutzen sowohl SCSI Festplatten als auch
Bänder. In einer Produktionsumgebung empfehlen wir SCSI und kein IDE wegen
der Art und Weise, wie IDE mit ,bad blocks' umgeht. Das heißt aber nicht,
dass diese Informationen nutzlos sind, wenn  du IDE benutzt,  sondern
einzig deine Gerätenamen werden sich leicht unterscheiden.  Zum Beispiel
wäre sd0a in einem IDE-basierten System wd0a.

<h3>Backup auf's Band bringen:</h3>

<p>
Um sein Backup auf ein Band zu bringen, muss man wissen, wo die
Dateisysteme gemountet sind. Das findet man mit dem 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)"></a>-Kommando
am Shell-Prompt heraus. Dabei sollte eine Ausgabe wie diese
herauskommen:

<pre>
# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0h on /usr type ffs (local)  
</pre>

<p>
In diesem Beispiel ist das root-Dateisystem (/) physikalisch auf sd0a, also
auf der SCSI-Festplatte 0, Partition a. Das /usr Dateisystem befindet sich
auf sd0h, also SCSI Festplatte 0, Partition h.

<p>
Ein weiteres Beispiel einer etwas größeren mount-Tabelle könnte so aussehen:

<pre>
# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0d on /var type ffs (local)
/dev/sd0e on /home type ffs (local)
/dev/sd0h on /usr type ffs (local)  
</pre>

<p>
In diesem fortgeschritteneren Beispiel befindet sich das root (/) Dateisystem
auf sd0a. Das /var Dateisystem befindet sich auf sd0d, das /home Dateisystem
auf sd0e und schlussendlich /usr auf sd0h.

<p>
Um ein Backup deiner Maschine zu machen, musst du dump mit jeder festgelegten
Partition füttern. Hier ist ein Beispiel der Kommandos, um die einfachere
mount-Tabelle weiter oben zu sichern:

<pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h</b>
# <b>mt -f /dev/rst0 rewind  </b>
</pre>

<p>
Für die etwas fortgeschrittenere mount-Tabelle würde man etwas wie das
hier benutzen:

<pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h  </b>
# <b>mt -f /dev/rst0 rewind  </b>
</pre>

<p>
Du kannst die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>
Manual Seite ansehen, um genau zu erfahren, was jede Kommandozeilenoption
macht. Hier ist eine kurze Übersicht über die Parameter, die oben verwendet
wurden:

<ul>
<li><b>0</b> - Führe einen Level 0 Dump durch, hole alles
<li><b>a</b> - Versuche automatisch die Bandlänge herauszufinden
<li><b>u</b> - Bringe die Datei /etc/dumpdates auf den neuesten Stand, um zu
reflektieren, wann die letzte Sicherung gemacht wurde
<li><b>f</b> - Welches Bandlaufwerk benutzt werden soll (/dev/nrst0 in diesem Fall)
</ul>

<p>
Zuletzt welche Partition gesichert werden soll (/dev/rsd0a, usw.)

<p>
Das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mt&amp;sektion=1">mt(1)</a>-Kommando
wird am Ende benutzt, um das Band zurückzuspulen. Sieh dir die
mt Manual Seite an, wenn du mehr Informationen haben willst (wie etwa eject).

<p>
Wenn du dir nicht sicher bist, wie dein Bandlaufwerk heißt, benutze einfach
dmesg, um das herauzufinden. Ein Beispieleintrag von dmesg für ein
Bandlaufwerk könnte so aussehen:
</p>

<pre>
st0 at scsibus0 targ 5 lun 0: &lt;ARCHIVE, Python 28388-XXX, 5.28&gt;
</pre>

<p>
Du hast vielleicht bemerkt, dass bei der Sicherung das Bandlaufwerk als
"<tt>nrst0</tt>" anstatt von "<tt>st0</tt>" bezeichnet wird, wie man es
in dmesg sieht. Wenn du auf <tt>st0</tt> statt <tt>nrst0</tt> zugreifst,
benutzt du das selbe physikalische Gerät, aber sagst ihm, es soll nicht
zurückspulen, nachdem der Job im ,raw'-Modus beendet wurde. Um mehrere
Dateien auf ein einziges Band zu sichern, stelle sicher, dass du nicht
zurückspulst, sprich das richtige Gerät (<tt>rst0</tt>) benutzt,
ansonsten wirst du mit der zweiten Sicherung die erste überschreiben,
usw. Du findest in der Manualseite zu dump eine ausführlichere
Beschreibung.

<p>
Wenn du ein kleines Skript namens "backup" schreiben würdest, könnte es
z.B. so aussehen:

<pre>
echo "  Starting Full Backup..."
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h
echo
echo -n "  Rewinding Drive, Please wait..."
mt -f /dev/rst0 rewind
echo "Done."
echo                      
</pre>

<p>
Wenn regelmäßige nächtliche Backups gefordert sind, könnte man
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cron&amp;sektion=8">cron(8)</a>
benutzen, um das Backup jede Nacht automatisch zu starten.

<p>
Es ist außerdem hilfreich, auf einem Blatt Papier aufzuschreiben, wie
groß jedes Dateisystem sein muss. Du kannst ,<tt>df -h</tt>' benutzen,
um herauszufinden, wieviel Platz jede Partition momentan verbraucht. Das
ist dann nützlich, wenn eine Platte versagt und du die Partitionstabelle
auf der neuen Platte wieder erstellen musst.

<p>
Deine Daten wiederherzustellen hilft außerdem noch gegen Fragmentierung. Der
beste Weg, um sicherzustellen, dass du alle Dateien erwischst, ist es, im
,single user' Modus zu booten. Dateisysteme müssen nicht gemountet werden,
um gesichert zu werden. Vergiss aber nicht root (/) zu mounten, denn sonst
wird dein dump versagen, wenn er versucht, Dumpdaten zu schreiben. Gib
einfach "<tt>bsd -s</tt>" am boot&gt; Prompt ein, um in den ,single user'
Modus zu kommen.

<h3>Den Inhalt eines dump Bandes ansehen:</h3>


<p>
Nachdem du deine Dateisysteme zum ersten Mal gesichert hast, ist es sicher
eine gute Idee, dein Band zu testen und sicherzustellen, dass es auch die
Daten enthält, die darauf sein sollen.

<p>
Du kannst den folgenden Befehl benutzen, um eine Auflistung der Dateien auf
einem dump Band zu bekommen:

<pre>
# <b>/sbin/restore -tvs 1 -f /dev/rst0</b>
</pre>

<p>
Das listet die Dateien auf der 1. Partition auf dem dump Band (dem
Sicherungsband) auf. Wie in den Beispielen weiter oben, ist 1 dein root
(/) Dateisystem.

<p>
Um den Inhalt der 2. Partition zu sehen und die Ausgabe in eine Datei
umzulenken, würde man z.B. solch ein Kommando benutzen:

<pre>
# <b>/sbin/restore -tvs 2 -f /dev/rst0 > /home/me/list.txt</b>
</pre>

<p>
Wenn du eine mount-Tabelle wie die oben aufgeführte hast, wäre 2 /usr,
wenn deine aber etwas größer wäre, könnte 2 auch /var sein oder irgendwas
anderes. Die Sequenznummer ist auf jeden Fall die gleiche Reihenfolge, in
der das Dateisystem auf Band gesichert wird.


<h3>Wiederherstellen vom Band:</h3>

<p>
Das Beispielszenario wäre sinnvoll, wenn deine eigentliche Festplatte
komplett ausgefallen wäre. Falls du aber nur eine einzige Datei
wiederherstellen willst, sieh dir die restore Manual Seite genau an und achte
besonders auf die Anweisungen zum interaktiven Modus.

<p>
Wenn du gut vorbereitet bist, kann der Prozess des Ersetzens einer
Festplatte sehr schnell von statten gehen. Die Standard OpenBSD 
install/boot Floppy enthält bereits das benötigte restore Werkzeug, genauso
wie die ausführbaren Dateien, um neue Partitionen zu erstellen und deine
Festplatte bootfähig zu machen. In den meisten Fällen sind diese Floppies
und dein Sicherungsband alles, was du brauchst, um wieder alles
betriebsbereit zu bekommen.

<p>
Nachdem du das kaputte Laufwerk physikalisch ersetzt hast, sind die
grundlegenden Schritte zur Wiederherstellung folgende:

<ul>
<li>
<p>
Boote von der OpenBSD install/boot Floppy. An der Menüauswahl wähle Shell.
Nimm dein neuestes und schreibgeschütztes Band und lege es in dein Laufwerk
ein.
<br>
<li>
<p>
Benutze das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>-Kommando,
um eine primäre OpenBSD-Partition auf dieser neu installierten
Festplatte zu erzeugen. Beispiel:

<pre>
# <b>fdisk -e sd0</b>
</pre>

<p>
Sieh einfach in die <a href="#fdisk">fdisk FAQ</a>, um genaueres zu erfahren.

<li>
<p>  
Mit dem disklabel Kommando stellst du dann deine OpenBSD Partitionstabelle
in der primären OpenBSD Partition wieder her, die du gerade mit fdisk
erzeugt hast. Beispiel:

<pre>
# <b>disklabel -E sd0</b>
</pre>

<p>
(Vergiss den Swap nicht, siehe dazu die <a href="#disklabel">disklabel FAQ</a>
für weitere Informationen)

<li>
<p>
Benutze das newfs Kommando, um ein neues sauberes Dateisystem auf jeder
Partition zu erstellen, die du mit dem oben aufgeführten Schritten erstellt
hast. Beispiel:

<pre>
# <b>newfs /dev/rsd0a</b>
# <b>newfs /dev/rsd0h</b>
</pre>

<li>
<p>
Mounte dein neu vorbereitetes root (/) Dateisystem auf /mnt. Beispiel:

<pre>
# <b>mount /dev/sd0a /mnt</b>
</pre>

<li>
<p>
Wechsel in das gemountete root Dateisystem und beginne mit dem restore
Prozess. Beispiel: 

<pre>
# <b>cd /mnt</b>
# <b>restore -rs 1 -f /dev/rst0</b>
</pre>

<li>
<p>
Wenn die Platte bootfähig sein soll, schreibe mit dem folgenden Befehl
einen neuen MBR auf deine Festplatte. Beispiel:

<pre>
# <b>fdisk -i sd0</b>
</pre>

<li>
<p>
Zusätzlich zum Schreiben eines neuen MBR musst du Bootblöcke installieren,
um davon booten zu können. Das folgende ist ein kurzes Beispiel:

<pre>
# <b>cp /usr/mdec/boot /mnt/boot</b>
# <b>/usr/mdec/installboot -v /mnt/boot /usr/mdec/biosboot sd0</b>
</pre>

<li>
<p>
Dein neues root Dateisystem auf der eingebauten Festplatte sollte jetzt
fertig sein, so dass du davon booten und damit beginnen kannst, den Rest
der Dateien wiederherzustellen. Da dein Betriebssystem noch nicht komplett
ist, solltest du alles im ,single user' Modus wiederherstellen. Am
Shellprompt benutze die folgende Kommandos, um deine Festplatten
"abzumelden" (umount) und das System anzuhalten:

<pre>
# <b>umount /mnt</b>
# <b>halt</b>
</pre>

<li>
<p>
Entferne die install/boot Floppy aus dem Laufwerk und reboote dein System.
Am OpenBSD boot&gt; Prompt benutze das folgende Kommando:

<pre>
boot&gt; <b>bsd -s</b>
</pre>

<p>
Das bsd -s führt dazu, dass der Kernel im ,single user' Modus gestartet
wird, der nur ein root (/) Dateisystem braucht.

<li>
<p>
Unter der Annahme, das du die obigen Schritte richtig ausgeführt hast und
nichts schief gegangen ist, solltest du von einem Prompt begrüßt werden,
der dich nach einem Pfad zu einer Shell fragt, oder du sollst Return
drücken. Drücke Return, um die sh zu benutzen. Als nächstes willst du sicher
root im r/w Modus (Schreib/Lese) remounten und nicht mehr im Nur-Lese-Modus
benutzen (ro). Dazu benutze folgendes: 

<pre>
# <b>mount -u -w /</b>
</pre>

<li>
<p>
Sobald du im r/w Modus remountet hast, kannst du fortfahren, deine
restlichen Dateisysteme wiederherzustellen. Beispiel:

<pre>
(einfache mount-Tabelle)
# <b>mount /dev/sd0h /usr; cd /usr; restore -rs 2 -f /dev/rst0</b>

(umfassendere mount-Tabelle)
#	<b>mount /dev/sd0d /var; cd /var; restore -rs 2 -f /dev/rst0</b>
#	<b>mount /dev/sd0e /home; cd /home; restore -rs 3 -f /dev/rst0</b>
#	<b>mount /dev/sd0h /usr; cd /usr; restore -rs 4 -f /dev/rst0</b>
</pre>

<p>
Benutze "<b>restore rvsf</b>" statt eines einfachen rsf, um die Namen
von Objekten zu sehen, während sie vom dump Set ausgepackt werden.

<li>
<p>
Nachdem du jetzt auch alle Dateien der anderen Dateisysteme wiederhergestellt
hast, führe einen Reboot in den ,multi user' Modus durch. Wenn alles geklappt
hat, sollte dein System wieder genauso sein, wie zum Zeitpunkt deiner
letzten Sicherung, und bereit, wieder eingesetzt zu werden.
</ul>

<a name="MountImage"></a>
<h2>14.10 - Diskimages unter OpenBSD mounten</h2>

<p>
Um ein Diskimage (ISO-Images, Diskimages, die mit dd erstellt wurden, etc)
unter OpenBSD zu mounten, musst du ein
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnd&amp;sektion=4">vnd(4)</a>
Device konfigurieren. 
Zum Beispiel, wenn du ein ISO-Image unter <i>/tmp/ISO.image</i> hast,
würdest du die folgenden Schritte machen, um es zu mounten:

<table border=0 width="650">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<pre>
# <b>vnconfig svnd0 /tmp/ISO.image</b>
# <b>mount -t cd9660 /dev/svnd0c /mnt</b>
</pre>
                </td>
        </tr>
</table>

<p>
Bedenke bitte, dass du den Typ <i>cd9660</i> angeben musst, wenn es
eine CD ist. Das gilt aber auch für die anderen Typen, also musst du
z.B. <i>ext2fs</i> beim Mounten eines Linux-Diskimages angeben. 

<p>
Um das Image wieder zu unmounten, benutze die folgenden Kommandos.

<table border=0 width="650">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<pre>
# <b>umount /mnt</b>
# <b>vnconfig -u svnd0</b>
</pre>
                </td>
        </tr>
</table>

<p>
Mehr Informationen gibt es in der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&amp;sektion=8">vnconfig(8)</a>-Manualseite.

<a name="pciideErr"></a>
<h2>14.11 - Hilfe! Ich erhalte Fehler mit IDE DMA!</h2>

<p>
DMA IDE Übertragungen, die durch
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pciide&amp;sektion=4">pciide(4)</a>
unterstützt werden, sind unzuverlässig. Bis vor kurzem wurden die meisten
"mainstream" Betriebssysteme, die behaupteten, dass sie DMA Übertragungen
mit IDE Laufwerken unterstützen, nicht mit standardmäßig aktivierter
Unterstützung wegen unzuverlässiger Hardware ausgeliefert.
Nun werden viele dieser gleichen Maschinen mit OpenBSD verwendet.

<p>
OpenBSD ist aggressiv und versucht, den höchsten DMA Modus zu benutzen,
den es konfigurieren kann. Dies führt in einigen Konfigurationen zu
Datenkorruptionen aufgrund von defekten Motherboard Chipsets, fehlerhaften
Treibern, die buggy sind und/oder Lärm auf den Kabeln. Glücklicherweise
schützt Ultra-DMA die Datenübertragungen mit einem CRC, um Korruptionen
zu entdecken. Falls ein Fehler bei einem solchen Ultra-DMA CRC geschieht,
wird OpenBSD eine Fehlermeldung ausgeben und erneut versuchen, die Daten
zu übertragen.

<pre>
wd2a:  aborted command, interface CRC error reading fsbn 64 of 64-79
(wd2 bn 127; cn 0 tn 2 sn 1), retrying
</pre>

<p>
Nach ein paar Fehlversuchen wird OpenBSD zu einem langsameren (und damit
hoffentlich zuverlässigeren) DMA-Modus herunterschalten. Nach den
Ultra-DMA Modi wird dann zu einem PIO Modus heruntergeschaltet.

<p>
UDMA Fehler werden meistens durch minderwertige oder beschädigte Kabel
verursacht. Kabelprobleme sollten normalerweise zuerst in Betracht gezogen
werden, wenn du viele DMA Fehler oder unerwartet niedrige DMA Leistung
erhälst. Es ist ebenfals eine schlechte Idee, das CD-ROM an den gleichen
Kanal wie die Festplatte zu stecken.

<p>
Wenn das Ersetzen der Kabel nicht zur Lösung des Problems führt und OpenBSD
nicht erfolgreich herunterschaltet oder der Prozess zu einem ,hard lock'
deiner Maschine führt, möchtest du vielleicht dein System auf einen
niedrigereren DMA oder UDMA Level standardmäßig begrenzen. Dies kann unter
Verwendung von <a href="faq5.html#BootConfig">UKC</a> oder
<a href="faq5.html#config">config(8)</a> realisiert werden, indem man die
Optionen des
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wd&amp;sektion=4">wd(4)</a>
Device ändert.


<a name="RAID"></a>
<h2>14.13 - RAID Optionen unter OpenBSD</h2>
RAID (Redundant Array of Inexpensive Disks) gibt die Möglichkeit, mehrere
Laufwerke zu verwenden, um bessere Leistung, Kapazität und/oder Redundanz
zu erhalten, als man aus einem einzelnen Laufwerk herausholen kann. Während
eine vollständige Diskussion über die Vorteile und Risiken von RAID außerhalb
des Rahmens dieses Artikels liegt, existieren einige Punkte, die so wichtig
sind, dass sie nun besprochen werden sollten:

<ul>
<li>RAID hat nichts mit Backup zu tun.
<li>RAID allein wird die Ausfallzeit nicht eliminieren.
</ul>

Wenn diese Information neu für dich ist, ist das kein guter Ausgangspunkt,
um RAID zu erforschen.

<h3>Software Möglichkeiten</h3>
OpenBSD beinhaltet RAIDframe, eine software-basierende RAID Lösung.
Dokumentation hierfür kann an folgenden Stellen gefunden werden:

<ul>
<li><a href="faq11.html#raid">FAQ 11, RAID</a>
<li><a href="http://www.pdl.cmu.edu/RAIDframe/">RAIDframe Homepage</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;sektion=8">Manual
     Seite für raidctl(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">Manual
     Seite für raid(4)</a>
</ul>

<p>
Die root Partition kann direkt von OpenBSD unter Verwendung der
"Autoconfiguration" Option von RAIDframe gespiegelt werden.

<p>
OpenBSD 3.7-stable und neuer beinhaltet ebenfalls ,mirroring' als
Funktionalität des
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccd&amp;sektion=4">ccd(4)</a>-Treibers.
Es wird nicht empfohlen, dass man 3.7-release hierfür einsetzt, es
gab einen Fehler, der mit 3.7-stable behoben wurde.
Dieses System wurde in den GENERIC-Kernel integriert und befindet sich
im Kernel bsd.rd, so dass es viel einfacher genutzt werden kann, obwohl
es einige Begrenzungen im Bezug auf das Neuerzeugen des Arrays hat.
Siehe:
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccd&amp;sektion=4">Manualseite
zu ccd(4)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccdconfig&amp;sektion=8">Manualseite
zu ccdconfig(8)</a>
</ul>

<h3>Hardware Möglichkeiten</h3>
<p>
Viele OpenBSD <a href="../../de/plat.html">Plattformen</a> beinhalten
Unterstützung für etliche Hardware RAID Produkte. Die Möglichkeiten variieren
von Plattform zu Plattform, siehe die passende Hardwareunterstützungsseite
(<a href="../../de/plat.html">hier</a> aufgelistet).

<p>
Eine andere Möglichkeit, die für viele Plattformen bereit steht, ist eine
der vielen Produkte, die mehrere Laufwerke dazu bringt, wie ein großes IDE
oder SCSI Laufwerk zu agieren und die dann in einen standardmäßigen IDE
oder SCSI Adapter gesteckt werden. Diese Geräte können nahezu auf jeder
Hardwareplattform funktionieren, die entweder SCSI oder IDE verwenden.

<p>
Einige Hersteller dieser Produkte:
<ul>
<li><a href="http://www.arcoide.com/">Arco</a>
<li><a href="http://www.accusys.com.tw/">Accusys</a>
<li><a href="http://www.maxtronic.com/">Maxtronic</a>
<li><a href="http://www.infortrend.com/">Infortrend</a>
</ul>
(Hinweis: dies sind nur Produkte, die von OpenBSD Anwendern verwendet und
gemeldet wurden -- dies ist weder eine Art von Werbung noch ist es eine
ausführliche Liste.)

<h3>Keine Möglichkeit</h3>
<p>
Eine häufig gestellte Frage in den
<a href="../../de/mail.html">Mailinglisten</a> ist "Werden die
kostengünstigen IDE- oder SATA-RAID-Controller (wie zum Beispiel jene,
die die Highpoint-, Promise- oder Adaptec-HostRAID-Chips benutzen)
unterstützt?" Die Antwort ist "Nein". Diese Karten und
Chips sind nicht echte Hardware RAID Controller, stattdessen
eher BIOS-assistierte Bots für ein Software RAID. Da OpenBSD bereits
Software RAID in einem Hardware-unabhängigen Weg unterstützt, besteht kein
großes Verlangen bei den OpenBSD Entwicklern, diese spezielle Unterstützung
für diese Karten zu implementieren.

<p>
Fast alle on-board SATA- oder IDE-,RAID'-Controller sind von diesem
softwarebasierendem Stil und funktionieren normalerweise einwandfrei als
SATA- oder IDE-Controller unter Verwendung des standardmäßigen IDE-Treibers
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pciide&amp;sektion=4">pciide(4)</a>),
aber werden nicht als Hardware-RAID-System unter OpenBSD funktionieren.

<a name="NegSpace"></a>
<h2>14.14 - Warum sagt mir <tt>df(1)</tt>, dass ich mehr als 100% von
meiner Platte belegt habe?</h2>
Leute sind manchmal erstaunt darüber, herausfinden zu müssen, dass sie
<i>negativen</i> verfügbaren Plattenspeicher haben oder mehr als 100% einer
Partition in Verwendung ist, wie es von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=df&amp;sektion=1">df(1)</a>
angezeigt wird.

<p>
Wenn eine Partition mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&amp;sektion=8">newfs(8)</a>
erstellt wird, wird ein Teil des verfügbaren Speichers vor den normalen
Benutzern in Reserve gehalten. Dies stellt einen Spielraum für Fehler bereit,
wenn du versehentlich die Platte füllst und hilft, die Plattenfragmentierung
auf einem Minimum zu halten.
Standardwert hierfür ist 5% der Plattenkapazität, so dass, falls der root
Anwender sorglos die Platte auffüllt, du bis zu 105% Speicher sehen kannst,
der verwendet wird.

<p>
Wenn der 5% Wert für dich nicht angemessen erscheint, kannst du ihn mit dem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tunefs&amp;sektion=8">tunefs(8)</a>
Kommando ändern.

<a name="OhBugger"></a>
<h2>14.15 - Partitionen wiederherstellen, nachdem das disklabel gelöscht
wurde</h2>

<p>
Wenn du eine Partitionstabelle beschädigt hast, gibt es einige Dinge,
die du versuchen kannst, um sie wiederherzustellen.

<p>
Zu aller erst Panik.
Das würde sowieso passieren, aber dann hast du es jedenfalls hinter dir.
Mach einfach nichts unvernünftiges.
Halte deine Panik von der Maschine fern.
Dann entspanne dich und guck, ob dir die unten stehenden Schritte
vielleicht weiterhelfen.

<p>
Seit OpenBSD 3.6 wird eine Kopie des disklabels für jede Platte als
Teil der täglichen Systemverwaltung in <tt>/var/backups</tt>
gespeichert. Angenommen, dass du die var-Partition weiterhin hast,
kannst du einfach die Ausgabe lesen und sie zurück in das disklabel
schreiben.

<p>
Falls du die Partition nicht mehr sehen kannst, gibt es zwei
Möglichkeiten.
Behebe genug Fehler der Platte, bis du sie sehen kannst oder behebe
genug Fehler der Platte, um deine Daten von ihr zu bekommen.

Abhängig davon, was passiert ist, könnt der eine oder ein anderer
Weg bevorzugt sein (mit sterbenden Platten, von denen du zuerst
die Daten haben willst, könntest du mit schlampigen Fingern nur das
Label bekommen).

<p>

Das erste Tool, das du brauchst, ist
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=scan_ffs">scan_ffs(8)</a>
(achte auf den Unterstrich, es wird nicht ,scanffs' genannt).
scan_ffs(8) durchsucht die Platte und versucht, Partitionen zu finden,
und teilt dir die Informationen mit, die es über sie herausgefunden hat.
Du kannst diese Informationen nutzen, um das disklabel neu zu erstellen.
Wenn du einfach nur <tt>/var</tt> zurückhaben willst, kannst du die
Partition für <tt>/var</tt> wieder erstellen und dann das gesicherte
label nutzen, um den Rest von diesem aus zu erstellen.

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel;sektion=8">disklabel(8)</a>
wird sowohl die Erkenntnis des Kernels über das disklabel erneuern
als auch versuchen, das label auf die Platte zu schreiben.
Selbst wenn der Bereich der Platte, in dem das disklabel liegt, nicht
lesbar ist, wirst du trotzdem in der Lage sein, bis zum nächsten
Neustart
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount;sektion=8">mount(8)</a>
aufzurufen.


<a name="foreignfs"></a>
<h2>14.16 - Kann ich auf Daten zugreifen, die auf anderen Dateisystemen
als FFS liegen?</h2>
<!-- This article written by Steven Mestdagh,
steven.mestdagh@esat.kuleuven.be, and released under the BSD license -->

Ja. Andere unterstützte Dateisysteme sind unter anderem: ext2 (Linux),
ISO9660 (CD-ROM-, DVD-Medien), FAT (MS-DOS und Windows), NFS, NTFS
(Windows), AmigaDOS. Einige von ihnen haben eingeschränkte, zum
Beispiel nur lesbare, Unterstützung.

<p>
Wir werden hier einen allgemeinen Überblick darüber geben, wie man eines
dieser Dateisysteme unter OpenBSD verwendet. Um in der Lage zu sein, ein
Dateisystem zu benutzen, muss es gemountet sein.
Für Details und Optionen für mount, konsultiere bitte die
Manualseite zu
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>
und die Manualseite zum mount-Kommando für das Dateisystem, das du
mounten möchtest, z.B. mount_msdos, mount_ext2fs, ...

<p>
Zu aller erst musst du wissen, auf welchem Device sich dein Dateisystem
befindet. Vielleicht einfach deine erste Festplatte,
<tt>wd0</tt> oder <tt>sd0</tt>, aber es könnte auch weniger
offensichtlich sein.
Alle erkannten und konfigurierten Devices deines Systems werden in der
Ausgabe vom Kommando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=1">dmesg(1)</a>
aufgeführt: ein Device-Name, gefolgt von einer einzeiligen Beschreibung
des Devices. Mein erstes CD-ROM-Laufwerk wird beispielsweise wie folgt
erkannt:

<blockquote><pre>
cd0 at scsibus0 targ 0 lun 0: &lt;COMPAQ, DVD-ROM LTD163, GQH3&gt; SCSI0 5/cdrom removable
</pre></blockquote>

<p>
An diesem Punkt angekommen ist es Zeit dafür, herauszufinden, welche
Partitionen sich auf dem Device befinden, und auf welcher Partition sich
das gewünschte Dateisystem liegt.
Daher untersuchen wir das Device mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>.
Das Disklabel beinhaltet eine Liste von Partitionen, mit einer maximalen
Anzahl von 16. Partition c steht immer für das gesamte Device.
Partitionen a-b und d-p werden von OpenBSD genutzt.
Partitionen i-p können automatisch für Dateisysteme anderer
Betriebssysteme allokiert werden.
In diesem Fall werde ich mir das Disklabel meiner Festplatte betrachten,
welches eine Anzahl verschiedener Dateisysteme beinhaltet:

<blockquote><pre>
# <b>disklabel wd0</b>

# using MBR partition 2: type A6 off 20338290 (0x1365672) size 29318625 (0x1bf5de1)
# /dev/rwd0c:
type: ESDI
disk: ESDI/IDE disk
label: ST340016A       
flags:
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 16383
total sectors: 78165360
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # microseconds
track-to-track seek: 0  # microseconds
drivedata: 0 

16 partitions:
#             size        offset  fstype [fsize bsize  cpg]
  a:        408366      20338290  4.2BSD   2048 16384   16 # Cyl 20176*- 20581 
  b:       1638000      20746656    swap                   # Cyl 20582 - 22206 
  c:      78165360             0  unused      0     0      # Cyl     0 - 77544 
  d:       4194288      22384656  4.2BSD   2048 16384   16 # Cyl 22207 - 26367 
  e:        409248      26578944  4.2BSD   2048 16384   16 # Cyl 26368 - 26773 
  f:      10486224      26988192  4.2BSD   2048 16384   16 # Cyl 26774 - 37176 
  g:      12182499      37474416  4.2BSD   2048 16384   16 # Cyl 37177 - 49262*
  i:         64197            63 unknown                   # Cyl     0*-    63*
  j:      20274030         64260 unknown                   # Cyl    63*- 20176*
  k:       1975932      49656978   MSDOS                   # Cyl 49262*- 51223*
  l:       3919797      51632973 unknown                   # Cyl 51223*- 55111*
  m:       2939832      55552833  ext2fs                   # Cyl 55111*- 58028*
  n:       5879727      58492728  ext2fs                   # Cyl 58028*- 63861*
  o:      13783707      64372518  ext2fs                   # Cyl 63861*- 77535*

</pre></blockquote>

<p>
Wie du in dieser Ausgabe erkennen kannst, werden die OpenBSD-Partitionen
zuerst aufgelistet. Nach diesen ist eine Anzahl von ext2-Partitionen und
eine MSDOS-Partition aufgelistet, sowie ein paar ,unknown' Partitionen.
Auf i386- und amd64-Systemen kannst du mehr über diese unter Verwendung
des Werkzeugs
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
in Erfahrung bringen.
Für den neugierigen Leser: Partition i ist eine Wartungspartition, die
vom Hersteller erzeugt wurde, Partition j ist eine NTFS-Partition und
Partition l ist eine Swappartition für Linux.

<p>
Sobald du herausgefunden hast, welche dieser Partitionen die ist, die du
benutzen möchtest, kannst du den letzten Schritt durchführen: Das
Dateisystem, das sich auf dieser befindet, mounten. Die meisten
Dateisysteme werden vom GENERIC-Kernel unterstützt: Werfe einfach einen
Blick in die Kernelkonfigurationsdatei, die sich im Verzeichnis
<tt>/usr/src/sys/arch/&lt;<i>arch</i>&gt;/conf</tt> befindet.
Einige werden jedoch nicht unterstützt, z.B. ist die NTFS-Unterstützung
experimentell und daher nicht im GENERIC.
Wenn du eines der Dateisysteme nutzen möchtest, die nicht in GENERIC
unterstützt werden, musst du <a href="faq5.html#Options">einen
angepassten Kernel erzeugen</a>.

<p>
Wenn du die Informationen auf zuvor beschriebene Weise gesammelt hast,
ist es nun an der Zeit, das Dateisystem zu mounten.
Lass uns annehmen, dass ein Verzeichnis namens <tt>/mnt/otherfs</tt>
existiert, welches wir als Mountpunkt nutzen werden, unter dem wir das
gewünschte Dateisystem mounten werden.
In diesem Beispiel werden wir das ext2-Dateisystem von Partition m
mounten:

<blockquote><pre>
# <b>mount -t ext2fs /dev/wd0m /mnt/otherfs</b>
</pre></blockquote>

<p>
Wenn du vor hast, dieses Dateisystem regulär zu nutzen, kannst du etwas
Zeit sparen, indem du eine Zeile in <tt>/etc/fstab</tt> schreibst; zum
Beispiel etwas wie:

<blockquote><pre>
/dev/wd0m /mnt/otherfs ext2fs rw,noauto,nodev,nosuid 0 0
</pre></blockquote>

Beachte den Wert 0 im fünften und sechsten Feld.
Diese bedeuten, dass wir nicht möchten, dass die Dateisysteme mit
dump gesichert oder unter Verwendung von fsck überprüft werden.
Generell gilt, dass du solche Aufgaben eher mit dem dazugehörigem
Betriebssystem machen möchtest.


<a name="flashmem"></a>
<h2>14.17 - Kann ich ein Gerät mit Flashspeicher unter OpenBSD
benutzen?</h2>
<!-- This article written by Steven Mestdagh,
steven.mestdagh@esat.kuleuven.be, and released under the BSD license -->

Normalerweise sollte ein Speichergerät erkannt werden, wenn es an eine
Schnittstelle deiner Maschine angeschlossen wird.
Kurz nach dem Anschließen werden einige Nachrichten auf der Konsole des
Kernels angezeigt.
Wenn ich zum Beispiel meinen USB-Flashspeicher anschließe, sehe ich
folgendes auf meiner Konsole:

<blockquote><pre>
umass0 at uhub1 port 1 configuration 1 interface 0
umass0: LEXR PLUG DRIVE LEXR PLUG DRIVE, rev 1.10/0.01, addr 2
umass0: using SCSI over Bulk-Only
scsibus2 at umass0: 2 targets
sd0 at scsibus2 targ 1 lun 0: &lt;LEXAR, DIGITAL FILM, /W1.&gt; SCSI2 0/direct removable
sd0: 123MB, 123 cyl, 64 head, 32 sec, 512 bytes/sec, 251904 sec total
</pre></blockquote>

Diese Zeilen deuten darauf, dass der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=umass&amp;sektion=4">umass(4)</a>-
(USB-Massenspeicher) -Treiber an das Speichergerät angehängt wurde und
dass es das SCSI-System nutzt.
Die beiden letzten Zeilen sind die wichtigsten: sie sagen, an welchem
Deviceknoten das Speichergerät angehängt wurde, und wie groß der gesamte
Speicherplatz ist.
Wenn du diese Zeilen warum auch immer verpasst haben solltest, kannst du
sie nachträglich mit dem Kommando
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=1">dmesg(1)</a>
betrachten.
Die angegebene CHS-Geometrie ist eine fiktive, da der Flashspeicher
wie eine normale SCSI-Platte verarbeitet wird.

<p>
Wir werden zwei Szenarien weiter unten besprechen.

<h3>Das Gerät ist neu/leer und du möchtest es nur mit OpenBSD
nutzen</h3>

Du musst ein Disklabel und mindestens eine Partition auf diesem Gerät
erstellen.
Bitte lese <a href="#disklabel">OpenBSDs disklabel verwenden</a> und die
Manualseite zu
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
für Details hierüber.

<p>
In diesem Beispiel habe ich nur eine Partition <i>a</i> erstellt, auf
der ich ein FFS-Dateisystem erstellen werde:

<blockquote><pre>
# <b>newfs sd0a</b>
Warning: inode blocks/cyl group (125) >= data blocks (62) in last
    cylinder group. This implies 1984 sector(s) cannot be allocated.
/dev/rsd0a:     249856 sectors in 122 cylinders of 64 tracks, 32 sectors
        122.0MB in 1 cyl groups (122 c/g, 122.00MB/g, 15488 i/g)
super-block backups (for fsck -b #) at:
 32,
</pre></blockquote>

Lass uns das Dateisystem, das wir auf der Partition <i>a</i> erstellt
haben, unter <tt>/mnt/flashmem</tt> speichern.
Erstelle zuerst einen Mountpunkt, wenn er noch nicht existiert.

<blockquote><pre>
# <b>mkdir /mnt/flashmem</b>
# <b>mount /dev/sd0a /mnt/flashmem</b>
</pre></blockquote>

<h3>Du hast das Speichergerät von jemandem erhalten, mit dem du Daten
austauschen möchtest</h3>

<p>
Möglicherweise wird diese andere Person nicht OpenBSD nutzen, so dass
sich ein fremdes Dateisystem auf diesem Speichergerät befinden kann.
Daher müssen wir zuerst alle Partitionen auf diesem Gerät finden, so
wie es in <a href="#foreignfs">FAQ 14 - Fremde Dateisysteme</a>
beschrieben steht.

<blockquote><pre>
# <b>disklabel sd0</b>

# /dev/rsd0c:
type: SCSI
disk: SCSI disk
label: DIGITAL FILM    
flags:
bytes/sector: 512
sectors/track: 32
tracks/cylinder: 64
sectors/cylinder: 2048
cylinders: 123
total sectors: 251904
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # microseconds
track-to-track seek: 0  # microseconds
drivedata: 0 

16 partitions:
#             size        offset  fstype [fsize bsize  cpg]
  c:        251904             0  unused      0     0      # Cyl     0 -   122 
  i:        250592            32   MSDOS                   # Cyl     0*-   122*
</pre></blockquote>

Wie man in der Ausgabe von disklabel sehen kann, gibt es nur eine
Partition <i>i</i>, das ein FAT-Dateisystem beinhaltet, das von einer
Windows-Maschine erstellt wurde. Wie gewöhnlich stellt die Partition
<i>c</i> das gesamte Gerät dar.

<p>
Lass uns nun das Dateisystem auf der Partition <i>i</i> unter
<tt>/mnt/flashmem</tt> mounten.

<blockquote><pre>
# <b>mount -t msdos /dev/sd0i /mnt/flashmem</b>
</pre></blockquote>

Nun können wir damit beginnen, es wie jede andere Platte anzusprechen.

<p>
<b>WARNUNG:</b>
Du solltest das Dateisystem <b>vor dem Herausziehen</b> des Geräts
<b>immer erst unmounten</b>.
Wenn du das nichts tust, könnte das Dateisystem in einem nicht
konsistenten Zustand zurückgelassen werden, was in Datenverlusten
enden kann.

<p>
Nach dem Entfernen des Speichergeräts von deiner Maschine wirst du
wieder sehen, dass der Kernel Meldungen hierüber auf der Konsole
ausgibt:

<blockquote><pre>
umass0: at uhub1 port 1 (addr 2) disconnected
sd0 detached
scsibus2 detached
umass0 detached
</pre></blockquote>

<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ Index]</a>
<a href= "../faq13.html">[Zum Kapitel 13 - Multimedia]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt="[back]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small> 
<!--
Originally [OpenBSD: faq14.html,v 1.133 ]
$Translation: faq14.html,v 1.41 2005/07/31 14:45:41 paldium Exp $
-->
$OpenBSD: faq14.html,v 1.36 2005/08/03 15:20:13 saad Exp $
</small>

</body>
</html>
