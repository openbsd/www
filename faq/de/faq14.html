<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>14 - Platten Einrichtung</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta http-equiv="Content-Language" content="de">
<meta name= "description"   content= "Die OpenBSD FAQ Seiten - FAQ 14: Einrichten von Festplatten">
<meta name= "keywords"      content= "openbsd,faq,festplatten,setup,partition">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2004 by OpenBSD.">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<style type="text/css">
  <!--
  pre { margin-left: 20px; }
  -->
</style>
</head>

<body bgcolor= "#ffffff" text= "#000000">

<a href="../../de/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">
</a>
<p>
<h2><font color=#e00000>14.0 - Disk Setup</font><hr></h2>
</p>

<p>
<ul><h3>Inhaltsverzeichnis</h3>
<li><a href="#14.1">14.1 - Benutzung von OpenBSD's disklabel</a></li>
<li><a href="#14.2">14.2 - Benutzung von OpenBSD's fdisk</a></li>
<li><a href="#14.3">14.3 - Zusätzliche Festplatten unter OpenBSD installieren</a></li>
<li><a href="#14.4">14.4 - Wie man in eine Datei 'swapt'</a></li>
<li><a href="#14.5">14.5 - Soft Updates</a></li>
<li><a href="#14.6">14.6 - Wenn ich nach der Installation von OpenBSD/i386 boote, stoppt der Rechner bei 
"Using partition 3 id 0".</a></li>
<li><a href="#14.7">14.7 - Wie man ein dmesg von einer Boot Floppy bekommt</a></li>
<li><a href="#14.8">14.8 - Bootblocks installieren- i386 spezifisch</a></li>
<li><a href="#14.9">14.9 - Auf das Disaster vorbereiten: Backups machen und Wiederherstellen mit Bändern.</a></li>
<li><a href="#14.10">14.10 - Disk images unter OpenBSD mounten</a></li>
<li><a href="#14.11">14.11 - Hilfe! Ich erhalte Fehler mit PCIIDE!</a></li>
</ul>
</p> 
<hr>

<a name="14.1"></a>
<h2>Benutzung von OpenBSD's disklabel</h2>
   
<p>
<h3>Inhaltsangabe</h3>
<ul>
<li><a href="#14.1.1">Was ist disklabel(8)?</a>
<li><a href="#14.1.2">Disklabel während der OpenBSD Installation</a>
<li><a href="#14.1.3">Gebräuchliche disklabel(8) Varianten</a>
</ul>
</p>
   
<p>
<a name="14.1.1"></a>
<h3>Was ist disklabel(8)?</h3>
   
  
<p>
Lese zunächst die 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&sektion=8&format=html">disklabel(8)</a>
man page.
</p>

<p>
Disklabels werden erzeugt, um ein effizientes Interface zwischen deiner Festplatte
und den Festplattentreibern, die im Kernel enthalten sind, zu erzeugen. 'Labels' enthalten
bestimmte Informationen über dein Dateisystem, wie z.B. die 'drive geometry' und 
Informationen über deine Dateisysteme. Dies wird dann vom 'bootstrap' Programm benutzt,
um die Festplatte zu laden und um zu wissen, wo auf der Platte die Dateisysteme sind.
Labels werden auch zusammen mit den Dateisystemen benutzt, um eine effizientere Umgebung
zu erzeugen. Tiefergehende Informationen über 'disklabel' gibt es in der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&sektion=5&format=html">disklabel(5)</a>
man page.
</p> 

<p>
Zusätzlich führt die Benutzung von disklabel zur Überwindung
der Architekturgrenzen beim Partitionieren von Festplatten. Auf i386 kann man z.B.
nur 4 primäre Partitionen haben. (Partitionen, so wie sie andere BS wie
Windows NT oder DOS sehen.) Mit 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&sektion=8&format=html">disklabel(8)</a>
benutzt du eine dieser
'primären' Partitionen, die dann *alle* deine OpenBSD Partitionen 
enthält (z.B. 'swap','/','/usr' und '/var'). Und du hast noch 3
weitere für andere Betriebssysteme über!
</p>

<a name="14.1.2"></a>
<h3>disklabel während der OpenBSD Installation</h3>

<p>
Einer der Hauptteile der OpenBSD Installation ist das erste Erzeugen der 
'labels'. Das kommt (für i386 Benutzer) direkt nach der Benutzung von <a href="#14.2">fdisk(1)</a>.
Während der Installation benutzt du 'disklabel' um deine separaten 'label' zu erzeugen, die deine
separaten 'mountpoints' enthalten. Während der Installation kannst du mittels 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&sektion=8&format=html">disklabel(8)</a> 
deine Mountpoints setzen, aber das ist eigentlich nicht nötig, da du deine Änderungen später
sowieso bestätigen musst. Aber es macht deine Installation schon etwas geradliniger.
</p>

<p>
Da das während der Installation geschieht, hast du noch keine funktionierenden 'labels', und
sie müssen erst erzeugt werden. Das erste 'label', das du erzeugt, ist das Label 'a'. Das sollte
das Label sein, auf dem dann '/' gemountet wird. Die empfohlenen Partitionen und ihren Grössen 
kannst du dir auf <a href="faq4.html#4.3">faq4.3</a> ansehen. Für Server wird empfohlen zumindest diese
'label' separat zu halten. Für Desktop User reicht vermutlich ein einzelner Mountpoint '/'. 
Wenn du deine root-Partition ('a' Label) erzeugst, denk dran, dass du in jedem Fall noch etwas Platz für 
deine Swap-Partition benötigst. Jetzt kennst du die Grundlagen, und daher geben wir hier jetzt mal ein
Beispiel für das Benutzen von disklabel. In diesem ersten Beispiel wird angenommen, dass 
OpenBSD das einzige Betriebssystem auf diesem Computer ist, und eine volle/komplette Installation gemacht
wird.
</p>

<ul><pre>

Wenn die Festplatte mit anderen Betriebssystemen geteilt wird, sollten diese BS einen
BIOS Partitionseintrag haben, der den kompletten Platz umfasst, den sie beanspruchen. 
Aus Sicherheitsgründen solltest du auch sicherstellen, dass alle OpenBSD Dateisysteme innerhalb 
des 'offset' und der Grösse sind, die in der 'A6' BIOS Partitionstabelle angegeben sind.
(Standardmässig wird der disklabel Editor das versuchen zu erzwingen). Wenn du dir nicht
sicher bist, wie man mehrere Partitionen sauber benutzt (also wie man /, /usr, /tmp, /var, /usr/local
und andere Dinge voneinander trennt), dann belasse es jetzt erstmal bei einer root und einer 
swap Partition.

# using MBR partition 3: type A6 off 63 (0x3f) size 4991553 (0x4c2a41) 

Treating sectors 63-16386300 as the OpenBSD portion of the disk.
You can use the 'b' command to change this.

Initial label editor (enter '?' for help at any prompt)
&gt; <strong>d a</strong>
&gt; <strong>a a</strong>
offset: [63] <strong>&lt;Enter&gt;</strong>
size: [16386237] <strong>64M</strong>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <strong>&lt;Enter&gt;</strong>
mount point: [none] <strong>/</strong>
fragment size: [1024] <strong>&lt;Enter&gt;</strong>
block size: [8192] <strong>&lt;Enter&gt;</strong>
cpg: [16] <strong>&lt;Enter&gt;</strong>
&gt; <strong>a b</strong>
offset: [131103] <strong>&lt;Enter&gt;</strong>
size: [16255197] <strong>64M</strong>
Rounding to nearest cylinder: 131040
FS type: [swap] <strong>&lt;Enter&gt;</strong>
</pre></ul>

<p>
An diesem Punkt hast du eine 64MB root Partition erzeugt, die mit / gemountet wird, und eine 64MB Swap Partition. 
In diesem Fall startet der Offset bei Sektor 63. So willst du es haben. Wenn es bei der Grösse angekommen
ist, wird dir Disklabel die Grössen in Sektoren angeben, du musst aber die Grössen nicht ebenfalls
im gleichen Format eingeben. Wie im Beispiel oben kannst du Grössen zum Beispiel so eingeben:
<i>64 Megabytes = 64M</i> und <i>2 Gigabytes = 2G</i>. Disklabel wird dann einfach auf den nächsten
Zylinder runden. Im obigen Beispiel kann man auch sehen, dass Disklabel annimmt, dass Label 'b' eine
Swap-Partition sein wird. Das ist eine korrekte Annahme, da im GENERIC Kernel Swap auf Label 'b' festgelegt
ist, und daher solltest du dieser Richtlinie ebenfalls folgen und 'b' als SwapBereich benutzen. 
</p>

<p>
Das nächste Beispiel wird dich durch die Erzeugung zweier weiterer Labels führen. Im übrigen kann
das keine komplette Installation sein, da die Grösse dieser beiden Partitionen nicht ausreicht, um OpenBSD
komplett zu installieren. Das Ganze dient nur zur Wiederholung und Vertiefung. 
</p>

<ul><pre>
&gt; <strong>a d</strong>
offset: [262143] <strong>&lt;Enter&gt;</strong>
size: [16124157] <strong>64M</strong>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <strong>&lt;Enter&gt;</strong>
mount point: [none] <strong>/tmp</strong>
fragment size: [1024] <strong>&lt;Enter&gt;</strong>
block size: [8192] <strong>&lt;Enter&gt;</strong>
cpg: [16] <strong>&lt;Enter&gt;</strong>
&gt; <strong>a e</strong>
offset: [393183] <strong>&lt;Enter&gt;</strong>
size: [15993117] <strong>64M</strong>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <strong>&lt;Enter&gt;</strong>
mount point: [none] <strong>/var</strong>
fragment size: [1024] <strong>&lt;Enter&gt;</strong>
block size: [8192] <strong>&lt;Enter&gt;</strong>
cpg: [16] <strong>&lt;Enter&gt;</strong>
</pre></ul>

<p>
Im obigen Beispiel fallen dir vermutlich zwei Dinge auf. Zum einen, dass der offset automatisch 
für dich errrechnet wird. Wenn du eine solche Installation machst, musst du dich mit dem
Ändern der Offsets nicht herumschlagen. Ein weiterer Unterschied, der dir vielleicht auffällt,
ist, dass Label 'c' übersprungen wurde. Das ist aber Absicht, und zwar deshalb, weil Label 'c' die ganze
Festplatte repräsentiert. Aus diesem Grund solltest du Label 'c' vollkommen in Ruhe lassen.
</p>

<p>
Sind deine Label erst einmal alle erzeugt, ist alles, was noch nötig ist, die Label auf die Festplatte 
zu schreiben, und einfach mit dem Installationsprozess fortzufahren. Um alles zu schreiben und disklabel zu
beenden (und mit der Installation weiterzumachen) tippe folgendes:
</p>

<ul><pre>
&gt; <strong>w</strong>
&gt; <strong>q</strong>
</pre></ul>

<p>
<strong>*HINWEIS*</strong> - Für User mit grossen Festplatten: Wenn dein BIOS nicht in der Lage ist, eine
so grosse Festplatte zu unterstützen, kann OpenBSD das auch nicht. Ansonsten sollte OpenBSD keine 
Schwierigkeiten mit deiner Festplatte haben. Wenn dein BIOS das nicht kann, könntest du es mit
Maxtor EZ-Drive oder einem anderen 'Overlay' Produkt ausprobieren.
</p>


<a name="14.1.3"></a>
<h3>Gebräuchliche Benutzung von disklabel(8)</h3>

<p>
Wenn dein System erst einmal installiert ist, solltest du disklabel nicht mehr allzuoft benutzen müssen.
Aber du kannst es gebrauchen, wenn du z.B. Festplatten hinzufügen willst, welche entfernen willst oder
auch einfach umstrukturieren. Eines der ersten Dinge, die du dann machst, ist, dir den momentanen gültigen
Disklabel anzusehen. Und das geht so:
</p>

<ul><pre>
# <strong>disklabel wd0</strong> &gt;----- Oder was du dir auch immer für eine Platte ansehen willst

# using MBR partition 3: type A6 off 64 (0x40) size 16777152 (0xffffc0)
# /dev/rwd0c:
type: ESDI
disk:
label: TOSHIBA MK2720FC
flags:
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 2633
total sectors: 2654064
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # milliseconds
track-to-track seek: 0  # milliseconds
drivedata: 0 

16 partitions:
#        size   offset    fstype   [fsize bsize   cpg]
  a:  2071440    65583    4.2BSD     1024  8192    16   # (Cyl.   65*- 2120)
  b:    65520       63      swap                        # (Cyl.    0*- 65)
  c:  2654064        0    unused        0     0         # (Cyl.    0 - 2632)
  j:   512001  2137023    4.2BSD     1024  8192    16   # (Cyl. 2120*- 2627*)
</pre></ul>

<p>
Der obige Befehl zeigt dir einfach den existierenden Disklabel, und stellt sicher, dass du nichts kaputt machst
oder durcheinanderbringst. (Was wir alle von Zeit zu Zeit mal brauchen.) Um aber Veränderungen 
durchzuführen, musst du die -E option mit angeben:
</p>

<ul><pre>
# <strong>disklabel -E wd0</strong>
</pre></ul>

<p>
Das wird dich einfach an einen Prompt bringen, und zwar den selben, den du schon während der OpenBSD Installation
benutzt hast. Das wahrscheinlich wichtigste Kommando ist '?'. Das erzeugt nämlich eine Liste mit möglichen
Optionen für Disklabel. Mit Hilfe von 'M' kannst du dir sogar die gesamte 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&sektion=8&format=html">disklabel(8)</a>
man page ansehen. Von
diesem Prompt aus wirst du dein gesamtes Hinzufügen, Löschen und Ändern der Partitionen
vornehmen. Zusätzliche Informationen gibt es in der 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&sektion=8&format=html">disklabel(8)</a>
man page.
</p>

<p>
<a name="14.2"></a>
<h2>14.2 - Benutzung von OpenBSD's fdisk</h2>
</p>
<p>
Um sicher zu sein, prüfe zuerst die fdisk man page:
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&apropos=0&sektion=8&arch=i386&format=html">fdisk(8)</a>
</p>
<p>
Fdisk ist ein Programm, dass bei der Pflege und Wartung deiner Partitionen helfen soll.
Dieses Programm wird auch bei der Installation benutzt, um deine OpenBSD Partition einzurichten (
diese Partition kann <u>mehrere</u> Labels enthalten, jedes mit Dateisystemen/Swap/etc.).
Es kann den Platz auf deiner Festplatte aufteilen und eine Partition als aktiv setzen.
Dieses Programm wird für gewöhnlich im 'Single User Mode' benutzt werden (boot -s).
Fdisk setzt auch den MBR auf deinen verschiedenen Festplatten.
</p>

<p>
Für Installationszwecke braucht man meistens nur <b>EINE</b> OpenBSD
Partition und benutzt dann disklabel, um Swap und Dateisysteme darauf zu installieren.
</p>

<p>
Um dir nur deine Partitionstabelle mit fdisk anzugucken:<br>
<ul>
<pre># <strong>fdisk fd0</strong><br>
</pre>
</ul>

Was dann eine ähnliche Ausgabe wie diese hier erzeugt:
</p>

<ul>
<pre>
         Disk: fd0       geometry: 80/2/18 [2880 sectors]
         Offset: 0       Signatures: 0xAA55,0x0
                  Starting        Ending
          #: id  cyl  hd sec -  cyl  hd sec [     start -       size]
----------------------------------------------------------------------
         *0: A6    0   0   1 -   79   1  18 [         0 -       2880] OpenBSD
          1: 00    0   0   0 -    0   0   0 [         0 -          0] unused
          2: A7    0   0   2 -   79   1  18 [         1 -       2879] NEXTSTEP
          3: 00    0   0   0 -    0   0   0 [         0 -          0] unused
</pre>
</ul>

<p>
In diesem Beispiel betrachten wir die Ausgabe der Floppy Disk. Wir können die
OpenBSD Partition (A6) und ihre Grösse sehen. Der * sagt uns, dass die OpenBSD
Partition bootbar ist.
</p>

<p>
Im vorigen Beispiel haben wir uns die Informationen nur angesehen. Was aber, wenn wir unsere
Partitionstabelle verändern wollen? Nunja, dazu müssen wir zunächst das <b>-e</b>
flag benutzen. Das bringt uns dann zu einer Kommandozeile, die uns mit fdisk interagieren läßt.
</p>

<ul>
<PRE>
# <strong>fdisk -e wd0</strong>
Enter 'help' for information
fdisk: 1&gt; <strong>help</strong>
        help            Command help list
        manual          Show entire OpenBSD man page for fdisk
        reinit          Re-initialize loaded MBR (to defaults)
        disk            Edit current drive stats
        edit            Edit given table entry
        flag            Flag given table entry as bootable
        update          Update machine code in loaded MBR
        select          Select extended partition table entry MBR
        print           Print loaded MBR partition table
        write           Write loaded MBR to disk
        exit            Exit edit of current MBR, without saving changes
        quit            Quit edit of current MBR, saving current changes
        abort           Abort program without saving current changes
fdisk: 1&gt;
</PRE>
</ul>

<p> 
Es ist absolut sicher in fdisk ein wenig rumzuwandern und zu probieren, solange man <Strong>N</strong> auf die
Frage antwortet, ob die Änderungen abgespeichert werden sollen und *NICHT* das <strong>write</strong> 
Kommando benutzt.
</p>

<p>Hier ist eine Übersicht über die Kommandos, die man nach der Eingabe des <b>-e</b> flags benutzen kann.<br>
<ul>
<li><strong>help</strong>    Zeige eine Liste der Kommandos an, die fdisk im interaktiven 'edit mode' versteht.</li>
<li><strong>reinit</strong>  Initialisiere die momentane, im Speicher befindliche Kopie des Boot-Blocks.</li>
<li><strong>disk</strong>    Zeige die momentane Platten-Geometrie an, die fdisk herausgefunden hat. Du bekommst eine Möglichkeit sie zu ändern, wenn du willst.</li>
<li><strong>edit</strong>     Ändere eine ausgewählte Platten-Geometrie in Kopie des momentanen Bootblocks.  Das geschieht entweder im BIOS geometry mode oder in sector offsets und Grössen.</li>
<li><strong>flag</strong>    Den jetzigen Partitionstabelleneintrag bootbar machen. Nur ein Eintrag zur Zeit kann bootbar sein. 
Wenn du von einer extended Partition booten willst, musst du auch den entsprechenden Eintrag als bootbar markieren. </li>
<li><strong>update</strong>  Bringe den Maschinencode in der Speicherkopie des momentanen Bootblocks auf aktuellen Stand.</li>
<li><strong>select</strong>  Wähle und lade den Boot block, auf den der Eintrag der erweiterten Partitionstabelle im momentanen Boot-Block zeigt.</li>
<li><strong>print</strong>   Gebe die momentan im RAM befindlichen und gewählte Kopie des Boot Blocks und seinen MBR auf dem Bildschirm aus.</li>
<li><strong>write</strong>   Schreibe die RAM-Version des Boot Blocks auf die Platte. Du wirst um eine Bestätigung gebeten.</li>
<li><strong>exit</strong>    Verlasse den momentanen Level von fdisk, kehre entweder zur vorher gewählten Kopie eines BootBlocks im RAM zurücke oder verlasse das Programm, wenn es keinen gibt.</li>
<li><strong>quit</strong>    Verlasse den momentanen Level von fdisk, kehre entweder zur vorher 
gewählten Kopie eines BootBlocks im RAM zurücke oder verlasse
das Programm, wenn es keinen gibt. Anders als exit schreibt diese Variante den modifizierten Block auf die Platte.</li>
<li><strong>abort</strong>   Verlasse das Programm ohne Änderungen zu speichern.</li>
</ul>
</p>
<br>

<p>
<a name="14.3"></a>
<h2>14.3 - Zusätzliche Festplatten unter OpenBSD installieren</h2>
</p>

<p>
Nun, nachdem du deine Festplatte <strong>SAUBER</strong> eingebaut hast, musst du 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&apropos=0&sektion=8&arch=i386&format=html">fdisk(8)</a>
(<i> nur bei i386 </i
>) und auch
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&apropos=0&sektion=8&format=html">
disklabel(8)</a>, um deine Festplatte unter OpenBSD benutzen zu können. 
<P>
Die i386 Leute starten mit fdisk.  Andere Architekturen ignorieren das einfach.
<ul><pre>
# <Strong>fdisk -i sd2</strong>
</pre></ul>
Das wird die "echte" Partitionstabelle der Festplatte für eine 
ausschliessliche Benutzung mit OpenBSD initialisieren.
Als nächstes musst du einen disklabel dafür erzeugen.
Das wird wohl etwas verwirrend sein.
<UL><PRE>
# <strong>disklabel -e sd2</strong>

<i>(der Bildschirm wird leer, dein $EDITOR erscheint)</i>
type: SCSI
<i>...bla...</i>
sectors/track: 63
total sectors: 6185088
<i>...bla...</i>
16 partitions:
#        size   offset    fstype   [fsize bsize   cpg]
  c:  6185088        0    unused        0     0         # (Cyl.    0 - 6135)
  d:  1405080       63    4.2BSD     1024  8192    16   # (Cyl.    0*- 1393*)
  e:  4779945  1405143    4.2BSD     1024  8192    16   # (Cyl. 1393*- 6135)
</pre></ul>
Zunächst einmal ignoriere die 'c' Partition, sie ist immer da und Programme wie disklabel
benötigen sie, um zu funktionieren.
Für den normalen Betrieb sollte die fsize immer 1024 sein, bsize immer 8192
und cpg immer 16.  Der Fstype ist 4.2BSD.  Total sectors ist die gesamte Grösse der Festplatte.
Nehmen wir an, es handelt sich um eine 3 Gigabyte Festplatte.  Drei Gigabytes in der Sprache der 
FestplattenHersteller sind 3000 Megabytes.  Rechne also 6185088/3000 (benutze bc(1)).  Du erhältst 2061.
um jetzt Partitionsgrössen für a, d, e, f, g, ... zu erhalten, rechne einfach X*2061
um X Megabytes Platz auf dieser Partition zu erhalten.  Der offset für deine erste Partition
sollte derselbe sein, wie von "sectors/track" vorher in disklabel's Ausgabe angegeben.
Bei uns ist es 63.  Der offset für jede Partition ist hinterher eine Kombination aus der
Grösse und dem Offset jeder anderen Partition (mit Ausnahme der C Partition, da sie keine
Rolle in dieser Gleichung spielt.)
<P>
Wenn du aber nur eine Partition auf deiner Festplatte brauchst, zum Beispiel wenn
das ganze Ding nur zum Ablegen von Webpages oder einem Homedirectory oder etwas anderem 
nutzen willst, nimm einfach die gesamte Grösse der Platte und ziehe die Sektoren pro Track
davon ab.
6185088-63 = 6185025.  Deine Partition ist
<UL><PRE>
    d:  6185025       63    4.2BSD     1024  8192    16 
</PRE></UL>
<P>
<b>Wenn dir das alles unnötig komplex erscheint, kannst du disklabel -E benutzten, um 
den selben Patitionierungsmodus zu erhalten, den du auf deiner Installationsdisk hattest!</b>
Dort kannst du "96M" benutzen, um "96 megabytes" anzugeben.  (Oder, wenn deine Festplatte gross
genug ist, 96G für 96 Gigabyte!) Unglücklicherweise benutzt der -E Modus die 
BIOS Platten-Geometrie und nicht die reale, und oft sind die beiden nicht deckungsgleich.
Um dieses Problem zu umgehen tippe 'g d' für 'geometry disk'.
(Andere Möglichkeiten sind 'g b' für Geometry BIOS' und 'g u' für 
geometry user, oder einfach das, was das Label gesagt hat, bevor disklabel irgendwelche
Änderungen gemacht hat.)
<P>
Das war eine Menge.  Aber du bist noch nicht fertig.  
Zuletzt musst du noch das Dateisystem auf der Festplatte mittels <a href=
"http://www.openbsd.org/cgi-bin/man.cgi?query=newfs
&apropos=0&sektion=8&format=html">newfs(8)</a> erzeugen.
</p>

<p>
<ul><pre>
bsd# <strong>newfs wd1a </strong></pre></ul>
</p>

<p>
Oder wie deine Festplatte auch immer nach dem OpenBSD Plattennummerierungs-Schema heissen mag.  (Guck einfach
in der Ausgabe von dmesg(1) nach, da steht es drin.)
</p>

<p>
Nun überleg dir, wohin du deine gerade neu geschaffene Partition mounten willst.
Sagen wir einfach mal /u.  Daher erzeuge zunächst einmal /u mit 'mkdir'. Dann mounte sie.
</p>

<UL><PRE>
mount /dev/wd1a /u
</PRE></UL>

<P>
Zuletzt musst du sie noch zu /etc/fstab hinzufügen.
</p>
<UL><PRE>/dev/wd1a /u ffs rw 1 1</PRE></UL>

<p>
Was aber, wenn du ein existierendes Verzeichnis, wie zum Beispiel /usr/local auslagern willst? Mounte
die neue Platte unter /mnt und benutze cpio -pdum, um /usr/local in das /mnt Verzeichnis zu kopieren.
Passe  die /etc/fstab so an, dass jetzt die /usr/local Partition auf /dev/wd1a zu finden ist.
(Deine frisch formatierte Partition.) 
Beispiel:
</p>

<ul>
<strong>/dev/wd1a /usr/local ffs rw 1 1</strong>
</ul>

<p>
Reboote in den single user Mode.. <strong>boot -s</strong> Verschiebe das existierende
/usr/local nach /usr/local-backup (oder lösche es gleich, wenn du mutig bist) und erzeuge ein
leeres Verzeichnis /usr/local. Dann reboote das System, und voila! Die Dateien sind da!
</p>

<br>

<p>
<a name="14.4"></a>
<h2>14.4 - Wie man in eine Datei swapt</h2>
</p>

<p>
(Hinweis: wenn du deshalb in eine Datei swappen willst, weil du immer 
&quot;virtual memory exhausted&quot; Fehler bekommst, solltest du lieber
versuchen deine 'per-process limits' zu erhöhen und zwar mit
csh's <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=unlimit&sektion=1&format=html">unlimit(1)</a>,
oder auch mit
sh's <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ulimit&sektion=1&format=html">ulimit(1)</a>.)
</p>

<p>
Nach der Veröffentlichung von OpenBSD 2.5 kam
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=swapctl&sektion=8&format=html">swapctl(8)</a> heraus, 
was den Umgang mit swap devices viel leichter machte. Falls du auf einem OpenBSD 2.5 System arbeitest, tausche swapctl mit swapon, und benutze pstat -s, um 
deine "swap devices" aufzulisten. Das Swappen in eine Datei benötigt keinen
selber gebauten Kernel, obwohl man das natürlich  trotzdem machen kann,
diese FAQ zeigt dir beide Wege den Swap zu erhöhen.
</p>

<h3>In eine Datei swappen. </h3>

<p>
In eine Datei zu swappen ist der einfachste und schnellste Weg, um 
zusätzlichen Swap zu bekommen. Das gilt aber nicht für Benutzer von 
Soft Updates (was ja standardmässig nicht aktiviert ist).
Für den Anfang findest du erstmal heraus, wieviel Swap du momentan hast,
und wieviel du davon benutzt, und das geht einfach mit dem
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=swapctl&sektion=8&format=html">swapctl(8)</a>
Werkzeug. Zum Beispiel mit diesem Kommando:
</p>

<ul><pre>
ericj@oshibana&gt; <strong>swapctl -l</strong>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
</pre></ul>

<p>
Das zeigt alle Geräte, die momentan für das swappen benutzt werden,
und ihre momentane Statistik. Im obigen Beispiel gibt es nur ein Gerät namens 
&quot;swap_device&quot;. Das ist der vordefinierte Bereich auf der Platte, der für das Swappen benutzt wird. 
(Wird im übrigen als Partition 'b' bei 'disklabel' angezeigt). Wie du auch sehen kannst, wird das Gerät
zur Zeit nicht sonderlich belastet oder vielmehr benutzt. Aber für den Zweck dieses Dokumentes tun wir einfach
so, als wenn noch weitere 32MB benötigt würden.
</p>
<p>
Der erste Schritt um eine Datei als Swap-Bereich zu nutzen, ist, die Datei zu erzeugen. Am besten macht man
das mit Hilfe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&sektion=1&format=html">dd(1)</a>
Hier ist ein Beispiel, das eine Datei <i>/var/swap</i> mit der Grösse von 32MB erzeugt.
</p>

<ul><pre>
ericj@oshibana&gt; <strong>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</strong>
32768+0 records in
32768+0 records out
33554432 bytes transferred in 20 secs (1677721 bytes/sec)
</pre></ul>

<p>
Nachdem das erledigt ist, können wir jetzt das swappen auf diese Datei richten. Benutze einfach das folgende
Kommando, um das Swappen auf diese Datei zu lenken
</p>

<ul><pre>
ericj@oshibana&gt; <strong>sudo chmod 600 /var/swap</strong>
ericj@oshibana&gt; <strong>sudo swapctl -a /var/swap</strong>
</pre></ul>

<p>
Jetzt müssen wir noch prüfen, ob sie auch korrekt zu unserer Liste der Swap-Geräte hinzugefügt wurde.
</p>

<ul><pre>
ericj@oshibana&gt; <strong>swapctl -l</strong>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
/var/swap        65536        0    65536     0%    0
Total           131056        8   131048     0%
</pre></ul>

<p>
Jetzt, wo die Datei erzeugt wurde und in sie hinein geswappt wird, musst du noch eine Zeile in deine
<i>/etc/fstab</i> Datei hineinschreiben, so dass die Datei beim nächsten Booten auch benutzt wird.
Wenn diese Zeile nicht hinzugefügt wird, wird dieses Swap-Gerät eben nicht konfiguriert.
</p>

<ul><pre>
ericj@oshibana&gt; <strong>cat /etc/fstab</strong>
/dev/wd0a / ffs rw 1 1
/var/swap /var/swap swap sw 0 0
</pre></ul>

<h3>Swappen über ein vnode Gerät</h3>

<p>
Dies ist eine dauerhaftere Lösung, um mehr Swap-Speicher zu erhalten. Um in eine Datei zu swappen,
erzeuge zunächst einen Kernel mit vnd0c als swap. Wenn du wd0a als root Dateisystem hast, und wd0b als bisherigen swap, 
benutze diese Zeile in deiner Kernel Konfigurations-Datei (wenn du dir nicht sicher bist, sieh dir die Sektion "Einen neuen
Kernel kompilieren" in dieser FAQ an): 
</p>

<ul><pre>
config          bsd     root on wd0a swap on wd0b and vnd0c dumps on wd0b
</pre></ul>

<p>
Nachdem das erledigt ist, muss die Datei, in die geswappt werden soll, erzeugt werden. Du solltest mit dem selben Kommando wie 
im Beispiel oben machen.
</p>

<ul><pre>
ericj@oshibana&gt; <strong>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</strong>
32768+0 records in
32768+0 records out
33554432 bytes transferred in 20 secs (1677721 bytes/sec)
</pre></ul>

<p>
Da deine Datei jetzt an ihrem Platz ist, musst du die Datei in die <i>/etc/fstab</i> eintragen. Hier ist eine Beispielzeile,
mit der man dieses Gerät beim booten als Swap benutzt.
</p>

<ul><pre>
ericj@oshibana&gt; <strong>cat /etc/fstab</strong>
/dev/wd0a / ffs rw 1 1
/dev/vnd0c none swap sw 0 0 
</pre></ul>

<p>
An diesem Punkt muss dein Computer neu gebootet werden, so dass die Änderungen am Kernel Effekt haben. Nachdem das 
passiert ist, ist es an der Zeit, das Gerät als swap zu konfigurieren. Dazu wirst du <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&sektion=8&format=html">vnconfig(8)</a> benutzen.
</p>

<ul><pre>
ericj@oshibana&gt; <strong>sudo vnconfig -c -v vnd0 /var/swap</strong>
vnd0: 33554432 bytes on /var/swap
</pre></ul>

<p>
Als letzten Schritt, musst du den Swap auf diesem Gerät noch einschalten. Wir machen das genau wie in dem Beispiel oben mit
swapctl(8). Und zuletzt prüfen wir wieder, ob es auch korrekt in unsere Tabelle eingetragen wurde. 
</p>

<ul><pre>
ericj@oshibana&gt; <strong>sudo swapctl -a /dev/vnd0c</strong>
ericj@oshibana&gt; <strong>swapctl -l</strong>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
/dev/vnd0c       65536        0    65536     0%    0
Total           131056        8   131048     0%
</pre></ul>



<p><a name="14.5"></a>
<h2>14.5 - Soft Updates</h2>
</p>

<p>
In den letzten paar Jahren hat Kirk McKusick an etwas gearbeitet, was 
"Soft Updates" genannt wird. Es basiert auf einer Idee von Greg Ganger und Yale
Patt, die besagt, dass ein teilweises Ordnen der "buffer cache" Operationen die
Notwendigkeit des synchronen Schreibens von Verzeichnis Einträgen im FFS
Code überflüssig machen würde. Ergo ein großer Performance-Gewinn
beim Schreiben auf Festplatten.<br>
Da Soft Updates sich im Ganzen noch in Entwicklung befinden, wird ein fsck nach einem 
abrupten Abschalten des Computers ohne saubere Shutdown Sequenz immer noch notwendig sein,
das wird aber in zukünftigen Versionen entfallen.<p>
Mehr Interna und Details über Soft Updates kann man in den Untersuchungen von
<a href="http://www.ece.cmu.edu/~ganger/papers/CSE-TR-254-95/">Ganger und Patt</a> 
und auch von <a href="http://www.mckusick.com/softdep/index.html">McKusick</a> finden. 

</p>

<p>
Um Softupdates aktivieren zu können, muss dein Kernel folgende Option haben:
</p>

<p>
<strong>option FFS_SOFTUPDATES</strong>
</p>

<p>
Diese Option ist beginnend mit OpenBSD Version 2.9 im GENERIC Kernel enthalten. Trotzdem musst du sie pro 
mount-Point mit Hilfe einer mount-Option aktivieren.
</p>

<p>
Beginnend mit 2.9 werden die soft updates durch eine "mount time" Option anstelle von 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tunefs&sektion=8">tunefs(8)</a> aktiviert. Wenn du jetzt 
eine Partition mit dem  <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&sektion=8">mount(8)</a> 
Utility mountest, kannst du angeben, dass soft updates auf dieser Partition aktiviert sein sollen. Unten ein 
beispielhafter <i>/etc/fstab</i> Eintrag, der eine Partition <i>sd0a</i> hat, die wir mit soft updates gemountet haben wollen.
</p>

<ul><pre>
/dev/sd0a / ffs rw,softdep 1 1
</pre></ul>

<p>
Wenn du eine ältere OpenBSD Version als 2.9 verwendest, boote in den single-user mode:
</p>

<ul>
<pre>
        boot> <strong>boot -s</strong>
        [snip]
        bsd# <strong>tunefs -s enable &lt;raw device&gt;</strong>
        bsd# <strong>reboot -n</strong>
</pre>
</ul>

<p>
Hinweis für Sparc User: Auf sun4 und sun4c Maschinen sollten soft updates nicht eingeschaltet werden.
Diese Archiktekturen unterstützen nur eine sehr begrenzte Menge an Kernel Speicher und können dieses Feature
nicht nutzen.
</p>

<p>
<a name="4.6"></a>
<h2>14.6 -  Wenn ich nach der Installation von OpenBSD/i386 boote, stoppt der Rechner bei "Using partition 3 id 0".</h2>
</p>
<p>
Das bedeutet, dass dein MBR (Master Boot Record) nicht sauber installiert wurde oder dass dein 
BIOS eine andere Idee hat, was die Geometrie deiner Fesplatte angeht, und zwar eine die nicht kompatibel ist
mit deinem jetzigen MBR. Um das Problem zu lösen, solltest du zuerst versuchen, den OpenBSD boot block erneut
zu installieren. Dazu lese
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&sektion=8&arch=i386&format=html">fdisk(8)</a> und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=installboot&sektion=8&arch=i386&format=html">installboot(8)</a>.
<P>
Um es zunächst zum Laufen zu kriegen, musst du deine boot disk als bootstrap benutzen.
Danach tust du deine Install Disk rein, und bevor sie den Kernel und die ramdisk lädt, bekommst
du einen <tt>boot&gt;</tt> Prompt von der Floppy Disk.  Benutze ihn, um OpenBSD von deiner Festplatte zu booten.
<ul><pre>
booting...
OpenBSD boot 1.2.3
probing hd0 fd0...
boot&gt; <b>boot hd0a:/bsd</b>
</pre></ul>
Jetzt, da du gebootet hast, und unter der Vorraussetzung, dass du deine ganze
Festplatte für OpenBSD reserviert hast, kannst du den Master Boot Record  mit fdisk(8) reinitialisieren.
(Falls du auf deiner Festplatte Partitionen für andere Betriebssystem hast, kannst du auf keinen Fall 
<tt>installboot</tt> verwenden, stattdessen musst du dir eine andere Option wie z.B. OS-BS ansehen,
siehe weiter unten)
<UL><PRE>
# <b>fdisk -i wd0</b>
</PRE></UL>
Jetzt musst du die boot blocks wieder schreiben.
<UL><PRE>
# <strong>cp /usr/mdec/boot /boot</strong>
# <strong>/usr/mdec/installboot -v /boot /usr/mdec/biosboot wd0</strong>
</PRE></UL>
Und zum Schluss musst du rebooten und es testen.
<p>
Wenn das nicht funktioniert hat, hast du immer noch ein paar Optionen. Deine Glückssträhne ist
also noch nicht zu Ende. Die erste ist, einen Bootloader wie OS-BS zu verwenden. Auf der OpenBSD CD-ROM 
ist der os-bs Bootloader im 'tools' Verzeichnis. Wenn du keine CD-ROM gekauft hast, kannst du os-bs von jedem
OpenBSD ftp-Mirror herunterladen. Die benötigte Datei ist 
<tt>pub/OpenBSD/2.8/tools/osbs135.exe</tt>
</p>

<p>
Nimm dir auch die Zeit, dir die OS-BS Webseiten anzusehen: 
<a href="http://www.prz.tu-berlin.de/~wolf/os-bs.html">
         http://www.prz.tu-berlin.de/~wolf/os-bs.html</a>
</p>

<p>
Es gibt auch einige andere kommerzielle Bootloader oder auch lilo, die du für das 
multi-booting nehmen kannst.
</p>

<p>
Hier ist eine kleine Anweisung, wie du lilo auf dein System bekommst.
</p>

<p>
<ul>
<li>Boote mit einer DOS floppy und gib ein "fdisk /MBR" ein. Stelle sicher, dass du auch auf
der Festplatte bist, von der du booten willst.</li>
<li>Boote von einer Linux Disk, installiere LILO &amp; und verknüpfe es mit deinem OpenBSD 
Bootblock.
</li>
</ul>
</p>

<p>
Ausführlichere Anweisungen gibt es in <a href="ftp://ftp.openbsd.org/pub/OpenBSD/2.8/i386/INSTALL.linux">INSTALL.linux</a>
</p>

<br>

<p>
<a name="14.7"></a>
<h2>14.7 - Wie man ein dmesg von einer Boot-Floppy bekommt</h2>

</p>
<p>
RAMDISK Images (boot floppies) enthalten das <i>dmesg</i> Werkzeug leider nicht.
Sie mounten aber das <code>/kern</code> Dateisystem. Um die dmesg Informationen in eine
Datei zu kopieren kannst du z.B. folgendes eingeben:
</p>

<ul><pre>
# <strong>cat /kern/msgbuf >mydmesg</strong>
</pre></ul>
<P>
Boot disks enthalten aber 'more', um seitenweise durch die Ausgabe zu scrollen :
<pre><ul>
# <strong>more /kern/msgbuf</strong>
</pre></ul>

Prüfe auch die <a href="faq4.html#4.5">Sektion 4.5</a>

<p>
<a name="14.8"></a>
<h2>14.8 - Bootblocks installieren - i386 spezifisch</h2>
</p>

<p>
Ältere Versionen von MS-DOS können nur mit Festplattengeometrien von 1024 Zylindern
oder weniger klarkommen.  Da nahezu alle modernen Betriebssysteme mehr als 1024 Zylinder haben,
haben die meisten SCSI BIOS Chips (die auf den SCSI Controller Karten) und IDE BIOSse
(was Teil des restlichen PC BIOS ist) eine Option, manchmal auch als Grundeinstellung, die 
wirkliche Geometrie in etwas zu übersetzen, mit dem MS-DOS umgehen kann.
Wie dem auch sei, nicht alle BIOS Chips "übersetzen" die Geometrie in der selben Weise.
Wenn du dein BIOS wechselst (entweder mit einem neuen Motherboard oder einem neuen SCSI
Controller), und das neue benutzt eine andere "übersetzte" Geometrie, wirst du nicht
in der Lage sein den 'second stage boot loader' zu laden (und kannst daher den Kernel auch nicht laden)
(Das liegt daran, dass der 'first stage boot loader' eine Liste der Blöcke enthält, die
/boot in der "übersetzten" Geometrie enthalten.)
Falls du IDE Platten benutzt, und du Änderungen an deinen BIOS Einstellungen machst,
kannst du seine Übersetzung ebenfalls (ungewollt) ändern. (die meisten IDE BIOSse bieten 3 verschiedene
Übersetzungen.) Um deinen Bootblock zu reparieren, damit du normal booten kannst,
stecke einfach eine Boot floppy in dein Floppy-Laufwerk und gib am Bootprompt
"b hd0a:/bsd" ein, um ihn zu zwingen, von der ersten Festplatte zu booten (und nicht von der Floppy).
Deine Maschine sollte normal booten. Jetzt musst du die erste Stufe des Bootloaders auf den neuen Stand bringen.
(und dazu passend den Boot block schreiben).
<br>
Unser Beispiel geht davon aus, dass deine boot disk sd0 ist (bei IDE wäre es wd0, etc..) :
</p>
<ul>
<pre>
# <strong>cd /usr/mdec; ./installboot /boot biosboot sd0</strong>
</pre>
</ul>
<p>
Wenn installboot sich darüber beschwert, dass es die BIOS Geometrie nicht lesen kann, kannst du 
am boot&gt; Prompt das &quot;machine diskinfo&quot; (oder kürzer
&quot;ma di&quot; ) Kommando eingeben, damit es die Informationen ausgibt, die du brauchst.
Füttere die &quot;heads&quot; und &quot;secs&quot; Werte in installboot's -h
und -s Flags, so dass das modifizierte installboot Kommando wie folgt aussieht:
</p>
<ul><pre>
#<strong> cd /usr/mdec; ./installboot -h &lt;heads&gt; -s &lt;secs&gt; /boot biosboot sd0</strong>
</pre></ul>

<p>
Wenn eine neuere Version von bootblocks benötigt wird, wirst du diese selber kompilieren müssen. Und das geht so:
</p>

<ul><pre>
# <strong>cd /sys/arch/i386/stand/</strong>
# <strong>make && make install </strong>
# <strong>cd /usr/mdec; cp ./boot /boot</strong>
# <strong>./installboot /boot biosboot sd0</strong> (oder wie deine Festplatte auch immer heissen mag)
</pre></ul>

<p>
<a name="14.9"></a>
<h2>14.9 - Auf die Katastrophe vorbereiten: Backups machen und Wiederherstellen mit Bändern (tapes)</h2>
</p>

<h3>Einführung:</h3>

<p>
Wenn du so etwas wie einen Poduktionsserver laufen lassen willst, ist es ratsam irgendeine Form von Backup zu haben,
für den Fall, dass eine deiner Festplatten versagt oder einen Crash hat.
</p>

<p>
Diese Information wird dir helfen die Standard-Werkzeuge <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&sektion=8&format=html">dump(8)</a> und <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&sektion=8&format=html">restore(8)</a> zu benutzen, die als Teil von OpenBSD ausgeliefert werden. 
Ein fortgeschritteneres Werkzeug ist "Amanda", das auch multiple Server auf ein Tape-Drive sichern kann. In den meisten Umgebungen sind 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&sektion=8&format=html">dump(8)</a>/<a href=http://www.openbsd.org/cgi-bin/man.cgi?query=restore&sektion=8&format=html">restore(8)</a> aber ausreichend. 
Wenn du aber multiple Maschinen auf ein Band sichern willst, ist Amanda auf jeden Fall einen Blick wert.
</p>

<p>
Die Beispiele in diesem Dokument benutzen sowohl SCSI Festplatten, als auch Tapes. In einer Produktionsumgebung empfehlen wir SCSI und kein
IDE wegen der Art und Weise, wie IDE mit 'bad blocks' umgeht. Das heisst aber nicht, dass diese Informationen nutzlos sind, wenn 
du IDE benutzt,  sondern einzig deine Gerätenamen werden sich leicht unterscheiden.  Zum Beispiel wäre sd0a in einem
IDE-basierten System wd0a.
</p>

<h3>Backup auf's Tape bringen:</h3>

<p>
Um sein Backup auf ein Band zu bringen, muss man wissen, wo seine Dateisysteme gemountet sind. Das findet man mit dem 
"mount"-Kommando am Shell-Prompt heraus. Dabei sollte eine Ausgabe wie diese herauskommen:
</p>

<ul><pre>
shell# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0h on /usr type ffs (local)  
</pre></ul>

<p>
In diesem Beispiel ist das root-Dateisystem (/) physikalisch auf sd0a, also auf der SCSI-Festplatte 0, Partition a. Das /usr 
Dateisystem befindet sich auf sd0h, also SCSI Festplatte 0, Partition h.
</p>

<p>
Ein weiteres Beispiel einer etwas grösseren mount-Tabelle könnte so aussehen:
</p>

<ul><pre>
shell# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0d on /var type ffs (local)
/dev/sd0e on /home type ffs (local)
/dev/sd0h on /usr type ffs (local)  
</pre></ul>

<p>
In diesem fortgeschritteneren Beispiel befindet sich das root (/) Dateisystem auf sd0a. Das /var Dateisystem befindet sich auf sd0d, das /home 
Dateisystem auf sd0e und /usr auf sd0h.
</p>

<p>
Um ein Backup deiner Maschine zu machen, musst du 'dump' mit jeder festgelegten Partition füttern. Hier ist ein
Beispiel der Kommandos, um die einfachere mount-Tabelle weiter oben zu sichern:
</p>

<ul><pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h</b>
# <b>mt -f /dev/rst0 rewind  </b>
</pre></ul>

<p>
Für die etwas fortgeschrittenere mount-Tabelle würde man etwas wie das hier benutzen:
</p>

<ul><pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h  </b>
# <b>mt -f /dev/rst0 rewind  </b>
</pre></ul>

<p>
Sieh dir einfach die dump-man-page für genauere Angaben über jedes Befehlsargument an.
</p>

<ul>
<li><b>0</b> - Führe einen Level 0 Dump durch, hole alles
<li><b>a</b> - Versuche automatisch die Bandlänge herauszufinden
<li><b>u</b> - Bringe die Datei /etc/dumpdates auf den neuesten Stand, um zu reflektieren, wann die letzte Sicherung gemacht wurde
<li><b>f</b> - Welches Bandlaufwerk benutzt werden soll (/dev/nrst0 in diesem Fall)
</ul>

<p>
Zuletzt welche Partition gesichert werden soll (/dev/rsd0a, usw.)
</p>

<p>
Das mt Kommando wird am Ende benutzt, um das Band zurückzuspulen. Sieh dir die mt man page an, wenn du mehr Informationen
haben willst (wie etwa eject).
</p>

<p>
Wenn du dir nicht sicher bist, wie dein Bandlaufwerk heisst, benutze einfach dmesg, um das herauzufinden. Ein Beispiel-Eintrag von
dmesg für ein Bandlaufwerk könnte so aussehen:
</p>

<ul><pre>
st0 at scsibus0 targ 5 lun 0: <ARCHIVE, Python 28388-XXX, 5.28>
</pre></ul>

<p>
Du hast vielleicht bemerkt, dass bei der Sicherung das Bandlaufwerk als "nrst0" anstatt von "sto" bezeichnet wird, wie man es in dmesg sieht.
Wenn du auf st0 als nrst0 zugreifst, benutzt du das selbe physikalische Gerät, aber sagst dem Gerät, es solle nicht 
zurückspulen, nachdem der Job im raw mode beendet wurde. Um multiple Dateien auf ein einziges Band zu sichern, stelle sicher, dass du 
nicht zurückspulst, sprich das richtige Gerät benutzt, ansonsten wirst du mit der zweiten Sicherung die erste überschreiben,
usw. Du findest in der dump man page eine ausführlichere Beschreibung.
</p>

<p>
Wenn du ein kleines Skript namens "backup" schreiben würdest, könnte es z.B. so aussehen:
</p>

<ul><pre>
echo "  Starting Full Backup..."
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h
echo
echo -n "  Rewinding Drive, Please wait..."
mt -f /dev/rst0 rewind
echo "Done."
echo                      
</pre></ul>

<p>
Wenn regelmässige nächtliche Backups gefordert sind, könnte man <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cron&sektion=8&format=html">cron(8)</a> benutzen, um das Backup jede Nacht automatisch zu starten.
</p>

<p>
Es ist ausserdem hilfreich, auf einem Blatt Papier aufzuschreiben, wie groß jedes Dateisystem sein muss. Du kannst df -h benutzen,
um herauszufinden, wieviel Platz jede Partition momentan verbraucht. Das ist dann nützlich, wenn eine Platte versagt, und
du die Partitionstabelle auf der neuen Platte wieder erstellen musst.
</p>

<p>
Deine Daten wiederherzustellen hilft ausserdem noch gegen Fragmentierung. Der beste Weg, um sicherzustellen, dass du alle Dateien erwischst, 
ist es, im Single-User-Mode zu booten. Dateisysteme müssen nicht gemountet werden, um gesichert zu werden. Vergiss aber nicht root (/)
zu mounten, denn sonst wird dein dump versagen, wenn er versucht Dumpdaten zu schreiben. Gib einfach bsd -s am Boot-Prompt ein, um in
den Single-User-Modus zu kommen.
</p>

<h3>Den Inhalt eines dump Bandes ansehen:</h3>


<p>
Nachdem du deine Dateisysteme zum ersten Mal gesichert hast, ist es sicher eine gute Idee dein Band zu testen und sicherzustellen,
dass es auch die Daten enthält, die darauf sein sollen.
</p>

<p>
Du kannst den folgenden Befehl benutzen, um eine Auflistung der Dateien auf einem 'dump' Band zu bekommen:
</p>

<ul><pre>
# <b>/sbin/restore -tvs 1 -f /dev/rst0</b>
</pre></ul>

<p>
Das listet die Dateien auf der 1. Partition auf dem dump Band (dem Sicherungsband) auf. Wie in den Beispielen weiter oben, ist 1 
dein root (/) Dateisystem.
</p>

<p>
Um den Inhalt der zweiten Partition zu sehen und die Ausgabe in eine Datei umzulenken, würde man z.B. solch ein Kommando 
benutzen:
</p>

<ul><pre>
# <b>/sbin/restore -tvs 2 -f /dev/rst0 > /home/me/list.txt</b>
</pre></ul>

<p>
Wenn du eine mount-Tabelle wie die oben aufgeführte hast, wäre 2 /usr, wenn deine aber etwas grösser wäre, könnte
2 auch /var sein oder irgendwas anderes. Die Sequenznummer ist auf jeden Fall die gleiche Reihenfolge, in der das Dateisystem auf Band 
gesichert wird.
</p>


<h3>Wiederherstellen vom Band:</h3>

<p>
Das Beispielszenario wäre sinnvoll, wenn deine eigentliche Festplatte komplett ausgefallen wäre. Falls du aber nur eine einzige 
Datei wieder herstellen willst, sieh dir die restore man page genau an, und achte besonders auf die Anweisungen zum interaktiven Modus.
</p>

<p>
Wenn du gut vorbereitet bist, kann der Prozess des Ersetzens einer Festplatte sehr schnell von statten gehen. Die Standard OpenBSD 
install/boot floppy enthält bereits das benötigte restore Werkzeug, genauso wie die ausführbaren Dateien, um neue Partitionen
zu erstellen, und deine Festplatte bootbar zu machen. In den meisten Fällen sind diese Floppy und dein Sicherungsband alles, was
du brauchst, um wieder alles betriebsbereit zu bekommen.
</p>

<p>
Nachdem du das kaputte Laufwerk physikalisch ersetzt hast, sind die grundlegenden Schritte zur Wiederherstellung folgende:
</p>

<ul>
<li>
<p>
Boote von der OpenBSD install/boot floppy. An der Menüauswahl wähle Shell. Nimm dein neuestes und schreibgeschütztes
Band und packe es in dein Laufwerk.
<br>
</p>

<li>
<p>
Benutze das <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&sektion=8&arch=i386&format=html">fdisk(8)</a> Kommando, um eine primäre
OpenBSD Partition auf dieser neu installierten Festplatte zu erzeugen. Z.B.:
</p>

<ul><pre>
shell# <b>fdisk -e sd0</b>
</pre></ul>

<p>
Sieh einfach in die <a href="#14.2">fdisk FAQ</a> um genaueres zu erfahren.
</p>

<li>
<p>  
Mit dem disklabel Kommando stellst du dann deine OpenBSD Partitionstabelle in der primären OpenBSD Partition wieder her, die du gerade 
mit fdisk erzeugt hast. Z.B.:
</p>

<ul><pre>
shell# <b>disklabel -E sd0</b>
</pre></ul>

<p>
(Vergiss den swap nicht, siehe dazu die <a href="#14.1">disklabel FAQ</a>)
</p>

<li>
<p>
Benutze das newfs Kommando, um ein neues sauberes Dateisystem auf jeder Partition zu erstellen, die du mit dem oben aufgeführten 
Schritt erstellt hast. Z.B.:
</p>

<ul><pre>
shell# <b>newfs /dev/rsd0a</b>
shell# <b>newfs /dev/rsd0h</b>
</pre></ul>

<li>
<p>
Mounte dein neu vorbereitetes root (/) Dateisystem auf /mnt. Beispiel:
</p>

<ul><pre>
shell# <b>mount /dev/sd0a /mnt</b>
</pre></ul>

<li>
<p>
Gehe in das gemountete root Dateisystem und beginne mit dem restore Prozess. Beispiel: 
</p>

<ul><pre>
shell# <b>cd /mnt</b>
shell# <b>restore -rs 1 -f /dev/rst0</b>
</pre></ul>

<li>
<p>
Wenn die Platte bootbar sein soll, schreibe mit dem folgenden Befehl einen neuen MBR auf deine Festplatte:
</p>

<ul><pre>
shell# <b>fdisk -i sd0</b>
</pre></ul>

<li>
<p>
Zusätzlich zum Schreiben eines neuen MBR musst du boot blocks installieren, um davon booten zu können.
Das folgende ist ein kurzes Beispiel:
</p>

<ul><pre>
shell# <b>cp /usr/mdec/boot /mnt/boot</b>
shell# <b>/usr/mdec/installboot -v /mnt/boot /usr/mdec/biosboot sd0</b>
</pre></ul>

<li>
<p>
Dein neues root Dateisystem auf der eingebauten Festplatte sollte jetzt fertig sein, so dass du davon booten kannst und damit beginnen
kannst, den Rest der Dateien wiederherzustellen. Da dein Betriebssystem noch nicht komplett ist, solltest du alles im single-User Modus
wiederherstellen. Am shell prompt benutze die folgende Kommandos, um deine Festplatten "abzumelden" (umount) und das
System anzuhalten:
</p>

<ul><pre>
shell# <b>umount /mnt</b>
shell# <b>halt</b>
</pre></ul>

<li>
<p>
Entferne die Install/boot floppy aus dem Laufwerk und reboote dein System. Am OpenBSD boot&gt; prompt benutze das folgende Kommando:
</p>

<ul><pre>
boot&gt; <b>bsd -s</b>
</pre></ul>

<p>
Das bsd -s führt dazu, dass der Kernel im Single-User-Modus gestartet wird, der nur ein root (/) Dateisystem braucht.
</p>

<li>
<p>
Unter der Annahme, das du die obigen Schritte  richtig ausgführt hast und nichts schief gegangen ist, solltest du von einem Prompt begrüsst
werden, der dich nach einem Pfad zu einer Shell fragt, oder du sollst Return drücken. Drücke return, um die sh zu benutzen.
Als nächstes willst du sicher root im r/w Modus (Schreib/Lese) remounten, und nicht mehr im Nur-Lese-Modus benutzen (ro)
Dazu benutze folgendes: 
</p>

<ul><pre>
shell# <b>mount -u -w /</b>
</pre></ul>

<li>
<p>
Sobald du im r/w Modus remountet hast, kannst du fortfahren deine restlichen Dateisysteme wiederherzustellen. Beispiel:
</p>

<ul><pre>
(einfache mount Tabelle)
shell# <b>mount /dev/sd0h /usr; cd /usr; restore -rs 2 -f /dev/rst0</b>

(etwas umfassendere mount Tabelle)
shell#	<b>mount /dev/sd0d /var; cd /var; restore -rs 2 -f /dev/rst0</b>
shell#	<b>mount /dev/sd0e /home; cd /home; restore -rs 3 -f /dev/rst0</b>
shell#	<b>mount /dev/sd0h /usr; cd /usr; restore -rs 4 -f /dev/rst0</b>
</pre></ul>

<p>
Benutze "<b>restore rvsf</b>" anstatt eines einfachen rsf um die Namen von Objekten zu sehen, während sie vom dump set
ausgepackt werden.
</p>

<li>
<p>
Nachdem du jetzt auch alle Dateien der anderen Dateisysteme wiederhergestellt hast, führe einen reboot in den Multi-User-Modus durch.
Wenn alles geklappt hat, sollte dein System wieder genauso sein, wie zum Zeitpunkt deiner letzten Sicherung, und wieder normal zu benutzen.
</p>
</ul>

<p>

<a name=14.10></a>
<h2>14.10 - Disk Images in OpenBSD mounten</h2>
</p>

<p>
Um ein Disk Image (ISO images, Disk images, die mit  dd erstellt wurden, etc) in OpenBSD
zu moutnen, musst du ein <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnd&sektion=4">vnd(4)</a> Device/Gerät konfigurieren. 
Zum Beispiel, wenn du ein ISO Image unter <i>/tmp/ISO.image</i> hast, würdest du die folgenden Schritte machen, um es zu mounten:
</p>

<ul>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<pre>
# <strong>vnconfig svnd0 /tmp/ISO.image</strong>
# <strong>mount -t cd9660 /dev/svnd0c /mnt</strong>
</pre>
                </td>
        </tr>
</table>
</ul>

<p>
Bedenke bitte, daß du den Typ <i>cd9660</i> angeben musst, wenn es eine CD ist. Das gilt aber auch für die 
anderen Typen, also musst du z.B. ffs beim mounten eines disk images angeben. 
</p>

<p>
Um das Image wieder 'unzumounten' benutze die folgenden Kommandos:
</p>

<ul>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<pre>
# <strong>umount /mnt</strong>
# <strong>vnconfig -u svnd0</strong>
</pre>
                </td>
        </tr>
</table>
</ul>

<p>
Mehr Informationen gibt es in der
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&sektion=8">vnconfig(8)</a> man page.
</p>


<p>
<a name=14.11></a>
<h2>14.11 - Hilfe! Ich erhalte Fehler mit PCIIDE!</h2>
</p>

<p>
PCI IDE DMA ist unzuverlässig. Darum schaltet Microsoft es auch bei seinen
Betriebssystemen grundsätzlich ab.
</p>

<p>
OpenBSD ist aggressiv und versucht den höchsten DMA Modus zu benutzen, den es kriegen kann.
Dies führt in einigen Konfigurationen zu Datenkorruptionen aufgrund von defekten Motherboard Chipsets,
Treibern, die buggy sind und/oder Lärm auf den Kabeln. Glücklicherweise schützt Ultra-DMA
die Daten Transfers mit einem CRC, um Korruptionen zu entdecken. Falls ein Fehler bei einem solchen 
Ultra-DMA CRC geschieht, wird OpenBSD eine Fehlermeldung ausgeben, und erneut versuchen die Daten 
zu übertragen.
</p>

<ul><pre>
wd2a:  aborted command, interface CRC error reading fsbn 64 of 64-79 (wd2 bn 127; cn 0 tn 2 sn 1), retrying
</pre></ul>

<p>
Nach ein paar Fehlversuchen, wird OpenBSD zu einem langsameren (und damit hoffentlich 
zuverlässigeren) DMA-Modus herunterschalten. Nach den Ultra-DMA Modi wird 
dann zu einem PIO Modus heruntergeschaltet.
</p>

<p>
Falls OpenBSD nicht erfolgreich herunterschalten kann, oder der Prozess zu einem "Hard-Lock"
deiner Maschine führt, schicke uns bitte einen 
<a href="../../de/report.html">bug report</a>.
</p>

<p>
<font color= "#0000e0">
<a href= "index.html">[Zurück zu Haupt-Index]</a>
<a href= "../faq13.html">[Zu Sektion 13.0 - IPsec]</a>
</font>
</p>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt="[back]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small> 
Originally [OpenBSD: faq14.html,v 1.48 ]
<br>
$Translation: faq14.html,v 1.23 2004/11/02 18:04:29 jufi Exp $
<br></small>
<small>$OpenBSD: faq14.html,v 1.21 2004/11/02 18:40:59 jufi Exp $</small>
</p>
</body>
</html>
