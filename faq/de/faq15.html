<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>15 - Das Packages- und Portssystem von OpenBSD</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
</head>

<!--
Copyright (c) 2005-2008 Steven Mestdagh <steven@openbsd.org>

Permission to use, copy, modify, and distribute this documentation for
any purpose with or without fee is hereby granted, provided that the
above copyright notice and this permission notice appear in all copies.

THE DOCUMENTATION IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
WARRANTIES WITH REGARD TO THIS DOCUMENTATION INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS DOCUMENTATION
-->

<body bgcolor= "#ffffff" text= "#000000">

<a href="../../de/index.html">
<img alt="[OpenBSD]" height=30 width=141
src="../../images/smalltitle.gif" border="
0">
</a>
<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ-Index]</a>
<a href= "faq14.html">[Zum Kapitel 14 - Platteneinrichtung]</a>
</font>

<h1><font color="#e00000">15 - Das Packages- und Portssystem von
OpenBSD</font></h1><hr>

<h3>Inhaltsverzeichnis</h3>
<ul>
<li><a href="#Intro"          >15.1 - Einführung</a>
<li><a href="#PkgMgmt"        >15.2 - Verwaltung der Packages</a>
  <ul>
  <li><a href="#PkgHow"       >15.2.1 - Wie funktioniert das?</a>
  <li><a href="#Easy"         >15.2.2 - Dinge einfach gestalten</a>
  <li><a href="#PkgFind"      >15.2.3 - Packages finden</a>
  <li><a href="#PkgInstall"   >15.2.4 - Neue Packages installieren</a>
  <li><a href="#PkgList"      >15.2.5 - Installierte Packages
      auflisten</a>
  <li><a href="#PkgUpdate"    >15.2.6 - Installierte Packages
      aktualisieren</a>
  <li><a href="#PkgRemove"    >15.2.7 - Installierte Packages
      deinstallieren</a>
<!--  <li><a href="#PkgSecurity"  >15.2.8 - Sicherheitsupdates (Packages für
      -stable)</a> -->
  <li><a href="#PkgPartial"   >15.2.8 - Unvollständige
      Package(de)installation</a>
  </ul>
<li><a href="#Ports"          >15.3 - Mit Ports arbeiten</a>
  <ul>
  <li><a href="#PortsHow"     >15.3.1 - Wie funktioniert das?</a>
  <li><a href="#PortsFetch"   >15.3.2 - Den Ports-Tree beziehen</a>
  <li><a href="#PortsConfig"  >15.3.3 - Konfiguration des
     Ports-Systems</a>
  <li><a href="#PortsSearch"  >15.3.4 - Den Ports-Tree durchsuchen</a>
  <li><a href="#PortsInstall" >15.3.5 - Unkomplizierte Installation:
     ein einfaches Beispiel</a>
  <li><a href="#PortsClean"   >15.3.6 - Nach dem Build aufräumen</a>
  <li><a href="#PortsDelete"  >15.3.7 - Das Package eines Ports
     deinstallieren</a>
  <li><a href="#PortsFlavors" >15.3.8 - Flavors und Subpackages
     verwenden</a>
<!--  <li><a href="#PortsSecurity">15.3.9 - Sicherheitsupdates (-stable)</a> -->
  </ul>
<li><a href="#PkgFAQ"         >15.4 - FAQ</a>
  <ul>
  <li><a href="#NoFun"        >15.4.1 - Ich bekomme alle möglichen
     unverständlichen Fehlermeldungen. Ich schaffe es einfach nicht,
     diesen Portskram zum Laufen zu kriegen.</a>
  <li><a href="#Latest"       >15.4.2 - Die aktuellste Version meiner
     Lieblingssoftware ist nicht verfügbar!</a>
  <li><a href="#NoPkg"        >15.4.3 - Warum gibt es kein Package
     meiner Lieblingssoftware?</a>
  <li><a href="#NoPort"       >15.4.4 - Warum gibt es keinen Port
     meiner Lieblingssoftware?</a>
  <li><a href="#NotInBase"    >15.4.5 - Warum ist meine
     Lieblingssoftware nicht Teil des Basissystems?</a>
  <li><a href="#PkgVsPorts"   >15.4.6 - Was sollte ich verwenden:
     Packages oder Ports?</a>
  <li><a href="#Knobs"        >15.4.7 - Wie optimiere ich diese Ports,
     damit sie bestmögliche Leistung bieten?</a>
  <li><a href="#Wait"         >15.4.8 - Ich habe einen neuen Port/ein
     neues Update vor Wochen bereitgestellt. Warum wird er/es nicht
     eingebunden?</a>
  </ul>
<li><a href="#Problems"       >15.5 - Probleme berichten</a>
<li><a href="#Helping"        >15.6 - Wie man uns helfen kann</a>
</ul>

<a name="Intro"></a>
<h2>15.1 - Einführung</h2>

<p>
Es gibt viele Applikationen von Drittanbietern, die du eventuell auf
einem OpenBSD-System einsetzen möchtest. Um die Installation und
Verwaltung dieser Software einfacher zu machen (und um es mit
OpenBSDs Richtlinien und Zielen in Einklang zu bringen), wird die
Software der Drittanbieter in OpenBSD <i>portiert</i>.
Diese Portierungsbemühung kann viele verschiedene Dinge beinhalten.
Beispiele sind: dafür sorgen, dass die Software sich an die
standardmäßige OpenBSD-Verzeichnisstruktur hält (z.&nbsp;B. sollten
Konfigurationsdateien in <tt>/etc</tt> abgelegt werden), die
Software sich an OpenBSDs Spezifikation für Shared Librarys
hält, die Software sicherer machen, wenn das möglich ist etc.

<p>
Das Endergebnis dieser Portierungsbemühung ist ein Binarypackage,
das direkt installiert werden kann. Das Ziel des Package-Systems ist
es, die Installation der Software zu vermerken, sodass es auf einfache
Art und Weise später aktualisiert oder entfernt werden kann. Auf diese
Weise werden keine unnötigen Dateien auf dem System vergessen, wodurch
Benutzer ihr System in einem sauberen Zustand halten können.
Das Package-System stellt ebenfalls sicher, dass nichts aus Versehen
gelöscht wird, was zur Folge hätte, dass Software nicht mehr
ordnungsgemäß ausgeführt werden könnte. Ein weiterer Vorteil ist,
dass <b>Benutzer nur sehr selten Software aus dem Quelltext übersetzen
müssen</b>, da Packages bereits kompiliert wurden und nun
bereitstehen, um auf einem OpenBSD-System eingesetzt werden zu können.
Innerhalb von Minuten kann eine große Anzahl Packages heruntergeladen
und installiert werden - und alles landet an der richtigen Stelle.

<p>
<b><font color="#e00000">
Die Packages- und Ports-Kollektionen unterliegen NICHT der gründlichen
Sicherheitsüberprüfung, die für das OpenBSD-Basissystem gilt. Obwohl
wir danach streben, die Qualität der Packageskollektion auf hohem Niveau
zu halten, stehen zu wenig Entwickler bereit, um die gleiche Robustheit
und Sicherheit zu gewährleisten.
</font></b>
Selbstverständlich werden so schnell wie möglich
<a href="#PortsSecurity">Sicherheitsupdates</a> für unterschiedlichste
Applikationen eingepflegt; auch die dazugehörigen Sicherheitsupdates für
die Packages werden als Snapshots für <i>-current</i> bereitgestellt.

<a name="PkgMgmt"></a>
<h2>15.2 - Verwaltung der Packages</h2>

<a name="PkgHow"></a>
<h3>15.2.1 - Wie funktioniert das?</h3>

<p>
Packages sind die vorkompilierten Binarys von einigen der am meist
genutzten Software von Drittanbietern.

Packages können mit Hilfe einiger Werkzeuge auf sehr einfache Art und
Weise verwaltet werden - diese werden auch als pkg*-Werkzeuge
bezeichnet:
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pkg_add&amp;sektion=1&amp;manpath=OpenBSD+4.2">pkg_add(1)</a>
  - ein Werkzeug, das für die Installation und das Upgraden von
    Softwarepackages zuständig ist.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pkg_delete&amp;sektion=1&amp;manpath=OpenBSD+4.2">pkg_delete(1)</a>
  - ein Werkzeug, das für das Deinstallieren von zuvor installierten
    Softwarepackages zuständig ist.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pkg_info&amp;sektion=1&amp;manpath=OpenBSD+4.2">pkg_info(1)</a>
  - ein Werkzeug, das für das Anzeigen von Informationen über
    Softwarepackages zuständig ist.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pkg_create&amp;sektion=1&amp;manpath=OpenBSD+4.2">pkg_create(1)</a>
  - ein Werkzeug, das für das Erstellen von Softwarepackages zuständig
    ist.
</ul>

<p>
Damit eine Applikation X ordnungsgemäß ausgeführt werden kann, kann es
notwendig sein, dass die Applikationen Y und Z installiert sind.
Applikation X ist somit abhängig von diesen anderen Applikationen. Das
ist der Grund, warum Y und Z <i>Abhängigkeiten</i> von X genannt werden.
Genauso gut könnte Y die anderen Applikationen P und Q, Z wiederum die
Applikation R benötigen, um funktionieren zu können.
Auf diese Weise wird ein gesamter <i>Abhängigkeitsbaum</i> modelliert.

<p>
Packages wirken wie einfache <tt>.tgz</tt>-Bündel. Im Grunde genommen
sind sie es auch doch gibt es einen wichtigen Unterschied: Sie enthalten
zusätzliche <i>Packageinformationen</i>. Diese Informationen werden
von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pkg_add&amp;sektion=1&amp;manpath=OpenBSD+4.2">pkg_add(1)</a>
für einige Zwecke genutzt:

<ul>
<li>Verschiedene Überprüfungen: Wurde das Package bereits installiert
oder gibt es Konflikte mit anderen installierten Packages oder
Dateinamen?
<li>Abhängigkeiten, die sich noch nicht auf dem System befinden,
werden automatisch heruntergeladen und installiert bevor mit der
Installation des Packages fortgefahren wird.
<li>Informationen über das Package / die Packages werden in einem
zentralen Repository abgelegt - standardmäßig befindet sich dieses
unter <tt>/var/db/pkg/</tt>.
Dies wird - neben anderen Dingen - dafür sorgen, dass Abhängigkeiten
eines Packages nicht deinstalliert werden können, bevor nicht auch
das Package selbst deinstalliert wird. Dies hilft dabei sicherzustellen,
dass eine Applikation nicht versehentlich wegen einem sorglosen
Anwender in einem nicht verwendbaren Zustand endet.
</ul>


<a name="Easy"></a>
<h3>15.2.2 - Dinge einfach gestalten: PKG_PATH</h3>

<p>
Du kannst dir das Leben wirklich einfach machen, indem du die
Umgebungsvariable <tt>PKG_PATH</tt> verwendest. Lass sie einfach auf
dein bevorzugtes Verzeichnis zeigen und pkg_add(1) wird dort automatisch
nach den von dir angegebenen Packages suchen <b>und</b> ebenfalls
alle notwendigen Abhängigkeiten des Packages automatisch herunterladen
und installieren.

<p>
Eine Liste möglicher Orte, von wo aus Packages heruntergeladen werden
können, befindet sich in <a href="#PkgFind">folgender Sektion</a>.

<p>
1. Beispiel: Installation von deiner
<a href="../../de/orders.html">CD-ROM</a>; unter der Annahme, dass sie
unter <tt>/mnt/cdrom</tt> gemountet wurde
<blockquote><pre>
$ <b>export PKG_PATH=/mnt/cdrom/4.2/packages/`machine -a`/</b>
</pre></blockquote>

<p>
2. Beispiel: Installation von einem nahe gelegenen
<a href="../../de/ftp.html">FTP-Mirror</a>
<blockquote><pre>
$ <b>export PKG_PATH=ftp://your.ftp.mirror/pub/OpenBSD/4.2/packages/`machine -a`/</b>
</pre></blockquote>

<p>
Es ist grundsätzlich eine gute Idee, eine zusätzliche Zeile in deine
<tt>~/.profile</tt> zu schreiben, die den vorherigen Beispielen
ähnlich ist.
So wie mit der klassischen <tt>PATH</tt>-Variable kannst du mehrere
Verzeichnisse angeben (mit Doppelpunkten getrennt).
<b>Jedes Verzeichnis in der <tt>PKG_PATH</tt>-Variable MUSS JEDOCH
mit einem Schrägstrich (/) enden.</b>
Auf diese Weise kann pkg_add(1) den Pfad richtig aufteilen selbst
wenn URL-Schemas angegeben werden, die Doppelpunkte beinhalten.
Wenn der erste Eintrag in <tt>PKG_PATH</tt> nicht zum Erfolg führt,
wird der nächste ausprobiert; so lange, bis das Package gefunden
wurde. Wenn das Package in keinem der Einträge gefunden werden kann,
wird eine Fehlermeldung ausgegeben.

<p>
Beachte die Verwendung von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=machine&amp;sektion=1">machine(1)</a>
in den vorherigen Kommandozeilen.
Hiermit wird automatisch deine installierte
OpenBSD-Applikationsarchitektur eingefügt, die normalerweise -
aber nicht zwangsläufig - dein Plattformname ist. Wenn du
Snapshots verwendest, musst du selbstverständlich »4.2« gegen
»snapshots« austauschen.


<a name="PkgFind"></a>
<h3>15.2.3 - Packages finden</h3>

Eine große Sammlung von vorkompilierten Packages wird für die
weit verbreiteten Architekturen bereitgestellt. Wenn du dein Package
suchst, dann sieh hier nach:

<ul>
<li>Auf einer der drei <a href="../../de/orders.html">CD-ROMs</a> -
abhängig von deiner Architektur. Die CD-ROMs enthalten die
oft genutzten frei distributierbaren Packages für die
weit verbreiteten Plattformen.
<li>Auf den <a href=../../de/ftp.html>FTP-Mirrorservern</a>.
Packages befinden sich im Verzeichnis
<tt>/pub/OpenBSD/4.2/packages</tt>. Von da aus werden die
Packages weiter anhand der Architektur unterteilt.
<li>In den Packagelisten der OpenBSD-Website:
<ul>
<li><a href="http://www.openbsd.org/4.2_packages/">Packages für OpenBSD 4.2</a>
<li><a href="http://www.openbsd.org/4.1_packages/">Packages für OpenBSD 4.1</a>
<li><a href="http://www.openbsd.org/4.0_packages/">Packages für OpenBSD 4.0</a>
</ul>
</ul>

<p>
Wenn du den Ports-Tree auf deinem System hast, dann kannst du
das Package sehr schnell aufspüren, indem du nach ihm suchst wie
es in <a href="#PortsSearch">Den Ports-Tree durchsuchen</a>
beschrieben steht.

<p>
Es wird dir auffallen, dass bestimmte Packages in verschiedenen
Variationen vorliegen; formal <b>Flavors</b> genannt. Andere sind Teile
der gleichen Applikation, die separat installiert werden könnten; diese
werden <b>Subpackages</b> genannt. Das ganze wird in der Sektion
<a href="#PortsFlavors">Flavors und Subpackages verwenden</a> genauer
erläutert, doch bedeutet Flavor im Grunde nichts anderes, als dass sie
mit anderen Optionen konfiguriert wurden.
Momentan haben viele Packages Flavors; beispielsweise
Datenbankunterstützung, Unterstützung für Systeme ohne X oder weitere
Netzwerkfunktionalitäten wie SSL und IPv6 bereitstellen. Jedes Flavor
eines Packages hat einen anderen Suffix im Packagenamen. Detailliertere
Informationen über Packagenamen können in
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=packages-specs&amp;sektion=7">packages-specs(7)</a>
gefunden werden.

<p>
<b>Hinweis:</b>
Nicht alle möglichen Packages müssen zwangsläufig auf den FTP-Servern
liegen! Es gibt Applikationen, die einfach nicht auf allen Architekturen
laufen. Weitere Applikationen können aus Lizenzgründen nicht über FTP
(oder CD-ROM) weitergegeben werden. Es kann auch einfach nur eine schier
unendliche Kombination aus Flavors für einen Port geben; das
OpenBSD-Projekt hat jedoch einfach nicht die Ressourcen, um sie alle
zu kompilieren. Wenn du eine Kombination brauchst, die nicht
bereitgestellt wird, musst du den Port vom Quelltext aus übersetzen.
Weitere Informationen darüber, wie du das machst, kannst du im
Kapitel <a href="#PortsFlavors">Flavors und Subpackages verwenden</a>
der Portssektion dieses Dokumentes nachlesen.


<a name="PkgInstall"></a>
<h3>15.2.4 - Neue Packages installieren</h3>

Um Packages zu installieren, wird das Werkzeug namens
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pkg_add&amp;sektion=1&amp;manpath=OpenBSD+4.2">pkg_add(1)</a>
verwendet. Wenn du <a href="#Easy">es dir einfach gemacht hast</a>,
indem du die Umgebungsvariable <tt>PKG_PATH</tt> gesetzt hast, kannst du
einfach pkg_add(1) mit dem Packagenamen aufrufen so wie es in dem
folgenden Beispiel gezeigt wird.

<blockquote><pre>
$ <b>sudo pkg_add -v screen-4.0.3p0</b>
parsing screen-4.0.3p0
installed /etc/screenrc from /usr/local/share/examples/screen/screenrc | 71%
screen-4.0.3p0: complete
</pre></blockquote>

<p>
In diesem Beispiel wird die Option <b>-v</b> verwendet, um eine
informativere Ausgabe zu erhalten. Diese Option ist nicht notwendig,
doch ist sie hilfreich, um Fehler zu finden, und wurde hier verwendet,
um mehr Aufschluss darüber zu ermöglichen, was pkg_add(1) eigentlich
macht. Beachte die Meldung, die <i>/etc/screenrc</i> erwähnt. Die
Verwendung von mehreren <b>-v</b>-Optionen wird auch mehr Informationen
in die Ausgabe schreiben.

<p>
<h4>pkg_add(1) im interaktiven Modus verwenden</h4>

Seit OpenBSD 3.9 verfügt pkg_add(1) über einen interaktiven Modus,
der aktiviert werden kann, wenn die Option <b>-i</b> angegeben wird.
In diesem Modus werden dir Fragen gestellt, falls pkg_add(1) keine
eigene Entscheidung fällen kann. Wenn du zum Beispiel die Versionsnummer
eines Packages vor dem Aufruf nicht kennst, kannst du Folgendes
ausprobieren:

<blockquote><pre>
$ <b>sudo pkg_add -i screen</b>
Ambiguous: screen could be screen-4.0.3p0 screen-4.0.3p0-shm screen-4.0.3p0-static
Choose one package
         0: &lt;None&gt;
         1: screen-4.0.3p0
         2: screen-4.0.3p0-shm
         3: screen-4.0.3p0-static
Your choice: 1
screen-4.0.3p0: complete
</pre></blockquote>


<p>
Für einige Packages werden weitere wichtige Informationen über die
Konfiguration oder über die Verwendung der Applikation auf einem
OpenBSD-System ausgegeben. Da diese wichtig sind, werden sie immer
ausgegeben - ob du nun die Option <b>-v</b> verwendet hast oder nicht.
Sieh dir zum Beispiel das folgende Beispiel an:

<blockquote><pre>
$ <b>sudo pkg_add ghostscript-fonts-8.11</b>
ghostscript-fonts-8.11: complete
You may wish to update your font path for /usr/local/share/ghostscript/fonts
--- ghostscript-fonts-8.11 -------------------
To install these fonts for X11, just make sure that the fontpath
lists the 75dpi or 100dpi bitmap fonts before the ghostscript fonts,
and make sure you have the string ":unscaled" appended to the bitmap
font's fontpath. This way, the bitmap fonts will be used if they
match, and the Type 1 versions will be used if the font needs to be
scaled. Below is the relevant section from a typical xorg.conf file.

   FontPath   "/usr/X11R6/lib/X11/fonts/misc/"
   FontPath   "/usr/X11R6/lib/X11/fonts/75dpi/:unscaled"
   FontPath   "/usr/X11R6/lib/X11/fonts/100dpi/:unscaled"
   FontPath   "/usr/local/lib/X11/fonts/ghostscript/"
   FontPath   "/usr/X11R6/lib/X11/fonts/Type1/"
</pre></blockquote>

<p>
Lass uns nun mit einem Beispiel fortfahren, in dem ein Package
installiert wird, welches Abhängigkeiten besitzt:

<blockquote><pre>
$ <b>sudo pkg_add -v tin-1.8.2p0</b>
parsing tin-1.8.2p0
Dependencies for tin-1.6.2 resolve to: gettext-0.14.6, libutf8-0.8, pcre-6.4p1, libiconv-1.9.2p3 (todo: libiconv-1.9.2p3,gettext-0.14.6,pcre-6.4p1,libutf8-0.8)
tin-1.8.2p0:parsing libiconv-1.9.2p3
tin-1.8.2p0:libiconv-1.9.2p3: complete
tin-1.8.2p0:parsing gettext-0.14.6
Dependencies for gettext-0.14.6 resolve to: expat-2.0.0, libiconv-1.9.2p3 (todo: expat-2.0.0)
tin-1.8.2p0:parsing expat-2.0.0
tin-1.8.2p0:expat-2.0.0: complete
tin-1.8.2p0:gettext-0.14.6: complete
tin-1.8.2p0:parsing pcre-6.4p1
tin-1.8.2p0:pcre-6.4p1: complete
tin-1.8.2p0:parsing libutf8-0.8
tin-1.8.2p0:libutf8-0.8: complete
tin-1.8.2p0: complete
</pre></blockquote>

Wieder haben wir die Option <b>-v</b> hinzugefügt, um mehr über das
eigentliche Geschehen zu erfahren. Beim Überprüfen der
Packageinformationen wurden Abhängigkeiten gefunden, die nun zuerst
installiert werden. Ungefähr in der Mitte kannst du sehen, wie das
gettext-Package installiert wurde, welches wiederum von libiconv
abhängig ist. Vor der Installation von gettext wurden seine
Packageinformationen ausgelesen und sichergestellt, ob libiconv
bereits installiert wurde.

<p>
Es ist möglich, mehrere Packagenamen bei einem Aufruf anzugeben, wodurch
alle auf einmal installiert werden - neben allen möglichen
Abhängigkeiten.

<p>
Falls du dich aus irgendeinem Grund gegen die Nutzung von
<tt>PKG_PATH</tt> entscheiden solltest, ist es trotzdem möglich, die
absolute Angabe eines Packages auf der Kommandozeile anzugeben.
Diese absolute Angabe kann ein lokaler Pfad oder eine URL sein, die
auf FTP-, HTTP- oder SCP-Pfade verweist. Lass uns im nächsten Beispiel
eine Installation über FTP ansehen:

<blockquote><pre>
$ <b>sudo pkg_add ftp://ftp.openbsd.org/pub/OpenBSD/4.2/packages/`machine -a`/screen-4.0.3p0.tgz</b>
screen-4.0.3p0: complete
</pre></blockquote>

<p>
In diesem Beispiel wurde die Option <b>-v</b> nicht verwendet, sodass
nur die notwendigen Nachrichten angezeigt werden. Achte darauf, dass der
vollständige Dateiname angegeben werden muss, indem man ein
<b>.tgz</b>-Suffix anhängt. Du kannst jedoch auch wie in den
vorherigen Beispielen auf dieses Suffix verzichten, da es automatisch
durch pkg_add(1) hinzugefügt wird.

<p>
<b>Hinweis:</b> Nicht alle Architekturen verfügen über die gleichen
Packages. Einige Ports funktionieren nur auf bestimmten Architekturen;
außerdem beschränkt die Leistung bestimmter Architekturen die Anzahl
der Packages, die auf diesen kompiliert werden kann.

<p>
Bei der Installation eines Packages, das du zuvor schon installiert
(oder eine frühere Version) und entfernt hast, wird pkg_add(1),
um sicherzugehen, <b>keine</b> Konfigurationsdateien überschreiben, die
du verändert hast. Stattdessen wird es dich über diese wie folgt
informieren (jedoch nur, wenn du die Option <b>-v</b> angegeben hast!):

<blockquote><pre>
$ <b>sudo pkg_add -v screen-4.0.3p0</b>
parsing screen-4.0.3p0
The existing file /etc/screenrc has NOT been changed**                 | 71%
It does NOT match the sample file /usr/local/share/examples/screen/screenrc
You may wish to update it manually
screen-4.0.3p0: complete
</pre></blockquote>

Manchmal kann es sein, dass du einen Fehler wie in dem folgenden
Beispiel siehst:

<blockquote><pre>
$ <b>sudo pkg_add xv-3.10ap4</b>
xv-3.10ap4:jpeg-6bp3: complete
xv-3.10ap4:png-1.2.14p0: complete
xv-3.10ap4:tiff-3.8.2p0: complete
Can't install xv-3.10ap4: lib not found X11.9.0
Even by looking in the dependency tree:
        tiff-3.8.2p0, jpeg-6bp3, png-1.2.14p0
Maybe it's in a dependent package, but not tagged with @lib ?
(check with pkg_info -K -L)
If you are still running 3.6 packages, update them.
</pre></blockquote>

Da ist pkg_add(1) gerade dabei, Abhängigkeiten zu installieren, als es
plötzlich während der Installation von xv abbricht. Dies ist ein
weiterer Sicherheitsmechanismus, der mit OpenBSD 3.7 eingeführt wurde.
Die Packageinformationen, die sich im Package befinden, enthalten
Informationen über Shared Librarys, von denen das Package erwartet,
dass sie installiert sind - sowohl Systembibliotheken als auch
Bibliotheken von Drittanbietern. Wenn eine dieser benötigten
Bibliotheken nicht gefunden werden kann, wird das Package nicht
installiert, da es sowieso nicht richtig funktionieren würde.

<p>
Um diese Art des Konfliktes zu lösen, musst du herausfinden, was
installiert werden muss, um die benötigten Bibliotheken auf dein System
zu bekommen.

<!--
Füge hier einen guten Algorithmus ein
-->

Es gibt mehrere Dinge, die überprüft werden sollten:
<ul>
<li>Vielleicht hast du ältere Packages installiert: Eine alte
Version der benötigten Bibliothek liegt vor. In diesem Fall musst du
diese Packages upgraden.
<li>Dein System könnte unvollständig sein: Du hast eines der Dateisets
nicht installiert, das die benötigte Bibliothek enthält. Du musst
lediglich <a href="faq4.html#AddFileSet">das benötigte Dateiset
hinzufügen</a>.
<li>Dein System könnte veraltet sein: Du hast eine ältere Version
der benötigten Bibliothek. Boote den Installer (wie in
<a href="faq4.html">FAQ 4</a> erklärt) und wähle (U)grade aus,
um dein gesamtes System upzugraden.
</ul>

<a name="PkgList"></a>
<h3>15.2.5 - Installierte Packages auflisten</h3>

Du kannst eine Liste aller installierten Packages erhalten, indem du
das Werkzeug
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pkg_info&amp;sektion=1&amp;manpath=OpenBSD+4.2">pkg_info(1)</a>
verwendest.

<blockquote><pre>
$ <b>pkg_info</b>
aterm-0.4.2p1       color vt102 terminal emulator with transparency support
bzip2-1.0.4         block-sorting file compressor, unencumbered
expat-2.0.0         XML 1.0 parser written in C
fluxbox-0.9.15.1p0  window manager based on the original Blackbox code
gettext-0.14.6      GNU gettext
imlib2-1.3.0        image manipulation library
jpeg-6bp3           IJG's JPEG compression utilities
libiconv-1.9.2p3    character set conversion library
libltdl-1.5.22p1    GNU libtool system independent dlopen wrapper
libungif-4.1.4p0    tools and library routines for working with GIF images
libutf8-0.8         provides UTF-8 locale support
mutt-1.4.2.2i       tty-based e-mail client
pcre-6.4p1          perl-compatible regular expression library
png-1.2.14p0        library for manipulating PNG images
screen-4.0.3p0      multi-screen window manager
tcsh-6.14.00p1      extended C-shell with many useful features
tiff-3.8.2p0        tools and library routines for working with TIFF images
tin-1.8.2p0         threaded NNTP and spool based UseNet newsreader
</pre></blockquote>

<p>
Wenn der Name eines installierten Packages angegeben wird (oder ein Pfad
zu einem Package, das installiert werden soll), wird pkg_info(1)
detailliertere Informationen über dieses bestimmte Package ausgeben.

<a name="PkgUpdate"></a>
<h3>15.2.6 - Installierte Packages aktualisieren</h3>

Seit OpenBSD 3.7 ist es möglich, existierende Packages zu aktualisieren,
indem man die Option <b>-r</b> (= replace [ersetzen]) mit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pkg_add&amp;sektion=1&amp;manpath=OpenBSD+4.2">pkg_add(1)</a>
verwendet. OpenBSD 3.8 führte die Option <b>-u</b> von pkg_add(1) ein,
der in 3.9 in einen echten Updatemechanismus umgewandelt wurde.

<p>
Angenommen, du hättest eine ältere Version von unzip installiert, bevor
du diesen Rechner von OpenBSD 4.1 auf 4.2 upgegradet hast. Nun kannst
du wie folgt ganz einfach auf das neuere 4.2-Package upgraden:

<blockquote><pre>
$ <b>sudo pkg_add -u unzip</b>
unzip-5.52 (extracting): complete
unzip-5.51 (deleting): complete
unzip-5.52 (installing): complete
Clean shared items: complete
</pre></blockquote>

<p>
Der Aufruf von pkg_add(1) mit der Option <b>-u</b> und keinem
Packagenamen wird versuchen, alle installierten Packages zu
aktualisieren.

<p>
<b>Hinweis:</b>
Die Option <b>-u</b> baut auf der Umgebungsvariable <tt>PKG_PATH</tt>
auf. Wenn diese nicht gesetzt ist, wird pkg_add(1) nicht in der Lage
sein, Updates finden zu können.

<p>
Beginnend mit OpenBSD 4.2 bedeuten mehrere Einträge in <tt>PKG_PATH</tt>
nicht mehr, dass bei Updatevorgängen alle Einträge durchsucht werden.
Stattdessen wird pkg_add(1) beim ersten Pfad aufhören, der passende
Kandidaten vorweist.

<p>
Wenn du eine Konfigurationsdatei für die alte Version hattest, die du
auch geändert hast, wird sie standardmäßig nicht modifiziert. Du kannst
sie jedoch mit der Standardkonfigurationsdatei der neuen Version
überschreiben, indem du pkg_add(1) mit der Option <b>-c</b> aufrufst.

<a name="PkgRemove"></a>
<h3>15.2.7 - Installierte Packages deinstallieren</h3>

<p>
Um ein Package zu deinstallieren, nimm einfach den richtigen Namen
des Packages, der beim Aufruf von pkg_info(1) angezeigt wird (siehe
<a href="#PkgList">Installierte Packages auflisten</a> weiter oben)
und verwende
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pkg_delete&amp;sektion=1&amp;manpath=OpenBSD+4.2">pkg_delete(1)</a>,
um Packages zu entfernen.
In dem folgenden Beispiel wird das screen-Package deinstalliert.
Beachte, dass es manchmal sein kann, dass es weitere Anweisungen für
die Deinstallation von weiteren Dingen gibt, die pkg_delete(1) nicht
für dich ausführt. Wie es auch mit dem Werkzeug pkg_add(1) der Fall
ist, kannst du die Option <b>-v</b> verwenden, um mehr Informationen in
der Ausgabe zu erhalten.

<blockquote><pre>
$ <b>sudo pkg_delete screen</b>
screen-4.0.3p0: complete
Clean shared items: complete
</pre></blockquote>

<p>
<b>Hinweis:</b> Oft ist es nicht notwendig, die Versionsnummern und die
Flavors mit dem Packagenamen anzugeben, da pkg_delete(1) normalerweise
in der Lage ist, diese Namen selbstständig herauszufinden.
Du musst den kompletten Packagenamen (in diesem Fall wäre das
screen-4.0.3p0) nur dann angeben, wenn eine Verwechslung aufgrund von
mehreren installierten Packages mit dem angegebenen Namen möglich wäre;
in dem Fall kann pkg_delete(1) nicht wissen, welches Package
deinstalliert werden soll.

<p>
Konfigurationsdateien werden von pkg_delete(1) nicht gelöscht, falls sie
geändert wurden - um sicherzugehen. Stattdessen wird es dich darüber
wie folgt informieren:

<blockquote><pre>
$ <b>sudo pkg_delete screen</b>
screen-4.0.3p0: complete
Clean shared items: complete
--- screen-4.0.3p0 -------------------
You should also remove /etc/screenrc (which was modified)
</pre></blockquote>

<p>
Wenn du möchtest, dass diese Konfigurationsdateien automatisch
deinstalliert werden, kannst du das tun, indem du die Option <b>-c</b>
angibst.


<!--
<a name="PkgSecurity"></a>
<h3>15.2.8 - Sicherheitsupdates (Packages für -stable)</h3>

Wenn kritische Bugs oder Sicherheitslücken in der Software von
Drittanbietern gefunden werden, dann werden sie im -stable-Branch des
Ports-Trees behoben und eine Auswahl von aktualisierten Binarypackages
wird bereitgestellt.

<p>
Bitte lies die <a href="../../pkg-stable.html">Seite über Packages für
-stable</a>, um mehr über aktualisierte Packages und wichtige Updates
für den -stable-Branch zu erfahren. Beachte, dass aktualisierte Packages
nur für die i386- und amd64-Plattformen bereitgestellt werden. Für
andere Plattformen gilt, dass sie den -stable-Branch des Ports-Trees
beziehen und vom Quelltext aus übersetzen müssen.

<p>
Wenn du sicherheitsbezogene Ankündigungen in Bezug auf Software im
Packages- und Ports-System erhalten möchtest, dann kannst du dich in
der <a href="../../de/mail.html">Mailingliste</a> ports-security
einschreiben.

<p>
Im Fall einer Packageaktualisierung werden die Namen der Packages
<b>immer</b> geändert, um die Verwechslungsgefahr zwischen einem Package
des Releases und eines fehlerbehobenen Packages zu vermeiden.
Dieser Name könnte eine höhere Versionsnummer beinhalten oder, falls die
Versionsnummer gleichgeblieben ist, ein <b>pN</b>-Suffix haben, wobei
<b>N+1</b> für die Anzahl angewandter Patches für dieses Package
steht.
-->

<a name="PkgPartial"></a>
<h3>15.2.8 - Unvollständige Package(de)installation</h3>

Wenn etwas schiefläuft, dann kann es sein, dass du feststellst, dass ein
Package nicht richtig hinzugefügt oder entfernt wurde weil es Konflikte
mit anderen Dateien gab. Die unvollständige Installation wird
üblicherweise mit einem »partial-« vor dem Packagenamen gekennzeichnet.
Dies kann zum Beispiel passieren, wenn du versehentlich [STRG]+C während
der Installation gedrückt hast:

<blockquote><pre>
$ <b>sudo pkg_add screen-4.0.3p0</b>
screen-4.0.3p0: complete
Adjusting md5 for /usr/local/info/screen.info-3 from 49fb3fe1cc3a3b0057518459811b6dac to 3b9c7811244fb9f8d83bb27d3a0f60d8
/usr/sbin/pkg_add: Installation of screen-4.0.3p0 failed , partial installation recorded as partial-screen-4.0.3p0
</pre></blockquote>

<p>
Es ist immer eine gute Idee, teilweise installierte Packages von deinem
System zu entfernen und potenzielle Probleme zu lösen, die zu diesem
Fehler geführt haben könnten. Wenn so etwas eintritt, dann ist das oft
ein Zeichen dafür, dass du kein ordentliches System hast, das
vollständig nur von Packages aus installiert wurde sondern mit Software
vermischt wurde, die du direkt vom Quelltext aus übersetzt hast.


<a name="Ports"></a>
<h2>15.3 - Mit Ports arbeiten</h2>

Wie in der Einführung erwähnt können Packages vom Ports-Tree aus
kompiliert werden. In diesem Kapitel werden wir erklären, wie der
Ports-Tree funktioniert, wann du ihn verwenden solltest und wie du ihn
verwenden kannst.

<p>
<b>WICHTIGER HINWEIS</b>: Der Ports-Tree ist nur für erfahrene Anwender
gedacht. <b>Es wird jedem nahegelegt, die vorkompilierten
Binary<a href="#PkgMgmt">packages</a> zu verwenden</b>.
Frage NICHT Anfängerfragen auf der Mailingliste wie zum Beispiel
"How can I get the ports tree working?". Wenn du Fragen über den
Ports-Tree hast, dann wird vorausgesetzt, dass du die Manualseiten und
diese FAQ gelesen hast, und dass du in der Lage bist, mit ihm zu
arbeiten.


<a name="PortsHow"></a>
<h3>15.3.1 - Wie funktioniert das?</h3>

Der Ports-Tree (ein Konzept, das ursprünglich von
<a href="http://www.freebsd.org/de/">FreeBSD</a> übernommen wurde)
ist ein Satz Makefiles, wobei für jede Applikation von Drittanbietern
ein Makefile existiert und bestimmt

<ul>
<li>von wo und wie der Quelltext der Software heruntergeladen werden
  soll,
<li>von welcher anderen Software sie abhängig ist,
<li>wie der Quelltext modifiziert werden muss (wenn nötig),
<li>wie man sie konfigurieren und erzeugen muss,
<li>wie man sie testet (optional),
<li>wie man sie installiert.
</ul>

<p>
Neben dem Makefile beinhaltet jeder Port ebenfalls mindestens folgende
Dinge:

<ul>
<li>eine PLIST oder Packinglist, die Anweisungen für die
Packageerstellung enthält, wenn die Applikation übersetzt wurde.
<li>eine DESCR oder Beschreibung der Applikation,
<li>eine distfile, die die Distributionsdateiprüfsummen und -größen
beinhaltet.
</ul>

<p>
All diese Informationen werden in einer Verzeichnishierarchie unter
<tt>/usr/ports</tt> gespeichert. Die Hierarchie besteht aus drei
speziellen Unterverzeichnissen:
<ul>
<li><tt>distfiles/</tt> - wo das Ports-System
Softwaredistributionssets nach dem Herunterladen aufbewahrt.
<li><tt>infrastructure/</tt> - das Hauptverzeichnis der
Portsinfrastruktur, in dem alle notwendigen Skripte und Makefiles
liegen.
<li><tt>packages/</tt> - beinhaltet Binarypackages, die vom Ports-System
aus erzeugt wurden.
</ul>
Die anderen Unterverzeichnisse stellen verschiedene
Applikationskategorien dar, die Unterverzeichnisse für die tatsächlichen
Ports haben. Komplexe Ports können in noch weitere Ebenen unterteilt
werden; zum Beispiel wenn sie eine Kernkomponente und einen
Erweiterungssatz haben - oder eine stabile und eine Snapshotversion der
Applikation vorliegt. Jedes Portsverzeichnis muss ein
<tt>pkg/</tt>-Unterverzeichnis haben, in dem sich die Packingliste(n)
und die Beschreibungsdatei(en) befinden. Es können auch die
Unterverzeichnisse <tt>patches/</tt> und <tt>files/</tt> vorliegen -
diese sind jeweils für Quelltextpatches und zusätzliche Dateien gedacht.

<p>
Wenn ein Benutzer
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=make&amp;sektion=1">make(1)</a>
in einem Unterverzeichnis eines speziellen Ports aufruft, dann wird das
System rekursiv den Abhängigkeitsbaum durchgehen und prüfen, ob alle
benötigten Abhängigkeiten bereits installiert wurden, die fehlenden
Abhängigkeiten übersetzen und installieren und dann mit der Erzeugung
des gewünschten Ports fortsetzen. All dies passiert in dem
<i>Arbeitsverzeichnis</i>, das der Port erstellt.
Dies ist entweder ein Unterverzeichnis des Porthauptverzeichnisses (in
diesem Fall kann es am Prefix »w-« erkannt werden) oder es ist ein
Unterverzeichnis von <tt>${WRKOBJDIR}</tt>, falls die Variable
<tt>WRKOBJDIR</tt> gesetzt wurde (siehe
<a href="#PortsConfig">Zusätzliche Konfiguration des Ports-Systems</a>).

<p>
<b>Hinweis:</b> Ports werden niemals direkt auf deinem System
installiert! Sie verwenden ein <i>Scheininstallationsverzeichnis</i>.
Alles, was dort installiert wird, wird in ein Package zusammengefasst
(welches dann im <tt>packages/</tt>-Unterverzeichnis des Ports-Trees
abgelegt wird, wie es zuvor beschrieben wurde). Einen Port installieren
bedeutet daher in Wirklichkeit: Ein Package erstellen und dieses dann
installieren!

<p>
<b>Weitere Informationen</b> über das Ports-System können in diesen
Manualseiten gefunden werden:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ports&amp;sektion=7">ports(7)</a>
- beschreibt die verschiedenen Stufen (Targets von make)
der Portinstallation, die Verwendung von Flavors und Subpackages sowie
einige andere Optionen.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bsd.port.mk&amp;sektion=5">bsd.port.mk(5)</a>
- Ins Detail gehende Informationen über alle Make-Targets, Variablen,
das Schein- (Installationsverzeichnis-)Framework etc.
</ul>

<a name="PortsFetch"></a>
<h3>15.3.2 - Den Ports-Tree beziehen</h3>

Bevor du fortfährst musst du diese Kapitel darüber lesen, dass du NICHT
<a href="#NoFun">dein OpenBSD-System mit dem Ports-Tree vermischst</a>.
Sobald du dich entschieden hast, welches Flavor des Ports-Trees du
haben möchtest, kannst du den Ports-Tree von unterschiedlichen Quellen
beziehen. Die folgende Tabelle gibt dir einen Überblick darüber, wo du
die verschiedenen Flavors finden kannst (und in welcher Form). Ein »x«
kennzeichnet die Verfügbarkeit und »-« bedeutet, dass du ihn über
diese bestimmte Quelle nicht beziehen kannst.

<p>
<table border="1" align="center" style="empty-cells: show;">
<tr align="center">
<td align="left">Quelle</td>
<td>Form</td>
<td colspan="4">Flavor</td>
</tr>
<tr align="center">
<td colspan="2"></td>
<td>-release</td>
<td>-stable</td>
<td>Snapshots</td>
<td>-current</td>
</tr>
<tr align="center">
<td align="left"><a href="../../de/orders.html">CD-ROM</a></td>
<td>.tar.gz</td>
<td>x</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr align="center">
<td align="left"><a href="../../de/ftp.html">FTP-Mirror</a></td>
<td>.tar.gz</td>
<td>x</td>
<td>-</td>
<td>x</td>
<td>-</td>
</tr>
<tr align="center">
<td align="left"><a href="../../de/anoncvs.html">AnonCVS</a></td>
<td>cvs checkout</td>
<td>x</td>
<td>x</td>
<td>-</td>
<td>x</td>
</tr>
</table>

<p>
Auf der CD-ROM und den FTP-Mirrors musst du nach einer Datei mit dem
namen <tt>ports.tar.gz</tt> suchen. Du solltest die Datei in das
Verzeichnis <tt>/usr/</tt> entpacken, womit du <tt>/usr/ports</tt> und
alle dazugehörigen Unterverzeichnisse erstellst. Zum Beispiel:

<blockquote><pre>
$ <b>cd /tmp</b>
$ <b>ftp ftp://ftp.openbsd.org/pub/OpenBSD/4.2/ports.tar.gz</b>
$ <b>cd /usr</b>
$ <b>sudo tar xzf /tmp/ports.tar.gz</b>
</pre></blockquote>

<p>
Die Snapshots, die auf den FTP-Mirrors vorliegen, werden täglich vom
-current-Ports-Tree erstellt. Diese Snapshots kannst du im Verzeichnis
<tt>pub/OpenBSD/snapshots</tt> finden. Wenn du einen Snapshot vom
Ports-Tree verwendest, dann solltest du einen dazu passenden
OpenBSD-Snapshot haben. Stelle sicher, dass du deinen Ports-Tree und
dein OpenBSD-System synchron hälst!

<p>
Lies bitte die <a href="../../de/anoncvs.html">AnonCVS-Seite</a>, die
eine Liste aller verfügbaren Server und einige Beispiele bereitstellt,
wenn du weitere Informationen über das Beziehen des Ports-Trees per
AnonCVS hast.


<a name="PortsConfig"></a>
<h3>15.3.3 - Konfiguration des Ports-Systems</h3>

<p>
<b>HINWEIS:</b>
Dieses Kapitel führt einige zusätzliche systemweite Einstellungen für
das Erzeugen von Applikationen aus den Ports ein. Du kannst dieses
Kapitel überspringen, doch musst du dann viele der make(1)-Ausdrücke
in den Beispielen als root ausführen.

<p>
Da dem OpenBSD-Projekt nicht genügend Ressourcen zur Verfügung stehen,
um den gesamten Quelltext der Software aus dem Ports-Tree zu überprüfen,
kannst du das Ports-System so konfigurieren, dass einige weitere
Sicherheitsmaßnahmen genutzt werden. Die Portsinfrastruktur ist in der
Lage, die gesamte Erzeugung als normaler Benutzer auszuführen; nur
die Schritte, die Superuserrechte benötigen, werden als root ausgeführt.
Beispiele hierfür sind die Make-Targets <tt>fake</tt> und
<tt>install</tt>. Weil die Rootrechte jedoch immer irgendwann notwendig
sind, wird dich das Ports-System nicht schützen können, wenn du dich
für die Installation einer bösartigen Software entschieden hast.

<p>
<ul>
<li>Du kannst
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sudo&amp;sektion=8">sudo(8)</a>
einrichten und dem Ports-System sagen, dass es sudo für die Aufgaben
verwenden soll, die Superuserrechte benötigen. Füge einfach eine Zeile
in <tt>/etc/mk.conf</tt> hinzu, die Folgendes beinhaltet:

<blockquote><pre>
SUDO=/usr/bin/sudo
</pre></blockquote>

<li>Du kannst den Besitzer des Ports-Trees ändern, sodass du als
normaler Benutzer Schreibzugriff hast. In diesem Fall wurde der Benutzer
der Gruppe wsrc hinzugefügt und alle Unterverzeichnisse mit
Gruppenschreibrecht ausgestattet.

<blockquote><pre>
# <b>chgrp -R wsrc /usr/ports</b>
# <b>find /usr/ports -type d -exec chmod g+w {} \;</b>
</pre></blockquote>

<li>Du kannst das Ports-System so konfigurieren, dass es
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=systrace&amp;sektion=1">systrace(1)</a>
verwendet, indem du Folgendes in <tt>/etc/mk.conf</tt> hinzufügst:

<blockquote><pre>
USE_SYSTRACE=Yes
</pre></blockquote>

Dies zwingt die Erzeugungsphase dazu, in den erlaubten Verzeichnissen
zu bleiben und verbietet das Schreiben auf ungültige Positionen.
Hierdurch wird die Gefahr, dass das System beschädigt werden könnte,
deutlich verringert. Beachte aber, dass systrace(2) die Zeit, die zum
Erzeugen der Ports benötigt wird, um ungefähr 20 % verlängert.

</ul>

<p>
Es ist auch möglich, einen schreibgeschützten Ports-Tree zu nutzen,
indem man die Verzeichnisse trennt, die während der Erzeugung des Ports
Schreibrechte haben müssen:

<ul>
<li>Das Arbeitsverzeichnis des Ports.
Dies wird über die Variable <tt>WRKOBJDIR</tt> verwaltet, die das
Verzeichnis angibt, das als Arbeitsverzeichnis genutzt werden soll.
<li>Das Verzeichnis, das die Distributionsdateien enthält. Dies wird
über die Variable <tt>DISTDIR</tt> verwaltet.
<li>Das Verzeichnis, in dem das neu erstellte Package abgelegt wird.
Dies wird über die Variable <tt>PACKAGE_REPOSITORY</tt> verwaltet.
</ul>

Du könntest zum Beispiel die folgenden Zeilen zur <tt>/etc/mk.conf</tt>
hinzufügen:

<blockquote><pre>
WRKOBJDIR=/usr/obj/ports
DISTDIR=/usr/distfiles
PACKAGE_REPOSITORY=/usr/packages
</pre></blockquote>

Wenn du möchtest, dann kannst du auch den Besitzer dieser Verzeichnisse
auf deinen lokalen Benutzernamen und deine Gruppe ändern, sodass das
Ports-System die Unterverzeichnisse als regulärer Benutzer anlegen kann.


<a name="PortsSearch"></a>
<h3>15.3.4 - Den Ports-Tree durchsuchen</h3>

Wenn dein Ports-Tree sich so weit auf deinem System befindet, wird es
sehr einfach, nach bestimmter Software zu suchen.
Verwende einfach <tt>make search key="Schlüsselwort"</tt> so wie es in
diesem Beispiel gezeigt wird.

<blockquote><pre>
$ <b>cd /usr/ports</b>
$ <b>make search key=rsnapshot</b>
Port:   rsnapshot-1.2.9
Path:   net/rsnapshot
Info:   remote filesystem snapshot utility
Maint:  Sigfred Haversen
Index:  net
L-deps:
B-deps: :net/rsync
R-deps: :net/rsync
Archs:  any
</pre></blockquote>

Das Suchergebnis gibt dir einen schönen Überblick über jede einzelne
Applikation, die gefunden wurde: der Portname, der Pfad zum Port,
eine einzeilige Beschreibung, den Verantwortlichen des Ports,
dem Port zugewiesene Schlüsselwörter,
Bibliotheken/Erzeugungs/Laufzeitabhängigkeiten und die Architekturen,
bei denen bekannt ist, dass der Port auf ihnen läuft.

<p>
Dieser Mechanismus ist allerdings ein recht simpler, da er nur awk(1)
auf die Indexdatei des Ports anwendet. Mit OpenBSD 4.0 wurde ein
neuer Port namens »sqlports« erstellt, der genaue Suchanfragen mit
SQL erlaubt. Es handelt sich dabei um eine SQLite-Datenbank, doch
kann mit der Portsinfrastruktur im Grunde jedes Datenbankformat
erstellt werden.

<p>
Füge das sqlports-Package einfach mit pkg_add(1) hinzu. In diesem
Fall benötigst du ebenfalls das sqlite3-Package. Eine Beispielsitzung
könnte wie folgt aussehen:

<blockquote><pre>
$ sqlite3 /usr/local/share/sqlports
SQLite version 3.3.12
Enter ".help" for instructions
sqlite> SELECT FULLPKGNAME,COMMENT FROM Ports WHERE COMMENT LIKE '%statistics%';
Guppi-0.40.3p1|GNOME-based plot program with statistics capabilities
mailgraph-1.12|a RRDtool frontend for Postfix statistics
R-2.4.1|clone of S, a powerful math/statistics/graphics language
py-probstat-0.912p0|probability and statistics utilities for Python
darkstat-3.0.540p1|network statistics gatherer with graphs
pfstat-2.2p0|packet filter statistics visualization
tcpstat-1.4|report network interface statistics
wmwave-0.4p2|Window Maker dockapp to display wavelan statistics
diffstat-1.43p0|accumulates and displays statistics from a diff file
sqlite>
</pre></blockquote>

Dieses Beispiel zeigt noch immer eine sehr einfache Suche. Mit SQL
kann aber alles durchsucht werden: Abhängigkeiten, Configureoptionen,
Shared Librarys etc.

<a name="PortsInstall"></a>
<h3>15.3.5 - Unkomplizierte Installation: ein einfaches Beispiel</h3>

Um das ganze klarer zu machen nehmen wir folgendes Beispiel an:
rsnapshot. Diese Applikation ist nur von einem Paket abhängig: rsync.

<blockquote><pre>
$ <b>cd /usr/ports/net/rsnapshot</b>
$ <b>make install</b>
===>  Checking files for rsnapshot-1.2.9
&gt;&gt; rsnapshot-1.2.9.tar.gz doesn't seem to exist on this system.
&gt;&gt; Fetch http://www.rsnapshot.org/downloads/rsnapshot-1.2.9.tar.gz.
100% |**************************************************|   173 KB    00:02
&gt;&gt; Size matches for /usr/ports/distfiles/rsnapshot-1.2.9.tar.gz
&gt;&gt; Checksum OK for rsnapshot-1.2.9.tar.gz. (sha1)
===&gt;  rsnapshot-1.2.9 depends on: rsync-2.6.9 - not found
===&gt;  Verifying install for rsync-2.6.9 in net/rsync
===&gt;  Checking files for rsync-2.6.9
&gt;&gt; rsync-2.6.9.tar.gz doesn't seem to exist on this system.
&gt;&gt; Fetch ftp://ftp.samba.org/pub/rsync/old-versions/rsync-2.6.9.tar.gz.
100% |**************************************************|   792 KB    00:31
&gt;&gt; Size matches for /usr/ports/distfiles/rsync-2.6.9.tar.gz
&gt;&gt; Checksum OK for rsync-2.6.9.tar.gz. (sha1)
===&gt;  Verifying specs:  c
===&gt;  found c.40.3
===&gt;  Extracting for rsync-2.6.9
===&gt;  Patching for rsync-2.6.9
===&gt;  Configuring for rsync-2.6.9
  [... Schnipp ...]
===&gt;  Building for rsync-2.6.9
  [... Schnipp ...]
===&gt;  Faking installation for rsync-2.6.9
  [... Schnipp ...]
===&gt;  Building package for rsync-2.6.9
Link to /usr/ports/packages/i386/ftp/rsync-2.6.9.tgz
Link to /usr/ports/packages/i386/cdrom/rsync-2.6.9.tgz
===&gt;  Installing rsync-2.6.9 from /usr/ports/packages/i386/all/rsync-2.6.9.tgz
rsync-2.6.9: complete
===&gt; Returning to build of rsnapshot-1.2.9
===&gt;  rsnapshot-1.2.9 depends on: rsync-2.6.9 - found
===&gt;  Extracting for rsnapshot-1.2.9
===&gt;  Patching for rsnapshot-1.2.9
===&gt;  Configuring for rsnapshot-1.2.9
  [... Schnipp ...]
===>  Building for rsnapshot-1.2.9
  [... Schnipp ...]
===&gt;  Faking installation for rsnapshot-1.2.9
  [... Schnipp ...]
===&gt;  Building package for rsnapshot-1.2.9
Link to /usr/ports/packages/i386/ftp/rsnapshot-1.2.9.tgz
Link to /usr/ports/packages/i386/cdrom/rsnapshot-1.2.9.tgz
===&gt;  rsnapshot-1.2.9 depends on: rsync-2.6.9 - found
===&gt;  Installing rsnapshot-1.2.9 from /usr/ports/packages/i386/all/rsnapshot-1.2.9.tgz
rsnapshot-1.2.9: complete
</pre></blockquote>

<p>
Wie du sehen kannst macht das Ports-System viele Dinge automatisch.
Es bezieht, extrahiert und patcht den Quelltext, konfiguriert und
erzeugt (kompiliert) den Quelltext, installiert die Dateien in ein
Scheinverzeichnis, erstellt ein Package (mit Bezug auf die Packinglist)
und installiert das Package auf dein System (normalerweise unter
<tt>/usr/local/</tt>). Das Ports-System macht das sogar rekursiv
<b>für alle Abhängigkeiten</b> des Ports. Achte einfach mal auf
die Zeilen »<tt>===&gt; Verifying install for ...</tt>« und
»<tt>===&gt; Returning to build of ...</tt>« der vorherigen Ausgabe,
die auf das Durchlaufen des Abhängigkeitsbaum deuten.

<p>
Wenn bereits eine vorherige Version der Applikation, die du installieren
möchtest, auf deinem System installiert wurde, kannst du <tt><b>make
update</b></tt> an Stelle von <tt><b>make install</b></tt> aufrufen.
Hiermit übergibst du pkg_add(1) die Option <b>-r</b>.

<p>
<b>Hinweis:</b>
Große Applikationen werden viele Systemressourcen für die Erzeugung
benötigen. Gute Beispiele hierfür sind Compiler wie GCC 4.0 oder
Java 2 Software Development Kit. Wenn du Fehlermeldungen wie
»out of memory« bei der Erzeugung eines solchen Ports erhältst,
geschah das meist aus einem dieser beiden Gründe:

<ul>
<li>Deine Ressourcenbegrenzungen sind zu restriktiv. Passe sie mit
Hilfe von kshs ulimit- oder cshs limit-Kommando an. Wenn das nicht
hilft, dann werde vor dem Erzeugen root oder verwende
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sudo&amp;sektion=8">sudo(8)</a>
mit der Option <tt>-c</tt>, um die Erzeugung mit den Begrenzungen der
dazugehörigen Loginklasse durchzuführen (greife auf
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=login.conf&amp;sektion=5">login.conf(5)</a>
zurück, wenn du weitere Informationen über Loginklassen benötigst).
<li>Du hast einfach nicht genügend RAM in deiner Maschine.
</ul>


<a name="PortsClean"></a>
<h3>15.3.6 - Nach dem Build aufräumen</h3>

Du möchtest vermutlich das standardmäßige Arbeitsverzeichnis eines Ports
aufräumen, wenn du mit der Erzeugung und Installation eines Packages
fertig bist.

<blockquote><pre>
$ <b>make clean</b>
===&gt;  Cleaning for rsnapshot-1.2.9
</pre></blockquote>

Zusätzlich kannst du auch die Arbeitsverzeichnisse aller Abhängigkeiten
des Ports mit diesem Make-Target aufräumen:

<blockquote><pre>
$ <b>make clean=depends</b>
===&gt;  Cleaning for rsync-2.6.9
===&gt;  Cleaning for rsnapshot-1.2.9
</pre></blockquote>

Wenn du das Set oder die Sets der Quelltextdistribution des Ports
löschen möchtest, würdest du Folgendes aufrufen:

<blockquote><pre>
$ <b>make clean=dist</b>
===&gt;  Cleaning for rsnapshot-1.2.9
===&gt;  Dist cleaning for rsnapshot-1.2.9
</pre></blockquote>

Falls du mehrere Flavors des gleichen Ports kompiliert hast, kannst
du das Arbeitsverzeichnis aller Flavors auf einmal aufräumen:

<blockquote><pre>
$ <b>make clean=flavors</b>
</pre></blockquote>

Du kannst auch eine spezielle Variable setzen, mit der automatisch
nach der Übersetzung aufgeräumt wird. Arbeitsverzeichnisse werden
somit automatisch nach der Erstellung eines Packages geleert:
<blockquote><pre>
$ <b>make package BULK=Yes</b>
</pre></blockquote>

<a name="PortsDelete"></a>
<h3>15.3.7 - Das Package eines Ports deinstallieren</h3>

Das Deinstallieren eines Ports ist sehr einfach:

<blockquote><pre>
$ <b>make uninstall</b>
===&gt; Deinstalling for rsnapshot-1.2.9
rsnapshot-1.2.9: complete
Clean shared items: complete
</pre></blockquote>

Dies wird pkg_delete(1) so aufrufen, dass das zugehörige Package von
deinem System entfernt wird. Wenn du möchtest, dann kannst du mit
folgendem Aufruf das Package eines Ports deinstallieren und zugleich
wieder neu installieren:

<blockquote><pre>
$ <b>make reinstall</b>
===&gt;  Cleaning for rsnapshot-1.2.9
/usr/sbin/pkg_delete rsnapshot-1.2.9
rsnapshot-1.2.9: complete
Clean shared items: complete
===&gt;  Installing rsnapshot-1.2.9 from /usr/ports/packages/i386/all/rsnapshot-1.2.9.tgz
rsnapshot-1.2.9: complete
</pre></blockquote>

Wenn du einfach nur die Packages loswerden willst, die du gerade erzeugt
hast, kannst du dies wie folgt tun:

<blockquote><pre>
$ <b>make clean=packages</b>
===&gt;  Cleaning for rsnapshot-1.2.9
rm -f /usr/ports/packages/i386/all/rsnapshot-1.2.9.tgz
</pre></blockquote>

<a name="PortsFlavors"></a>
<h3>15.3.8 - Flavors und Subpackages verwenden</h3>

Lies bitte die
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ports&amp;sektion=7">ports(7)</a>-Manualseite,
die einen guten Überblick über diese Thematik verschafft. Es gibt zwei
Mechanismen, mit denen das Erstellen von Packages der Software in Bezug
auf verschiedene Bedürfnisse verwaltet werden kann.

<p>
Der erste Mechanismus wird <b>Flavors</b> genannt. Ein Flavor verweist
normalerweise auf einen bestimmten Satz Kompilierungsoptionen. Zum
Beispiel haben einige Applikationen ein no_x11-Flavor, das auf Systemen
ohne X genutzt werden kann. Einige Shells haben ein static-Flavor, das
eine statisch gelinkte Version erzeugen wird. Es gibt Ports, die
verschiedene Flavors für die Erzeugung mit unterschiedlichen grafischen
Toolkits besitzen. Andere Beispiele sind u.&nbsp;a.: Unterstützung für
verschiedene Datenbankformate, verschiedene Netzwerkoptionen (SSL, IPv6,
...), verschiedene Papierformate etc.

<p>
<b>Zusammenfassung:</b>
Am wahrscheinlichsten wirst du Flavors verwenden, wenn ein Package nicht
für das Flavor bereitgestellt wurde, nach dem du suchst. In diesem Fall
musst du das gewünschte Flavor angeben und selbst den Port erzeugen.

<p>
Die meisten Flavors haben ihr eigenes Arbeitsverzeichnis während
der Erzeugungsphase; ebenfalls wird jedes Flavor in ein Package mit
dem zum Flavor gehörigen Namen gepackt, um Verwechslungen mit anderen
auszuschließen. Um die Flavors eines bestimmten Ports anzeigen zu
lassen, würdest du in das Unterverzeichnis wechseln und Folgendes
aufrufen:

<blockquote><pre>
$ <b>make show=FLAVORS</b>
</pre></blockquote>

Wirf auch einen Blick in die DESCR-Dateien der Ports; mit ihnen sollen
die verfügbaren Flavors erklärt werden.

<p>
Der zweite Mechanismus wird <b>Subpackages</b> genannt.
Ein Portierer könnte entscheiden, dass Subpackages für verschiedene
Teile der gleichen Applikation erstellt werden, falls diese logisch
getrennt werden können. Dir werden oft Subpackages für den Client-
und für den Serverteil eines Programmes begegnen. Manchmal wird auch
sehr ausgiebige Dokumentation in ein separates Subpackage gebündelt, da
dieses viel Plattenspeicher in Anspruch nimmt. Ebenfalls werden
zusätzliche Funktionalitäten in eigene Packages ausgelagert, falls diese
eine große Anzahl zusätzlicher Abhängigkeiten mit sich bringen. Der
Portierer entscheidet ebenfalls, welches Subpackage das Haupt-Subpackage
ist und somit standardmäßig installiert wird. Andere Beispiele sind:
ausgiebige Testumgebungen, die mit der Software ausgeliefert werden,
separate Module mit Unterstützung für unterschiedliche Dinge etc.

<p>
<b>Zusammenfassung:</b>
Einige Ports werden in mehrere Packages aufgeteilt. Mit
<tt>make install</tt> wird nur das Haupt-Subpackage installiert.

<p>
Um die unterschiedlichen Packages anzuzeigen, die von einem Port erzeugt
werden, verwende:
<blockquote><pre>
$ <b>make show=PACKAGES</b>
</pre></blockquote>
<p>

Mit <tt>make install</tt> wird nur das erste Subpackage installiert.
Um alle zu installieren, verwende:

<blockquote><pre>
$ <b>make install-all</b>
</pre></blockquote>
<p>


Um die verschiedenen verfügbaren Subpackages für einen Port anzuzeigen,
verwende:

<blockquote><pre>
$ <b>make show=MULTI_PACKAGES</b>
</pre></blockquote>

Es ist möglich, auszuwählen, welches Subpackage vom Ports-Tree aus
installiert werden soll - das Gleiche gilt für mehrere Subpackages.
Nach einigen Tests wird ein
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pkg_add&amp;sektion=1&amp;manpath=OpenBSD+4.2">pkg_add(1)</a>-Aufruf
erfolgen, der das gewünschte Subpackage (oder die gewünschten
Subpackages) installiert.

<blockquote><pre>
$ <b>env SUBPACKAGE="-server" make install</b>
</pre></blockquote>

<p>
<b>Hinweis:</b>
Der Subpackagesmechanismus verarbeitet nur Packages - es werden
keine Konfigurationsoptionen vor dem Erzeugen des Ports geändert. Du
müsstest hierfür Flavors verwenden.

<!--
<a name="PortsSecurity"></a>
<h3>15.3.9 - Sicherheitsupdates</h3>

Wenn schwerwiegende Fehler oder Sicherheitslücken in der Software von
Drittanbietern gefunden werden, dann werden sie im <b>-stable</b>-Branch
des Ports-Trees behoben. Denke daran, dass der Lebenszyklus 1 Jahr
beträgt: Nur current und das aktuellste Release werden aktualisiert;
erklärt wird das ganze in <a href="faq5.html#Flavors">FAQ 5 - OpenBSDs
Flavors</a>.

<p>
Dies bedeutet, dass du lediglich darauf achten musst, dass du den
korrekten Branch des Ports-Trees verwendest und die gewünschte Software
von diesem aus erzeugst. Du kannst deinen Tree mit CVS auf dem
aktuellen Stand halten und dich zusätzlich in der
<a href="../../de/mail.html">Mailingliste</a> ports-security
einschreiben, um über sicherheitsbezogene Ankündigungen, die die
Software im Ports-Tree betrifft, auf dem Laufenden gehalten zu werden.

<p>
Selbstverständlich landen die Sicherheitsupdates erst im
-current-Ports-Tree bevor sie in den -stable-Branch übernommen werden.
-->

<a name="PkgFAQ"></a>
<h2>15.4 - FAQ</h2>

<a name="NoFun"></a>
<h3>15.4.1 - Ich bekomme alle möglichen unverständlichen
Fehlermeldungen. Ich schaffe es einfach nicht, diesen Portskram zum
Laufen zu kriegen.</h3>

<p>
Es ist sehr wahrscheinlich, dass du ein System und einen Ports-Tree
verwendest, die nicht synchron sind.

<p>
<i>Bitte was?</i>
<ul>
<li>Lies ALLES über
<a href="faq5.html#Flavors">OpenBSDs Flavors</a>:
-release, -stable und -current.
Dies hier ist eine kurze Zusammenfassung doch lies bitte das gerade
genannte Dokument, um eine Ahnung zu kriegen, welches der genannten
Flavors sinnvoll für dich wäre.
<ul>
<li><a href="../../de/orders.html">Release</a>: das, was auf der CD ist
<li><a href="../../de/stable.html">Stable</a>: Release mit Sicherheits-
  und Stabilitätsverbesserungen
<li><a href="current.html">Current</a>: die Entwicklungsversion von
  OpenBSD
</ul>
<li>Lade NIEMALS einen -current-Ports-Tree herunter und erwarte, dass
er auf einem -release oder -stable-System funktioniert. Dies ist einer
der häufigsten Fehler und wird Leute verunsichern, wenn du fragst, warum
nichts zu funktionieren scheint.
<b>Wenn du -current folgst benötigst du sowohl ein -current-System als
auch einen -current-Ports-Tree</b>.  Ja, das bedeutet in der Tat, dass
ein wundervoller neuer Port nicht auf deinem »älteren« System läuft -
selbst wenn das System noch vor ein paar Wochen -current war.
Wenn du X11 als Teil deines Systems einsetzt, dann musst du auch darauf
achten, dass der zugehörige Branch eingesetzt wird!
<li>Aufgrund der Tatsache, dass keine großartigen Änderungen in -stable
einfließen, ist es möglich, -release-Packages und -Ports auf einem
-release-System einzusetzen. Es besteht keine Notwendigkeit, alle
installierten Packages zu aktualisieren, wenn ein paar Erratapatches in
dein System eingespielt wurden.
</ul>

<p>
Ein weiterer häufiger Grund ist eine fehlende X11-Installation. Selbst
wenn der Port, den du übersetzen willst, keine direkte X11-Abhängigkeit
vorweist, so könnten Subpackages oder weitere Abhängigkeiten X11-Header
und -Bibliotheken voraussetzen. Übersetzen von Ports auf Systemen
ohne X11 wird daher nicht unterstützt. Solltest du dennoch darauf
bestehen, bist du auf dich allein gestellt und musst Fehler selbst
herausfinden.  Für viele Ports gibt es dennoch »no_x11«-Packages,
die du auch ohne X11 auf deinem System installieren kannst.

<p>
Für 4.2 gilt, dass für viele Packages, die libexpat verwenden,
ein installiertes xbase42.tgz <i>Bedingung</i> ist; selbst wenn keine
grafische Funktionalität gewünscht ist. In 4.3 wird dieses Problem
behoben sein.

<a name="Latest"></a>
<h3>15.4.2 - Die aktuellste Version meiner Lieblingssoftware ist nicht
verfügbar!</h3>

Wenn du eine Release- oder stabile Version von OpenBSD verwendest,
dann wirst du keine Aktualisierungen der Packages bis zum nächsten
Release sehen; es sei denn, dass Sicherheitsprobleme ein Update des
Ports im -stable-Branch und dem dazugehörigen Package rechtfertigen.

<p>
<b>WARNUNG: Mische NIEMALS Versionen der Ports und von OpenBSD!</b>

<p>
Tätest du das, so würdest du früher oder später (aber vermutlich sogar
schon sehr früh) dir selbst Kopfzerbrechen bereiten, da du
<a href="#NoFun">alle möglichen Fehler</a> beheben müsstest.

<p>
<i>Was solls, alles was ich hier habe ist -current!</i>

<p>
Die Ports-Collection ist ein Projekt von Freiwilligen. Manchmal hat das
Projekt einfach nicht genügend Entwicklerressourcen, um alles auf dem
neuesten Stand zu halten. Entwickler beschäftigen sich meist mit dem,
was sie selbst als interessant ansehen und testen es in ihrer Umgebung.
Deine <a href="../../de/donations.html">Spenden</a> können einen
Unterschied machen, auf wie vielen Plattformen die Ports getestet werden.

<p>
Einige individuelle Ports können gerade deshalb hinter den
Mainstreamversionen liegen. In der Ports-Collection könnte eine Version
eines Programms vom Januar sein, obwohl eine neue Version des Programms
von dessen Entwicklern im Mai - also drei Monate später - veröffentlicht
wurde. Oft ist das eine schwere Entscheidung; die neue Version könnte
Probleme unter OpenBSD haben, die der Verantwortliche beheben muss -
oder aber die Entwickler haben die Software einfach schlechter gemacht
als die alte: OpenBSD könnte andere
<a href="../../de/goals.html">Ziele</a> als die Mainstreamentwickler
der anderen Projekte haben, was manchmal dazu führt, dass
Funktionalitäts-, Entwurfs- oder Implementationsänderungen der
Software aus Sicht der OpenBSD-Entwickler nicht hinnehmbar sind.
Das Update könnte aber auch einfach nach hinten verschoben worden sien,
da die neue Version einfach nicht als wichtig genug für eine
Aktualisierung angesehen wird.

<p>
Wenn du wirklich unbedingt eine neue Version eines Ports benötigst,
kannst du den Verantwortlichen des Ports bitten, eine Aktualisierung
des Ports zu veröffentlichen (siehe <a href="#Problems">unten</a>, wie
man herausfindet, wer der Verantwortliche ist). Wenn du
<a href="#Helping">helfen</a> kannst, dann ist es natürlich noch besser.


<a name="NoPkg"></a>
<h3>15.4.3 - Warum gibt es kein Package meiner Lieblingssoftware?</h3>

Hierfür kann es mehrere Möglichkeiten geben:

<ul>
<li>Auf den OpenBSD-<a href="../../de/orders.html">CD-ROMs</a> gibt es
nicht genügend Speicherplatz, um jedes Package für jede Plattform
bereitzustellen. Daher werden nur die am häufigsten verwendeten
Packages mit auf die CDs aufgenommen. Außerdem kann manche Software nur
frei weitergegeben werden, wodurch sie nicht mit auf die CDs
genommen werden dürfen. Falls du ein Package nicht auf den CDs finden
kannst, dann probiere eine andere Quelle, wie zum Beispiel einen
FTP-Mirror.
<li>Manche Software darf einfach nicht in Form von Binarypackages
weitergegeben werden - so wie es in der Lizenz steht. Andere Software
könnte mit Patenten behaftet sein und kann daher nicht
weitergegeben werden. Falls deine Lieblingssoftware in diese Kategorie
fällt, musst du den Port verwenden - also vom dem Quelltext aus
übersetzen.
<li>Offensichtlich, doch manchmal vergessen: Es gibt
<a href="#NoPort">keinen Port deiner Lieblingssoftware</a>. Dies
kannst du überprüfen, indem du <a href="#PortsSearch">den Ports-Tree
durchsuchst</a>. Wenn es in der Tat keinen Port deiner Lieblingssoftware
gibt, ist deine <a href="#Helping">Hilfe</a> natürlich gern gesehen.
</ul>

<a name="NoPort"></a>
<h3>15.4.4 - Warum gibt es keinen Port meiner Lieblingssoftware?</h3>

Die Ports-Collection ist ein Projekt von Freiwilligen. Aktive
Portentwicklung wird von einer begrenzten Anzahl Leute in ihrer
Freizeit durchgeführt. Diese Leute erstellen Ports meist nur von der
Software, die sie direkt nutzen oder interessant finden.

<p>
Du kannst <a href="#Helping">helfen</a>. Ziehe das Erstellen eines
eigenen Ports in Betracht. Es gibt einige Dokumentationen darüber:
<a href="../../de/porting.html">Einen OpenBSD-Port erzeugen</a>.
Lies es - und lies es wieder. Insbesondere den Teil über das
<i>Verwalten</i> deines Ports. Versuche dann, einen eigen Port
zu erstellen und teste ihn sorgfältig Schritt für Schritt. Wenn er
schlussendlich einwandfrei für dich arbeitet, sende ihn an die
Portsmailingliste
<a href="mailto:ports@openbsd.org">ports@openbsd.org</a>. Die Chancen,
eine Rückmeldung und Testberichte von anderen Leuten zu erhalten, stehen
gut. Wenn die Tests erfolgreich sind wird dein Port in Betracht gezogen,
in den Ports-Tree übernommen zu werden.


<a name="NotInBase"></a>
<h3>15.4.5 - Warum ist meine Lieblingssoftware nicht Teil des
Basissystems?</h3>

OpenBSD soll ein kleines eigenständiges Unix-ähnliches Betriebssystem
sein. Wir müssen daher klar begrenzen, was rein darf und was nicht.
Generell muss für eine Applikation Folgendes gelten, um in das
Basissystem übernommen werden zu können:

<ul>
<li>Es muss unseren hohen Qualitätsstandards entsprechen, die in den
<a href="../../de/goals.html">Zielen</a> des OpenBSD-Projekts festgelegt
sind.
<li>Die Lizenz darf nicht zu restriktiv und muss mit der BSD-Lizenz
kompatibel sein.
<li>Sie darf nicht zu groß sein, damit die Größe des Basissystems
weiterhin akzeptabel ist.
</ul>

<p>
Weitere Antworten hierzu können ebenfalls in der
<a href="faq1.html#HowAbout">FAQ 1</a> gefunden werden.

<a name="PkgVsPorts"></a>
<h3>15.4.6 - Was sollte ich verwenden: Packages oder Ports?</h3>

Generell wird dir <b>dringend geraten</b>, die Packages dem Erzeugen
der Applikationen von den Ports aus vorzuziehen. Das OpenBSD-Portsteam
betrachtet die Packages als ihr Ziel ihrer Portierungsbemühung - nicht
die Ports selbst.

<p>
Das Erzeugen einer komplexen Applikation vom Quelltext aus ist nicht
trivial. Nicht nur muss die Applikation kompiliert werden, auch die
Werkzeuge, die während der Erzeugung genutzt werden, müssen übersetzt
werden. Leider entwickeln sich OpenBSD, die Werkzeuge und die
Applikationen ständig weiter; oft ist es schwer, alle Teile
zusammenfügen zu können. Wenn dann alles läuft, könnte eine Revision
eines der Teile wieder alles zunichte machen. Alle
<a href="faq1.html#Next">sechs Monate</a> wird ein
<a href="faq5.html#Flavors">neues Release</a> von OpenBSD
veröffentlicht. Es gibt Bemühungen, das Erzeugen jedes einzelnen Ports
auf allen Plattformen gewährleisten zu können, doch ist es während dem
Entwicklungszyklus sehr wahrscheinlich, dass das mit einigen Ports
nicht funktioniert.

<p>
Neben der Zusammenstellung aller Teile ist es eine Frage der benötigten
Zeit und der Ressourcen, einige der Applikationen vom Quelltext aus zu
übersetzen. Ein typisches Beispiel ist
<a href="http://www.cvsup.org/">CVSup</a> - ein Werkzeug, das oft zum
<a href="../../de/cvsup.html">Folgen des OpenBSD-Source-Trees</a>
genutzt wird. Um CVSup auf einem durchschnittlich schnellen System mit
guter Internetanbindung zu installieren dauert ca. zehn Sekunden - das
ist die Zeit, die zum Download und Entpacken einer einzelnen 779 kB
großen Packagedatei benötigt wird. Im Gegensatz dazu ist das
Erzeugen von CVSup auf der gleichen Maschine vom Quelltext aus eine
riesige Aufgabe, die viele Werkzeuge und einen Bootstrap eines
Compilers benötigt; das ganze nimmt mehr als eine halbe Stunde auf der
gleichen Maschine in Anspruch.
Andere Applikationen wie zum Beispiel
<a href="http://www.mozilla.org">Mozilla</a> oder
or <a href="http://www.kde.org">KDE</a> können Stunden und riesige
Mengen Plattenspeicher und RAM/Swap in Anspruch nehmen, um erzeugt
werden zu können. Warum willst du dir das alles antun und die Zeit
opfern, wenn die Programme bereits kompiliert vorliegen und auf deiner
<a href="../../de/orders.html">CD-ROM</a> oder auf einem
<a href="../../de/ftp.html">FTP-Mirror</a> darauf warten, installiert
zu werden?

<p>
Selbstverständlich gibt es ein paar gute Gründe, in einigen Fällen
Ports statt Packages zu verwenden:

<ul>
<li>Distributionsgesetze verbieten OpenBSD die Weitervergabe eines
Packages.
<li>Du möchtest die Applikation modifizieren oder debuggen - oder
einfach den Quelltext ansehen.
<li>Du brauchst ein Flavor eines Ports, der nicht vom OpenBSD-Portsteam
bereitgestellt wird.
<li>Du möchtest das Verzeichnislayout ändern (z.&nbsp;B. <tt>PREFIX</tt>
oder <tt>SYSCONFDIR</tt> modifizieren).
</ul>

Für die meisten Leute und für die meisten Applikationen ist das
Verwenden der Packages jedoch bei weitem einfacher und
selbstverständlich der empfohlene Weg, um Applikationen zu OpenBSD
hinzuzufügen.


<a name="Knobs"></a>
<h3>15.4.7 - Wie optimiere ich diese Ports, damit sie bestmögliche
Leistung bieten?</h3>

Bei OpenBSD geht es um Stabilität und Sicherheit. Genauso wie der
GENERIC-Kernel der standardmäßige und der einzige unterstützte Kernel
ist, so stellt auch das Portsteam sicher, dass die Ports funktionieren
und stabil sind. Wenn du alle möglichen Compileroptionen aktivieren
willst, so musst du das schon selbst machen. Frage bitte nicht auf den
Mailinglisten nach, warum etwas nicht funktioniert, wenn du versucht
hast, ein paar der versteckten Kniffe zu aktivieren, die die Dinge
schneller machen. Generell gilt, dass das Optimieren für 99 % der
Anwender nicht nötig ist und vermutlich eine totale Verschwendung von
Zeit ist - deiner Zeit, die der Anwender sowie die der Entwickler, die
von deinen Problemen lesen, die in Wirklichkeit aber gar keine sind.


<a name="Wait"></a>
<h3>15.4.8 - Ich habe einen neuen Port/ein neues Update vor Wochen
bereitgestellt. Warum wird er/es nicht eingebunden?</h3>

Dem Portsteam stehen nur begrenzte Ressourcen zur Verfügung und kein
Commiter konnte sich deinen Port/dein Update bisher ansehen. So
frustrierend es sein mag, ignoriere die Tatsache einfach. Kümmer dich
um deinen Port und sende Updates - vielleicht wird sich jemand darum
kümmern. Es ist bereits vorgekommen, dass Leute auf einmal etwas freie
Zeit hatten, Ports zu commiten oder ihr Interesse richtete sich auf
einmal auf andere Dinge, was dann plötzlich dazu führte, dass alte
Bereitstellungen interessant wurden, wenn man sich an sie erinnerte.


<a name="Problems"></a>
<h2>15.5 - Probleme berichten</h2>

Wenn du Probleme mit einem bereits existierenden Port hast, sende bitte
eine E-Mail an den Verantwortlichen. Um herauszufinden, wer der
Verantwortliche für den Port ist, gib beispielsweise Folgendes ein:

<blockquote><pre>
$ cd /usr/ports/archivers/unzip
$ make show=MAINTAINER
</pre></blockquote>

<p>
Alternativ dazu, falls kein Verantwortlicher angegeben ist oder du
ihn/sie nicht erreichen kannst, sende eine E-Mail an die
OpenBSD-Portsmailingliste
<a href="mailto:ports@openbsd.org">ports@openbsd.org</a>.
Bitte verwende NICHT die misc@openbsd.org-Mailingliste für
portsbezogene Fragen.
<p>
Stelle in jedem Fall Folgendes bereit:
<ul>
<li>Deine OpenBSD-Version; einschließlichen allen Patches, die du
angewandt hast. Die Kernelversion kannst du mit
<tt>sysctl -n kern.version</tt> ermitteln.
<li>Die Version deines Ports-Trees: Wenn die Datei
<tt>/usr/ports/CVS/Tag</tt> existiert, gib ihren Inhalt mit an.
Falls diese Datei nicht existiert, verwendest du den
-current-Ports-Tree.
<li>Eine komplette Beschreibung deines Problems. Scheue nicht davor,
Details anzugeben. Erwähne alle Schritte, die du durchgeführt hast,
bevor das Problem auftrat. Ist das Problem reproduzierbar? Je mehr
Informationen du zur Verfügung stellst, desto wahrscheinlicher
erhältst du auch Hilfe.
</ul>
Für Ports, die nicht richtig übersetzt werden können, muss eine
vollständige Protokollierung der Erzeugungsphase angegeben werden.
Du kannst hierfür das portslogger-Skript verwenden, das sich extra
hierfür unter <tt>/usr/ports/infrastructure/build</tt> befindet.
Ein Beispiel für einen portslogger-Aufruf könnte Folgendes sein:

<blockquote><pre>
$ mkdir ~/portslogs
$ cd /usr/ports/archivers/unzip
$ make clean install 2&gt;&amp;1 | /usr/ports/infrastructure/build/portslogger \
           ~/portslogs
</pre></blockquote>

Hiernach solltest du eine Logdatei der Erzeugungsphase in deinem
~/portslogs-Verzeichnis haben, die du dem Verantwortlichen des Ports
senden kannst. Stelle ebenfalls sicher, dass du keine speziellen
Optionen während der Übersetzung verwendet hast (z.&nbsp;B. in
<tt>/etc/mk.conf</tt>).

<p>
Alternativ dazu kannst du auch Folgendes machen:
<ul>
<li>Verwende
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=script&amp;sektion=1">script(1)</a>,
um eine vollständige Logdatei der Erzeugungsphase zu erstellen.
Entferne nicht die Konfigurationsinformationen.
<li>Hänge die Ausgabe von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pkg_info&amp;sektion=1&amp;manpath=OpenBSD+4.2">pkg_info(1)</a>
mit an selbst wen es nur im entferntesten relevant wirkt.
<li>Interne Compilerfehler von
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gcc&amp;sektion=1">gcc(1)</a>
bitten dich darum, einen Fehlerbericht an die gcc-Mailingliste zu
schicken. Es erspart eine Menge Zeit, wenn du diesem Rat folgst und
du zumindest die Dateien mit bereitstellst, die von
<tt>gcc -save-temps</tt> erstellt werden.
</ul>


<a name="Helping"></a>
<h2>15.6 - Wie man uns helfen kann</h2>

Es gibt viele Wege, wie du uns helfen kannst. Sie sind hier
aufgelistet - sortiert nach der Schwierigkeit.

<ul>
<li><a href="#Problems">Berichte Probleme</a> sobald du welchen
begegnest.
<li>Du kannst systematisch Ports testen und Problemfälle berichten
oder Verbesserungen vorschlagen. Wirf einfach einen Blick auf die
<a href="../../de/porttest.html">Anleitung zum Portstesten</a>.
<li>Probier die Aktualisierungen für die Ports aus, die auf der
Portsmailingliste angekündigt werden.
<li>Sende Aktualisierungen oder Patches an die Verantwortlichen der
Ports oder an die Portsmailingliste, wenn der Port keinen
Verantwortlichen hat. Generell ist dies sehr gerne gesehen, da deine
Patches sonst die Zeit der Entwickler in Anspruch nehmen statt ihnen die
Zeit zu ersparen.
<li>Erstelle neue Ports. Wenn du wirklich engagiert bist und alles über
das Portieren von Applikationen auf OpenBSD wissen willst, ist das
Dokument <a href="../../de/porting.html">Einen OpenBSD-Port erzeugen</a>
ein guter Startpunkt.
</ul>

<b>Hinweis:</b> Für alle Erstellungen von neuen Ports und das
subsequente Testen, oder für das Testen von Portupdates <b>musst du
ein -current-System verwenden!</b> Generell ist das aufgrund der
ständigen Änderungen keine schöne Grundlage, sodass du dir sicher sein
solltest, ob du -current ständig folgen willst.

<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ-Index]</a>
<a href= "faq14.html">[Zum Kapitel 14 - Platteneinrichtung]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt="[back]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: faq15.html,v 1.47 ]<br>
$Translation: faq15.html,v 1.45 2008/03/04 23:03:09 paldium Exp $<br>
-->
$OpenBSD: faq15.html,v 1.38 2008/03/09 13:37:12 tobias Exp $
</small>

</body>
</html>
