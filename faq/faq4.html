<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>4 - OpenBSD Installation Guide</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name= "description"   content= "OpenBSD FAQ 4 - Installation Guide">
<meta name= "copyright"     content= "This document copyright 1998-2015 by OpenBSD.">
<link rel="canonical" href="http://www.openbsd.org/faq/faq4.html">
</head>

<!-- Passes validator.w3.org.  Please keep it this way -->

<body bgcolor= "#ffffff" text= "#000000">

<a href="../index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../images/smalltitle.gif" border="0">
</a>
<p>

<a href= "index.html">[FAQ Index]</a>
<a href= "faq3.html">[To Section 3 - Getting started with OpenBSD]</a>
<a href= "faq5.html">[To Section 5 - Building the System from Source]</a>

<h1><font color="#e00000">4 - OpenBSD Installation Guide</font></h1>
<hr>

<p>
<h3>Table of Contents</h3>
<ul>
<li><a href= "#Overview"    >4.1 - Overview of the OpenBSD installation
                                     procedure</a>
<li><a href= "#Checklist"   >4.2 - Pre-installation checklist</a>

<li><a href="#MkInsMedia"   >4.3 - Creating bootable OpenBSD install
                                     media</a>
    <ul>
    <li><a href="#MkCD-ROM" >4.3.1 - Creating a boot CD</a>
    <li><a href="#MkFlop"   >4.3.2 - Creating floppies</a>
    <li><a href="#Flash"    >4.3.4 - Creating a bootable install flash
	 drive from Unix</a>
    </ul>
<li><a href="#Boot"         >4.4 - Booting OpenBSD install media</a>
<li><a href="#Install"      >4.5 - Performing a simple install</a>
  <ul>
  <li><a href="#InstStart"    >4.5.1 - Starting the install</a>
  <li><a href="#InstQuestions">4.5.2 - The Install Questions</a>
  <li><a href="#InstDisks"    >4.5.3 - Setting up disks</a>
  <li><a href="#InstMedia"    >4.5.4 - Choosing installation media and
    file sets</a>
  <li><a href="#Inst1stBoot"  >4.5.5 - First Boot!</a>
  <li><a href="#InstFinish"   >4.5.6 - One Last Thing...</a>
  </ul>

<li><a href="#More"         >4.6 - Details for a more complex install</a>
  <ul>
  <li><a href="#MoreNetwork"  >4.6.1 - Setting up the network</a>
  <li><a href="#MoreTimeZone" >4.6.2 - Setting the time zone</a>
  <li><a href="#Morefdisk"    >4.6.3 - Custom fdisk(8) layout</a>
  <li><a href="#Moredisklabel">4.6.4 - Custom disklabel layout</a>
  </ul>
<li><a href= "#FilesNeeded" >4.7 - What files are needed for installation?</a>
<li><a href= "#Partitioning">4.8 - How should I partition my disk?</a>
<li><a href= "#Multibooting">4.9 - Multibooting OpenBSD (amd64, i386)</a>
<li><a href= "#SendDmesg"   >4.10 - Sending your dmesg to dmesg@openbsd.org
                                     after the install</a>
<li><a href= "#AddFileSet"  >4.11 - Adding a file set after install</a>
<li><a href= "#bsd.rd"      >4.12 - What is 'bsd.rd'?</a>
<li><a href= "#InstProb"    >4.13 - Common installation problems</a>
  <ul>
  <li><a href="#noboot"     >4.13.2 - My i386 won't boot after install</a>
  <li><a href="#sshhang"    >4.13.3 - My machine booted, but hung at the
     ssh-keygen process</a>
  <li><a href="#noftplist"  >4.13.4 - Why don't the downloadable images
     include SHA256.sig?</a>
  <li><a href="#blankfdisk" >4.13.5 - My fdisk partition table is trashed
     or blank!</a>
  <li><a href="#noflopcd"   >4.13.6 - I have no floppy or CD-ROM on my
     machine</a>
  <li><a href="#shamismatch">4.13.7 - I got the message "Failed to change directory"
     when doing an install!</a>
  </ul>
<li><a href= "#site"        >4.14 - Customizing the install process</a>
<li><a href= "#Multiple"    >4.15 - How can I install a number of similar
     systems?</a>
<li><a href="#getdmesg"     >4.16 - How can I get a dmesg(8) to report an
     install problem?</a>
</ul>
<hr>

<h2 id="Overview">4.1 - Overview of the OpenBSD installation procedure</h2>

<p>
OpenBSD has long been respected for its simple and straight forward
installation process, which is very consistent across all platforms.

<p>
All platforms use a very similar installation procedure, however
there are some minor differences in details on a few platforms.
In all cases, you are urged to read the platform-specific INSTALL
document in the <i>platform</i> directory on the CD-ROM or FTP sites
(for example, <tt>i386/INSTALL.i386</tt>, <tt>macppc/INSTALL.macppc</tt>
or <tt>sparc/INSTALL.sparc</tt>).

<p>
The OpenBSD installer is a <a href="#bsd.rd">special</a> kernel
with a number of utilities and install scripts embedded in a
pre-loaded RAM disk.
After this kernel is booted, the operating system is extracted from
a number of compressed
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tar&amp;sektion=1">tar(1)</a>
(<tt>.tgz</tt>) files from a source other than this pre-loaded RAM disk.
There are several ways to boot this install kernel:

<ul>
<li><b>Floppy disk:</b>
At this point, if you are running a system that only has floppy support,
we will consider you an advanced user who probably doesn't need this
FAQ for guidance.

<li><b>CD-ROM:</b> On several platforms a CD-ROM image
(<tt>cdXX.iso</tt> for just booting, or <tt>installXX.iso</tt> for the
entire install) is provided allowing creation of a bootable CD-ROM.

<li><b>Existing partition:</b> The <a href="#bsd.rd">RAM disk</a> kernel
can be booted off an already existing partition for an upgrade or
reinstall.

<li><b>Network:</b> Some platforms support booting over a network
(for example using <a href="faq6.html#PXE">PXE</a> or other
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=diskless&amp;sektion=8">network
boot</a>).

<li><b>Writing a file system image to disk (miniroot):</b> 
Typically, these are written to a USB device to boot up the install
kernel.

</ul>

Not every <a href="../plat.html">platform</a> supports all boot options:

<ul>
<li><a href="../alpha.html"><b>alpha:</b></a> Floppy, CD-ROM, network,
writing a floppy image to hard disk.

<li><a href="../amd64.html"><b>amd64:</b></a> Floppy, CD-ROM, miniroot,
<a href="faq6.html#PXE">network</a>.

<li><a href="../armish.html"><b>armish:</b></a>
Varies by machine.

<li><a href="../aviion.html"><b>aviion:</b></a> Network, existing OS partition.

<li><a href="../hppa.html"><b>hppa:</b></a> Network.

<li><a href="../i386.html"><b>i386:</b></a> Floppy, CD-ROM, miniroot,
<a href="faq6.html#PXE">network</a>.

<li><a href="../landisk.html"><b>landisk:</b></a> Miniroot, installed
using another computer.

<li><a href="../loongson.html"><b>loongson:</b></a> Miniroot, existing OS partition.

<li><a href="../luna88k.html"><b>luna88k:</b></a> Network.

<li><a href="../macppc.html"><b>macppc:</b></a> CD-ROM, network.

<li><a href="../octeon.html"><b>octeon:</b></a> Network.

<li><a href="../sgi.html"><b>sgi:</b></a> Network, CD-ROM.

<li><a href="../socppc.html"><b>socppc:</b></a> Network.

<li><a href="../sparc.html"><b>sparc:</b></a> Floppy, CD-ROM, network,
writing image to existing swap partition.

<li><a href="../sparc64.html"><b>sparc64:</b></a> Floppy (U1/U2 only),
CD-ROM, network, writing image to existing partition.

<li><a href="../vax.html"><b>vax:</b></a> Floppy, network.

<li><a href="../zaurus.html"><b>zaurus:</b></a> Boot bsd.rd from
Linux partition.  See
<a href="http://ftp.openbsd.org/pub/OpenBSD/5.8/zaurus/INSTALL.zaurus">INSTALL.zaurus</a>
for details. <!-- XXXrelease - bump link -->

</ul>

All platforms can also use a
<a href="#bsd.rd">bsd.rd</a> to reinstall or upgrade.

<p>
Once the install kernel is booted, you have several options of where to get
the <a href="#FilesNeeded">install file sets</a>.
Again, not every platform supports every option.

<ul>
<li><b>CD-ROM:</b> Of course, we prefer you use the
<a href="../orders.html">Official CD-ROM set</a>, but you can also use
<tt>installXX.iso</tt> or you can make your own.

<li><b>HTTP:</b>
Either one of the OpenBSD
<a href="../ftp.html#http">HTTP mirror sites</a>
or your own local web server holding the file sets.

<li><b>Local disk partition:</b>
In many cases, you can install file sets from another partition
on a local hard disk.
For example, on <a href="../i386.html">i386</a>,
you can install from a FAT partition or a CD-ROM formatted in
ISO9660, Rock Ridge or Joliet format.
In some cases, you will have to manually mount the file system before using it.

<li><b>NFS:</b>
Some platforms support using NFS mounts for the file sets.

</ul>

<h2 id="Checklist">4.2 - Pre-installation checklist</h2>

<p>
Before you start your install, you should have some idea what you
want to end up with.

You will want to know the following items, at least:
<ul>
<li>Machine name.
<li>Hardware installed and available:
  <ul>
  <li>Verify compatibility with your platform's hardware
      compatibility page.
  <li>If ISA, you also need to know hardware settings, and confirm
      they are as OpenBSD requires.
  </ul>
<li>Install method to be used (CD-ROM, HTTP, etc.).
<li>Should an important bug be found, how will the system be patched?
  <ul>
  <li>If done locally, you will need to have
      <a href="#Partitioning">sufficient space</a> available for the
      source tree and building it.
  <li>Otherwise, you will need access to another machine to build
      a patched
      <a href="faq5.html#Release">release</a>
      on.
  </ul>
<li>Desired disk layout:
  <ul>
  <li>Does existing data need to be saved elsewhere?
  <li>Will OpenBSD coexist on this system with another OS?
      If so, how will each system be booted?
      Will you need to install a "boot manager"?
  <li>Will the entire disk be used for OpenBSD, or do you want to
      keep an existing partition/OS (or space for a future one)?
  <li>How do you wish to sub-partition the OpenBSD part of your
      disk?
  </ul>
<li>Network settings, if not using DHCP:
  <ul>
  <li>Domain name.
  <li>Domain Name Server(s) (DNS) address.
  <li>IP addresses and subnet masks for each NIC.
  <li>Gateway address.
  </ul>
<li>Will you be running the X Window System?
</ul>

<h2 id="MkInsMedia">4.3 - Creating bootable OpenBSD install media</h2>
Before creating install media, you may wish to 
<a href="faq3.html#Verify">verify</a> the signatures on your downloads.

<p>
Note that it is not possible for the downloaded files to directly check
themselves -- an altered download would always say the files validated
perfectly, of course!


<p>
As examples, we will look at the installation images available for the
<a href="../i386.html">i386</a>
and <a href="../sparc.html">sparc</a> platforms.

<p>
The <a href="../i386.html">i386</a> platform has five separate
installation disk images to choose from:

<ul>
<li><b><tt>cdXX.iso</tt></b> is an ISO9660 image that can be used to
  create a bootable CD with most popular CD-ROM creation software
  on most platforms.
  This image has the widest selection of drivers, and is usually
  the recommended choice if your hardware can boot from a CD-ROM.
<li><b><tt>installXX.iso</tt></b> is an ISO9660 image, containing
  all the standard install files.
  This file can be used to create a CD that can do a stand-alone
  OpenBSD install.
<li><b><tt>floppyXX.fs</tt></b> (Desktop PC) supports many
  older machines that lack bootable CD-ROMs.
  Not recommended for modern hardware.
<li><b><tt>minirootXX.fs</tt></b> is a disk image, can be written to a
  bootable device, such as a USB flash drive, and booted for the install.
  This is equivalent to using the <tt>cdXX.iso</tt> for install.
  File sets would then be pulled down via network; they are not on this
  file system.
<li><b><tt>installXX.fs</tt></b> much like minirootXX.fs, but includes
  all the file sets for install.
  This is equivalent to using <tt>installXX.iso</tt>.
</ul>

<p>
The <a href="../sparc.html">sparc</a> platform has four separate
installation disk images to choose from:

<ul>
<li><b><tt>floppyXX.fs</tt></b> supports systems with a floppy disk.
<li><b><tt>cdXX.iso</tt></b> is an ISO image usable to make your own
  CD for booting SPARC systems with a CD-ROM.
<li><b><tt>minirootXX.fs</tt></b> can be written to a swap partition
  and booted.
<li><b><tt>installXX.iso</tt></b> is an ISO9660 image, containing
  all the standard install files.
  This file can be used to create a CD that can do a stand-alone
  OpenBSD install.
</ul>

On modern platforms, you are best advised to not use floppy install
boot images, as in some of the "bigger" platforms (such as amd64,
sparc64), the floppy images have had to have a lot of drivers and
utilities cut out, which can make installation much more difficult.

<h3 id="MkCD-ROM">4.3.1 - Making a CD-ROM</h3>

<p>
You can create a CD-ROM using the <tt>cdXX.iso</tt> or
<tt>installXX.iso</tt> files.
The exact details here are left to the reader to determine with
the tools they have at their disposal.
Do note that the goal is to create a CD based on the image file,
not to put the ISO file on a CD as a single file.

<p>
In OpenBSD, you can create a CD from an ISO image using
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cdio&amp;sektion=1">cdio(1)</a>:

<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  # <b>cdio tao cd*.iso</b>
</pre></td></tr></table>

<p>
Modern Windows and Macintosh systems can directly create CDs from ISO
images.
<p>
Other Unix-like systems use applications such as
<a href="http://www.cdrkit.org/">cdrkit</a>.

<p>
<h3 id="MkFlop">
4.3.2 - Creating floppies
</h3>
Creating floppies in OpenBSD can be done with
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdformat&amp;sektion=1">fdformat(1)</a>
to prep the disk,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&amp;sektion=0">dd(1)</a>
to write the image, then
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cmp&amp;sektion=1">cmp(1)</a>
to verify the write was good.
A similar process and tools can be used on other Unix platforms.

<p>
Creating floppies on Windows can be done with the native low-level
formatting tools, and a program like <i>ntrw</i> which can be retrieved
from the "tools" directory on any of the mirror sites.


<h3 id="Flash">4.3.3 - Creating a bootable install flash drive from Unix</h3>
A bootable USB flash drive (or a CF/SD/other card, external hard disk,
etc) can be created by installing the target device on a Unix machine
via any recognized adapters, then copying over the image with dd.

<p>
Here is an OpenBSD example, assuming the device was recognized as "sd6":
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  # dd if=/location/install*.fs of=/dev/rsd6c bs=1m
</pre></td></tr></table>
Details of this will vary on other platforms -- the important things are:
<ul>
<li><b><tt>if=</tt></b> the location and name of the image file
<li><b><tt>of=</tt></b> the name of the device being written to -- the
device must be the ENTIRE device (in BSD language, the 'c' partition),
and a raw I/O device (the 'r' in front of the device "sd6"), not a block
mode device.
In some Linux variants, it might be "/dev/sdg" (all of the seventh ("g")
sd disk).
<li><b><tt>bs=1m</tt></b> sets a block size of one megabyte (1024K),
which typically greatly increases the creation speed.
Size is not critical.
	
</ul>

<h2 id="Boot">4.4 - Booting OpenBSD install media</h2>

<h3>Booting i386/amd64</h3>

Booting an install media on the i386 and amd64 PC platforms is nothing new
to most people.
Your system will have to be instructed to boot from whatever media you have
chosen to use, usually through a BIOS setup option.
If you want to boot from CD or a USB device, your system BIOS must be
able to and be set to do so.
Note that some machines are buggy with regard to booting from USB devices;
a BIOS update may help.

<p>
You can also install by booting <a href="#bsd.rd">bsd.rd</a> from an
existing OpenBSD partition, or over the network using the
<a href="faq6.html#PXE">PXE boot process</a>.

<h3>Booting sparc/sparc64</h3>

<b>NOTE:</b>
On the <a href="../sparc64.html">sparc64</a> platform, only the SBus
machines (Ultra 1, Ultra 2) are bootable from floppy.

<p>
You will need the system to be at a monitor ROM prompt, which
typically looks like "<tt>ok </tt>".
If you are using a Sun keyboard, press and hold "STOP" while
tapping "A".
If using a serial console, a BREAK should return you to the
monitor prompt.

<p>
Use the following command to boot from the floppy:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  ok <b>boot floppy</b>
</pre></td></tr></table>

<p>
Usually, you can boot from the CD-ROM drive of a Sun system from
the boot prompt by typing '<tt>boot cdrom</tt>':

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  ok <b>boot cdrom</b>
</pre></td></tr></table>

<h2 id="Install">4.5 - Performing a simple install</h2>

OpenBSD's new installer is designed to install and configure OpenBSD in
a very usable default configuration with very little user intervention.
In fact, you can often just hit <i>ENTER</i> a number of times to get a
good OpenBSD install, moving your hands to the rest of the keyboard only
to enter the root password.

<p>
The installer will create a partitioning plan based on the size of your
hard disk.
While this will NOT be a perfect layout for all people, it provides a
good starting point and a good overall strategy for figuring out what
you need.

<p>
We will start with a very simple install, with brief discussions of the
options provided, and using the magic of hypertext links, allow you to
read more on the topics that interest you and explore your options.

<p>
Installation notes for each platform are on the install CDs and FTP
servers, in the file <tt>INSTALL.<i>&lt;plat&gt;</i></tt>, where
<i>&lt;plat&gt;</i> is your <a href="../plat.html">platform</a>, for
instance, <tt>i386</tt>.

<h3 id="InstStart">4.5.1 - Starting the install</h3>
Whatever your means of booting is, it is now time to use it.  During
the boot process, the kernel and all of the programs used to install
OpenBSD are loaded into memory.
Once the install kernel is booted, the boot media is no longer needed,
everything runs from the RAM disk.
You can actually remove the CD, flash drive or floppy you booted from at
this point, assuming you don't need it for installation files.

<p>
At almost any point during the OpenBSD install process, you can
terminate the current install attempt by hitting CTRL-C and can restart
it without rebooting by running <tt>install</tt> at the shell prompt.
You can also enter a "!" at most places in the installation to get to
a shell prompt, then <tt>exit</tt> the shell to return to the installer.

<p>
When your boot is successful, you will see a lot of text messages scroll by.
This text, on many architectures in white on blue, is the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg</a>,
the kernel telling you what devices have been found and how they are
hooked to other devices.
A copy of this text is saved as <tt>/var/run/dmesg.boot</tt>.

<p>
Then, you will see the following:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  ...
  root on rd0a swap on rd0b dump on rd0b
  erase ^?, werase ^W, kill ^U, intr ^C, status ^T

  Welcome to the OpenBSD/i386 5.8 installation program.
  (I)nstall, (U)pgrade, (A)utoinstall or (S)hell? <b>i</b>
</pre></td></tr></table> <!-- XXXrelease -->

<p>
And with that, we reach our first question.  You have the four options
shown:

<ul>
<li><b>Install:</b> Load OpenBSD onto the system, overwriting whatever
may have been there.  Note that it is possible to leave some partitions
untouched in this process, such as a <tt>/home</tt>, but otherwise,
assume everything else is overwritten.
<li><b>Upgrade:</b> Install a new set of <a href="#FilesNeeded">install
files</a> on this machine, but do not overwrite any configuration
information, user data, or additional programs.  No disk formatting is
done, nor are the <tt>/etc</tt> or <tt>/var</tt> directories overwritten.
A few important notes:
<ul>
<li>After the install, you will have to <!-- XXXrelease -->
<a href="upgrade58.html#etcUpdates">manually merge</a> the changes
into your system before you can expect it to be fully functional.
This is an important step which must be done, as otherwise certain key
services (such as
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf&amp;sektion=4">pf(4)</a>)
may not start.

<li>The Upgrade process is not designed to skip releases!
While this will often work, it is not supported.
If you have to upgrade from an older version, upgrade to each intermediate
version first, or, if the system is very out-of-date, consider a
complete reinstall.

</ul>
<!-- XXXrelease -->
More information on upgrading between releases can be found in the
<a href="upgrade58.html">OpenBSD 5.8 Upgrade Guide</a>.

<li><b>Autoinstall:</b> This option causes the installer to attempt to
fetch an installer response file specified by the local DHCP server.
This is documented in
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=autoinstall&amp;sektion=8">autoinstall(8)</a>.
Autoinstall files can be "one-for-all", or customized by machine's MAC
address.
If the machine boots via <a href="faq6.html#PXE">PXE</a> or other
network booting system, the autoinstall process will start automatically
after a brief pause if configured and no user intervention takes place.

<li><b>Shell:</b> Sometimes, you need to perform repairs or maintenance
to a system which will not (or should not) boot to a normal kernel.
This option will allow you to do maintenance to the system.
A number of important utilities are available on the boot media.
</ul>

We are assuming you are choosing "(I)nstall" here.

<h3 id="InstQuestions">4.5.2 - The Install Questions</h3>

Now we start getting the questions that will define how the system
is set up.
You will note that in most cases, all the questions are asked up front,
then the installation takes place.
If you have a slow computer or a slow Internet connection, you will be
able to answer these questions, walk away, come back later and only have
to reboot the system to complete the install.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  At any prompt except password prompts you can escape to a shell by
  typing '!'. Default answers are shown in []'s and are selected by
  pressing RETURN.  You can exit this program at any time by pressing
  Control-C, but this can leave your system in an inconsistent state.

  Choose your keyboard layout ('?' or 'L' for list) [default] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
In most cases, the default keyboard layout (or terminal type if a serial
console install is being done) is appropriate; however don't just take
the default, respond appropriately.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  System hostname? (short form, e.g. 'foo') <i><b>puffy</b></i>
</pre></td></tr></table>

<p>
This value, along with the DNS domain name (specified
<a href="#MoreNetwork">below</a>), will be saved in the
file <tt>/etc/myname</tt>, which is used during normal boot to set
the hostname of the system.
If you do not set the domain name of the system, the default value of
'my.domain' will be used.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Available network interfaces are: fxp0 vlan0.
  Which one do you wish to configure? (or 'done') [fxp0] <i><b>Enter</b></i>
</pre></td></tr></table>

<p>
<tt>vlan0</tt> is the VLAN virtual interface.
For our purposes here, we are going to ignore this option and stick
to the physical interfaces.
If you have multiple physical interfaces, they will be listed here.
Note that they are identified by driver name, not generic Ethernet
devices.
In this case, "<tt>fxp0</tt>" refers to the first device using the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp&amp;sektion=4">fxp(4)</a>
driver, <tt>fxp1</tt> would be the second device, etc.
More on device naming is in <a href="faq6.html#Setup.if">FAQ 6</a>.

<p>
After selecting the device you wish to configure, you will now
configure it.
In many cases, you will want to configure it using DHCP:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  IPv4 address for fxp0? (or 'dhcp' or 'none') [dhcp] <b><i>Enter</i></b>
  DHCPDISCOVER on fxp0 to 255.255.255.255 port 67 interval 1
  DHCPOFFER from 192.168.1.250 (08:00:20:94:0b:c8)
  DHCPREQUEST on fxp0 to 255.255.255.255 port 67
  DHCPACK from 192.168.1.250 (08:00:20:94:0b:c8)
  bound to 192.168.1.199 -- renewal in 43200 seconds.
</pre></td></tr></table>

<p>
DHCP will configure the IP address, subnet mask, default gateway,
DNS domain name and DNS servers.
If you are not using DHCP, you will need to specify all these things
manually; see the more detailed discussion
<a href="#MoreNetwork" id="backMoreNetwork">below</a>.

<p id="backMoreNetwork">
If you have any IPv6 configuration to do or there are other interfaces
to configure (or you don't like how you configured the previous one),
you can do that now, but in our case, we are done:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  IPv6 address for fxp0? (or 'rtsol' or 'none') [none] <b><i>Enter</i></b>
  Available network interfaces are: fxp0 vlan0.
  Which one do you wish to configure? (or 'done') [done] <b><i>Enter</i></b>
  Using DNS domainname example.org
  Using DNS nameservers at 192.168.1.252
</pre></td></tr></table>

<p>
Now, we set the root account password:
<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Password for root account? (will not echo) <i><b>er8Eeheix0ei</b></i>
  Password for root account? (again) <i><b>er8Eeheix0ei</b></i>
</pre></td></tr></table>

<p>
Use a secure password for the root account. Remember, on the Internet,
they ARE out to get into your computer, and they will be trying lots of
common passwords people think are really clever.

<p>
You will later be given a chance to create an administrative account and
disable remote (SSH) access to the root account, but you still want a
good password on your root account.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Start sshd(8) by default? [yes] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Usually, you will want sshd(8) running.
If your application has no need for sshd(8), there is a small
theoretical security advantage to not having it running.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Do you expect to run the X Window System? [yes] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Not all systems will ask if you expect to run X, those that do ask
require a sysctl to be set to use X.
Answering "y" here will modify <tt>/etc/sysctl.conf</tt> to include the
line <tt>machdep.allowaperture=1</tt> or
<tt>machdep.allowaperture=2</tt>, depending on your system.

<p>
If you do not intend to run X on this system or are not sure, answer 'N'
here, as you can easily change it by editing <tt>/etc/sysctl.conf</tt>
and rebooting, should you need to later.
There is a potential security advantage to leaving this aperture driver
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=xf86&amp;sektion=4">xf86(4)</a>
disabled, as the graphics engine on a modern video card could
potentially be used to alter memory beyond the processor's control.
Note that non-graphical applications that require X libraries and
utilities to run do NOT need this sysctl to be set.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Do you want the X Window System to be started by xdm(1)? [no] <b>y</b>
</pre></td></tr></table>

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=xdm&amp;sektion=1">xdm(1)</a>
starts the X environment at system boot.
We'd recommend doing this at install only if you are very confident
that X will work on your system by default.
Otherwise, <a href="faq11.html">configure X</a> before setting up
xdm(1).

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Change the default console to com0? [no] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
Sometimes, you want a system to use a serial port as a console instead
of a keyboard and monitor.
Answering "y" here will cause the installer to prompt you for a
serial bit rate and configure the system to use the serial port for
a console instead of the monitor and keyboard.
Some platforms do this automatically if no keyboard is attached,
these platforms will not ask this question.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Setup a user? (enter a lower-case loginname, or 'no') [no] <b>nick</b>
  Full name for user nick? [nick] Nick Holland
  Password for user nick? (will not echo) <b><i>Tu0xie9onahJ</i></b>
  Password for user nick? (again) <b><i>Tu0xie9onahJ</i></b>
  WARNING: root is targeted by password guessing attacks, pubkeys are safer.
  Allow root ssh login? (yes, no, prohibit-password) [no] <i><b>Enter</b></i>
</pre></td></tr></table>

<p>
You are being given an opportunity to create a user OTHER than
root for system maintenance.
This user will be a member of the "wheel" group so they can run
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=su&amp;sektion=1">su(1)</a>
and mail addressed to root will be forwarded to them.
If you create a user here, you are given the option of disabling root
logins via SSH, as you can do all administration remotely with the user
you have created.
If you later change your mind, you can edit the <tt>PermitRootLogin</tt>
line in <tt>/etc/ssh/sshd_config</tt>.

<p>
Note that if you wish to create the user, enter the user's name, not "y"
or "yes".

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  What timezone are you in? ('?' for list) [Canada/Mountain] <b>US/Michigan</b>
</pre></td></tr></table>

<p>
OpenBSD assumes your computer's real-time clock (RTC) is set to GMT, but
you also have to specify what time zone you are in.
There may be several valid answers for your physical location.
Hitting "?" at the prompt will help guide you to finding the best
(most specific) time zone name.

<p>
Note that the installer will quite often guess correctly for your
time zone, and you can then just hit "Enter".

<p>
More on setting the time zone <a href="#MoreTimeZone" id="backMoreTimeZone">here</a>.

<h3 id="InstDisks">4.5.3 - Setting up disks</h3>

<i><b>Important Note:</b>
Users with a large hard disk (larger than was commonly available when
your computer was made) will want to see
<a href="faq14.html#LargeDrive">this section</a> before going any
further.</i>

<p>
Laying out your disk appropriately is probably the most difficult part
of an OpenBSD install.
The good news is the default layout works well for learning OpenBSD.

<p>
Setting up disks in OpenBSD varies a bit between platforms.
For <a href="../i386.html">i386</a>, <a href="../amd64.html">amd64</a>,
<a href="../macppc.html">macppc</a>, <a href="../zaurus.html">zaurus</a>
and <a href="../armish.html">armish</a>,
disk setup is done in two stages.
First, the OpenBSD slice of the hard disk is defined using fdisk(8),
then that slice is subdivided into OpenBSD partitions using
disklabel(8).

<p>
Some users may be a little confused by the terminology used here. It
will appear we are using the word "partition" in two different ways.
This observation is correct.
There are two layers of partitioning in the above OpenBSD platforms, the
first, one could consider the Operating System partitioning, which is
how multiple OSs on one computer mark out their own space on the disk,
and the second one is how the OpenBSD partition is sub-partitioned into
individual filesystems.
The first layer is visible as a disk partition to DOS, Windows, and any
other OS that uses this disk layout system, the second layer of
partitioning is visible only to OpenBSD and those OSs which can directly
read an OpenBSD filesystem.

<p>
OpenBSD's new installer attempts to make your disk layout tasks easier
by having a sane default for "general" use.
Note that many people will still want to customize the default, or
use their own disk layout, but new users should probably start with
this configuration until they see what they need to do differently.
Note that the default layout will vary depending on how large your
disk system is.

<p>
For now, we'll take the defaults on our 60G disk.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Available disks are: wd0.
  Which one is the root disk? (or 'done') [wd0] <i><b>Enter</b></i>
  Use DUIDs rather than device names in fstab? [yes] <i><b>Enter</b></i>
  Disk: wd0       geometry: 7296/255/63 [117210240 Sectors]
  Offset: 0       Signature: 0xAA55
              Starting         Ending         LBA Info:
   #: id      C   H   S -      C   H   S [       start:        size ]
  -------------------------------------------------------------------------------
   0: 07      0   1   1 -   7295 254  63 [           0:   117210177 ] NTFS
   1: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
   2: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
   3: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
  Use (W)hole disk or (E)dit the MBR? [whole] <i><b>Enter</b></i>
  Setting OpenBSD MBR partition to whole wd0...done.
</pre></td></tr></table>

<p>
Note that this disk has a pre-existing partition on it -- <i>using "whole"
disk will remove it!</i>

<p>
Setting up the "whole" disk for OpenBSD does a number of important things:
<ul>
<li>Erases any existing partitions on the disk.
<li>Creates an MBR and disk signature so the disk can be booted.
<li>Creates an OpenBSD partition using the entire disk.
<li>Sets that partition as "active".
</ul>

There are many times when you won't want to do that, including:
<ul>
<li>You wish to retain other OS partitions.
<li>You wish to retain "setup", "suspend to disk", or other system
partitions.
<li>You wish to build a <a href="#Multibooting">multibooting</a>
system.
</ul>

Note that it is critical that a new (or never-used for booting) drive
has a valid MBR, a valid signature, an OpenBSD partition, and a
partition flagged as "active".
If you don't do these things using the "Use whole disk" option,
you need to make sure they get done manually.

<p>
More information on fdisk partitioning your disk
<a href="#Morefdisk" id="BackMorefdisk">below</a>.

<p>
Now we will break up our OpenBSD fdisk partition into OpenBSD
disk partitions using
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Setting OpenBSD MBR partition to whole wd0...done.
  The auto-allocated layout for wd0 is:
  #                size           offset  fstype [fsize bsize  cpg]
    a:          1024.0M               64  4.2BSD   2048 16384    1 # /
    b:           510.5M          2097216    swap
    c:         57231.6M                0  unused                   
    d:          4096.0M          3142688  4.2BSD   2048 16384    1 # /tmp
    e:          4606.5M         11531264  4.2BSD   2048 16384    1 # /var
    f:          2048.0M         20965312  4.2BSD   2048 16384    1 # /usr
    g:          1024.0M         25159616  4.2BSD   2048 16384    1 # /usr/X11R6
    h:          7054.3M         27256768  4.2BSD   2048 16384    1 # /usr/local
    i:          2025.3M         41704064  4.2BSD   2048 16384    1 # /usr/src
    j:          2048.0M         45851808  4.2BSD   2048 16384    1 # /usr/obj
    k:         32795.0M         50046112  4.2BSD   2048 16384    1 # /home
  Use (A)uto layout, (E)dit auto layout, or create (C)ustom layout? [a] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
The installer has presented us with its proposed "Auto layout" for
OpenBSD partitions on our disk, which we are going to accept.

<p>
If the proposed layout is not appropriate for your needs you can,
of course, edit the default or customize it completely.
More details on the disklabel partitioning <a href="#Moredisklabel" id="BackMoredisklabel">below</a>.

<p>
<b>NOTE for re-installers:</b>
The new installer will not clear your old disklabel if you chose
"(C)ustom Layout", but you will need to re-specify each mount point
using the 'n' option in disklabel(8).

<p>
The installer now creates those partitions and creates file systems
on them using
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&amp;sektion=8">newfs(8)</a>,
and mounts them for installation.

<p>
You will note there is a <i>c</i> partition we seem to have ignored.  This
partition is your entire hard disk; don't attempt to alter it.

<h3 id="InstMedia">4.5.4 - Choosing installation media and file sets</h3>

Next, you will get a chance to choose your installation media.
In this case, we will install from an HTTP (web) server.
<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Location of sets? (cd disk http or 'done') [cd] <b>http</b>
  HTTP proxy URL? (e.g. 'http://proxy:8080', or 'none') [none] <b><i>Enter</i></b>
  Server? (hostname, list#, 'done' or '?') [ftp5.usa.openbsd.org] <b>mirror.example.org</b>
</pre></td></tr></table>

<p>
If you can't remember your favorite (or any!) mirror's location, the
installer will often be able to come up with a default of a mirror which
will work well for you.
Otherwise, hit "?" to have a list of mirrors displayed, and select the
number of a mirror that will work well for you.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Server directory? [pub/OpenBSD/5.8/i386] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
You can now adjust the list of <a href="#FilesNeeded">file sets</a>.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Select sets by entering a set name, a file name pattern or 'all'. De-select
  sets by prepending a '-' to the set name, file name pattern or 'all'. Selected
  sets are labelled '[X]'.
      [X] bsd           [X] base58.tgz    [X] game58.tgz    [X] xfont58.tgz
      [X] bsd.rd        [X] comp58.tgz    [X] xbase58.tgz   [X] xserv58.tgz
      [ ] bsd.mp        [X] man58.tgz     [X] xshare58.tgz
  Set name(s)? (or 'abort' or 'done') [done] <b><i>Enter</i></b>
</pre></td></tr></table> <!-- XXXrelease -->


<p>
At a bare minimum, you need to have a kernel (<tt>bsd</tt>) and
baseXX.tgz file set.
Unless you know what you are doing, stick with the default sets.
You can add and remove file sets using "+" and "-" characters in front
of the file set name, and also use wildcards:

<ul>
<li><tt><b>-comp*.tgz</b></tt> removes <tt>compXX.tgz</tt>
<li><tt><b>+bsd.mp</b></tt> adds bsd.mp
<li><tt><b>-x*</b></tt> removes all X components
</ul>

But again, we'll take the default.
This machine is a single-processor system, so bsd.mp is not installed,
but everything else is.
If it could later be upgraded to a multi-processor system, you might
want to install bsd.mp as well (it is relatively very small, but then
it is easy to add later, too).

<p>
And now, we start our install!
This is the point at which you might want to come back later if you have
a slow computer or Internet connection, though with a fast computer and
local files, this process may take just a couple minutes or less!

<p>
If the install process can find the file <tt>SHA256.sig</tt> in the
install source AND it can find sufficient space to pull over the
install file sets to verify the signatures before installation, the file
sets will be verified.
If either of those cases are not true (i.e., installing from an
<tt>installXX.iso</tt> or <tt>installXX.fs</tt>, or your hard disk is
too small to "pre-load" the files), you will be presented with a message:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Directory does not contain SHA256.sig. Continue without verification? [no]
</pre></td></tr></table>
or
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Cannot determine prefetch area. Continue without verification? [no]
</pre></td></tr></table>
<p>
Note that this is not saying that verification <i>failed</i>, it says
that verification can't be done.
If you are satisfied with your trust of the source of the files, hit "y"
and your install will take place as normal (though without the
"Get/Verify" steps you see below).
Note that on slow hardware, the "Get/Verify" step can take quite a while.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Get/Verify SHA256.sig   100% |**************************|  1534       00:01
  Signature Verified
  Verifying  bsd          100% |**************************| 10292 KB    00:05
  Verifying  bsd.rd       100% |**************************|  6867 KB    00:03
  Verifying  base58.tgz   100% |**************************| 51721 KB    00:26
  Verifying  comp58.tgz   100% |**************************| 45434 KB    00:28
  Verifying  man58.tgz    100% |**************************|  8780 KB    00:06
  Verifying  game58.tgz   100% |**************************|  2649 KB    00:02
  Verifying  xbase58.tgz  100% |**************************| 16510 KB    00:06
  Verifying  xshare58.tgz 100% |**************************|  4383 KB    00:04
  Verifying  xfont58.tgz  100% |**************************| 39072 KB    00:17
  Verifying  xserv58.tgz  100% |**************************| 18509 KB    00:15
  Installing bsd          100% |**************************| 10384 KB    00:00
  Installing bsd.rd       100% |**************************|  6803 KB    00:00
  Installing base58.tgz   100% |**************************| 51618 KB    00:22
  Extracting etc.tgz      100% |**************************|   109 KB    00:00
  Installing comp58.tgz   100% |**************************| 45434 KB    00:17
  Installing man58.tgz    100% |**************************|  8780 KB    00:06
  Installing game58.tgz   100% |**************************|  2649 KB    00:00
  Installing xbase58.tgz  100% |**************************| 16510 KB    00:03
  Extracting xetc.tgz     100% |**************************|  9156       00:00
  Installing xshare58.tgz 100% |**************************|  4383 KB    00:05
  Installing xfont58.tgz  100% |**************************| 39072 KB    00:10
  Installing xserv58.tgz  100% |**************************| 18509 KB    00:06
  Location of sets? (cd disk http or 'done') [done] <b><i>Enter</i></b>
</pre></td></tr></table> <!-- XXXrelease -->

<p>
Yes, it is asking us again where we wish to install things from.
This is so that missed, forgotten or failed file sets can be
re-installed, and also so <a href="#site">custom file sets</a> can be
installed.

<p>
Again, we just take the default, we are done installing files

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Time appears wrong.  Set to 'Sat Oct 18 09:21:38 EST 2015'? [yes] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
If the system can reach an NTP server, you may get this message to
set the system clock accurately.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Saving configuration files...
  Making all device nodes...done.

  CONGRATULATIONS! Your OpenBSD install has been successfully completed!
  To boot the new system, enter 'reboot' at the command prompt.
  When you login to your new system the first time, please read your mail
  using the 'mail' command.

  #
</pre></td></tr></table>
<p>

<h3 id="Inst1stBoot">4.5.5 - First boot!</h3>
OpenBSD is now installed on your system and ready for its first
boot, but before you do...

<p>

<h4>Before you reboot</h4>
At this point, your system is installed and ready to be rebooted and
configured for service.  Before doing this, however, it would be wise to
check out the <a href="../errata.html">errata page</a> and see if there
are any bugs that would immediately impact you.

<h4>After you reboot</h4>

On your first boot, <a href="http://www.openssh.com">SSH</a> keys will
be generated.
On modern computers, this will take a few seconds, you may not even
notice it happening.
On older systems, it may take many minutes, potentially even an hour
or more for really slow systems.

<p>
One of your first things to read after you install your system is
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=afterboot&amp;sektion=8">afterboot(8)</a>.

<p>
you may also find the following links useful:
<ul>
<li><a href="faq10.html#AddDelUser">Adding users in OpenBSD</a>
<li><a href="faq6.html#Setup">Initial Network Setup</a>
<li><a href="faq2.html#ManPages">Man Pages of popular/useful commands</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi">OpenBSD man pages on
  the Web</a>
<li><a href="faq15.html">The OpenBSD Packages and Ports system for
  installing software</a>
</ul>

<h3 id="InstFinish">4.5.6 - One last thing...</h3>

The OpenBSD developers ask you to <a href="#SendDmesg">Send in a copy of
your dmesg</a>.
This is really appreciated by the developers, and ultimately, all users.

<h2 id="More">4.6 - Details for a more complex install</h2>
Sometimes you can't just take the defaults.
Here are some more details on parts of the installation process.

<h3 id="MoreNetwork">4.6.1 - Setting up the network</h3>

If you don't have a DHCP server available, you will have to set up
your network adapter(s) manually.
Here's an example:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Which one do you wish to configure? (or 'done') [xl0] <b><i>Enter</i></b>
  IPv4 address for xl0? (or 'dhcp' or 'none') [dhcp] <b>192.168.1.37</b>
  Netmask? [255.255.255.0] 255.255.254.0
  IPv6 address for xl0? (or 'rtsol' or 'none') [none] <b><i>Enter</i></b>
</pre></td></tr></table>

<p>
After that set of questions, you will be given a chance to configure any other
network adapters that your machine has.
If you specify another network adapter here, the above questions repeat.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Available network interfaces are: xl0 vlan0.
  Which one do you wish to configure? (or 'done') [done]
</pre></td></tr></table>

<p>
Now, you will set up the default gateway and DNS servers, things that
impact all network adapters:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Default IPv4 route? (IPv4 address, 'dhcp' or 'none') <b>192.168.1.1</b>
  add net default: gateway 192.168.1.1
  DNS domain name? (e.g. 'bar.com') [my.domain] <b>example.org</b>
  DNS nameservers? (IP address list or 'none') [none] <b>192.168.1.250 192.168.1.251</b>
</pre></td></tr></table>

<p>
Note that multiple DNS servers can be listed, separated by spaces.

<p>
Sometimes, you will have to do something more, for example set up a
wireless access key or hard-set a duplex or speed setting (don't do this
unless you absolutely HAVE to, fixing your switch configuration is a
much better idea!).
You are now given a chance to drop to the shell and do any manual configuration
that you would like.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Do you want to do any manual network configuration? [no] <b>y</b>
  Type 'exit' to return to install.
  # <b>ifconfig xl0 media</b>
  xl0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
          lladdr 00:08:74:2c:df:9c
          groups: egress
          media: Ethernet autoselect (100baseTX full-duplex)
          status: active
          supported media:
                  media 10baseT
                  media 10baseT mediaopt full-duplex
                  media 100baseTX
                  media 100baseTX mediaopt full-duplex
                  media autoselect
          inet 192.168.1.37 netmask 0xfffffe00 broadcast 192.168.1.255
  # <b>ifconfig xl0 media 100baseTX mediaopt full-duplex</b>
  # <b>ifconfig xl0</b>
  xl0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
          lladdr 00:08:74:2c:df:9c
          groups: egress
          media: Ethernet 100baseTX full-duplex
          status: active
          inet6 fe80::208:74ff:fe2c:df9c%xl0 prefixlen 64 scopeid 0x1
          inet 192.168.1.37 netmask 0xfffffe00 broadcast 192.168.1.255
  # <b>exit</b>
<i>...setup resumes...</i>
</pre></td></tr></table>

<p>
<a href="#backMoreNetwork">(back to where we might have been)</a>

<h3 id="MoreTimeZone">4.6.2 - Setting the Time Zone</h3>
Time in Unix is not a simple thing (or put another way, time in Unix is
a <i>really</i> simple thing, human time is a politically manipulated
mess).
Time zone files help the system convert Unix time (the number of seconds
past midnight GMT, Jan 1, 1970) to human time, taking into account things
like time zones, daylight savings time (DST), DST rule changes, etc.
They also include the history of changes.

<p>
Multiple time zone definition files will sometimes give the same
<i>current</i> time, but may have different history.
For example, EST5EDT and US/Michigan have the same time NOW, but back in
1975, the rules were different, so if you were doing math with dates and
times that involved 1975, you would care about the differences.
You should use the most specific and accurate timezone file you can for
your region, rather than one that just gives the correct time at this
moment.

<p>
OpenBSD's installer will help you find an appropriate time zone file for
you if you are not sure.
Simply hit "<tt>?</tt>" at each prompt, and the installer will show you
options.
If the first level of answers doesn't suit you, pick a continent or
country, and look at your options there:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  What timezone are you in? ('?' for list) [right/EST5EDT] <b>?</b>
  Africa/      Chile/       GB-Eire      Israel       NZ-CHAT      UCT
  America/     Cuba         GMT          Jamaica      Navajo       US/
  Antarctica/  EET          GMT+0        Japan        PRC          UTC
  Arctic/      EST          GMT-0        Kwajalein    PST8PDT      Universal
  Asia/        EST5EDT      GMT0         Libya        Pacific/     W-SU
  Atlantic/    Egypt        Greenwich    MET          Poland       WET
  Australia/   Eire         HST          MST          Portugal     Zulu
  Brazil/      Etc/         Hongkong     MST7MDT      ROC          posix/
  CET          Europe/      Iceland      Mexico/      ROK          posixrules
  CST6CDT      Factory      Indian/      Mideast/     Singapore    right/
  Canada/      GB           Iran         NZ           Turkey
  What timezone are you in? ('?' for list) [right/EST5EDT] <b>US</b>
  What sub-timezone of 'US' are you in? ('?' for list) ?
  Alaska          Central         Hawaii          Mountain        Samoa
  Aleutian        East-Indiana    Indiana-Starke  Pacific
  Arizona         Eastern         Michigan        Pacific-New
  What sub-timezone of 'US' are you in? ('?' for list) <b>Michigan</b>
</pre></td></tr></table>

<p>
We've now set the time to "US/Michigan".  This creates a symbolic link in
<tt>/etc</tt> pointing to the appropriate zoneinfo file in
<tt>/usr/share/zoneinfo</tt>, something like this:

<blockquote><pre>
  /etc/localtime -> /usr/share/zoneinfo/US/Michigan
</pre></blockquote>

Note the directory "<tt>right/</tt>", this directory includes leap second
adjustments, but otherwise duplicates the standard zoneinfo choices.
More <a href="faq8.html#NTPerror">here</a>.

<p>
<a href="#backMoreTimeZone">(back to where we might have been)</a>

<h3 id="Morefdisk">4.6.3 - Custom fdisk(8) layout</h3>

Note: only some OpenBSD platforms use fdisk at all, and usually, only
<a href="../i386.html">i386</a> and <a href="../amd64.html">amd64</a>
users will have to worry about getting fancy with fdisk.
Users of most other fdisk(8) using platforms generally don't have to
worry about multibooting or setup/diagnostic partitions.
For this reason, this section is focused on i386 and amd64.

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8">fdisk(8)</a>
is used to mark off the OpenBSD part of your hard disk.
It helps mark off the part of the disk used by OpenBSD from the parts used
by other OSs or system functions.

<p>
If you have a partition on your disk you wish to retain or wish to leave
space for another partition, you will NOT want to chose "(W)hole disk",
but will need to edit the partition table with
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8">fdisk(8)</a>.
More information on manually running fdisk(8) can be found
<a href="faq14.html#fdisk">here</a>.

<b>Before working with any system that has data you don't wish to lose,
make sure you have a good backup.</b>
It is very easy in this process to clobber important data, so make sure
you are ready to get it back, if need be.

<p>
If you are adding OpenBSD to an existing system, you will probably
need to create some free space on your system before installing OpenBSD.
This will usually involve deleting or possibly reducing the size of
existing partitions.
The program <a href="http://gparted.sourceforge.net/">gparted</a>
has been found useful for shrinking the partitions of many popular OSs,
making it possible to install OpenBSD on the freed space.

<p>
In this example, we will assume we are starting with a blank 40G disk
and wish to create a multiboot system, reserving 5G at the beginning
of the disk for Windows, and the rest for OpenBSD.
Note that a blank drive has to have valid MBR boot code and signature
written to the disk before it can be booted.

<p>
The process is very much the same for working around an existing
partition, you just need to skip over the parts where we create the
Windows partition and worry about installing the MBR boot code.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Available disks are: wd0.
  Which one is the root disk? (or 'done') [wd0] <b><i>Enter</i></b>
  MBR has invalid signature; not showing it.
</pre></td></tr></table>

<p>
If the disk had a valid MBR in place, it would show you the existing
partition table, which can be a good way to show if a disk may have
data on it already.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Use (W)hole disk or (E)dit the MBR? [whole] <b>e</b>

  You will now create a single MBR partition to contain your OpenBSD data. This
  partition must have an id of 'A6'; must *NOT* overlap other partitions; and
  must be marked as the only active partition.  Inside the fdisk command, the
  'manual' command describes all the fdisk commands in detail.

  Disk: wd0       geometry: 4998/255/63 [80293248 Sectors]
  Offset: 0       Signature: 0x0
              Starting         Ending         LBA Info:
   #: id      C   H   S -      C   H   S [       start:        size ]
  -------------------------------------------------------------------------------
   0: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
   1: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
   2: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
   3: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
Enter 'help' for information
fdisk: 1>
</pre></td></tr></table>

<p>
First of all notice the fdisk prompt.
The number "1" indicates the first level of partition tables -- if you
were editing an extended partition, it would be "2" (or bigger).
Extended partitions are partitions which have their own sub-partition
table, getting around the IBM AT four partition design limit.
Extended partitions won't be covered here.

<p>
First, we will make partition "0" a 5G Windows partition (using NTFS),
and partition "1" will be our OpenBSD partition using the rest of the
disk.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  fdisk: 1> <b>e 0</b>
              Starting         Ending         LBA Info:
   #: id      C   H   S -      C   H   S [       start:        size ]
  -------------------------------------------------------------------------------
   0: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
  Partition id ('0' to disable)  [0 - FF]: [0] (? for help)
</pre></td></tr></table>

<p>
Since we don't know by memory what the partition ID is for NTFS, we hit
"?" here to get a list.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Partition id ('0' to disable)  [0 - FF]: [0] (? for help) <b>?</b>
  Choose from the following Partition id values:
  00 unused         20 Willowsoft     66 NetWare 386    A9 NetBSD
  01 DOS FAT-12     24 NEC DOS        67 Novell         AB MacOS X boot
  02 XENIX /        27 Win Recovery   68 Novell         AF MacOS X HFS+
  03 XENIX /usr     38 Theos          69 Novell         B7 BSDI filesy*
  04 DOS FAT-16     39 Plan 9         70 DiskSecure     B8 BSDI swap
  05 Extended DOS   40 VENIX 286      75 PCIX           BF Solaris
  06 DOS > 32MB     41 Lin/Minux DR   80 Minix (old)    C0 CTOS
  07 NTFS           42 LinuxSwap DR   81 Minix (new)    C1 DRDOSs FAT12
  08 AIX fs         43 Linux DR       82 Linux swap     C4 DRDOSs < 32M
  09 AIX/Coherent   4D QNX 4.2 Pri    83 Linux files*   C6 DRDOSs >=32M
  0A OS/2 Bootmgr   4E QNX 4.2 Sec    84 OS/2 hidden    C7 HPFS Disbled
  0B Win95 FAT-32   4F QNX 4.2 Ter    85 Linux ext.     DB CPM/C.DOS/C*
  0C Win95 FAT32L   50 DM             86 NT FAT VS      DE Dell Maint
  0E DOS FAT-16     51 DM             87 NTFS VS        E1 SpeedStor
  0F Extended LBA   52 CP/M or SysV   8E Linux LVM      E3 SpeedStor
  10 OPUS           53 DM             93 Amoeba FS      E4 SpeedStor
  11 OS/2 hidden    54 Ontrack        94 Amoeba BBT     EB BeOS/i386
  12 Compaq Diag.   55 EZ-Drive       99 Mylex          EE EFI GPT
  14 OS/2 hidden    56 Golden Bow     9F BSDI           EF EFI Sys
  16 OS/2 hidden    5C Priam          A0 NotebookSave   F1 SpeedStor
  17 OS/2 hidden    61 SpeedStor      A5 FreeBSD        F2 DOS 3.3+ Sec
  18 AST swap       63 ISC, HURD, *   A6 OpenBSD        F4 SpeedStor
  19 Willowtech     64 NetWare 2.xx   A7 NEXTSTEP       FF Xenix BBT
  1C ThinkPad Rec   65 NetWare 3.xx   A8 MacOS X
  Partition id ('0' to disable)  [0 - FF]: [0] (? for help) <b>07</b>
</pre></td></tr></table>

<p>
Now we define its starting and ending points:
<p>

<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Do you wish to edit in CHS mode? [n]
</pre></td></tr></table>

<p>
CHS mode allows you to specify disk space in Cylinders, Heads and Sectors.
Keep in mind that for modern hard disks, the CHS numbers are completely
bogus, just three numbers that translate to a sector on the disk, which
is translated to your drives physical geometry (which probably varies
across the disk anyway).

<p>
If you answer "y" here, you will be prompted for the starting and
ending cylinder, head and sector.
If you answer "no" here (as we will), you will be prompted for starting
sector and the size.
Editing by CHS is often easier when working around an existing partition,
starting sector and size is often easier when you want to quickly create
a partition of a given size.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  offset: [0] <b>64</b>
</pre></td></tr></table>

<a name="trackoffset"></a>
<p>
The fdisk platforms need a gap before the first partition.
The exact amount will not matter on modern machines, OpenBSD defaults
to 64 sectors.
This is recommended for performance reasons on modern disks, and does
not matter on older disks.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  size: [0] <b>5g</b>
  Rounding to nearest cylinder: 10490381
</pre></td></tr></table>

<p>
The "Size" value can be the number of sectors (512 bytes each), or the
desired capacity when followed by a "k", "m" or "g".
When editing using offset and size, fdisk will round your partition so
it ends on a cylinder boundary (OpenBSD doesn't care about this, and it
is possible no modern OS cares about this, but some might have at one
time).

<p>
Now, let's look at our new partition:
<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  fdisk:*1> p
  Disk: wd0       geometry: 4998/255/63 [80293248 Sectors]
  Offset: 0       Signature: 0x0
              Starting         Ending         LBA Info:
   #: id      C   H   S -      C   H   S [       start:        size ]
  -------------------------------------------------------------------------------
   0: 07      0   1   2 -    652 254  63 [          64:    10490381 ] NTFS
   1: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
   2: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
   3: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
  fdisk:*1>
</pre></td></tr></table>

<p>
Note that the prompt now includes an "*", this means there are unsaved
changes.

<p>
We've now created our Windows partition.
Note that this partition is so far just reserved space on the disk, it
isn't formatted; no file system exists here.
You will worry about that when you install Windows; we've accomplished
our goal of reserving space for the Windows partition to be created
later.

<p>
Now we create our OpenBSD partition.
In this case, the partition ID will be "A6".

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  fdisk:*1> e 1
              Starting         Ending         LBA Info:
   #: id      C   H   S -      C   H   S [       start:        size ]
  -------------------------------------------------------------------------------
   1: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
  Partition id ('0' to disable)  [0 - FF]: [0] (? for help) <b>a6</b>
  Do you wish to edit in CHS mode? [n] <b><i>Enter</i></b>
  offset: [0]
</pre></td></tr></table>

<p>
Uh-oh!
What's our offset?  Simple -- the offset of the previous partition plus
the size of the partition, in this case, 64+10490381 = 10490445.

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  offset: [0] <b>10490445</b>
  size: [0] <b>*</b>
  fdisk:*1>
</pre></td></tr></table>

<p>
Note that here, we entered "*" as the size, meaning "rest of the disk".
Again, we could have entered the size in sectors, "m" or "g" if we
wanted to leave space for something else.

<p>
Now we look at our partition table:

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  fdisk:*1> <b>p</b>
  Disk: wd0       geometry: 4998/255/63 [80293248 Sectors]
  Offset: 0       Signature: 0x0
              Starting         Ending         LBA Info:
   #: id      C   H   S -      C   H   S [       start:        size ]
  -------------------------------------------------------------------------------
   0: 07      0   1   1 -    652 254  63 [          64:    10490381 ] NTFS
   1: A6    653   0   1 -   4998   5  63 [    10490445:    69802803 ] OpenBSD
   2: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
   3: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
  fdisk:*1>
</pre></td></tr></table>

<p>
<b>WE AREN'T DONE YET!</b><br>
This disk is not yet bootable!
As it was a brand new disk, the disk's
<a href="faq14.html#Boot386">MBR</a> was completely blank.
The "Signature: 0x0" message there shows there is not a valid signature
(0xAA55), which indicates there definitely is not a valid boot code.
Of course, you could have a valid signature without valid boot code,
through either random bad luck or damage to the existing boot code, but
an invalid signature pretty well indicates you are lacking boot code, so
we will install it now using the "update" command:

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  fdisk:*1> <b>update</b>
  Machine code updated.
  fdisk:*1>
</pre></td></tr></table>

<p>
We also have to "flag" a partition as "active" so the boot ROM knows
what partition to boot from:

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  fdisk:*1> <b>f 1</b>
  Partition 1 marked active.
</pre></td></tr></table>

<p>
Now, let's see how it looks:

<p>
<table border=0 width="650"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  fdisk:*1> <b>p</b>
  Disk: wd0       geometry: 4998/255/63 [80293248 Sectors]
  Offset: 0       Signature: 0xAA55
              Starting         Ending         LBA Info:
   #: id      C   H   S -      C   H   S [       start:        size ]
  -------------------------------------------------------------------------------
   0: 07      0   1   1 -    652 254  63 [          64:    10490381 ] NTFS
  *1: A6    653   0   1 -   4998   5  63 [    10490445:    69802803 ] OpenBSD
   2: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
   3: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
  fdisk:*1>
</pre></td></tr></table>

<p>
A checklist of things you want to make sure about before you exit
fdisk(8):

<ul>
<li>Valid signature?
<li>non-overlapping partitions?
<li>OpenBSD partition with an "A6" id?
<li>Proper partition (probably OpenBSD) flagged active?
</ul>

<p>
<a href="#BackMorefdisk">(Back to where we may have been)</a>

<p>
<a name="Moredisklabel"></a>
<h3>4.6.4 - Custom disklabel layout</h3>

Inside the OpenBSD fdisk(8) partition, we use
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
to create OpenBSD file system partitions.
OpenBSD labels its file system partitions using sixteen letters, "a"
through "p".
Partition "a" on the boot disk is defined as the root partition,
"b" on the boot disk is the default swap partition.
"c" on all disks is the "whole disk" partition, it is used by programs
that have to have raw access to the physical disk, such as fdisk(8)
and disklabel(8).
The "c" partition is created automatically for you, and should not be
deleted or changed.
The remaining letters are available for you to define mount points on.
You may skip letters, you can define them in any order, and they can be
in any order on the disk (although some platforms do have a requirement
for where the "a" partition is).
You can also leave gaps in the disk that are unallocated, and allocate
them later, or potentially enlarge existing partitions later into that
unallocated space using
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=growfs&amp;sektion=8">growfs(8)</a>.

<p>
All partitions which have native FFS partitions on them should be within
the OpenBSD fdisk(8) partition, however
<a href="faq14.html#foreignfs">non-OpenBSD</a> partitions can (and
usually should) be outside the OpenBSD fdisk partition.

<p>
More information on using disklabel can be found
<a href="faq14.html#disklabel">here</a>.

<p>
More information on why partitioning is beneficial and strategy for
creating a good partitioning plan are <a href="#Partitioning">below</a>.

<p>
The OpenBSD installer will attempt to auto-partition your
disk in a usable, "general purpose" configuration, based on the size of
your disk.
If your disk is big enough, unused space will be allocated to the
<tt>/home</tt> partition.
While this is often quite useful, it doesn't satisfy all users' needs.

<p>
For our example, we'll assume we are building a static web server
for some of our friends to use.
We have a machine attached to a modest Internet connection, with a 40G
disk, with most of it used for OpenBSD (with the same 5G Windows
partition as the example above.
Why?  Maybe this system has a RAID controller which is supported by
OpenBSD, but manageable only from within Windows.
More likely, because the FAQ editor doesn't feel like maintaining lots
of different example systems).

<p>
The web pages served by an OpenBSD web server will be in
<tt>/var/www</tt>, and very little will be stored in <tt>/home</tt>, so
this indicates a definite change from the default that needs to be made.
For the sake of discussion, we'll also assume that we won't need to
rebuild the OS from source on this machine (we'll do that elsewhere).
The system will not run X, however being that some web applications
<a href="#FilesNeededX">expect X to be installed</a>, we will have X
installed.
The machine is not overly powerful, it can't have more than 1G RAM in
it, and it is unlikely our application will ever desire more than that.

<p>
So, after a bit of thought, our plan is to partition the system like
this:
<ul>
<li><tt>/ - root</tt>: 100m.  This will be 'a'.
<li><tt>swap</tt>: 1G (so we'll always have enough space for a core dump),
   this will be partition 'b'
<li><tt>/usr</tt>: 2g, partition d
<li><tt>/tmp</tt>: 100m (we don't anticipate much use of this), partition e
<li><tt>/usr/local</tt>: 2g, partition f
<li><tt>/usr/X11R6</tt>: 1g, partition g
<li><tt>/home</tt>: 1g, partition h
<li><tt>/var</tt>: 1g (that's a lot of system log files), partition j
<li><tt>/var/www</tt>: rest of disk, partition k
</ul>

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  The auto-allocated layout for wd0 is:
  #                size           offset  fstype [fsize bsize  cpg]
    a:          1024.0M         10490445  4.2BSD   2048 16384    1 # /
    b:           252.1M         12587597    swap
    c:         39205.7M                0  unused
    d:          2319.3M         13103933  4.2BSD   2048 16384    1 # /tmp
    e:          3653.9M         17853877  4.2BSD   2048 16384    1 # /var
    f:          1149.8M         25337016  4.2BSD   2048 16384    1 # /usr
    g:          1024.0M         27691862  4.2BSD   2048 16384    1 # /usr/X11R6
    h:          3422.6M         29789014  4.2BSD   2048 16384    1 # /usr/local
    i:          5122.3M               63    NTFS
    j:          1848.7M         36798433  4.2BSD   2048 16384    1 # /usr/src
    k:          1848.7M         40584654  4.2BSD   2048 16384    1 # /usr/obj
    l:         17540.2M         44370875  4.2BSD   2048 16384    1 # /home
  Use (A)uto layout, (E)dit auto layout, or create (C)ustom layout? [a] <b>c</b>
</pre></td></tr></table>

<p>
If we had only minor revisions, we'd probably opt to "Edit" the custom
layout rather than starting from a clean slate, but we are going to do
things the hard way here.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  You will now create an OpenBSD disklabel inside the OpenBSD MBR
  partition. The disklabel defines how OpenBSD splits up the MBR partition
  into OpenBSD partitions in which filesystems and swap space are created.
  You must provide each filesystem's mountpoint in this program.

  The offsets used in the disklabel are ABSOLUTE, i.e. relative to the
  start of the disk, NOT the start of the OpenBSD MBR partition.

  Label editor (enter '?' for help at any prompt)
  > <b>p</b>
  OpenBSD area: 10490445-80293248; size: 69802803; free: 69802803
  #                size           offset  fstype [fsize bsize  cpg]
    c:         80293248                0  unused
    i:         10490381               64    NTFS
  >
</pre></td></tr></table>

<p>
Note there are already two partitions here -- the "c" partition which is
always there and created for you, but disklabel(8) has also noticed the
existing NTFS partition and assigned it a disklabel partition so it
could potentially be accessed by OpenBSD (note, at this time, NTFS
support is experimental and requires a custom kernel but FAT/FAT32
support is quite good).

<p>
We will now create our partitions.
We will start with the "a" partition, our root partition:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  > <b>a a</b>
  offset: [10490445] <b><i>Enter</i></b>
  size: [69802803] <b>100m</b>
  Rounding to cylinder: 208845
  FS type: [4.2BSD]  <b><i>Enter</i></b>
  mount point: [none] <b>/</b>
  >
</pre></td></tr></table>

<p>
Note that disklabel defaulted to the first available OpenBSD sector on
the disk, which is what we want.
It also defaulted to a size of all available space, which is NOT what we
want.
Here we overrode it with our preferred size, which can be specified in
sectors, "M" or "G".

<p>
You will usually want to use the default FS type of "4.2BSD" for a
FFS (Fast File System) or FFS2 partition, though other types you may find
useful include "swap" and "RAID".

<p>
Finally is the mount point.
Our "a" partition is the root partition, by definition.

<p>
Now, we do swap, which is our 'b' partition (again, this is a
requirement -- 'b' on your boot disk is swap):

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  > <b>a b</b>
  offset: [10699290] <b><i>Enter</i></b>
  size: [69593958] <b>1g</b>
  Rounding to cylinder: 2104515
  FS type: [swap] <b><i>Enter</i></b>
  >
</pre></td></tr></table>

<p>
Again, disklabel correctly calculated our starting sector, and presented
us with a suggested size of "entire remaining space", which we again
overrode with our desired size.
Since this is the 'b' partition, disklabel assumed it was to be used
for swap, and when we confirmed that, it didn't bother to ask us a
mount point.

<p>
We are now ready to create the rest of the partitions.

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  > <b>a d</b>
  offset: [12803805] <b><i>Enter</i></b>
  size: [67489443] <b>2g</b>
  Rounding to cylinder: 4209030
  FS type: [4.2BSD] <b><i>Enter</i></b>
  mount point: [none] <b>/usr</b>
  > <b>a e</b>
  offset: [17012835] <b><i>Enter</i></b>
  size: [63280413] <b>100m</b>
  Rounding to cylinder: 208845
  FS type: [4.2BSD] <b><i>Enter</i></b>
  mount point: [none] <b>/tmp</b>
  > <b>a f</b>
  offset: [17221680] <b><i>Enter</i></b>
  size: [63071568] <b>2g</b>
  Rounding to cylinder: 4209030
  FS type: [4.2BSD] <b><i>Enter</i></b>
  mount point: [none] <b>/usr/local</b>
  > <b>a g</b>
  offset: [21430710] <b><i>Enter</i></b>
  size: [58862538] <b>1g</b>
  Rounding to cylinder: 2104515
  FS type: [4.2BSD] <b><i>Enter</i></b>
  mount point: [none] <b>/usr/X11R6</b>
  > <b>a h</b>
  offset: [23535225] <b><i>Enter</i></b>
  size: [56758023] <b>1g</b>
  Rounding to cylinder: 2104515
  FS type: [4.2BSD] <b><i>Enter</i></b>
  mount point: [none] <b>/home</b>
  > <b>a j</b>
  offset: [25639740] <b><i>Enter</i></b>
  size: [54653508] <b>1g</b>
  Rounding to cylinder: 2104515
  FS type: [4.2BSD] <b><i>Enter</i></b>
  mount point: [none] <b>/var</b>
  > <b>a k</b>
  offset: [27744255] <b><i>Enter</i></b>
  size: [52548993] <b><i>Enter</i></b>
  FS type: [4.2BSD] <b><i>Enter</i></b>
  mount point: [none] <b>/var/www</b>
  >
</pre></td></tr></table>

<p>
Note that on the <tt>/var/www</tt> partition ("k"), we just took the
default to use all remaining available disk space.
With modern monstrously huge drives, this is usually a bad idea.
If you know you will never use it, don't allocate it, and save it for
some future use.

<p>
Now, let's look at our results, using the "p" and "p m" commands:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  > <b>p</b>
  OpenBSD area: 10490445-80293248; size: 69802803; free: 0
  #                size           offset  fstype [fsize bsize  cpg]
    a:           208845         10490445  4.2BSD   2048 16384    1 # /
    b:          2104515         10699290    swap
    c:         80293248                0  unused
    d:          4209030         12803805  4.2BSD   2048 16384    1 # /usr
    e:           208845         17012835  4.2BSD   2048 16384    1 # /tmp
    f:          4209030         17221680  4.2BSD   2048 16384    1 # /usr/local
    g:          2104515         21430710  4.2BSD   2048 16384    1 # /usr/X11R6
    h:          2104515         23535225  4.2BSD   2048 16384    1 # /home
    i:         10490381               64    NTFS
    j:          2104515         25639740  4.2BSD   2048 16384    1 # /var
    k:         52548993         27744255  4.2BSD   2048 16384    1 # /var/www
  > <b>p m</b>
  OpenBSD area: 10490445-80293248; size: 34083.4M; free: 0.0M
    #                size           offset  fstype [fsize bsize  cpg]
    a:           102.0M         10490445  4.2BSD   2048 16384    1 # /
    b:          1027.6M         10699290    swap
    c:         39205.7M                0  unused
    d:          2055.2M         12803805  4.2BSD   2048 16384    1 # /usr
    e:           102.0M         17012835  4.2BSD   2048 16384    1 # /tmp
    f:          2055.2M         17221680  4.2BSD   2048 16384    1 # /usr/local
    g:          1027.6M         21430710  4.2BSD   2048 16384    1 # /usr/X11R6
    h:          1027.6M         23535225  4.2BSD   2048 16384    1 # /home
    i:          5122.3M               64    NTFS
    j:          1027.6M         25639740  4.2BSD   2048 16384    1 # /var
    k:         25658.7M         27744255  4.2BSD   2048 16384    1 # /var/www
  >
</pre></td></tr></table>

<p>
Like with fdisk, you don't want your OpenBSD disklabel partitions to
overlap (other than the 'c' partition, which overlaps everything, of
course).

<p>
Write your changes and quit disklabel:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  > <b>w</b>
  > <b>q</b>
  No label changes.
  newfs: reduced number of fragments per cylinder group from 13048 to 12992 to
  enlarge last cylinder group
  /dev/rwd0a: 102.0MB in 208844 sectors of 512 bytes
  5 cylinder groups of 25.38MB, 1624 blocks, 3328 inodes each
  /dev/rwd0h: 1027.6MB in 2104512 sectors of 512 bytes
  6 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
  newfs: reduced number of fragments per cylinder group from 13048 to 12992 to
  enlarge last cylinder group
  /dev/rwd0e: 102.0MB in 208844 sectors of 512 bytes
  5 cylinder groups of 25.38MB, 1624 blocks, 3328 inodes each
  /dev/rwd0d: 2055.2MB in 4209028 sectors of 512 bytes
  11 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
  /dev/rwd0g: 1027.6MB in 2104512 sectors of 512 bytes
  6 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
  /dev/rwd0f: 2055.2MB in 4209028 sectors of 512 bytes
  11 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
  /dev/rwd0j: 1027.6MB in 2104512 sectors of 512 bytes
  6 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
  /dev/rwd0k: 25658.7MB in 52548992 sectors of 512 bytes
  127 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
  /dev/wd0a on /mnt type ffs (rw, asynchronous, local)
  /dev/wd0h on /mnt/home type ffs (rw, asynchronous, local, nodev, nosuid)
  /dev/wd0e on /mnt/tmp type ffs (rw, asynchronous, local, nodev, nosuid)
  /dev/wd0d on /mnt/usr type ffs (rw, asynchronous, local, nodev)
  /dev/wd0g on /mnt/usr/X11R6 type ffs (rw, asynchronous, local, nodev)
  /dev/wd0f on /mnt/usr/local type ffs (rw, asynchronous, local, nodev)
  /dev/wd0j on /mnt/var type ffs (rw, asynchronous, local, nodev, nosuid)
  /dev/wd0k on /mnt/var/www type ffs (rw, asynchronous, local, nodev, nosuid)

  Let's install the sets!
...
</pre></td></tr></table>

<p>
<a href="#BackMoredisklabel">(Back to where we may have been)</a>

<p>
<a name= "FilesNeeded"></a>
<h2>4.7 - What files are needed for installation?</h2>

<p>
The complete OpenBSD installation is broken up into a number of
separate <i>file sets</i>.
Not every application requires every file set, however new users are
recommended to install ALL of them.

Here is an overview of each:
<p>
<ul>
  <li><b><i>bsd</i></b>          - This is the Kernel - <b>Required</b>
  <li><b><i>bsd.mp</i></b> - Multi-processor (SMP) kernel (only some
     platforms)
  <li><b><i>bsd.rd</i></b> - <a href="#bsd.rd">RAM disk kernel</a>
  <li><b><i>baseXX.tgz</i></b>   - Contains the base OpenBSD system -
    <b>Required</b>
  <li><b><i>compXX.tgz</i></b>    - Contains the compiler and its
    tools, headers and libraries
  <li><b><i>manXX.tgz</i></b>    - Contains man pages
  <li><b><i>gameXX.tgz</i></b>   - Contains the games for OpenBSD
  <li><b><i>xbaseXX.tgz</i></b>  - Contains the base libraries and
    utilities for X11
  <li><b><i>xfontXX.tgz</i></b>  - Contains X11's font server and fonts
  <li><b><i>xservXX.tgz</i></b>  - Contains X11's X servers
  <li><b><i>xshareXX.tgz</i></b> - Contains manpages, locale settings,
    includes, etc. for X
</ul>

<a name="FilesNeededX"></a>
<h3>Why do I have to install X for my non-graphical application?</h3>
Even if you have no intention of running X, many third party
<a href="faq15.html">packages</a> require the libraries or other
utilities in X to be installed on your system.
These applications can sometimes be satisfied simply by installing
just xbaseXX.tgz, the rest of X is not always needed.
Many people who resist installing X on their system don't have a valid reason:

<ul>
<li>By itself, installing X does not cause any program to
execute on the system.
<li>By itself, installing X on a system does not change the
risk of external security issues.
<li>If someone is already ON your system, they can most likely install
whatever they wish, so the presence or absence of the X
does not appreciably change the situation.
<li>The only parts of X that are running are the parts
required by your application.
<li>The space required for X is relatively modest on modern hardware.
</ul>

People sometimes waste a lot of time and effort trying to pick through
xbaseXX.tgz and pull out just the files they need to install their
application.
This is not only pointless, but an effort that would have to be
repeated for each upgrade cycle, which probably means you will not
upgrade your system properly, creating REAL security problems.

<p>
IF you need X, just install it.
It won't hurt you any more than the application you are needing it
for will.


<a name="FilesNeededComp"></a>
<h3>I don't want to install the compilers</h3>
Ok, don't, but please don't tell yourself this is for "security
reasons".
By the time someone is far enough into your system that the presence or
absence of the compiler matters, they are far enough in they can install
a compiler themselves.
However, the compXX.tgz file set is relatively big and has a lot of
files in it, so it can take a while to install and upgrade, and on
slow or small systems, this can matter.

<p>
If you do decide to not install the compiler, you will probably need
another system to maintain and build updated software on.
There are far more systems that have been compromised because of
improper maintenance than there have been because a compiler was
installed.

<p>
<a name="Partitioning"></a>
<h2> 4.8 - How should I partition my disk?</h2>

<p>
Obviously, the answer to this question varies tremendously based on your
use of the system.
OpenBSD can be installed in as little as 512M, but using that
small of a device is something for advanced users.
Until you have some experience, an 8G or larger hard disk is recommended
to start with.

<p>
Unlike many other OSs, OpenBSD encourages users to partition their
disk into a number of partitions, rather than having just one or two
big partitions.
There are a number of reasons to partition your disk:

<ul>
<li><b>Security:</b> You can mark some filesystems as 'nosuid', 'nodev',
  'noexec', 'readonly', etc.
  This is done for you by the install process, if you use the
  recommended partitions.
<li><b>Stability:</b> A user, or a misbehaved program, can fill a
  filesystem with garbage if they have write permissions for it.  Your
  critical programs, which hopefully run on a different filesystem, do
  not get interrupted.
<li><b>Speed:</b> A filesystem which gets written to frequently may get
  somewhat fragmented.  (Luckily, the ffs filesystem that OpenBSD uses
  is not prone to heavy fragmentation.)
<li><b>Integrity:</b> If one filesystem is corrupted for some reason
  then your other filesystems are most likely still OK.
<li><b>Size:</b> Many machines have limits on the area of a disk where
  the boot ROM can load the kernel from.  In some cases, this limit may
  be very small (504M for an older 486), in other cases, a much larger
  limit (for example, 2G, 8G, or 128G on i386 systems).  As the kernel
  can end up anywhere within the root partition, the entire root
  partition should be within this area.  For more details, see <a
  href="faq14.html#LargeDrive">this section</a>.  A good guideline might
  be to keep your / partition completely below 2G, unless you know your
  platform (and particular machine) can handle more (or less) than that.
<li><b>Read-only:</b> You can mount partitions that you never or
  rarely need to write to as "Read-only" most of the time, which will
  eliminate the need for fsck(8) after a crash or power interruption,
  and may help prevent unintended data alteration.
<li><b>fsck(8):</b> Very large partitions require more RAM to
  fsck(8), and on small-memory systems, you can end up having to use
  swap, resulting in very long fsck times.
</ul>

Given sufficient disk space, OpenBSD's installer will default to the
following partitions:

<ul>
<li><b>/ - root:</b>
In addition to being where the other file systems are mounted,
the root file system holds all the files needed to boot OpenBSD.
This includes the kernel, plus the basic utilities in <tt>/sbin</tt> and
<tt>/bin</tt>, the configuration files in <tt>/etc</tt>, and the device
directory, <tt>/dev</tt> which are all used to bring up the system.
The root file system can be as small as 60M, though 200M to 500M is
easier for a machine that will last through many upgrade cycles.
The 'a' partition of your boot drive becomes your root partition
automatically.
SOME platforms place restrictions on the physical location on the
disk (i.e., must be at start of disk) in order to boot.

<li><b>Swap:</b>
In addition to swap, this partition is also used for storing core dumps
after system crashes, so it is suggested that the swap space (if set
up at all) be bigger than the largest amount of RAM you are likely to
ever install on the machine.
Read more about this in <a href="faq14.html#Swap">FAQ 14, Swap</a>.

<li><b>/tmp:</b>
This is a world-writeable directory used for (as the name implies!)
temporary storage.
Most systems can get by with very modest amounts of storage here, 50M is
usually many times what you should ever need, though there are a few
applications which can use much, much more.
While this directory is world-writable, when it is a separate partition,
OpenBSD defaults to mounting it nodev and nosuid, which minimizes how
it can be used to abuse your system.
Files left unattended here will be purged automatically, this is NOT for
long term storage!

<li><b>/var:</b>
This directory and mount point is used for a LOT of things, and depending
on your uses, may be a prime candidate to subdivide into more partitions.
Some of the things that end up here (and potential additional mount points):
<ul>
  <li><tt>/var/log</tt>: System logs.
  <li><tt>/var/mail</tt>: Incoming mail boxes.
  <li><tt>/var/spool</tt>: Outgoing mail (and other things)
  <li><tt>/var/www</tt>: OpenBSD's web server lives here.
  <li><tt>/var/crash</tt>: If the system panics, it will attempt to
     save a core dump in the swap partition before rebooting.
     This core dump will then be saved to <tt>/var/crash</tt> upon
     reboot, so <tt>/var</tt> will need at least as much free space as
     the system has RAM for this to work automatically.
   </ul>

<li><b>/usr:</b>
This is where most of OpenBSD resides.
Program binaries, libraries, documentation, manual pages, etc. are all
located in the <tt>/usr</tt> directory.
The files in this mount point are relatively unchanging -- in many
cases, you could easily mount the <tt>/usr</tt> partition read-only with
no other system changes until your next upgrade or update.

<li><b>/usr/X11R6:</b>
This is where the X Window system resides.
The X binaries, font files, libraries, etc. all are here.
The only part of X not here is the configuration files.

<li><b>/usr/local:</b>
On a default OpenBSD installation, this mount point/directory is
completely empty.
It is used for locally installed binaries and libraries for local
applications.

<li><b>/usr/src:</b>
This directory holds the basic system source files, excluding X and
ports.
This directory is empty by default, you have to load it as detailed in
<a href="faq5.html#BldGetSrc">FAQ 5</a>.

<li><b>/usr/obj:</b>
This directory is populated during the build process with the object
and binary files.
Having this directory a separate mount point allows it to be formatted
rather than erased file by file, which can be significantly faster.

<li><b>/home:</b>
This is where user files go.
Having this a separate partition makes it easy to completely reinstall
your system; simply don't format this partition on reload.
</ul>

<p>
Some additional thoughts on partitioning:
<ul>
 <li>For your first attempt at an experimentation system, one big
   <tt>/</tt> partition and swap may be easiest until you know how much
   space you need. By doing this you will be sacrificing some of the
   default security features of OpenBSD that require separate
   filesystems for <tt>/, /tmp, /var, /usr</tt> and <tt>/home</tt>.
   However, you probably should not be going into production with your
   first OpenBSD install.
 <li>A system exposed to the Internet or other hostile forces should
   have a separate <tt>/var</tt> (and maybe even a separate
   <tt>/var/log</tt>) for logging.
 <li>A <tt>/home</tt> partition can be nice.  New version of the OS?
   Wipe and reload everything else, leave your <tt>/home</tt> partition
   untouched.  Remember to save a copy of your configuration files,
   though!
 <li>A separate partition for anything which may accumulate a large
   quantity of files that may need to be deleted can be faster to
   reformat and recreate than to delete.  See the <a
   href="faq5.html#ProbObjPt">building by source FAQ</a> for an example
   (<tt>/usr/obj</tt>).
 <li>If you wish to rebuild your system from source for any reason,
   the source will be in <tt>/usr/src</tt>.  If you don't make a
   separate partition for <tt>/usr/src</tt>, make sure <tt>/usr</tt> has
   sufficient space.
 <li>A commonly forgotten fact: you do <b>not</b> have to allocate
   all space on a drive when you set the system up! Since  you will now
   find it a challenge to buy a new drive smaller than 100G, it can make
   sense to leave a chunk of your drive unallocated.  If you outgrow a
   partition, you can allocate a new partition from your unused space,
   <a href="faq10.html#DupFS">duplicate</a> your existing partition to
   the new partition, change
   <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab</a>
   to point to the new partition, remount, you now have more space.
 <li>If you make your partitions too close to the minimum size required,
   you will probably regret it later, when it is time to upgrade your
   system.
 <li>If you make very large partitions, keep in mind that performing
   filesystem checks using
   <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)</a>
   requires about 1M of RAM per gigabyte of filesystem size, and may be
   very time-consuming or not even feasible on older, slower systems
   (please also refer to <a href="faq14.html#LargeDrive">this section</a>).
 <li>If you permit users to write to <tt>/var/www</tt> (i.e., personal
   web pages), you might wish to put it on a separate partition, so you
   can use <a href="faq10.html#Quotas">quotas</a> to restrict the space
   they use, and if they fill the partition, no other parts of your
   system will be impacted.
 <li>You may also want to create an <tt>/altroot</tt> partition, as
   described in
   <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=daily&amp;sektion=8">daily(8)</a>.
   This can make a daily copy of your <tt>/</tt> partition, giving you
   an extra copy of your kernel and <tt>/etc</tt> configuration files should
   something happen to your root partition.
   Obviously, the <tt>/altroot</tt> partition needs to be at least as big
   as <tt>/</tt>.
   If you have a second drive and have something else duplicating the
   rest of your disk, either software
   <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=softraid&amp;sektion=4">softraid(4)</a>
   or a periodic copy using
   <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a
   >/<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>,
   this disk can be bootable after the removal of the primary disk.
 <li>Compiling some <a href="faq15.html#Ports">ports</a> from source
   can take huge amounts of space on your <tt>/usr</tt> and <tt>/tmp</tt>
   partitions.
   This is another reason we suggest using
   <a href="faq15.html#PkgMgmt">pre-compiled packages</a> instead.
 <li>At least some editors use <tt>/tmp</tt> for scratch space, and
   this often needs to be as big or bigger than the largest file you edit.
   If you plan on editing 500M files, your <tt>/tmp</tt> partition will
   need to be much larger than you might have planned on.

</ul>


<p>
<a name= "Multibooting"></a>
<h2>4.9 - Multibooting OpenBSD (amd64, i386)</h2>

Multibooting is having several operating systems on one computer, and
some means of selecting which OS is to boot.  It is <i>not</i> a
trivial task!  If you don't understand what you are doing, you may
end up deleting large amounts of data from your computer.  New OpenBSD
users are <i>strongly</i> encouraged to start with a blank hard drive on a
dedicated machine, and then practice your desired configuration on a
non-production system before attempting a multiboot configuration on a
production machine.  <a href="faq14.html">FAQ 14</a> has more
information about the OpenBSD boot process.

<p>
Preferably use one of the four <i>primary</i> MBR partitions for
booting OpenBSD (i.e., extended partitions may not work).

<p>
Note that Windows 7 and Vista can resize their system partitions: go
to the Control Panel, search for "partition", and enter the corresponding
system tool.  Right click on a partition, and you will notice you can shrink
it.  Its main limitation is that the Windows Exchange File can't be moved,
so if you need more space, you may have to move/disable it.

<p>
Here are several ways you might configure multibooting:

<h3>Setting active partitions</h3>
This is probably the most overlooked, and yet, sometimes the best
solution for multibooting.  Simply set the active partition in whatever
OS you are currently using to be the one you want to boot by default
when you next boot.  Virtually every OS offers a program to do
this; OpenBSD's is <a href="faq14.html#fdisk">fdisk(8)</a>, similar
named programs are in Windows 9x and DOS, and many other operating
systems.  This can be highly desirable for OSs or systems which take a
long time to shut down and reboot -- you can set it and start the reboot
process, then walk away, grab a cup of coffee, and come back to the system
booted the way you want it -- no waiting for the Magic Moment to select
the next OS.

<h3>Boot floppy</h3>
If you have a system that is used to boot OpenBSD infrequently (or don't
wish other users of the computer to note anything has changed), consider
using a boot floppy.  Simply use one of the <a href="#MkFlop">standard
OpenBSD install floppies</a>, and create an <tt>/etc/boot.conf</tt> file
(yes, you will also have to create an <tt>/etc</tt> directory on the
floppy) with the contents:

<pre>
     boot hd0a:/bsd
</pre>

to cause the system to boot from hard drive 0, OpenBSD partition 'a',
kernel file <tt>/bsd</tt>.  Note you can also boot from other drives
with a line like: "<tt>boot hd2a:/bsd</tt>" to boot off the third
hard drive on your system.  To boot from OpenBSD, slip your floppy in,
reboot.  To boot from the other OS, eject the floppy, reboot.
(You can, of course, use this floppy to make a bootable CD, too.)

<p>
The
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">boot(8)</a>
program is loaded from the floppy, it then looks for and reads
<tt>/etc/boot.conf</tt>.  The "<tt>boot hd0a:/bsd</tt>" line instructs
boot(8) where to load the kernel from -- in this case, the first HD the
BIOS sees.  Keep in mind, only a small file (<tt>/boot</tt>) is loaded
from the floppy -- the system loads the entire kernel off the hard disk,
so this only adds about five seconds to the boot process.

<h3>Windows NT/2000/XP NTLDR</h3>

To multiboot OpenBSD and Windows NT/2000/XP, you can use NTLDR, the
boot loader that NT uses. To multiboot with NT,  you need a copy of your
OpenBSD Partition Boot Record (PBR). After running installboot, you can
copy it to a file using
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&amp;sektion=1">dd(1)</a>,
following a process similar to:

<pre>
	# <strong>dd if=/dev/rsd0a of=openbsd.pbr bs=512 count=1</strong>
</pre>

Note: this is a really good time to remind you that blindly typing in
commands that you don't understand is a really bad idea.
This line will not work directly on most computers.
It is left to the reader to adapt it to their machine.

<p>
Now boot NT and put <tt>openbsd.pbr</tt> in C:. Add a line like this to
the end of <tt>C:\BOOT.INI</tt>:

<pre>
	c:\openbsd.pbr="OpenBSD"
</pre>

<p>
When you reboot, you should be able to select OpenBSD from the NT loader
menu. There is much more information available about NTLDR at the
<a href="http://www.tburke.net/info/ntldr/ntldr_hacking_guide.htm">NTLDR
Hacking Guide</a>.

<p>
On Windows XP you can also edit the boot information using the GUI; see the
<a href="http://support.microsoft.com/default.aspx?scid=kb;en-us;289022">XP Boot.ini HOWTO</a>.

<p>
Programs that do much of this for you are available, for example,
<a href="http://www.winimage.com/bootpart.htm">BootPart</a>.
This program can be run from Windows NT/2000/XP, and will fetch
the OpenBSD PBR, place it on your NT/2000/XP partition, and will
add it to <tt>C:\BOOT.INI</tt>.

<p>
Note: The Windows NT/2000/XP  boot loader is only capable of booting OSs
from the primary hard drive.
You can not use it to load OpenBSD from the second drive on a system.

<h3>Windows Vista</h3>

<p>
With Vista, Microsoft dropped NTLDR support in favor of their newer Boot
Configuration Data (BCD) store used for controlling the boot
environment.  Since <tt>BOOT.INI</tt> is no longer available for
customization, a command-line utility, <tt>bcdedit</tt>, takes its
place.

<p>
Once OpenBSD's PBR is copied to Vista's system partition, the following
three commands are required to select and boot OpenBSD when the system
is restarted:

<p>
<blockquote><pre>
C:\Windows\system32> bcdedit /create /d "OpenBSD/i386" /application bootsector
The entry {05a763ce-d81b-11db-b3ec-000000000000} was successfully created.

C:\Windows\System32>
</pre></blockquote>

<p>
The GUID returned here, <tt>05a763ce-d81b-11db-b3ec-000000000000</tt>,
is shown for illustrative reasons.  Take note of the GUID displayed
when you run this command as this value will need to be copied into
the following commands.  Simply copying the GUID shown above will not
work.

<p>
The following two commands are also required:

<p>
<blockquote><pre>
C:\Windows\system32> bcdedit /set {05a763ce-d81b-11db-b3ec-000000000000} device boot
The operation completed successfully.

C:\Windows\system32> bcdedit /set {05a763ce-d81b-11db-b3ec-000000000000} path \openbsd.pbr
The operation completed successfully.

C:\Windows\system32>
</pre></blockquote>

<p>This must be run in a shell with administrative privileges.
Once you've located cmd.exe, right click to be able to select 
"run as administrator".

<p>
Note the absolute pathname of the imported PBR file. Do not add a drive
letter as it is assumed that the file is placed in the system partition.
<tt>bcdedit</tt> will not complain about an explicit drive
specification, but the boot manager will later balk claiming that it
cannot resolve the designated pathname.

<p>
Upon rebooting, Vista will be listed first in the boot manager
ultimately followed by OpenBSD.  Selecting either entry will boot the
corresponding operating system.

<p>
If nothing happens, look around in the control panel for boot information.
Most likely, your Windows boot is set up with no delay, so you don't see the
boot menu. You can also use this to boot OpenBSD by default.

<p>
For more information, consult <tt>bcdedit</tt>'s help by issuing:

<p>
<blockquote><pre>
C:\Windows\system32> bcdedit /?
</pre></blockquote>

<p>
or by searching Microsoft's documentation and Website.  A good
introduction can be found in this TechNet
<a href="http://technet.microsoft.com/en-us/library/cc721886%28WS.10%29.aspx">
Frequently Asked Questions</a> article.

<p>
For those who find manual configuration daunting,
<a href="http://neosmart.net/dl.php?id=1">EasyBCD</a> provides a GUI
alternative.

<h3>Windows 7</h3>

<p>
Microsoft has enhanced BCD since releasing Vista to allow multiple
versions of Windows to be booted through <tt>bcdedit</tt>.  Because of
this greater control, five commands are required to configure a
multiboot environment with OpenBSD.

<p>
After copying OpenBSD's PBR into Windows 7's system partition, issue
the following command to initialize the needed registry hive:

<p>
<blockquote><pre>
C:\Windows\system32> bcdedit /create /d "OpenBSD/i386" /application bootsector
The entry {0154a872-3d41-11de-bd67-a7060316bbb1} was successfully created.

C:\Windows\system32>
</pre></blockquote>

<p>
As admonished before, the
<tt>{0154a872-3d41-11de-bd67-a7060316bbb1}</tt> GUID is
system-dependent.  Note the value you receive when executing, and copy
it into the following commands:

<p>
<blockquote><pre>
C:\Windows\system32> bcdedit /set {0154a872-3d41-11de-bd67-a7060316bbb1} device boot
The operation completed successfully.

C:\Windows\system32> bcdedit /set {0154a872-3d41-11de-bd67-a7060316bbb1} path \openbsd.pbr
The operation completed successfully.

C:\Windows\system32> bcdedit /set {0154a872-3d41-11de-bd67-a7060316bbb1} device partition=c:
The operation completed successfully.

C:\Windows\system32> bcdedit /displayorder {0154a872-3d41-11de-bd67-7060316bbb1} /addlast
The operation completed successfully.

C:\Windows\system32>
</pre></blockquote>

<h3>Other boot loaders</h3>

<p>
Some other bootloaders OpenBSD users have used successfully include
<a href="http://gag.sourceforge.net/">GAG</a>,
<a href="http://www.ranish.com/part/">The Ranish Partition Manager</a>,
<a href="http://refit.sourceforge.net/">rEFIt</a>,
and <a href="http://www.gnu.org/software/grub/">GRUB</a>.


<h3>Time zone issues</h3>
OpenBSD expects the computer's real-time clock to be set to UTC
(Universal Coordinated Time).
Some other OSs expect the real-time clock to be set to local time.
Obviously, this can create a bit of a problem if you are using both
OSs on the same computer.
One or the other is most likely going to have to be adapted.
More info on doing this is in <a href="faq8.html#TimeZone">FAQ 8 - Why
is my clock off by several hours?</a>

<p>
<a name= "SendDmesg"></a>
<h2>4.10 - Sending your dmesg to dmesg@openbsd.org after the install</h2>

<p>
Just to remind people, it's important for the OpenBSD developers to keep
track of what hardware works, and what hardware doesn't work perfectly,
including the hardware sensors that are found in machines.

<p>
A quote from /usr/src/etc/root/root.mail
<blockquote><pre>
If you wish to ensure that OpenBSD runs better on your machines, please do us
a favor (after you have your mail system configured!) and type something like:
 # (dmesg; sysctl hw.sensors) | \
        mail -s "Sony VAIO 505R laptop, apm works OK" dmesg@openbsd.org
so that we can see what kinds of configurations people are running.  As shown,
including a bit of information about your machine in the subject or the body
can help us even further.  We will use this information to improve device driver
support in future releases.  (Please do this using the supplied GENERIC kernel,
not for a custom compiled kernel, unless you're unable to boot the GENERIC
kernel.  If you have a multi-processor machine, dmesg results of both GENERIC.MP
and GENERIC kernels are appreciated.)  The device driver information we get from
this helps us fix existing drivers. Thank you!
</pre></blockquote>

<p>
Make sure you send email from an account that is able to also receive
email so developers can contact you if they have something they
want you to test or change in order to get your setup working. It's not
important at all to send the email from the same machine that is running
OpenBSD, so if that machine is unable to receive email, just

<pre>
$ (dmesg; sysctl hw.sensors) | mail your-account@yourmail.dom
</pre>
and then forward that message to
<pre>
 dmesg@openbsd.org
</pre>
where <tt>your-account@yourmail.dom</tt> is your regular email account.

<p>
<b>NOTES</b>

<ul>
<li>Please send only GENERIC kernel dmesgs.
Custom kernels that have device drivers removed are not helpful.
<li>If you have a supported multiprocessor system and
normally run the GENERIC.MP kernel, it is helpful to developers to see the
dmesg output of both the GENERIC kernel and the GENERIC.MP kernel, so please
send both of them in separate emails.
<li>The dmesgs are received on a computer using the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=spamd&amp;sektion=8">spamd</a>
spam rejection system.
This may cause your dmesg to not be accepted by the mail servers for a
period of time.
Be patient, after half an hour to an hour or so, it will get through.
</ul>

<p>
The method above is very easy, but if you have chosen not to configure mail on
your OpenBSD system, you should still send your dmesg to the developers.
Save your dmesg output to a text file.

<pre>
$ (dmesg; sysctl hw.sensors) > ~/dmesg.txt
</pre>

Then transfer this file (using FTP/scp/floppydisk/carrier-pigeon/...)  to the
system you normally use for email.
Since the dmesg output you send in is processed automatically, be sure to
check the following when using alternate email clients/systems:
<ul>
<li>Configure your email client to send messages as plain text;
    do not use HTML-formatted email.
<li>Turn off any forced line break feature.
    Many email clients are configured to insert line breaks at 72 columns
    (the norm for mailing lists).
<li>Make sure your email client does not reformat messages into "text-flow"
    nonsense.
<li>Do not send the dmesg output as a file attachment.
    Put the dmesg output into the body of the message.
</ul>


<a name="AddFileSet"></a>
<h2>4.11 - Adding a file set after install</h2>
"Oh no!  I forgot to add a file set when I did the install!"
<p>
Sometimes, you realize you really DID need <tt>compXX.tgz</tt> (or any
other system component) after all, but you didn't realize this at the
time you installed your system.  Good news: There are two easy ways to
add file sets after the initial install:

<h3>Using the upgrade process</h3>
Simply boot your install media (CD-ROM or Floppy), and choose Upgrade
(rather than Install).  When you get to the lists of file sets to
install, choose the sets you neglected to install first time around,
select your source, and let it install them for you.

<h3>Using tar(1)</h3>
The install file sets are simply compressed tar files, and you can
expand them manually from the directory in which the file sets reside:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  # tar -C / -xzvphf comp*.tgz
</pre></td></tr></table>

<p>
Do NOT forget the <tt>'p'</tt> option in the above command in
order to restore the file permissions properly!
<p>
One common mistake is to think you can use
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pkg_add&amp;sektion=1">pkg_add(1)</a>
to add missing file sets.  This does not work.  pkg_add(1) is
the <a href="faq15.html#PkgMgmt">package management tool</a>
to install third party software.
It handles package files, not generic tar files like the install sets.

<p>
If you are installing the <tt>xbase</tt> file set on your system for the first time
using tar(1) and without rebooting, the shared library cache must be
updated after the installation using
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ldconfig&amp;sektion=8"
>ldconfig(8)</a>.
To add all the X libraries to the cache:

<blockquote><pre>
# <b>ldconfig -m /usr/X11R6/lib</b>
</pre></blockquote>

Alternatively, you can just reboot your system, and this will be done
automatically by the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&amp;sektion=8"
>rc(8)</a> startup script.

<p>
<a name="bsd.rd"></a>
<h2>4.12 - What is 'bsd.rd'?</h2>

<b><tt>bsd.rd</tt></b> is a "RAM Disk" kernel.  This file can be very
useful; many developers are careful to keep it on the root of their
system at all times.

<p>
Calling it a "RAM Disk kernel" describes the root filesystem of the
kernel -- rather than being a physical drive, the utilities available
after the boot of <tt>bsd.rd</tt> are stored in the kernel, and are run
from a RAM-based filesystem.  <tt>bsd.rd</tt> also includes a healthy set
of utilities to allow you to do system maintenance and installation.

<p>
On some platforms, <tt>bsd.rd</tt> is actually the preferred
installation technique -- you place this kernel on an existing
filesystem, boot it, and run the install from it.  On most
platforms, if you have a running older version of OpenBSD, you
can FTP  a new version of <tt>bsd.rd</tt>, reboot from it, and
install a new version of OpenBSD without using any removable
media at all.

<p>
Here is an example of booting <tt>bsd.rd</tt> on an i386 system:

<p>
<table border=0 width="90%"><tr><td nowrap bgcolor="#EEEEEE"><pre>
  Using Drive: 0 Partition: 3
  reading boot.....
  probing: pc0 com0 com1 apm mem[639k 255M a20=on]
  disk: fd0 hd0+
  &gt;&gt; OpenBSD/i386 BOOT 3.26
  boot&gt; <b>boot hd0a:/bsd.rd</b>
<i>. . . normal boot to install . . .</i>
</pre></td></tr></table>

<p>
As indicated, you will be brought to the install program, but you
can also drop to the shell to do maintenance on your system.
<p>
The general rule on booting <tt>bsd.rd</tt> is to change your boot
kernel from <tt>/bsd</tt> to <tt>bsd.rd</tt> through whatever
means used on your platform.

<p>
<a name="InstProb"></a>
<h2>4.13 - Common installation problems</h2>

<p>
<a name="noboot"></a>
<h3>4.13.2 - My i386 won't boot after install</h3>
Your install seemed to go fine, but on first boot, you see no sign of
OpenBSD attempting to boot.  There are a few common reasons for this
problem:

<ul>
<li><b>No partition was flagged active in fdisk(8).</b>  To fix this,
reboot the machine using the boot floppy or media, and "flag" a
partition as "active" (bootable).  See
<a href="faq14.html#fdisk">here</a> and
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">here</a>.

<li><b>No valid boot loader was ever put on the disk.</b>
If you hit "Enter" or answer "w" to the
"Use (W)hole disk or (E)dit the MBR?" question during the install, or
use the "<tt>reinit</tt>" option of fdisk(8), the
OpenBSD boot record is installed on the Master Boot Record of the disk;
otherwise, the existing master boot code is untouched.  This will be a
problem if no other boot record existed.
One solution is to boot the
install media again, drop to the shell and invoke
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
to update the MBR code from the command line:
<pre>
    # fdisk -u wd0
</pre>
Note: the "update" option within the interactive ("-e") mode of
fdisk will not write the signature bytes required to make the disk
bootable.

<li><b>On some rare occasions, something may go wrong with the second
stage boot loader install.</b>  Reinstalling the second stage boot
loader is discussed <a href="faq14.html#InstBoot">here</a>.

</ul>

<a name="sshhang"></a>
<h3>4.13.3 - My (older, slower) machine booted, but hung at the ssh-keygen
steps</h3>
It is very likely your machine is running fine, just taking a while
to do the ssh key generation process.  A SPARCStation2 or a slow 80486
may take <i>several hours</i> to complete the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh-keygen&amp;sektion=1">ssh-keygen(1)</a>
steps.
Just let it finish; it is only done once per install.

<p>
<a name="noftplist"></a>
<h3>4.13.4 - Why aren't the downloadable images self-signed?</h3>

If you use <tt>installXX.iso</tt> or <tt>installXX.fs</tt>, you will
find the installer will complain about no <tt>SHA256.sig file</tt>, and
thus, it can't verify the files during the installation.

<p>
It is not possible to <i>usefully</i> have the complete installer verify
the sets.
After all, if someone were to make a "rogue" installXX.iso file, they
would almost certainly change the installer to say everything verified
successfully.  Thus, you must <a href="faq3.html#Verify">verify</a> your
installer downloads separately.

<p>
<a name="blankfdisk"></a>
<h3>4.13.5 - My fdisk partition table is trashed or blank!</h3>
Occasionally, a user will find a system will work, but when doing an
<tt>fdisk wd0</tt>, they see a completely blank (or sometimes, garbage)
partition table.
This is usually caused by having created a partition in
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
which had an offset of zero sectors, rather than the
<a href="#trackoffset">one track offset</a> it should have
(note: this is assuming the <a href="../i386.html">i386</a> or
<a href="../amd64.html">amd64</a> platform.
Other platforms have different offset requirements, some need NO
offset).
The system then <a href="faq14.html#Boot386">boots</a> using the PBR,
not using the MBR.

<p>
While this configuration can work, it can be a maintenance problem and
should be fixed.
To fix this, the disk's file systems must generally be recreated from
scratch (though if you REALLY know what you are doing, you may be able
to recreate just your disklabel and MBR, and only lose and have to
rebuild the first OpenBSD partition on the disk).

<p>
<a name="noflopcd"></a>
<h3>4.13.6 - I have no floppy or CD-ROM on my machine</h3>
Some computers people might want to run OpenBSD on lack any obvious way
to install OpenBSD, having no floppy or CD-ROM drive.
Either the machine was designed without it (for example, many laptops
and "flash" based machines, like Soekris and ALIX systems), or the boot
devices have failed or been removed, and would be difficult to replace.
Here are some tips and techniques you can use to get OpenBSD installed
on these systems.
<ul>
<li>Network boot, using <a href="faq6.html#PXE">PXE</a> (i386 or amd64) or
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=diskless&amp;sektion=8">diskless(8)</a>
(other platforms).

<li>External USB CD-ROM or USB floppy, if your machine can boot from
one.

<li>USB Flash disk or hard disk, again if your computer can boot from
a USB device.
Prepare the device on another computer as described in
<a href="faq14.html#flashmemLive">FAQ 14</a>.
Boot from it, but choose the bsd.rd kernel, then install as normal.
You could also have the file sets pre-loaded on the flash media, as
well.

<li>Worst case, if none of the above is suitable, you can usually pull
the disk out of the target system, use suitable adapters to install it
in a "normal" computer, install OpenBSD, then replace the disk back in
the target system.
OpenBSD will then boot nicely in the target machine, though you will
very possibly have to adjust the network configuration.
You may also have to adjust <tt>/etc/fstab</tt> if you (for example)
did your install using a USB->IDE/SATA adapter or your target or install
machine uses
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ahci&amp;sektion=4">ahci(4)</a>
and the other does not.
IDE and some SATA disks will normally be recognized as
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wd&amp;sektion=4">wd(4)</a>
devices, but if attached to a USB adapter, will come up as
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sd&amp;sektion=4">sd(4)</a>.
A SATA disk attached to a
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pciide&amp;sektion=4">pciide(4)</a>
interface will come up as wd(4), but attached to an
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ahci&amp;sektion=4">ahci(4)</a>
interface, will come up as a sd(4) device.
However, once you correct the <tt>/etc/fstab</tt> file, the system
will generally boot just fine.

</ul>

In all cases, remember that the machine had an OS installed on it
before, and it was usually intended that the OS could be reloaded in the
field.
How this was originally intended to be done will often provide you a
good idea how you can install OpenBSD now.

<p>
<a name="shamismatch"></a>
<h3>4.13.7 - I got a "Continue without verification?" message during install!</h3>
The verification process consists of fetching the <tt>SHA256.sig</tt>
file, then fetching all the install files to the local hard disk and
verifying their signatures.
If either the signature file is unavailable or there is insufficient
disk space for that extra copy of the files, verification will not be
possible, and you will get that message.
If you trust your source, this should not be a problem.
If you do not trust your source, you can manually verify the files as
detailed <a href="faq3.html#Verify">here</a>.


<p>
<a name="site"></a>
<h2>4.14 - Customizing the install process</h2>

<h3><tt>siteXX.tgz</tt> file</h3>
The OpenBSD install/upgrade scripts allow the selection of a
user-created set called "<tt>siteXX.tgz</tt>", where XX is the release
version.  The <tt>siteXX.tgz</tt> file set is, like the other
<a href="#FilesNeeded">file sets</a>, a
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gzip&amp;sektion=1">gzip(1)</a>
compressed
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tar&amp;sektion=1">tar(1)</a>
archive rooted in '/' and is un-tarred like the other sets with the
options <tt>xzphf</tt>.  This set will be installed last, after
all other file sets.

<p>
This file set allows the user to add to and/or override the files
installed in the 'normal' sets and thus customize the installation or
upgrade.

<p>
You can also create and use hostname-specific install sets, which are
named <tt>siteXX-<i>&lt;hostname&gt;.tgz</i></tt>, for example,
"<tt>siteXX-puffy.tgz</tt>".
This allows easy per-host customized installations, upgrades, or
disaster recovery.

<p>
Some example uses of a <tt>siteXX.tgz</tt> file:
<ul>
<li>Create a siteXX.tgz file that contains all the file changes you made
since first installing OpenBSD. Then, if you have to re-create the
system you simply select siteXX.tgz during the re-install and all of
your changes are replicated on the new system.

<li>Create a series of machine specific directories that each contain a
siteXX.tgz file that contains files specific to those machine types.
Installation of machines (e.g. boxes with different graphics cards) of a
particular category can be completed by selecting the appropriate
siteXX.tgz file.

<li>Put the files you routinely customize in a same or similar way
in a siteXX.tgz file --
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser&amp;sektion=8"
><tt>/etc/skel</tt></a> files,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5"
><tt>/etc/pf.conf</tt></a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf.local&amp;sektion=8"
><tt>/etc/rc.conf.local</tt></a>,
etc.
</ul>

<h3><tt>install.site</tt>/<tt>upgrade.site</tt> scripts</h3>
As the last step in the install/upgrade process, the scripts look in the
root directory of the newly installed/upgraded system for
<tt>install.site</tt> or <tt>upgrade.site</tt>, as appropriate to the
current process, and runs this script in an environment
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=chroot&amp;sektion=8">chroot</a>ed
to the installed/upgraded system's root.  Remember, the upgrade is done
from a booted file system, so your target file system is actually
mounted on <tt>/mnt</tt>.
However, because of the chroot, your script can be written as if
it is running in the "normal" root of your file system.  Since this
script is run after all the files are installed, you have much of the
functionality of the full system when your script runs.
Keep in mind that you are running a minimal kernel, not all features are
available, and due to space constraints, things that work today may not
work in a future release.

<p>
Note that the <tt>install.site</tt> script would have to be in a
<tt>siteXX.tgz</tt> file, while the <tt>upgrade.site</tt> script could
be put in the root directory before the upgrade, or could be put in a
<tt>siteXX.tgz</tt> file.

<p>
The scripts can be used to do many things:
<ul>
<li>Remove files that are installed/upgraded that you don't want present
on the system.
<li> Remove/upgrade/install the
<a href="faq15.html#PkgMgmt">packages</a> you want on the installed
system (may not work for all packages!).
<li> Do an <a href="faq14.html#Backup">immediate backup/archive</a> of
the new system before you expose it to the rest of the world.
<li>Use
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rdate&amp;sektion=8">rdate(8)</a>
to set the system time.
<li>Have a set of arbitrary commands be run after the first boot.
This will happen if install.site is used to append any such commands to an
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.firsttime&amp;sektion=8">rc.firsttime(8)</a>
file (appending to this file is necessary since the installer itself may
write to this file). At boot time, rc.firsttime is executed once then deleted.
</ul>

<p>
The combination of <tt>siteXX.tgz</tt> and
<tt>install.site/upgrade.site</tt> files is intended to give users
broad customization capabilities without having to build their own
custom install sets.

<p>
Note: if you will be doing your install from an http server, you will
need to add your <tt>site*.tgz</tt> file(s) to the file
<tt>index.txt</tt> in the source directory in order for them to be
listed as an option at install time.
This is not needed for other install methods.

<p>
<a name="Multiple"></a>
<h2>4.15 - How can I install a number of similar systems?</h2>
Here are some tools you can use when you have to deploy a number
of similar OpenBSD systems.

<h3><tt>siteXX.tgz</tt> and <tt>install/upgrade.site</tt> files</h3>
See the <a href="#site">above</a> article.

<h3>Restore from dump(8)</h3>
On most platforms, the boot media includes the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>
program, which can be used to restore a backup made by
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>.
Thus, you could boot from a
<a href="#MkFlop">floppy</a>,
<a href="../orders.html">CD</a>, or
<a href="#bsd.rd">bsd.rd</a> file, then
<a href="faq14.html#fdisk">fdisk</a>,
<a href="faq14.html#disklabel">disklabel</a>, and
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore</a>
the desired configuration from tape or other media, and install the
<a href="faq14.html#InstBoot">boot blocks</a>. More details
<a href="faq14.html#Backup">here</a>.

<h3>Disk imaging</h3>
Unfortunately, there are no known disk imaging packages which are
FFS-aware and can make an image containing only the active file space.
Most of the major disk imaging solutions will treat an OpenBSD partition
as a "generic" partition, and can make an image of the whole disk. This
often accomplishes your goal, but usually with huge amounts of wasted
space --  an empty, 10G <tt>/home</tt> partition will require 10G of
space in the image, even if there isn't a single file in it.  While you
can typically install a drive image to a larger drive, you would not be
able to directly use the extra space, and you would not be able to
install an image to a smaller drive.

<p>
If this is an acceptable situation, you may find the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&amp;sektion=1">dd</a>
command will do what you need, allowing you to copy one disk to another,
sector-for-sector.  This would provide the same functionality as
commercial programs without the cost.

<p>
<a name="getdmesg"></a>
<h2>4.16 - How can I get a dmesg(8) to report an install problem?</h2>
When <a href="../report.html">reporting a problem</a>, it is critical to
include the complete system
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)</a>.
However, often when you need to do this, it is because the system is
working improperly or won't install so you may not have disk, network,
or other resources you need to get the dmesg to the appropriate
<a href="../mail.html">mail list</a>.  There are other ways, however:

<ul>
<li><b>Floppy disk:</b>  The boot disks and CD-ROM have enough tools
to let you record your dmesg to an MSDOS floppy disk for reading on
another machine.  Place an MSDOS formatted floppy in your disk drive and
execute the following commands:

<pre>
     mount -t msdos /dev/fd0a /mnt
     dmesg >/mnt/dmesg.txt
     umount /mnt
</pre>
If you have another OpenBSD system, you can also write it to an OpenBSD
compatible floppy -- often, the boot floppy has enough room on it to
hold the dmesg.  In that case, leave off the "<tt>-t msdos</tt>" above.

<p>
<li><b>Serial Console:</b>
Using a serial console and capturing the output on another computer
is often the best way to capture diagnostic information - particularly
if the computer panics immediately after boot.
As well as a second computer, you will need a suitable serial cable
(often a null-modem cable), and a terminal emulator program that can
capture screen output to file.

<p>
General information on setting up a serial console is provided
<a href="faq7.html#SerCon">elsewhere in the FAQ</a>;
in order to capture a log of the install,
the following commands are usually sufficient.

<p><b>i386</b>

<p>
At the boot loader prompt, enter

<p>
<blockquote>
<pre>
boot> <b>set tty com0</b>
</pre>
</blockquote>

<p>
This will tell OpenBSD to use the first serial port (often called
COM1 or COMA in PC documentation) as a serial console.
The default baud rate is 9600.

<p><b>Sparc/Sparc64</b>

<p>
These machines will automatically use a serial console if started
without a keyboard present.
If you have a keyboard and monitor attached, you can still force the
system to use a serial console with the following invocation at the
<tt>ok</tt> prompt.

<p>
<blockquote>
<pre>
ok <b>setenv input-device ttya</b>
ok <b>setenv output-device ttya</b>
ok <b>reset</b>
</pre>
</blockquote>

</ul>

<p>
<hr>
<p>
<a href= "index.html">[FAQ Index]</a>
<a href= "faq3.html">[To Section 3 - Getting started with OpenBSD]</a>
<a href= "faq5.html">[To Section 5 - Building the System from Source]</a>
</body>
</html>
