<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>

<!-- If you make edits to any FAQ documents, please start each sentence
     on a new line, and try to keep the general formatting consistent
     with the rest of the pages -->

<title>7 - Keyboard and Display Controls</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name= "description"   content= "The OpenBSD FAQ page">
<meta name= "copyright"     content= "This document copyright 1998-2016
                                      by OpenBSD.">
<link rel="canonical" href="http://www.openbsd.org/faq/faq7.html">
</head>

<body bgcolor= "#ffffff" text= "#000000">

<a href="../index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../images/smalltitle.gif" border="0">
</a>
<p>
<a href= "index.html">[FAQ Index]</a>
<a href= "faq6.html">[To Section 6 - Networking]</a>
<a href= "faq8.html">[To Section 8 - General Questions]</a>

<h1><font color="#e00000">7 - Keyboard and Display Controls</font></h1>
<hr>
<p>
<h3>Table of Contents</h3>
<ul>
<li><a href= "#Keyboard"     >7.1 - How do I remap the keyboard? (wscons)</a>
<li><a href= "#ConsoleMouse" >7.2 - Is there console mouse support in
                              OpenBSD?</a>
<li><a href= "#Scrollback"   >7.3 - Accessing the console scrollback
                              buffer (some amd64, i386, Alpha)</a>
<li><a href= "#SwitchConsole">7.4 - How do I switch consoles? (amd64, i386,
                              Zaurus, some Alpha)</a>
<li><a href= "#80x50"        >7.5 - How can I use a console resolution
                              of 80x50? (some amd64, i386, Alpha)</a>
<li><a href= "#SerCon"       >7.6 - How do I use a serial console?</a>
<li><a href= "#Blanker"      >7.7 - How do I blank my console? (wscons)</a>
<li><a href= "#tmux"         >7.8 - What is tmux(1)?</a>
</ul>
<hr>

<h2 id="Keyboard">7.1 - How do I remap the keyboard? <i>(wscons)</i></h2>

Most modern OpenBSD platforms use the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wscons">wscons(4)</a>
console driver.

<p>
With
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wscons">wscons(4)</a>
consoles, most options can be controlled using the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconsctl">
wsconsctl(8)</a> utility.
For example, to change keymappings with
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconsctl">
wsconsctl(8)</a>, one would execute the following:

<blockquote><pre>
# <b>wsconsctl keyboard.encoding=uk</b>
</pre></blockquote>

In the next example, we will remap "Caps Lock" to be "Control L"
(the left control key):

<blockquote><pre>
# <b>wsconsctl keyboard.map+="keysym Caps_Lock = Control_L"</b>
</pre></blockquote>

<h2 id="ConsoleMouse">7.2 - Is there console mouse support in OpenBSD?</h2>

For the <a href="../alpha.html">alpha</a>, <a href="../amd64.html">amd64</a>
and <a href="../i386.html">i386</a> platforms, OpenBSD provides
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsmoused">wsmoused(8)</a>,
a port of FreeBSD's moused(8).
It can be enabled automatically at startup by copying and editing the
appropriate line from <tt>/etc/rc.conf</tt> to
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf.local">
rc.conf.local(8)</a> or with the 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rcctl">rcctl(8)</a>
utility.

<h2 id="Scrollback">7.3 - Accessing the Console Scrollback Buffer
<i>(some amd64, i386, Alpha)</i></h2>

On a few platforms and hardware combinations, OpenBSD provides a console
scrollback buffer.
This allows you to see information that has already scrolled past your screen.
To move up and down in the buffer, simply use the key combinations
<tt>[SHIFT]+[PGUP]</tt> and <tt>[SHIFT]+[PGDN]</tt>.

<p>
The default scrollback buffer, or the number of pages that you can move up
and view, is 8.
This is a feature of the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vga">vga(4)</a>
driver, so it will not work without a VGA card on any platform (many
Alpha systems have TGA video), or on hardware that uses
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=drm">drm(4)</a>.

<p>
Due to space limitations, the install kernels do not provide the
scrollback function.
<a href="#SwitchConsole">Switching consoles</a> will clear the scrollback
buffer.

<h2 id="SwitchConsole">7.4 - How do I switch consoles? <i>(amd64, i386, Zaurus,
some Alpha)</i></h2>

On amd64, i386 and Alpha systems with
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vga">vga(4)</a>
cards, OpenBSD provides six virtual terminals by default, <tt>/dev/ttyC0</tt>
through <tt>/dev/ttyC5</tt>.
<tt>ttyC4</tt> is reserved for use by the X Window system, leaving five text
consoles available.
You can switch between them using
<tt>[CTRL]+[ALT]+[F1]</tt>, <tt>[CTRL]+[ALT]+[F2]</tt>,
<tt>[CTRL]+[ALT]+[F3]</tt>, <tt>[CTRL]+[ALT]+[F4]</tt> and
<tt>[CTRL]+[ALT]+[F6]</tt>.

<p>
The X environment uses ttyC4, <tt>[CTRL]+[ALT]+[F5]</tt>.
When using X, the <tt>[CTRL]+[ALT]+[F</tt><i>n</i><tt>]</tt> keys will
take you to the text screens; <tt>[CTRL]+[ALT]+[F5]</tt> will take you
back to the graphical environment.

<p>
If you wish to have more than the default number of virtual consoles,
use the <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconscfg">
wsconscfg(8)</a> command to create screens for <tt>ttyC6</tt>, <tt>ttyC7</tt>
and above.
For example:

<blockquote><pre>
# <b>wsconscfg -t 80x25 6</b>
</pre></blockquote>

This will create a virtual terminal for <tt>ttyC6</tt>, accessed by
<tt>[CTRL]+[ALT]+[F7]</tt>.
Don't forget to add this command to your
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.local">
rc.local(8)</a> file if you want the extra screen the next time you
boot the computer.

<p>
Note that you will not get a <tt>login:</tt> prompt on the newly created
virtual console unless you set it to "on" in
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ttys">ttys(5)</a>,
and either reboot or send
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=init">init(8)</a>
a HUP signal using
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=kill">kill(1)</a>.

<p>
On the Zaurus, two virtual terminals (<tt>/dev/ttyC0</tt> and
<tt>/dev/ttyC1</tt>) are available by default, accessible with
<tt>[ALT]+[CALENDAR]</tt> and <tt>[ALT]+[ADDRESS]</tt> (The <tt>[ALT]</tt>
key is the one right of the left <tt>[CTRL]</tt> key).

<h2 id="80x50">7.5 - How do I use a console resolution of 80x50?
<i>(some amd64, i386, Alpha)</i></h2>

amd64, i386, and Alpha users with VGA but
non-<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=drm">drm(4)</a>
display adapters normally get a console screen of 25 lines of 80 characters.
However, many VGA video cards are capable of displaying a higher text
resolution of 50 lines of 80 characters.

<p>
First, a font that supports the desired resolution must be loaded using the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsfontload">
wsfontload(8)</a> command.
The standard 80x25 text screen uses 8x16 pixel fonts; to double the number
of lines we will have to use 8x8 pixel fonts.

<p>
After that, we will have to delete and recreate a <a href="#SwitchConsole">
virtual console</a> at the desired screen resolution, using the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconscfg">
wsconscfg(8)</a> command.

<p>
This can be done automatically at boot by adding the following lines to
the end of your
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.local">
rc.local(8)</a> file:

<blockquote><pre>
wsfontload -h 8 -e ibm /usr/share/misc/pcvtfonts/vt220l.808
wsconscfg -dF 5
wsconscfg -t 80x50 5
</pre></blockquote>

As with any modification to your system configuration, it is recommended
you spend some time with the man pages to understand what these commands do.

<p>
The first line above loads the 8x8 font.
The second line deletes screen 5 (which would be accessed by
<tt>[CTRL]+[ALT]+[F6]</tt>).
The third line creates a new screen 5 with 50 lines of 80 characters each.
If you do this, you will see your primary screen, and the other three default
virtual consoles, come up in the standard 80x25 mode, but a new screen 5 at
80x50 accessible through <tt>[CTRL]+[ALT]+[F6]</tt>.

<p>
Remember that <tt>[CTRL]+[ALT]+[F1]</tt> is screen 0 (<tt>ttyC0</tt>).
If you wish to alter other screens, simply repeat the delete and add screen
steps for whichever screens you want running at the 80x50 resolution.

<p>
You should avoid changing screen 4 (<tt>ttyC4</tt>, <tt>[CTRL]+[ALT]+[F5]</tt>),
which is used by X as a graphical screen.
It is also not possible to change the resolution of the primary console
device (i.e., <tt>ttyC0</tt>).

<p>
As one might expect, all these commands can be run as root at the console.

<p>
<b>Note: this will not work on all video cards.</b>
Unfortunately, not all video cards support the uploaded fonts that
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wscons">wscons(4)</a>
requires to achieve the 80x50 text mode.
In these cases, you might wish to consider running X.
Cards supported by the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=drm">drm(4)</a>
driver will have a higher resolution anyway, but can not use these uploaded
fonts.

<h2 id="SerCon">7.6 - How do I use a serial console?</h2>

There are many reasons you may wish to use a serial console for your
OpenBSD system:

<ul>
<li>Recording console output (for documentation)
<li>Remote management
<li>Easier maintenance of a large quantity of machines
<li>Providing a useful dmesg from machines which might otherwise be difficult
to get one from
<li>Providing an accurate "trace" and "ps" output if your system crashes so
developers can have a chance to fix the problem
</ul>

OpenBSD supports serial console on most platforms, however details vary
greatly between platforms.

<p>
Note that serial interfacing is NOT a trivial task -- you will often
need unusual cables, and ports are not standardized between machines, in
some cases, not even consistent on one machine.
It is assumed you know how to select the appropriate cable to go between
your computer and the device acting as your serial terminal.
A full tutorial on serial interfacing is beyond the scope of this article,
however, we offer one hint: just because the ends plug in doesn't mean it
will work.

<h3 id="SerContty"><i>/etc/ttys</i> change</h3>

There are two parts to getting a functional serial console on an OpenBSD
system.
First, you must have OpenBSD use your serial port as a console for status
and single user mode.
This part is very platform-dependent.
Second, you must enable the serial port to be used as an interactive terminal,
so a user can log into it when running multi-user.
This part is fairly similar between platforms, and is detailed here.

<p>
Terminal sessions are controlled by the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ttys">ttys(5)</a> file.
Before OpenBSD will give you a <tt>login:</tt> prompt at a device, it has
to be enabled in <tt>/etc/ttys</tt>.
After all, there are uses for a serial port other than for a terminal.
In platforms which typically have an attached keyboard and screen as a
console, the serial terminal is typically disabled by default.
We'll use the i386 platform as an example.
In this case, you must edit the line that reads:

<blockquote><pre>
tty00   "/usr/libexec/getty std.9600"   unknown off
</pre></blockquote>

to read something like:

<blockquote><pre>
tty00   "/usr/libexec/getty std.9600"   vt220   on secure
</pre></blockquote>

Here, <tt>tty00</tt> is the serial port we are using as a console.
<tt>vt220</tt> is the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=termcap">termcap(5)</a>
entry that matches YOUR terminal (other likely options might include
<tt>vt100</tt>, <tt>xterm</tt>, etc.).
The <tt>on</tt> bit activates the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=getty">getty(8)</a>
for that serial port, so that a <tt>login:</tt> prompt will be presented.
The <tt>secure</tt> bit permits a root (uid 0) login at this console
(which may or may not be what you desire).
The <tt>9600</tt> bit is the terminal baud rate.
Resist the urge to crank the baud rate up to the maximum your hardware
can support, as you are more likely to create problems than benefit.
Most systems have a "default" speed (supported by default by the boot
ROM and/or the boot loader, often 9600), use this unless you have real
reason to use something different.

<p>
Note that you can use a serial console for install without doing this step,
as the system is running in single user mode, and not using <i>getty</i>
for login.

<p>
On some platforms and some configurations, you must bring the system up
in single user mode to make this change if a serial console is all you
have available.

<h3>amd64 and i386</h3>
To direct the boot process to use the serial port as a console,
create or edit your
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot.conf">
boot.conf(5)</a> file to include the line...

<blockquote><pre>
set tty com0
</pre></blockquote>

...to use the first serial port as your console.
The default baud rate is 9600bps.
This can be changed with a <tt>/etc/boot.conf</tt> line using the stty option.
This file is put on your boot drive, which could also be your install media,
or the command can be entered at the <tt>boot&gt;</tt> prompt from the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot">OpenBSD
second-stage boot loader</a> for a one-time (or first time) serial console
usage.

<p>
<h4>amd64 and i386 notes:</h4>
<ul>
<li>OpenBSD numbers the serial ports starting at <i>tty00</i>,
DOS/Windows labels them starting at <i>COM1</i>.
So, keep in mind <i>tty02</i> is <i>COM3</i>, not <i>COM2</i>.

<li>Some systems may be able to operate without a video card in the
machine, but certainly not all -- many systems consider this an error
condition.
Some machines will even refuse to work easily without a keyboard attached.

<li>Some systems are capable of redirecting all BIOS keyboard and screen
activity to a serial port through a configuration option, so the machine
can be completely maintained through the serial port.
Your results may vary -- when using this feature, some BIOSs may prevent
the bootloader from seeing the serial port, and thus, the kernel will
not be told to use it.
Some BIOSs have an option to "Continue Console Redirection after POST"
(Power On Self Test), this should be set to "OFF", so the boot loader
and the kernel can handle their own console.
Unfortunately, this feature is not universal.

<li>PC-compatible computers are not designed to be run from a serial
console, unlike some other platforms.
Even those systems that support a serial console usually have it as a
BIOS configuration option -- and should the configuration information
get corrupted, you will find the system looking for a standard monitor
and keyboard again.
You generally must have some way to get a monitor and keyboard to your
amd64 and i386 systems in an emergency.

<li>You will need to edit <tt>/etc/ttys</tt> as <a href="#SerContty">above</a>.

</ul>

<h3>SPARC and UltraSPARC</h3>
These machines are designed to be completely maintainable with a serial
console.
Simply remove the keyboard from the machine, and the system will run serial.

<h4>SPARC and UltraSPARC notes</h4>
<ul>
<li>The serial ports on a SPARC are labeled <i>ttya</i>, <i>ttyb</i>, etc.

<li>Unlike some other platforms, it is not necessary to make any changes to
<tt>/etc/ttys</tt> to use a serial console.

<li>The SPARC/UltraSPARC systems interpret a BREAK signal on the console
port to be the same as a STOP-A command, and kicks the system back to
the Forth prompt, stopping any application and operating system at that
point.
This is handy when desired, but unfortunately, some serial terminals at
power-down and some RS-232 switching devices send something the computer
interprets as a break signal, halting the machine.
Test before you go into production.

<li>If you have a keyboard and monitor attached, you can still force
the serial console to be used instead by using the following commands
at the <tt>ok</tt> prompt:

<blockquote><pre>
ok <b>setenv input-device ttya</b>
ok <b>setenv output-device ttya</b>
ok <b>reset</b>
</pre></blockquote>

If the keyboard and monitor (<tt>ttyC0</tt>) are active in <tt>/etc/ttys</tt>
(<a href="#SerContty">above</a>), you can use the keyboard and monitor in X.
</ul>

<h3>MacPPC</h3>
The MacPPC machines are configured for a serial console through OpenFirmware.
Use the commands:

<blockquote><pre>
ok <b>setenv output-device scca</b>
ok <b>setenv input-device scca</b>
ok <b>reset-all</b>
</pre></blockquote>

Set your serial console to 57600bps, 8N1.

<h4>MacPPC notes</h4>
<ul>
<li>Unfortunately, serial console is not directly possible on most MacPPCs.
While most of these machines do have serial hardware, it isn't accessible
outside the machine.
Fortunately, a few companies offer add-on devices for several Macintosh
models which will make this port available for use as a serial console
(or other uses).
Use your favorite search engine and look for "Macintosh internal serial port."

<li>You will have to change <tt>tty00</tt> in <tt>/etc/ttys</tt> to
<tt>on</tt> and set the speed to 57600 instead of the default of 9600 as
detailed <a href="#SerContty">above</a> in single user mode before
booting multi-user and having the serial console functional.
</ul>

<h3>I get input/output error when trying to use my tty devices</h3>

You need to use <tt>/dev/cuaXX</tt> for connections initiated from the OpenBSD
system, the <tt>/dev/ttyXX</tt> devices are intended only for terminal or
dial-in usage.
While it was possible to use the tty devices in the past, the OpenBSD kernel
is no longer compatible with this usage.

<p>
From
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cua">cua(4)</a>:

<p>
For hardware terminal ports, dial-out is supported through matching
device nodes called calling units.
For instance, the terminal called <tt>/dev/tty03</tt> would have a matching
calling unit called <tt>/dev/cua03</tt>.
These two devices are normally differentiated by creating the calling unit
device node with a minor number 128 greater than the dial-in device node.
<i>Whereas the dial-in device (the tty) normally requires a
hardware signal to indicate to the system that it is active, the
dial-out device (the cua) does not, and hence can communicate unimpeded
with a device such as a modem</i>.
This means that a process like
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=getty">getty(8)</a>
will wait on a dial-in device until a connection is established.
Meanwhile, a dial-out connection can be established on the dial-out
device (for the very same hardware terminal port) without disturbing
anything else on the system.
The <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=getty">getty(8)</a>
process does not even notice that anything is happening on the terminal port.
If a connecting call comes in after the dial-out connection has finished, the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=getty">getty(8)</a>
process will deal with it properly, without having noticed the intervening
dial-out action.

<h2 id="Blanker">7.7 - How do I blank my console? (wscons)</h2>

If you wish to blank your console after a period of inactivity without
using X, you can alter the following
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wscons">wscons(4)</a>
variables:

<ul>
<li><b><tt>display.vblank</tt></b> set to <tt>on</tt> will disable the
vertical sync pulse, which will cause many monitors to go into an
"energy saver" mode.
This will require more time to bring the screen back on, but will reduce
energy consumption and heat production of newer monitors.
When set to <tt>off</tt>, the display will blank, but the monitor will still
be receiving the normal horizontal and vertical sync pulses, so the unblanking
will be almost instant.

<li><b><tt>display.screen_off</tt></b> determines the blanking time in
thousandths of a second, i.e., 60000 would set the timeout to one minute.

<li><b><tt>display.kbdact</tt></b> determines if keyboard activity will
restore the blanked screen.
Usually, this is desirable.

<li><b><tt>display.outact</tt></b> determines if screen output will
restore the blanked screen.
</ul>

You can set these variables at the command line using the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconsctl">
wsconsctl(8)</a> command:

<blockquote><pre>
# <b>wsconsctl display.screen_off=60000</b>
display.screen_off -> 60000
</pre></blockquote>

or set them permanently by editing
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wsconsctl.conf">
wsconsctl.conf(5)</a> so these changes take place at next boot:

<blockquote><pre>
display.vblank=on               # enable vertical sync blank
display.screen_off=600000       # set screen blank timeout to 10 minutes
display.kbdact=on               # Restore screen on keyboard input
display.outact=off              # Restore screen on display output
</pre></blockquote>

The blanker is activated when either <tt>display.kbdact</tt> or
<tt>display.outact</tt> is set to <tt>on</tt>.
Yes, one of those two must be <tt>off</tt>.

<h2 id="tmux">7.8 - What is tmux?</h2>

For those familiar with the "screen" program, provided as a package, it may
be easiest to answer this by saying that
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tmux">tmux(1)</a>
performs many of the functions as screen, but with many additional features.

<p>
For those not familiar with these types of programs, tmux is a
<i>terminal multiplexer</i>.
This is a program which allows a number of other processes to share the same
screen for input and output.
In tmux, such a collection of programs is known as a <i>session</i>, with each
program contained in a tmux <i>window</i>.

<p>
In addition to sharing the terminal, tmux lets you detach a session and its
windows from the screen, leave them continue running in the background, and
later reattach them to the same or to a different screen.
A session may be detached manually or through an unexpected event such as
network disconnection.
In either case, the programs survive and continue running as normal.

<p>
tmux also has many other features, such as splitting a single window into
multiple sections (known as <i>panes</i>), a history of text printed in each
window, copying and pasting text between windows, configurable key bindings,
and terminal locking.
Take a look at the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tmux">tmux(1)</a>
man page for further information.

<h3>How do I use tmux?</h3>

The first step is to run tmux:

<blockquote><pre>
$ <b>tmux</b>
</pre></blockquote>

This starts a new tmux with a single new session (called "0") and creates a
client displaying it on screen.
Most of the screen will show a window containing a shell prompt, and you will
notice the last line is occupied by a status line.
This shows the name of the session in square brackets on the left, the window
title (normally empty for shells) and the time on the right, and a summary of
the current open windows in the middle.
In your new session, the currently open windows will contain one entry, for
example:

<blockquote><pre>
0:ksh*
</pre></blockquote>

A brief aside regarding terminals: on OpenBSD, applications are made aware of
the capabilities of the terminal by the TERM environment variable.
This is set to the name of an entry in the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=terminfo">terminfo(5)</a>
database and tells programs that the terminal, for example, supports color,
has the ability to insert lines, or many other things.
An important thing to note is that the "xterm" entry in the database does not
include color, so tmux will not use color in xterm by default, TERM should be
set to "xterm-xfree86" instead if color is desired (the "XTerm*termName"
X resource may be set in <tt>.Xdefaults</tt> to use this for all xterms).
It is also important that <tt>TERM</tt> in shells started inside tmux is set
to "screen" or programs run from them may not display correctly - tmux will
set this itself, but care should be taken not to override it in shell startup
files.

<p>
Returning to the status line, the number "0" is the window index, "ksh" the
name of the window, and the "*" indicates this is the current window displayed
above the status line.
Any typing is passed on to the shell and any output displayed.
For example, if you start
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=top">top(1)</a>,

<blockquote><pre>
$ <b>top</b>
</pre></blockquote>

It will run as normal, occupying the part of the screen above the status line.
You may also notice that the window name in the status line has changed from
"ksh" to "top" - tmux renames windows to reflect the program currently running
in them.

<p>
Now, let's say you want to detach tmux from the screen and return to the
original shell from which you started it.
A tmux session may be detached by first pressing the <i>Ctrl</i> and <i>b</i>
keys together, and then the <i>d</i> key.
The <i>Ctrl-b</i> key combination (shortened in tmux and its man page to "C-b")
is known as the <i>prefix key</i> and is used to tell tmux that the next key
pressed is an instruction that it should perform some action, rather than
passing the key through to the program in the window.

<p>
After pressing <i>Ctrl-b d</i> and returning to the shell prompt, reattach
the tmux session using the "attach" command:

<blockquote><pre>
$ <b>tmux attach</b>
</pre></blockquote>

The tmux session will reappear, with the status line and "top" still happily
running.
If you instead run tmux again without arguments, a second session will be
created, named 1.

<p>
Next, let's create a second window.
This is done using the "c" key: press the prefix key, <i>Ctrl-b</i>, then the
"c" key.
A new window will be created and again a shell prompt displayed on screen.
The status line will be updated to show the new window:

<blockquote><pre>
0:top- 1:ksh*
</pre></blockquote>

The "-" after "top" shows the previously current window (the last window).
Pressing <i>Ctrl-b c</i> again creates another new shell:

<blockquote><pre>
0:top  1:ksh- 2:ksh*
</pre></blockquote>

There are several commands for moving between windows.
From window 2, you can move the previous window, number 1, by typing
<i>Ctrl-b p</i>.
<i>Ctrl-b n</i> moves to the next window: in this case, there is no window
3, so the current window wraps to window 0.
You can also press <i>Ctrl-b w</i> to get an interactive menu of open
windows, <i>Ctrl-b l</i> to move to the last window (the one marked with "-"),
or <i>Ctrl-b 0</i> to move to window 0, <i>Ctrl-b 1</i> for window 1 and so on
up to <i>Ctrl-b 9</i> for window 9.
So, to get back to "top" in window 0, you can press <i>Ctrl-b 0</i> to go
directly to window 0, <i>Ctrl-b p</i> twice to move via window 1, <i>Ctrl-b
n</i> to wrap from window 2 to window 0, or press <i>Ctrl-b w</i> and select
window 0 from the list.

<p>
Sometimes you may want to create a window running a program directly, without
using a shell first.
This can be done from the tmux <i>command prompt</i>.
Pressing the <i>Ctrl-b :</i> key sequence changes the status line to display a
":" prompt at which commands may be entered.
All the tmux commands are documented in the man page.
In this case, the "new-window" command is needed.
Many commands have shorthand aliases which may be used instead of typing the
full name; for "new-window" this is "neww."
So, to create a new window running
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tetris">tetris(6)</a>,
type:

<blockquote><pre>
neww tetris
</pre></blockquote>

The new window will close when tetris exits, or may be forcibly killed using
the <i>Ctrl-b &</i> key binding.
This will first prompt for confirmation and if given, close the window and
terminate the program running in it.

<p>
Another common requirement is renaming a window.
This can be done with the <i>Ctrl-b ,</i> key binding.
The status line will change to display a "(rename-window)" prompt at which the
new name may be entered.
Renaming a window turns off automatic renaming for that window, to reenable
that feature, press <i>Ctrl-b :</i> to get to the command prompt and enter the
following (more on what this means is in the next section):

<blockquote><pre>
setw -u automatic-rename
</pre></blockquote>

One other important key is worth remembering: <i>Ctrl-b ?</i>.
This will show a list of all the tmux keys and the commands they execute.
For example, <i>Ctrl-b ?</i> shows that the <i>c</i> key is bound to the
"new-window" command and the <i>n</i> key to the "next-window" command.

<h3>Configuring tmux</h3>

Many users want to customize the way tmux looks or behaves.
This is done through the configuration file, <tt>~/.tmux.conf</tt>.
This file is a list of tmux commands which are executed when tmux is initially
started, before the first session is created.
All tmux commands are documented in the man page, but a few common examples you
might want to put in your configuration file are discussed below.

<p>
The most common requirement is setting options.
There are two types of option in tmux: <i>session options</i> and
<i>window options</i>.
Session options control the behavior of a session and window options of an
individual window.
For both there is a set of global options.
When tmux comes to decide on an options value for a particular session or
window, it looks first at the options local to that window; if the option has
not been set, the global option value is used.

<p>
Session options are set with the "set-option" (alias "set") command and window
options with the "set-window-option" command (alias "setw").
To set a global option, use the <tt>-g</tt> flag.
If this is left out, the option is set for the current window or session.
These commands also accept a few other flags, such as <tt>-u</tt> to unset
a local option and allow a window or session to inherit the global option again.

<p>
In the configuration file, it is usual to set global options.
Let's look at some examples customizing the status line:

<blockquote><pre>
set -g status-bg blue
set -g status-right '#(sysctl vm.loadavg)'
setw -g window-status-current-attr underscore
</pre></blockquote>

Putting these three commands in <tt>.tmux.conf</tt> and restarting tmux
changes the status line background to blue, puts the current load average
on the right side and underlines the current window.
The status line may be turned off entirely with:

<blockquote><pre>
set -g status off
</pre></blockquote>

There are a large number of other options; another handy one is changing to
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vi">vi(1)</a>-style
key bindings at the command prompt and in the window list and other
tmux interactive modes:

<blockquote><pre>
set -g status-keys vi
setw -g mode-keys vi
</pre></blockquote>

The current options and their values may be listed with the "show-options"
and "show-window-options" commands.
Like the set commands these accept "-g" to show the global options.

<p>
Another common task for the configuration file is adding or modifying tmux
command key bindings, that is the commands that are executed after you press
<i>Ctrl-b</i> with another key.
These are added or changed with the "bind-key" command (alias "bind") and
removed with the "unbind-key" command (alias "unbind").
Two examples of using "bind-key" are:

<blockquote><pre>
bind C-d detach
bind / neww 'exec top'
</pre></blockquote>

The first line creates a binding for <i>Ctrl-b Ctrl-d</i> to detach tmux, the
same as the default <i>Ctrl-b d</i>, and the second binds <i>Ctrl-b /</i> to
create a new window running top.

<p>
Many people like to use a different prefix key than <i>Ctrl-b</i>.
This can be achieved using both the "set-option" and key binding commands to
alter the prefix key option and change so that pressing the prefix twice
continues to pass the same key through to the window.
To change the prefix key to <i>Ctrl-a</i>:

<blockquote><pre>
set -g prefix C-a
unbind C-b
bind C-a send-prefix
</pre></blockquote>

The final useful thing to do in the configuration file is to create an initial
set of windows when tmux starts.
This is slightly more complicated than the previous examples.
In tmux, a session cannot have no windows, and you cannot create windows
without a session.
So, to have windows created by the configuration file you must first create a
session to contain them.
For example (note that "new" is the alias for the "new-session" command):

<blockquote><pre>
new -d 'exec top'
neww -d
neww -d
</pre></blockquote>

These commands create a new session with "top" running in the first window,
then create two additional windows.
The <tt>-d</tt> flags instruct tmux not to try to attach the new session or
to make the new windows the current window.
Before putting these lines into <tt>.tmux.conf</tt>, there is one other issue.
When executed without arguments, tmux runs the "new-session" command, so when
starting tmux with "tmux" from the shell, the configuration file tells tmux to
create one session, then the command from the shell tells it to create another,
so you end up with <i>two</i> sessions.
To avoid this, tmux should be started with "tmux attach" when creating a
session from the configuration file - this means it will create the session
from <tt>.tmux.conf</tt> then immediately attach to it without creating a
second session.

<h3>Advanced tmux usage</h3>

This section briefly covers some of the more advanced features available in
tmux.
See the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tmux">man page</a>
for more information.

<p>
In tmux, you can copy and paste text between windows.
This is done by copying the text in <i>copy mode</i> and then pasting it with
the paste command.
To enter copy mode, press <i>Ctrl-b [</i>.
In copy mode (with the "mode-keys" window option set to emacs, for vi keys see
the man page) the arrow keys may be used to position the
cursor, <i>Ctrl-Space</i> starts the selection and <i>Ctrl-w</i> copies.
You can also use <i>Page Up</i>, <i>Page Down</i>, <i>Ctrl-a</i>
and <i>Ctrl-e</i> to move the cursor around.
Press <i>q</i> or <i>Escape</i> to exit copy mode.
After that, <i>Ctrl-b ]</i> will paste the copied text into the current window
as if you had typed it directly.

<p>
tmux is quite scriptable, and most commands that may be entered from the command
prompt or bound to a key may be executed from the shell.
Almost all tmux commands accept an optional <tt>-t</tt> argument which
specifies the session or window on which to act.
For example, this command:

<blockquote><pre>
$ tmux kill-window -t0:1
</pre></blockquote>

will kill window 1 in session 0.
And:

<blockquote><pre>
$ tmux new-window -tmysession
</pre></blockquote>

creates a new window in the session named "mysession."
Many commands accept other arguments, for example the "new-window" command
accepts a <tt>-n</tt> option to give the name of the new window, and
"new-session" accepts several arguments to specify the attributes of the
initial window created with the session.
These arguments may naturally be used when a command is bound to a key or
executed from the command prompt as well.

<p>
Another useful feature is the ability to split a single window into several
sections, called <i>panes</i>.
You can split a window vertically (top to bottom) with the <i>Ctrl-b
"</i> key combination, and horizontally with the <i>Ctrl-b %</i> combination.
A pane can be resized up or down with <i>Ctrl-b Alt-Up</i> and <i>Ctrl-b
Alt-Down</i> and the active pane changed with <i>Ctrl-b o</i>.
In addition, a window split in that way may be changed into one of a number of
fixed layouts, which may be cycled through with <i>Ctrl-b Space</i>.

<p>
<hr>
<p>
<a href= "index.html">[FAQ Index]</a>
<a href= "faq6.html">[To Section 6 - Networking]</a>
<a href= "faq8.html">[To Section 8 - General Questions]</a>
</body>
</html>
