<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>PF: Filtragem de Pacotes</title>
<link rev="made" href="mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="resource-type" content="document">
<meta name="description" content="the OpenBSD FAQ page">
<meta name="keywords" content="openbsd,faq,pf">
<meta name="distribution" content="global">
</head>

<!--
Copyright (c) 2003, 2004 Joel Knight <enabled@myrealbox.com>

Permission to use, copy, modify, and distribute this documentation for
any purpose with or without fee is hereby granted, provided that the
above copyright notice and this permission notice appear in all copies.

THE DOCUMENTATION IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
WARRANTIES WITH REGARD TO THIS DOCUMENTATION INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS DOCUMENTATION
-->


<body bgcolor="#ffffff" text="#000000">
<!-- Passes validator.w3.org, please keep it this way;
please, use a max of 72 chars per line -->

<a href="../../../pt/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../../images/smalltitle.gif" border="0">
</a>
<p>
[<a href="tables.html">Anterior: Tabelas</a>]
[<a href="index.html">Conte&uacute;do</a>]
[<a href="nat.html">Pr&oacute;ximo: Tradu&ccedil;&atilde;o do Endere&ccedil;o de Rede (NAT)</a>]

<h1><font color="#e00000">PF: Filtragem de Pacotes</font></h1>

<hr>

<h3>Conte&uacute;do</h3>
<ul>
<li><a href="#intro">Introdu&ccedil;&atilde;o</a>
<li><a href="#syntax">Sintaxe das Regras</a>
<li><a href="#defdeny">Negar por Padr&atilde;o</a>
<li><a href="#pass">Passando Tr&aacute;fego</a>
<li><a href="#quick">A Palavra-Chave <tt>quick</tt></a>
<li><a href="#state">Mantendo o Estado</a>
<li><a href="#udpstate">Mantendo o Estado para UDP</a>
<li><a href="#tcpflags">Flags TCP</a>
<li><a href="#synproxy">TCP SYN Proxy</a>
<li><a href="#antispoof">Bloqueando Pacotes Spoofados</a>
<li><a href="#osfp">Detec&ccedil;&atilde;o Passiva de Sistema Operacional</a>
<li><a href="#ipopts">Op&ccedil;&otilde;es IP</a>
<li><a href="#example">Exemplo de Arquivo de Regras</a>
</ul>

<hr>

<a name="intro"></a>
<h2>Introdu&ccedil;&atilde;o</h2>
Filtragem de pacotes &eacute; o bloqueio ou libera&ccedil;&atilde;o da passagem 
de pacotes de dados de maneira seletiva, conforme eles atravessam 
a interface de rede. O crit&eacute;rio usado pelo 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf&amp;sektion=4&amp;manpath=OpenBSD+3.6"
>pf(4)</a> ao inspecionar pacotes &eacute; baseado nos cabe&ccedil;alhos da Camada 3 
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4&amp;manpath=OpenBSD+3.6"
>IPv4</a> e 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip6&amp;sektion=4&amp;manpath=OpenBSD+3.6"
>IPv6</a>) e Camada 4
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcp&amp;sektion=4&amp;manpath=OpenBSD+3.6"
>TCP</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=udp&amp;sektion=4&amp;manpath=OpenBSD+3.6"
>UDP</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp&amp;sektion=4&amp;manpath=OpenBSD+3.6"
>ICMP</a>, e
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp6&amp;sektion=4&amp;manpath=OpenBSD+3.6"
>ICMPv6</a>). Os crit&eacute;rios mais usados s&atilde;o endere&ccedil;o de origem e destino, 
porta de origem e destino e protocolo.

<p>
Regras de filtragem especificam o crit&eacute;rio em que o pacote deve se 
enquadrar e a a&ccedil;&atilde;o resultante, que pode ser bloqueio ou libera&ccedil;&atilde;o, 
tomada quando o pacote casa com a regra. As regras de filtragem 
s&atilde;o avaliadas em sequ&ecirc;ncia da primeira a &uacute;ltima.
A n&atilde;o ser que o pacote encontre um regra contendo a palavra-chave 
<tt>quick</tt>, o mesmo ser&aacute; avaliado contra <i>todas</i> as regras de
filtragem antes da a&ccedil;&atilde;o final ser tomada. A &uacute;ltima regra a casar &eacute; a 
"vencedora" e dita qual a&ccedil;&atilde;o tomar. Existe um 
<tt>pass all</tt> impl&iacute;cito no in&iacute;cio das regras de 
filtragem, que significa que caso o pacote n&atilde;o case com nenhuma regra 
a a&ccedil;&atilde;o resultante ser&aacute; <tt>pass</tt>.

<a name="syntax"></a>
<h2>Sintaxe das Regras</h2>
A forma geral <i>simplificada</i> da sintaxe para regras de filtragem &eacute;:
<blockquote>
<tt>
<i>a&ccedil;&atilde;o</i> [<i>dire&ccedil;&atilde;o</i>] [log] [quick] [on <i>interface</i>]
[<i>af</i>] [proto <i>protocolo</i>] \<br>
&nbsp;&nbsp;&nbsp;[from <i>src_addr</i> [port <i>src_port</i>]] [to 
<i>dst_addr</i> [port <i>dst_port</i>]] \<br>
&nbsp;&nbsp;&nbsp;[flags <i>tcp_flags</i>] [<i>state</i>]
</tt>
</blockquote>

<dl>
<dt><tt><i>a&ccedil;&atilde;o</i></tt>
<dd>A a&ccedil;&atilde;o executada em pacotes que combinem com a regra, pode ser
<tt>pass</tt> ou <tt>block</tt>. A a&ccedil;&atilde;o <tt>pass</tt> libera a passagem do 
pacote para processamento posterior pelo kernel, enquanto que a a&ccedil;&atilde;o 
<tt>block</tt> reagir&aacute; com base na op&ccedil;&atilde;o
<a href="options.html#block-policy"><tt>block-policy</tt></a>. 
A rea&ccedil;&atilde;o padr&atilde;o pode ser sobrescrita especificando 
<tt>block drop</tt> ou <tt>block return</tt> na regra.

<dt><tt><i>dire&ccedil;&atilde;o</i></tt>
<dd>A dire&ccedil;&atilde;o em que o pacote est&aacute; se movendo na interface, pode ser 
<tt>in</tt> ou <tt>out</tt>.

<dt><tt>log</tt>
<dd>Especifica que o pacote deve ser logado via
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+3.6"
>pflogd(8)</a>. Caso a regra especifique as op&ccedil;&otilde;es <tt>keep state</tt>,
<tt>modulate state</tt> ou <tt>synproxy state</tt> somente o pacote que estabelece 
a conex&atilde;o &eacute; logado.
Para logar todos pacotes, use <tt>log-all</tt>.

<dt><tt>quick</tt>
<dd>Se um pacote casar com uma regra que especifique a palavra <tt>quick</tt>,
esta regra &eacute; considerada final e a <tt><i>a&ccedil;&atilde;o</i></tt> especificada 
&eacute; executada.

<dt><tt><i>interface</i></tt>
<dd>O nome ou grupo da interface de rede onde o pacote passa.
Um grupo de interface &eacute; especificado com o nome da interface mas sem o 
n&uacute;mero no final.
Por exemplo: <tt>ppp</tt> ou <tt>fxp</tt>.
Far&aacute; com que a regra case com qualquer pacote atravessando qualquer 
interface <tt>ppp</tt> ou <tt>fxp</tt> respectivamente. 

<dt><tt><i>af</i></tt>
<dd>A fam&iacute;lia de endere&ccedil;os a que o pacote pertence, <tt>inet</tt> 
para IPv4 ou <tt>inet6</tt> para IPv6. Geralmente o PF pode determinar essa 
informa&ccedil;&atilde;o com base no endere&ccedil;o(os) de origem e/ou destino do pacote.

<dt><tt><i>protocolo</i></tt>
<dd>O protocolo de Camada 4 do pacote:
<ul>
<li><tt>tcp</tt>
<li><tt>udp</tt>
<li><tt>icmp</tt>
<li><tt>icmp6</tt>
<li>Um nome de protocolo v&aacute;lido em 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=protocols&amp;sektion=5&amp;manpath=OpenBSD+3.6"><tt>/etc/protocols</tt></a>
<li>Um n&uacute;mero de protocolo entre 0 e 255
<li>Um grupo de protocolos utilizando uma <a href="macros.html#lists">lista</a>.
</ul>

<dt><tt><i>src_addr</i></tt>, <tt><i>dst_addr</i></tt> 
<dd>Os endere&ccedil;os de origem/destino no cabe&ccedil;alho do IP. Endere&ccedil;os podem ser 
especificados como:
<ul>
<li>Endere&ccedil;o IPv4 ou IPv6 simples.
<li>Um bloco de rede <a href="http://public.pacbell.net/dedicated/cidr.html">CIDR</a>.
<li>Nome de dom&iacute;nio totalmente qualificado, que ser&aacute; resolvido pelo DNS 
quando as regras forem carregadas. Todos endere&ccedil;os IP resultantes ser&atilde;o 
substituidos na regra.
<li>O nome de uma interface de rede. Quaisquer endere&ccedil;os IP na interface 
substituir&atilde;o a regra.
<li>O nome de uma interface de rede seguido por uma 
<tt>/<i>m&aacute;scara</i></tt> (ex., <tt>/24</tt>). Cada endere&ccedil;o IP na interface 
&eacute; combinado com a m&aacute;scara para formar um bloco de rede CIDR que ser&aacute; 
substituido na regra.
<li>O nome de uma interface de rede entre parenteses <tt>( )</tt>. Isto
informa ao PF para atualizar a regra caso o endere&ccedil;o(os) da interface sofra 
altera&ccedil;&atilde;o. &Uacute;til em interfaces que obt&eacute;m seu endere&ccedil;o IP 
via DHCP ou dial-up, pois as outras regras n&atilde;o precisar&atilde;o ser recarregadas toda 
vez que o endere&ccedil;o mudar.
<li>O nome de uma interface de rede seguido por algum dos modificadores:
  <ul>
  <li><tt>:network</tt> - substitui o bloco de rede CIDR (ex.,
  192.168.0.0/24)
  <li><tt>:broadcast</tt> - substitui o endere&ccedil;o de broadcast
  (ex., 192.168.0.255)
  <li><tt>:peer</tt> - substitui o endere&ccedil;o da outra ponta num link 
  ponto-a-ponto 
  </ul>
  <dl>
  <dd>Al&eacute;m disso, o modificador <tt>:0</tt> pode ser adicionado a um nome 
  de interface ou qualquer um dos modificadores acima para indicar ao PF 
  para n&atilde;o incluir endere&ccedil;os IP de aliases na substitui&ccedil;&atilde;o.
  Estes modificadores tamb&eacute;m podem ser usados quando o nome da interface 
  est&aacute; entre par&ecirc;nteses.
  Exemplo: <tt>fxp0:network:0</tt>
  </dl>
<li>Uma <a href="tables.html">tabela</a>.
<li>Qualquer dos apresentados acima, negado usando o modificador <tt>!</tt> ("not") .
<li>Um grupo de endere&ccedil;os usando-se uma <a href="macros.html#lists">lista</a>.
<li>A palavra-chave <tt>any</tt> indicando todos os endere&ccedil;os
<li>A palavra-chave <tt>all</tt> que &eacute; um atalho para <tt>from any to
any</tt>.
</ul>

<dt><tt><i>src_port</i></tt>, <tt><i>dst_port</i></tt>
<dd>A porta de origem/destino no cabe&ccedil;alho da Camada 4 do pacote. Portas 
podem ser especificadas da seguinte forma:
<ul>
<li>Um n&uacute;mero entre 1 e 65535
<li>Nome de servi&ccedil;o v&aacute;lido em 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=services&amp;sektion=5&amp;manpath=OpenBSD+3.6"><tt>/etc/services</tt></a>
<li>Lista de portas usando uma <a href="macros.html#lists">lista</a>
<li>Uma faixa:
	<ul>
	<li><tt>!=</tt> (diferente)
	<li><tt>&lt;</tt> (menor que)
	<li><tt>&gt;</tt> (maior que)
	<li><tt>&lt;=</tt> (menor ou igual a)
	<li><tt>&gt;=</tt> (maior ou igual a)
	<li><tt>&gt;&lt;</tt> (faixa)
	<li><tt>&lt;&gt;</tt> (faixa inversa)
	<dl>
	<dd>Os dois &uacute;ltimo s&atilde;o operadores bin&aacute;rios (recebem dois argumentos) 
	e n&atilde;o incluem os argumentos na faixa.
	</dl>
	<li><tt>:</tt> (faixa inclusiva)
	<dl>
	<dd>O operador de faixa inclusiva tamb&eacute;m &eacute; um operador bin&aacute;rio
	e inclui os argumentos na faixa.
	</dl>
	</ul>
</ul>

<dt><tt><i>tcp_flags</i></tt>
<dd>Especifica os flags que devem estar setados no cabe&ccedil;alho 
TCP quando for usado <tt>proto tcp</tt>. Flags s&atilde;o especificados na forma: 
<tt>flags <i>check</i>/<i>mask</i></tt>. Por exemplo: <tt>flags
S/SA</tt> - instrui o PF a verificar somente os flags S e A (SYN e ACK)
e casar, se apenas o flag SYN estiver "setado".

<dt><tt><i>state</i></tt>
<dd>Especifica se a informa&ccedil;&atilde;o de estado deve ser mantida em pacotes 
que casem com a regra.
<ul>
<li><tt>keep state</tt> - funciona com TCP, UDP, e ICMP.
<li><tt>modulate state</tt> - funciona apenas com TCP. PF ir&aacute; gerar 
N&uacute;meros de Sequ&ecirc;ncia Inicial (ISNs) seguros para pacotes que combinem 
com esta regra.
<li><tt>synproxy state</tt> - faz proxy de pedidos de conex&atilde;o TCP 
para ajudar a proteger servidores contra floods de pacotes SYN TCP 
spoofados.
Essa op&ccedil;&atilde;o inclui a funcionalidade <tt>keep state</tt> e
<tt>modulate state</tt>.
</ul>
</dl>

<a name="defdeny"></a>
<h2>Negar por Padr&atilde;o</h2>
A pr&aacute;tica recomendada ao configurar um firewall &eacute; usar uma pol&iacute;tica
"negar por padr&atilde;o". Isto &eacute;, bloquear <i>tudo</i>, e depois ir permitindo 
certos tipos de tr&aacute;fego atrav&eacute;s do firewall. Esta &eacute; a abordagem 
recomendada por ser mais cautelosa, al&eacute;m de facilitar a configura&ccedil;&atilde;o
das regras.

<p>
Para criar uma pol&iacute;tica de filtragem negar por padr&atilde;o, as primeiras duas regras de 
filtragem devem ser:
<blockquote>
<tt>
block in &nbsp;all<br>
block out all
</tt>
</blockquote>

<p>
Isto ir&aacute; bloquear todo o tr&aacute;fego em todas interfaces em qualquer 
dire&ccedil;&atilde;o, de qualquer lugar para qualquer lugar.

<a name="pass"></a>
</p><h2>Passando Tr&aacute;fego</h2>
O tr&aacute;fego agora deve ser explicitamente permitido ou ser&aacute; barrado pela
pol&iacute;tica padr&atilde;o do firewall. &Eacute; aqui que os crit&eacute;rios de 
filtragem como porta de origem/destino, endere&ccedil;o de origem/destino e protocolo entram 
em cena. Sempre que o tr&aacute;fego tiver permiss&atilde;o de cruzar o firewall as 
regras devem ser escritas da maneira mais restritiva poss&iacute;vel. Isso &eacute; 
para nos certificarmos de que o tr&aacute;fego v&aacute;lido, e, somente tr&aacute;fego 
v&aacute;lido ter&aacute; permiss&atilde;o de passagem.

<p>
Alguns exemplos:
<blockquote>
<tt>
# Autoriza passagem de tr&aacute;fego chegando em dc0 vindo da rede local 192.168.0.0/24,<br>
# e indo para a m&aacute;quina OpenBSD com endere&ccedil;o IP 192.168.0.1. Tamb&eacute;m permite<br>
# tr&aacute;fego de retorno saindo via dc0.<br>
pass in &nbsp;on dc0 from 192.168.0.0/24 to 192.168.0.1<br>
pass out on dc0 from 192.168.0.1 to 192.168.0.0/24<br>
<br>
<br>
# Permite tr&aacute;fego TCP chegando em fxp0 e indo para o servidor web<br>
# rodando na m&aacute;quina OpenBSD. O nome da interface, fxp0, &eacute; usado como<br>
# endere&ccedil;o de destino, para que apenas pacotes destinados &agrave;<br>
# m&aacute;quina OpenBSD casem com a regra.<br>
pass in on fxp0 proto tcp from any to fxp0 port www
</tt>
</blockquote>

<a name="quick"></a>
<h2>A palavra-chave <tt>quick</tt></h2>
Como dito anteriormente, cada pacote &eacute; avaliado contra as regras de 
filtragem de cima para baixo.  Por padr&atilde;o, o pacote &eacute; marcado para passagem, 
o que pode ser alterado por qualquer regra, e depois alterado novamente 
v&aacute;rias vezes antes do fim das regras de filtragem. <b>A &uacute;ltima regra que casa 
"vence".</b>  Mas, h&aacute; uma excess&atilde;o &agrave; regra: A op&ccedil;&atilde;o 
<tt>quick</tt> numa regra de filtragem tem o efeito de cancelar o processamento de qualquer 
outra regra que venha em seguida e executa imediatamente a a&ccedil;&atilde;o especificada. 
Vejamos alguns exemplos:

<p>
Errado:
<blockquote>
<tt>
block in on fxp0 proto tcp from any to any port ssh<br>
pass &nbsp;in all
</tt>
</blockquote>

<p>
Neste caso, a linha <tt>block</tt> ser&aacute; avaliada, mas jamais ter&aacute; efeito 
algum, pois &eacute; seguida de uma linha que permite a passagem de tudo.

<p>
Melhor:
<blockquote>
<tt>
block in quick on fxp0 proto tcp from any to any port ssh<br>
pass &nbsp;in all
</tt>
</blockquote>

<p>
Essas regras s&atilde;o avaliadas de maneira ligeiramente diferente. 
Caso a linha <tt>block</tt> case com a regra, devido o uso da op&ccedil;&atilde;o
<tt>quick</tt>, o pacote ser&aacute; bloqueado, e o restante das regras ser&atilde;o 
ignoradas.

<a name="state"></a>
<h2>Mantendo o Estado</h2>
Uma das caracter&iacute;sticas importantes do Packet Filter &eacute;  
"manter o estado das conex&otilde;es", ou "stateful inspection". Stateful
inspection &eacute; a habilidate do PF em registrar o estado, ou progresso de uma 
conex&atilde;o de rede. Armazenando informa&ccedil;&otilde;es sobre o estado de cada 
conex&atilde;o numa tabela, o PF pode rapidamente determinar se um pacote 
passando pelo firewall pertence a uma conex&atilde;o j&aacute; estabelecida. Caso 
afirmativo, ele passa direto pelo firewall sem ser avaliado pelas 
regras.

<p>
Manter informa&ccedil;&otilde;es de estado das conex&otilde;es traz muitas vantagens incluindo 
simplicidade na configura&ccedil;&atilde;o das regras e melhor performance na filtragem 
de pacotes. O PF pode criar entradas na tabela de estado para pacotes 
indo em <i>qualquer</i> dire&ccedil;&atilde;o, o que significa que regras de filtragem 
que autorizam o tr&aacute;fego de retorno n&atilde;o precisam ser escritas. E, como 
pacotes que possuem entradas na tabela de estado n&atilde;o s&atilde;o avaliados pelas 
regras, o tempo que o PF gasta no processamento destes pode ser drasticamente 
reduzido.

<p>
Quando uma regra possui a op&ccedil;&atilde;o <tt>keep state</tt>, o primeiro pacote 
que casa com a regra cria um "estado" entre transmissor e receptor.
Agora, n&atilde;o somente os pacotes do transmissor para o receptor combinam 
com a entrada na tabela e passam direto pelas regras, como tamb&eacute;m as 
respostas do receptor. Por exemplo:
<blockquote>
<tt>
pass out on fxp0 proto tcp from any to any keep state
</tt>
</blockquote>

<p>
Isto permite qualquer tr&aacute;fego TCP saindo pela interface <tt>fxp0</tt>, bem 
como o tr&aacute;fego retornando em resposta ao firewall. Al&eacute;m do recurso 
de manuten&ccedil;&atilde;o de estado ser uma excelente caracter&iacute;stica, seu uso ainda
melhora a performance do firewall, pois pesquisas na tabela de estado 
s&atilde;o muito mais r&aacute;pidas do que comparar o pacote contra todas as regras
de filtragem.

<p>
A op&ccedil;&atilde;o <tt>modulate state</tt> funciona como a <tt>keep state</tt>
exceto que ela se aplica apenas a pacotes TCP. Com <tt>modulate state</tt>,
o N&uacute;mero de Sequ&ecirc;ncia Inicial (ISN) de conex&otilde;es saindo do 
firewall &eacute; aleat&oacute;rio. Isso &eacute; &uacute;til para proteger 
conex&otilde;es iniciadas por certos sistemas operacionais que n&atilde;o fazem 
um bom trabalho ao escolher ISNs.
Desde o OpenBSD 3.5, a op&ccedil;&atilde;o <tt>modulate state</tt> pode ser usada 
tamb&eacute;m em regras que especifiquem protocolos diferentes do TCP.

<p>
Mantendo estado em pacotes TCP, UDP e ICMP e modulanto ISNs TCP:
<blockquote>
<tt>
pass out on fxp0 proto { tcp, udp, icmp } from any \<br>
&nbsp;&nbsp;&nbsp;&nbsp;to any modulate state<br>
</tt>
</blockquote>

<p>
Outra vantagem de manter o estado &eacute; que o tr&aacute;fego ICMP correspondente 
tamb&eacute;m passa pelo firewall. Por exemplo, se for especificado 
<tt>keep state</tt> para uma conex&atilde;o TCP e chegar uma mensagem ICMP source-quench
referenciando esta conex&atilde;o, ela ser&aacute; identificada como pertencendo a 
uma entrada v&aacute;lida na tabela de estado e passar&aacute; direto pelo firewall.

<p>
O escopo de uma entrada na tabela de estado &eacute; controlado globalmente 
pela op&ccedil;&atilde;o <a href="options.html#state-policy"><tt>state-policy</tt></a>
em tempo de execu&ccedil;&atilde;o, e com base nas regras de estado pelas palavras-chave 
<tt>if-bound</tt>, <tt>group-bound</tt> e <tt>floating</tt>.
Essas palavras-chave usadas nas regras tem o mesmo efeito de  
quando s&atilde;o usadas na op&ccedil;&atilde;o <tt>state-policy</tt>. Exemplo:

</p><blockquote>
<tt>
pass out on fxp0 proto { tcp, udp, icmp } from any \<br>
&nbsp;&nbsp;&nbsp;&nbsp;to any modulate state (if-bound)<br>
</tt>
</blockquote>

<p>
Essa regra define que para um pacote casar com a entrada na tabela de 
estado, ele deve estar transitando na interface <tt>fxp0</tt>.


<p>
Perceba que para regras 
<a href="nat.html"><tt>nat</tt></a>, 
<a href="nat.html#binat"><tt>binat</tt></a> e
<a href="rdr.html"><tt>rdr</tt></a> &eacute; impl&iacute;cita 
a cria&ccedil;&atilde;o de estados para conex&otilde;es v&aacute;lidas desde que os 
pacotes passem pelas regras de filtragem.

<a name="udpstate"></a>
<h2>Mantendo Estado Para UDP</h2>
Algumas vezes voc&ecirc; pode ouvir que, "N&atilde;o se pode criar estados para 
conex&otilde;es UDP, pelo fato do UDP ser um protocolo que n&atilde;o mant&eacute;m o 
estado nas conex&otilde;es!". Enquanto &eacute; verdade que uma sess&atilde;o de 
comunica&ccedil;&atilde;o UDP n&atilde;o possui nenhum conceito de estado (um in&iacute;cio e fim 
expl&iacute;cito na comunica&ccedil;&atilde;o), isso n&atilde;o causa nenhum impacto na habilidade 
do PF em criar estados para sess&otilde;es UDP.  No caso de protocolos sem 
pacotes de "in&iacute;cio" e "fim", o PF simplesmente mant&eacute;m um registro do 
tempo desde a &uacute;ltima ocorr&ecirc;ncia de um pacote para dada conex&atilde;o.  Caso 
o tempo de espera seja atingido, o registro de estado &eacute; eliminado. 
Valores para esse intervalo podem ser definidos n&atilde;o se&ccedil;&atilde;o
<a href="options.html">op&ccedil;&otilde;es</a> do arquivo <tt>pf.conf</tt> .

<a name="tcpflags"></a>
<h2>Flags TCP</h2>
Comparar pacotes TCP com base em seus flags &eacute; geralmente usado na 
filtragem de pacotes tentando abrir novas conex&otilde;es. Os flags TCP e 
seu significado s&atilde;o listados aqui:
<ul>
<li><b>F</b> : FIN  - Finish (Final); t&eacute;rmino da sess&atilde;o
<li><b>S</b> : SYN  - Synchronize; indica requisi&ccedil;&atilde;o de conex&atilde;o
<li><b>R</b> : RST  - Reset; derruba uma conex&atilde;o
<li><b>P</b> : PUSH - Push; o pacote &eacute; enviado imediatamente
<li><b>A</b> : ACK  - Acknowledgement (Reconhecimento)
<li><b>U</b> : URG  - Urgent (Urgente)
<li><b>E</b> : ECE  - Explicit Congestion Notification Echo (Mensagem de Notifica&ccedil;&atilde;o 
de Congestionamento Expl&iacute;cita)
<li><b>W</b> : CWR  - Congestion Window Reduced (Janela de Congestionamento Reduzida)
</ul>

<p>
Para que o PF inspecione os flags TCP durante a avalia&ccedil;&atilde;o de uma regra, 
a palavra-chave <tt>flags</tt> &eacute; usada com a seguinte sintaxe:
<blockquote>
<tt>
flags <i>check</i>/<i>mask</i>
</tt>
</blockquote>

<p>
A parte <tt><i>mask</i></tt> diz ao PF para verificar apenas os flags indicados
e a parte <tt><i>check</i></tt> informa quais flag(s) devem estar "setados" no 
cabe&ccedil;alho para que o pacote case com a regra.
</p><blockquote>
<tt>
pass in on fxp0 proto tcp from any to any port ssh flags S/SA
</tt>
</blockquote>

<p>
A regra acima autoriza tr&aacute;fego TCP com o flag SYN setado, mas verifica 
somente os flags SYN e ACK. Um pacote com os flags SYN e ECE combinam 
com a regra acima, enquanto um pacote com SYN e ACK ou somente ACK n&atilde;o 
combina.

<p>
Nota: em vers&otilde;es anteriores do OpenBSD, a sintaxe a seguir era suportada:
</p><blockquote>
<tt>
. . . flags S
</tt>
</blockquote>

<p>
Isso n&atilde;o se aplica mais. Agora uma m&aacute;scara <i>sempre</i> deve ser especificada.

<p>
Geralmente os flags s&atilde;o usados em conjunto com regras <tt>keep state</tt> 
para ajudar a controlar a cria&ccedil;&atilde;o de entradas na tabela de estado:
<blockquote>
<tt>
pass out on fxp0 proto tcp all flags S/SA keep state
</tt>
</blockquote>

<p>
Isso permitir&aacute; a cria&ccedil;&atilde;o de estado para todos pacotes TCP saindo 
com o flag SYN setado, na verifica&ccedil;&atilde;o dos flags SYN e ACK.

<p>
Deve-se tomar cuidado ao usar flags -- entenda o que voc&ecirc; est&aacute; fazendo e o 
porqu&ecirc;, e tenha cuidado com conselhos dados pelos outros, pois grande 
parte deles &eacute; incorreto.  Algumas pessoas sugerem a cria&ccedil;&atilde;o de estado
"somente se o flag SYN estiver setado e nenhum outro". Esta regra deve 
ficar asssim:
<pre>     
     . . . flags S/FSRPAUEW  <i>m&aacute; id&eacute;ia!!</i>
</pre>

<p>
A  teoria &eacute;, crie estado apenas no in&iacute;cio da sess&atilde;o TCP, e a 
sess&atilde;o deve ser iniciada somente com um flag SYN, nada mais.  O problema &eacute; que 
alguns sites est&atilde;o come&ccedil;ando a usar o flag ECN e qualquer um que use 
ECN e tente se conectar ao seu servidor ter&aacute; os pacotes rejeitados por 
esta regra. Uma abordagem muito melhor seria:
<blockquote>
<tt>
. . . flags S/SAFR
</tt>
</blockquote>

<p>
Al&eacute;m de ser pr&aacute;tico e seguro, tamb&eacute;m n&atilde;o &eacute; necess&aacute;rio 
verificar os flags FIN e RST caso o tr&aacute;fego passe antes por regras 
<a href="scrub.html">scrub</a>. No processo de normaliza&ccedil;&atilde;o o PF descartar&aacute; 
quaisquer pacotes que cheguem com combina&ccedil;&otilde;es de flags TCP 
inv&aacute;lidas (como SYN e FIN ou SYN e RST).
&Eacute; sempre recomendado o uso de 
<tt>scrub</tt> para tr&aacute;fego entrante:
<blockquote>
<tt>
scrub in on fxp0<br>
.<br>
.<br>
.<br>
pass in on fxp0 proto tcp from any to any port ssh flags S/SA \<br>
&nbsp;&nbsp;&nbsp;keep state
</tt>
</blockquote>

<a name="synproxy"></a>
<h2>TCP SYN Proxy</h2>
<p>
Normalmente quando um cliente inicia uma conex&atilde;o TCP com o servidor, 
o PF transfere os pacotes do 
<a href="http://www.inetdaemon.com/tutorials/internet/tcp/connections.html">handshake</a>
da forma como eles vieram. O PF, por&eacute;m possui a habilidade de fazer proxy no handshake.
Com o uso de proxy no handshake, o pr&oacute;prio PF completar&aacute; o handshake 
com o cliente, iniciar&aacute; um handshake com o servidor, e ent&atilde;o 
transferir&aacute; pacotes entre os dois.
O benef&iacute;cio deste procedimento &eacute; que nenhum pacote &eacute; enviado ao servidor 
antes do cliente completar o handshake. 
Isso evita que ataques TCP SYN flood spoofados atinjam o servidor 
porque uma conex&atilde;o spoofada n&atilde;o conseguir&aacute; completar o handshake. 

<p>
O TCP SYN proxy &eacute; habilitado usando as palavras-chave 
<tt>synproxy state</tt> em regras de filtragem. Exemplo:

<blockquote>
<tt>
pass in on $ext_if proto tcp from any to $web_server port www \<br>
&nbsp;&nbsp;&nbsp;flags S/SA synproxy state
</tt>
</blockquote>

<p>
Aqui, as conex&otilde;es para o servidor web passar&atilde;o pelo proxy do PF.

<p>
Pela forma como o <tt>synproxy state</tt> funciona, ele tamb&eacute;m inclui as 
mesmas funcionalidades de <tt>keep state</tt> e <tt>modulate state</tt>.

<p>
O SYN proxy n&atilde;o funcionar&aacute; caso o PF esteja atuando numa 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4&amp;manpath=OpenBSD+3.6"
>bridge(4)</a>.

<a name="antispoof"></a>
<h2>Bloqueando Pacotes Spoofados</h2>
"Spoofing" &eacute; quando um usu&aacute;rio malicioso falsifica o endere&ccedil;o IP de origem 
nos pacotes transmitidos por ele para esconder seu endere&ccedil;o real ou
personificar outro n&oacute; na rede. Uma vez que o usu&aacute;rio tenha spoofado seu 
endere&ccedil;o ele pode lan&ccedil;ar um ataque na rede sem que sua verdadeira origem seja 
descoberta, ou ainda tentar ganhar acesso a servi&ccedil;os restritos a determinados
endere&ccedil;os IP.

<p>
O PF oferece alguma prote&ccedil;&atilde;o contra spoofing atrav&eacute;s do uso da palavra-chave
<tt>antispoof</tt>:

<blockquote>
<tt>
antispoof [log] [quick] for <i>interface</i> [<i>af</i>]
</tt>
</blockquote>

<dl>
<dt><tt>log</tt>
<dd>Especifica que, pacotes combinando com a regra devem ser logados via
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+3.6"
>pflogd(8)</a>.

<dt><tt>quick</tt>
<dd>Caso um pacote case com a regra ela ser&aacute; considerada a regra 
"vencedora" e a avalia&ccedil;&atilde;o das regras terminar&aacute;. 

<dt><tt><i>interface</i></tt>
<dd>A interface de rede onde ativar a prote&ccedil;&atilde;o antispoof. Pode ser
tamb&eacute;m uma <a href="macros.html#lists">lista</a> de interfaces.

<dt><tt><i>af</i></tt>
<dd>A fam&iacute;lia de endere&ccedil;amento onde se deve ativar a prote&ccedil;&atilde;o 
antispoof, <tt>inet</tt> para IPv4 ou <tt>inet6</tt> para IPv6.
</dl>

<p>
Exemplo:
<blockquote>
<tt>
antispoof for fxp0 inet
</tt>
</blockquote>

<p>
Quando as regras s&atilde;o carregadas, quaisquer ocorr&ecirc;ncias da palavra 
<tt>antispoof</tt> s&atilde;o expandidas em duas regras de filtragem. Assumindo que 
a interface <tt>fxp0</tt> possui endere&ccedil;o IP 10.0.0.1 e m&aacute;scara de rede 
255.255.255.0 (ex. /24), a regra <tt>antispoof</tt> acima ser&aacute; expandida para:

<blockquote>
<tt>
block in on ! fxp0 inet from 10.0.0.0/24 to any<br>
block in inet from 10.0.0.1 to any
</tt>
</blockquote>

<p>
Estas regras fazem duas coisas:
<ul>
<li>Bloqueia todo tr&aacute;fego vindo da rede 10.0.0.0/24 que <i>n&atilde;o</i> venha
por <tt>fxp0</tt>. Como a rede 10.0.0.0/24 est&aacute; na interface <tt>fxp0</tt>, 
pacotes com endere&ccedil;o de origem neste bloco de rede jamais devem ser vistos 
em qualquer outra interface.
<li>Bloqueia todo tr&aacute;fego vindo de 10.0.0.1, o endere&ccedil;o IP 
em <tt>fxp0</tt>.
A m&aacute;quina nunca deve enviar pacotes para ela mesma pela interface externa, 
portanto qualquer pacote chegando com endere&ccedil;o de origem da pr&oacute;pria 
m&aacute;quina deve ser considerado malicioso.
</ul>

<p>
<b>NOTA</b>: As regras de filtragem <tt>antispoof</tt> expandidas 
tamb&eacute;m ir&atilde;o bloquear pacotes enviados pela interface de loopback para 
o endere&ccedil;o local. Esses endere&ccedil;os devem ser permitidos explicitamente.
Exemplo:
<blockquote>
<tt>
pass quick on lo0 all<br>
<br>
antispoof for fxp0 inet
</tt>
</blockquote>

<p>
O uso de <tt>antispoof</tt> deve ser restrito a interfaces que possuam
endere&ccedil;o IP. Usar <tt>antispoof</tt> numa interface sem um endere&ccedil;o IP 
resultar&aacute; em regras como:
<blockquote>
<tt>
block drop in on ! fxp0 inet all<br>
block drop in inet all
</tt>
</blockquote>

<p>
Nestas regras existe o risco de se bloquear <i>todo</i> tr&aacute;fego entrante 
em <i>todas</i> as interfaces.

<a name="osfp"></a>
<h2>Detec&ccedil;&atilde;o Passiva de Sistema Operacional</h2>

<p>
Passive OS Fingerprinting (OSFP) &eacute; um m&eacute;todo para identificar de maneira 
passiva o sistema operacional de um host remoto com base em certas 
caracter&iacute;sticas dos pacotes TCP SYN gerados pelo host.
Esta informa&ccedil;&atilde;o pode ent&atilde;o ser usada como crit&eacute;rio em regras de 
filtragem.

<p>
O PF determina o sistema operacional remoto comparando as caracter&iacute;sticas 
do pacote TCP SYN contra um 
<a href="options.html#fingerprints">arquivo de impress&otilde;es digitais</a>, que por 
padr&atilde;o &eacute; 
<a 
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.os&amp;sektion=5&amp;manpath=OpenBSD+3.6"
><tt>/etc/pf.os</tt></a>. 
Quando o PF est&aacute; habilitado, a lista atual de impress&otilde;es digitais pode ser vista 
com o comando:

<blockquote>
<tt>
# pfctl -s osfp
</tt>
</blockquote>

<p>
Numa regra de filtragem, a impress&atilde;o digital pode ser especificada 
pela classe do SO, vers&atilde;o ou subtipo/revis&atilde;o.
Cada um dos itens &eacute; listado como sa&iacute;da do comando <tt>pfctl</tt> 
mostrado acima. Para especificar uma impress&atilde;o digital numa regra 
de filtragem, a palavra-chave <tt>os</tt> deve ser usada.

<blockquote>
<tt>
pass &nbsp;in on $ext_if any os OpenBSD keep state<br>
block in on $ext_if any os "Windows 2000"<br>
block in on $ext_if any os "Linux 2.4 ts"<br>
block in on $ext_if any os unknown
</tt>
</blockquote>

<p>
A classe de sistema operacional <tt>unknown</tt> permite o enquadramento 
de pacotes quanto a impress&atilde;o digital do SO n&atilde;o &eacute;
conhecida.

<p>
<font color="#ff0000">TOME NOTA</font>:
<ul>
  <li>Impress&otilde;es digitais de sistemas operacionais ocasionalmente 
  podem estar erradas, devido a pacotes spoofados e/ou trabalhados 
  para que pare&ccedil;am originados de um sistema operacional em espec&iacute;fico.
  <li>Determinadas revis&otilde;es ou patches de um sistema operacional 
  podem alterar o comportamento da pilha, fazendo com que ela n&atilde;o 
  combine com a impress&atilde;o digital do arquivo ou at&eacute; mesmo fique igual 
  a de outro.
  <li>OSFP funciona apenas com pacotes TCP SYN; n&atilde;o funcionar&aacute; 
  com outros protocolos ou em conex&otilde;es j&aacute; estabelecidas.
</ul>

<a name="ipopts"></a>
<h2>Op&ccedil;&otilde;es IP</h2>
Por padr&atilde;o, o PF bloqueia pacotes com op&ccedil;&otilde;es IP setadas. Isso pode 
dificultar o trabalho de ferramentas de "detec&ccedil;&atilde;o de sistema operacional" 
como nmap. Caso possua alguma aplica&ccedil;&atilde;o que fa&ccedil;a uso destes pacotes, como 
multicast ou IGMP, voc&ecirc; pode usar a diretiva <tt>allow-opts</tt>:
<blockquote>
<tt>
pass in quick on fxp0 all allow-opts
</tt>
</blockquote>

<a name="example"></a>
<h2>Exemplo de Arquivo de Regras</h2>
Abaixo est&aacute; um arquivo de exemplo para regras de filtragem. A m&aacute;quina 
rodando PF funciona como firewall entre uma pequena rede interna e a Internet. 
S&atilde;o mostradas apenas as regras de filtragem;
<a href="queueing.html">queueing</a>, 
<a href="nat.html"><tt>nat</tt></a>, 
<a href="rdr.html"><tt>rdr</tt></a>, 
etc., foram deixadas fora deste exemplo.
<br>
<br>
<table border="0" width="650">
<tr><td nowrap bgcolor="#EEEEEE">
<pre>
ext_if  = "fxp0"
int_if  = "dc0"
lan_net = "192.168.0.0/24"

# tabela contendo todos endere&ccedil;os IP atribu&iacute;dos ao firewall
table &lt;firewall&gt; const { self }

# faz scrub em pacotes que chegam
scrub in all

# define o pol&iacute;tica padr&atilde;o
block in  all
block out all

# aceita tr&aacute;fego em qualquer dire&ccedil;&atilde;o na interface de loopback 
pass quick on lo0 all

# ativa prote&ccedil;&atilde;o contra spoof na interface interna
antispoof quick for $int_if inet

# permite conex&otilde;es ssh vindas apenas da rede interna, e se for 
# de um computador confi&aacute;vel, 192.168.0.15. usa "block return" de 
# forma que um TCP RST &eacute; enviado para derrubar conex&otilde;es bloqueadas.
# usa "quick" para que esta regra n&atilde;o seja invalidada por alguma 
# regra "pass" abaixo.
block return in quick on $int_if proto tcp from ! 192.168.0.15 \
   to $int_if port ssh flags S/SA

# aceita tr&aacute;fego indo e vindo para a rede interna
pass in  on $int_if from $lan_net to any
pass out on $int_if from any to $lan_net

# aceita tcp, udp, e icmp saindo pela interface externa (Internet). 
# mant&eacute;m o estado em udp e icmp e usa modulate state em tcp.
pass out on $ext_if proto tcp all modulate state flags S/SA
pass out on $ext_if proto { udp, icmp } all keep state

# permite conex&otilde;es ssh na interface externa contanto que N&Atilde;O sejam 
# destinadas ao firewall (ex., conex&otilde;es destinadas a m&aacute;quinas na rede
# local). loga os pacotes iniciais para que mais tarde possamos saber
# quem tentou se conectar. usa tcp syn proxy nas conex&otilde;es.
pass in log on $ext_if proto tcp from any to ! &lt;firewall&gt; \
   port ssh flags S/SA synproxy state
</pre>
</td></tr>
</table>

<p>
[<a href="tables.html">Anterior: Tabelas</a>]
[<a href="index.html">Conte&uacute;do</a>]
[<a href="nat.html">Pr&oacute;ximo: Tradu&ccedil;&atilde;o do Endere&ccedil;o de Rede (NAT)</a>]

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../../images/back.gif" border="0" alt="[voltar]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
Originally [OpenBSD: filter.html,v 1.27 ]<br>                                                      
$Translation: filter.html,v 1.2 2005/02/05 18:56:18 dsantos Exp $<br>                 
$OpenBSD: filter.html,v 1.2 2005/02/06 09:27:06 saad Exp $ 
</small>

</body>
</html>
