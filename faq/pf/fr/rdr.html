<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>PF : Redirection de Trafic ("Forwarding"
            de Ports)</title>
<link rev="made" href="mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="resource-type" content="document">
<meta name="description"   content="the OpenBSD FAQ page">
<meta name="keywords"      content="openbsd,faq,pf">
<meta name="distribution"  content="global">
</head>

<!--
Copyright (c) 2003, 2004, Nick Holland <nick@openbsd.org>

Permission to use, copy, modify, and distribute this documentation for
any purpose with or without fee is hereby granted, provided that the
above copyright notice and this permission notice appear in all copies.

THE DOCUMENTATION IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
WARRANTIES WITH REGARD TO THIS DOCUMENTATION INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS DOCUMENTATION
-->

<body bgcolor="#ffffff" text="#000000">
<!-- Passes validator.w3.org, please keep it this way;
please, use a max of 72 chars per line -->

<img alt="[OpenBSD]" height=30 width=141 src="../../../images/smalltitle.gif">
<p>
[<a href="nat.html">Précédent : Traduction d'Adresses
Réseau</a>]
[<a href="index.html">Index</a>]
[<a href="shortcuts.html">Suivant : Raccourcis pour la Création
de Jeux de Règles</a>]

<h1><font color="#e00000">PF : Redirection de Trafic ("Forwarding" de
    Ports)</font></h1>

<hr>

<h3>Table des Matières</h3>
<ul>
<li><a href="#intro">Introduction</a>
<li><a href="#filter">Redirection et Filtrage de Paquets</a>
<li><a href="#security">Implications au niveau de la
    Sécurité</a>
<li><a href="#reflect">Redirection et Réflexion</a>
        <ul>
        <li><a href="#splitdns">DNS en "Split-Horizon"</a>
        <li><a href="#sepnet">Déplacer le Serveur Vers un
            Réseau Local Séparé</a>
        <li><a href="#tcpproxy">Mandater les Connexions TCP ("TCP
            Proxying")</a>
        <li><a href="#rdrnat">Combinaison RDR et NAT</a>
        </ul>
</ul>

<hr>

<a name="intro"></a>
<h2>Introduction</h2>
Quand vous utilisez la NAT, les machines sur votre réseau peuvent
accéder à la totalité des ressources Internet.
Qu'en est-il lorsqu'une de vos machines derrière la passerelle
NAT a besoin d'être accédée depuis Internet ? la
redirection est utilisée pour résoudre ce genre de
problèmes. Elle permet au trafic entrant d'être
acheminé vers une machine derrière la passerelle NAT.

<p>
Prenons un exemple :
<blockquote>
<tt>
rdr on tl0 proto tcp from any to any port 80 -&gt; 192.168.1.20
</tt>
</blockquote>

<p>
La ligne ci-dessus redirige le trafic à destination du port TCP
80 (serveur web) vers une machine sur le réseau d'adresse IP
192.168.1.20. Ainsi, même si cette machine est derrière
votre passerelle, le monde externe peut y avoir accès.

<p>
La partie <tt>from any to any</tt> de la ligne <tt>rdr</tt>
précitée peut être assez utile. Si vous voulez
restreindre les adresses ou les sous-réseaux autorisés
à avoir accès au serveur web sur le port 80, vous pouvez
le faire de la façon suivante :
<blockquote>
<tt>
rdr on tl0 proto tcp from 27.146.49.0/24 to any port 80 -&gt; \<br>
&nbsp;&nbsp;&nbsp;192.168.1.20
</tt>
</blockquote>

<p>
Ceci aura pour effet de rediriger uniquement le trafic en provenance du
sous-réseau spécifié. Notez que cela implique la
possibilité de rediriger différentes machines en
entrée vers des machines derrière la passerelle. Une telle
fonctionnalité est utile. Par exemple, vous pouvez autoriser des
utilisateurs sur des sites distants à accèder à
leur propre machine dans la mesure où vous connaissez leur
adresse IP :
<blockquote>
<tt>
rdr on tl0 proto tcp from 27.146.49.14 to any port 80 -&gt; \<br>
&nbsp;&nbsp;&nbsp;192.168.1.20<br>
rdr on tl0 proto tcp from 16.114.4.89 to any port 80 -&gt; \<br>
&nbsp;&nbsp;&nbsp;192.168.1.22<br>
rdr on tl0 proto tcp from 24.2.74.178 to any port 80 -&gt; \<br>
&nbsp;&nbsp;&nbsp;192.168.1.23
</tt>
</blockquote>

<a name="filter"></a>
<h2>Redirection et Filtrage de Paquets</h2>
<font color="#ff0000">REMARQUE :</font> Les paquets redirigés
doivent encore être autorisés par le moteur de filtrage.
Ils seront bloqués ou autorisés selon les règles de
filtrage qui ont été définies. La <i>seule</i>
exception à cette règle est lorsque le mot-clé
<tt>pass</tt> est utilisé dans la règle <tt>rdr</tt>; dans
ce cas, les paquets redirigés seront automatiquement
autorisés par le moteur de filtrage.

<p>
Notez aussi que la traduction est effectuée <i>avant</i> le
filtrage. Le moteur de filtrage verra le paquet <i>traduit</i>,
ç.à.d. après que son adresse IP destination et/ou
port de destination soient modifiés pour correspondre à
l'adresse/au port de redirection spécifié(e) dans la
règle <tt>rdr</tt>. Considérons le cas suivant :
<ul>
<li>192.0.2.1 - hôte sur Internet
<li>24.65.1.13 - adresse IP externe du routeur OpenBSD
<li>192.168.1.5 - adresse IP interne du serveur web
</ul>

<p>
Règle de redirection :
<blockquote>
<tt>
rdr on tl0 proto tcp from 192.0.2.1 to 24.65.1.13 port 80 \<br>
&nbsp;&nbsp;&nbsp;-&gt; 192.168.1.5 port 8000
</tt>
</blockquote>

<p>
Avant que la règle de redirection ne soit utilisée, le
paquet est traité :
<ul>
<li>Adresse source : 192.0.2.1
<li>Port source : 4028 (choisi de manière arbitraire par le
    système d'exploitation)
<li>Adresse de destination : 24.65.1.13
<li>Port de destination : 80
</ul>

<p>
Puis la règle de redirection est évaluée :
<ul>
<li>Adresse source : 192.0.2.1
<li>Port source : 4028
<li>Adresse de destination : 192.168.1.5
<li>Port de destination : 8000
</ul>

<p>
Le moteur de filtrage verra le paquet IP tel qu'il apparaît
après la traduction effectuée par le mécanisme de
redirection.

<a name="security"></a>
<h2>Implications au niveau de la Sécurité</h2>
La redirection a des implications au niveau de la
sécurité. La création d'une ouverture pour
autoriser le trafic à destination du réseau interne
protégé peut causer la compromission d'une machine sur ce
dernier. Par exemple, si le trafic est redirigé vers un serveur
web interne et par malheur, une vulnérabilité est
découverte dans le service web ou dans un script CGI
executé par le serveur, alors la machine peut être
compromise par un intrus provenant d'Internet. Une fois cette
compromission réalisée, l'intrus peut rebondir à
partir de cette machine vers le réseau interne ce qui est bien
entendu permis par le pare-feu.

<p>
Ces risques peuvent être minimisés en confinant de
manière stricte le système accédé depuis
l'extérieur à un réseau séparé. Ce
réseau est souvent appelé zone démilitarisée
(DMZ) ou réseau de service privé (Private Service Network,
PSN). De cette façon, si le serveur web est compromis, les effets
peuvent être limités au réseau DMZ/PSN en filtrant
soigneusement le trafic autorisé entre DMZ/PSN et vos autres
réseaux.

<a name="reflect"></a>
<h2>Redirection et Réflexion</h2>
Souvent, les règles de redirection sont utilisées pour
faire suivre des connexions Internet entrantes à un serveur local
disposant d'une adresse privée sur le réseau interne comme
le montre l'exemple suivant :
<blockquote>
<tt>
server = 192.168.1.40<br>
<br>
rdr on $ext_if proto tcp from any to $ext_if port 80 -&gt; $server \<br>
&nbsp;&nbsp;&nbsp;port 80
</tt>
</blockquote>

<p>
Mais lorsque la règle de redirection est testée par un
client du LAN, elle ne fonctionne pas. C'est normal car les
règles de redirection ne s'appliquent qu'aux paquets qui passent
à travers l'interface spécifiée dans chacune
d'elles (dans l'exemple précité, c'est l'interface externe
<tt>$ext_if</tt>). Cependant, une connexion émanant d'un client
interne et à destination de l'adresse externe du pare-feu
n'implique pas que les paquets vont passer à travers l'interface
externe du pare-feu. La pile TCP/IP sur le pare- feu compare l'adresse
de destination des paquets entrants avec ses propres adresses et aliases
et détecte les connexions qui lui sont destinées lorsque
les paquets constituant celles-ci passent son interface interne. De tels
paquets ne passent pas physiquement à travers l'interface
externe, et de toute façon la pile ne simule pas ce passage.
Ainsi, PF ne voit jamais ces paquets sur l'interface externe. Du coup,
la règle de redirection sur l'interface externe n'est jamais
appliquée.

<p>
Que doit-on faire alors ? ajouter une seconde règle de
redirection sur l'interface interne ? non, ça ne fonctionnera pas
mieux. Lorsque le client local se connecte à l'interface externe
du pare-feu, le paquet initial de l'échange TCP atteint le 
pare-feu via son interface interne. La nouvelle règle de
redirection s'applique et l'adresse de destination est remplacée
par celle du serveur interne. Le paquet et alors redirigé par
l'interface interne du pare-feu vers le serveur interne. Mais l'adresse
source n'a pas été modifiée. Elle contient
l'adresse du client local. Le serveur envoie alors directement les
réponses au client. Le pare-feu ne voit jamais le retour et n'a
aucune chance de traduire correctement les paquets de retour. Le client
reçoit une réponse à partir d'une source
inattendue. Il met alors fin à cette connexion.

<p>
Cependant, il est souvent souhaitable que les clients sur le LAN se
connectent au même serveur interne que les clients externes et de
manière aussi transparente. Il existe plusieurs solutions
à ce problème :

<a name="splitdns"></a>
<h3>DNS en "Split-Horizon"</h3>

<p>
Il est possible de configurer les serveurs DNS pour fournir une
réponse différente selon la provenance de la requête
: clients internes ou externes. Ainsi les clients internes recevront
l'adresse interne du serveur en réponse à leur demande de
résolution de nom. Ils pourront alors se connecter directement au
serveur local sans impliquer le pare-feu. Ce dernier sera alors moins
sollicité.

<a name="sepnet"></a>
<h3>Déplacer le Serveur Vers un Réseau Local
    Séparé</h3>

<p>
Une autre solution consiste à ajouter une carte réseau au
pare-feu et à déplacer le serveur local vers un
réseau dédié de type DMZ. Les connexions des
clients locaux seront alors redirigées de la même
manière que les connexions en provenance d'Internet.
L'utilisation de réseaux séparés a plusieurs
avantages. Entre autres, une amélioration du niveau de
sécurité en isolant le serveur des machines internes. Si
le serveur (qui, nous le rappelons, est joignable d'Internet) est
compromis, il ne peut se connecter à des machines internes
directement vu que toutes ces connexions doivent passer à travers
le pare-feu.

<a name="tcpproxy"></a>
<h3>Mandater les Connexions TCP ("TCP Proxying")</h3>

<p>
Un proxy TCP générique peut être mis en place sur le
pare-feu. Ce proxy devra écouter sur le port de redirection ou
accepter les connexions sur l'interface interne et redirigées sur
le port sur lequel il écoute. Lorsqu'un client se connecte sur le
pare-feu, le proxy accepte la connexion, établit une seconde
connexion au serveur interne, et véhicule les données
entre les deux connexions.

<p>
Des proxies simples peuvent être crées avec 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inetd&amp;sektion=8&amp;manpath=OpenBSD+3.5"
>inetd(8)</a> et
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nc&amp;sektion=1&amp;manpath=OpenBSD+3.5"
>nc(1)</a>.
L'entrée suivante dans le fichier <tt>/etc/inetd.conf</tt>
crée une socket d'écoute rattachée à
l'adresse de loopback (127.0.0.1) et le port 5000. Les connexions sont
redirigées sur le port 80 du serveur 192.168.1.10.
<blockquote>
<tt>
127.0.0.1:5000 stream tcp nowait nobody /usr/bin/nc nc -w \<br>
&nbsp;&nbsp;&nbsp;20 192.168.1.10 80
</tt>
</blockquote>

<p>
La règle de redirection suivante redirige le port 80 sur
l'interface interne du proxy :
<blockquote>
<tt>
rdr on $int_if proto tcp from $int_net to $ext_if port 80 -&gt; \<br>
&nbsp;&nbsp;&nbsp;127.0.0.1 port 5000
</tt>
</blockquote>

<a name="rdrnat"></a>
<h3>Combinaison RDR et NAT</h3>

<p>
A l'aide d'une règle NAT supplémentaire sur l'interface
interne, la traduction manquante d'adresse source décrite plus
haut peut être réalisée.
<blockquote>
<tt>
rdr on $int_if proto tcp from $int_net to $ext_if port 80 -&gt; \<br>
&nbsp;&nbsp;&nbsp;$server
<br>
no nat on $int_if proto tcp from $int_if to $int_net<br>
nat on $int_if proto tcp from $int_net to $server port 80 -&gt; \<br>
&nbsp;&nbsp;&nbsp;$int_if
</tt>
</blockquote>

<p>
Ceci aura pour effet d'effectuer une autre traduction d'adresse du
paquet initial envoyé par le client lorsque celui-ci est
redirigé à travers l'interface interne. Cette seconde
opération de traduction remplacera l'adresse source du client par
l'adresse interne du pare-feu. Le serveur interne répondra alors
à l'adresse interne du pare-feu, qui effectuera les
opérations de NAT et de RDR inverses avant de faire suivre le
paquet au client. Cette méthode est relativement complexe. Elle
crée deux états séparés pour chaque
connexion redirigée. Il faut prendre des précautions pour
éviter que la règle de NAT s'applique au reste du trafic
tel que les connexions en provenance de hôtes externes (via
d'autres redirections) ou en provenance du pare-feu lui-même. Il
est à noter que la règle <tt>rdr</tt>
précitée fera apparaître à la pile TCP/IP des
paquets en provenance du réseau interne et à destination
de ce dernier.

<p>
Cependant, nous recommandons de privilégier plutôt les
solutions précédemment mentionnées.

<p>
[<a href="nat.html">Précédent : Traduction d'Adresses
Réseau</a>]
[<a href="index.html">Index</a>]
[<a href="shortcuts.html">Suivant : Raccourcis pour la Création
de Jeux de Règles</a>]

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../../images/back.gif" border="0" alt="[back]"></a> 
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
Originally [OpenBSD: rdr.html,v 1.16 ]<br>
$Translation: rdr.html,v 1.9 2004/10/11 12:24:36 saad Exp $<br>
$OpenBSD: rdr.html,v 1.8 2004/10/11 16:17:48 jufi Exp $
</small>

</body>
</html> 
