<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>PF : Filtrage de Paquets</title>
<link rev="made" href="mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="resource-type" content="document">
<meta name="description"   content="the OpenBSD FAQ page">
<meta name="keywords"      content="openbsd,faq,pf">
<meta name="distribution"  content="global">
</head>

<!--
Copyright (c) 2003, 2004 Joel Knight <enabled@myrealbox.com>

Permission to use, copy, modify, and distribute this documentation for
any purpose with or without fee is hereby granted, provided that the
above copyright notice and this permission notice appear in all copies.

THE DOCUMENTATION IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
WARRANTIES WITH REGARD TO THIS DOCUMENTATION INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS DOCUMENTATION
-->

<body bgcolor="#ffffff" text="#000000">
<!-- Passes validator.w3.org, please keep it this way;
please, use a max of 72 chars per line -->

<a href="../../fr/index.html">
<img alt="[OpenBSD]" height="30" width="141" src="../../../images/smalltitle.gif" border="0">
</a>
<p>
[<a href="tables.html">Section précédente : Tables</a>]
[<a href="index.html">Index</a>]
[<a href="nat.html">Section suivante : Traduction des Adresses IP (&quot;NAT&quot;)</a>]

<h1><font color="#e00000">PF : Le Filtrage de Paquets</font></h1>

<hr>

<h3>Table des Matières</h3>

<ul>
<li><a href="#intro">Introduction</a>
<li><a href="#syntax">Syntaxe</a>
<li><a href="#defdeny">Blocage par défaut</a>
<li><a href="#pass">Laisser passer le trafic</a>
<li><a href="#quick">L'option <tt>quick</tt></a>
<li><a href="#state">Conserver l'état</a>
<li><a href="#udpstate">Conserver l'état avec UDP</a>
<li><a href="#tcpflags">Les drapeaux TCP</a>
<li><a href="#synproxy">Service mandataire TCP SYN</a>
<li><a href="#antispoof">Bloquer les paquets usurpés</a>
<li><a href="#osfp">Reconnaissance passive d'OS par leurs empreintes</a>
<li><a href="#ipopts">Les options IP</a>
<li><a href="#example">Un exemple de règles de filtrage</a>
</ul>

<hr>

<a name="intro"></a>

<h2>Introduction</h2>
Le filtrage de paquets à l'aide de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf&amp;sektion=4&amp;manpath=OpenBSD+3.6">pf(4)</a>
consiste à autoriser ou bloquer le trafic réseau en fonction des
propriétés des protocoles des couches 3
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4&amp;manpath=OpenBSD+3.6"
>IPv4</a> et
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip6&amp;sektion=4&amp;manpath=OpenBSD+3.6"
>IPv6</a>) et 4 
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcp&amp;sektion=4&amp;manpath=OpenBSD+3.6"
>TCP</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=udp&amp;sektion=4&amp;manpath=OpenBSD+3.6"
>UDP</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp&amp;sektion=4&amp;manpath=OpenBSD+3.6"
>ICMP</a>, et 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp6&amp;sektion=4&amp;manpath=OpenBSD+3.6"
>ICMPv6</a>).
Les adresses et ports source et destination ainsi que les protocoles
utilisés sont des critères fréquemment employés.

<p>
Les règles de filtrage énumèrent les critères auxquels doivent se
conformer les paquets et spécifient les actions qui y sont associées :
bloquer ou laisser passer. Ces règles sont évaluées de façon
séquentielle de la première à la dernière (du haut vers le bas dans les
fichiers de règles utilisés).

Sauf utilisation du mot-clef <tt>quick</tt> dans l'une d'entre elles, chaque paquet est évalué à l'aune de <i>toutes</i> les règles avant qu'une décision finale ne soit prise. 

L'action (block ou pass) associée à la dernière règle dont les critères
se rapportent au paquet traité est appliquée. La première règle est un
<tt>tout laisser passer</tt> implicite de sorte que si aucune règle
n'est applicable à un paquet, celui-ci est accepté.

<a name="syntax"></a>
<h2>Syntaxe</h2>

L'écriture des règles obéit à la syntaxe <i>très simplifiée</i> suivante
:
<blockquote>
<tt>
<i>action</i> <i>direction</i> [log] [quick] on <i>interface</i> [<i>af</i>] 
[proto <i>protocol</i>] \<br>
&nbsp;&nbsp;&nbsp;from <i>src_addr</i> [port <i>src_port</i>] to 
<i>dst_addr</i> [port <i>dst_port</i>] \<br>
&nbsp;&nbsp;&nbsp;[flags <i>tcp_flags</i>] [<i>state</i>]

</tt>
</blockquote>

<dl>
<dt><tt><i>action</i></tt>
<dd>Ce mot-clef indique le type d'action associé à tout paquet
    correspondant aux critères contenus dans la règle. Les deux valeurs
    possibles sont <tt>pass</tt> et <tt>block</tt>.
<tt>pass</tt> signifie que le paquet sera transféré au noyau pour être
traité. Le blocage du paquet (<tt>block</tt>) sera fonction de la
politique définie par les options
<a href="options.html#block-policy"><tt>block-policy</tt></a>. L'action
associée à <tt>block</tt> par défaut peut être modifiée en spécifiant
<tt>block drop</tt> ou <tt>block return</tt>.

<dt><tt><i>direction</i></tt>
<dd>Ce mot-clef spécifie le sens du trafic vu depuis l'interface réseau
    : celui-ci peut être entrant (<tt>in</tt>) ou sortant
    (<tt>out</tt>).

<dt><tt>log</tt>
<dd>La présence de ce mot-clef dans une règle déclenche la
    journalisation des paquets correspondants à la règle grâce à
    l'utilitaire
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+3.6">pflogd(8)</a>.
    Si les options <tt>keep state</tt>, <tt>modulate state</tt>, ou
    <tt>synproxy state</tt> sont également renseignées, seul le paquet
    correspondant à l'ouverture de la session est conservé. Pour
    conserver tous les paquets d'une session, il faut utiliser le mot-
    clef <tt>log-all</tt>.

<dt><tt>quick</tt>
<dd>Si ce mot-clef est utilisé dans une règle, celle-ci est considérée
    comme étant la dernière à prendre en compte. Les règles suivantes
    sont ignorées.

<dt><tt><i>interface</i></tt>
<dd>Ce mot-clef désigne l'interface sur laquelle le trafic est à
    analyser. Il est possible de grouper plusieurs interfaces. Dans ce
    cas, le groupe est désigné par le nom générique de l'interface non
    suivi d'un numéro. Par exemple : <tt>ppp</tt> ou <tt>fxp</tt>. La
    règle s'appliquera aux paquets traversant toute interface de type
    <tt>ppp</tt> ou <tt>fxp</tt> respectivement.

<dt><tt><i>af</i></tt>
<dd>Il est possible de spécifier la famille d'adresses IP à laquelle
    appliquer une règle à l'aide de ce mot-clef. Les deux valeurs
    possibles sont <tt>inet</tt> pour les adresses IPv4 ou
    <tt>inet6</tt> pour IPv6. PF peut généralement déterminer à quelle
    famille appartient un paquet à partir de ses adresses source et
    destination.

<dt><tt><i>protocol</i></tt>
<dd>Ce mot-clef identifie les protocoles de couche 4 utilisés. Il peut
    prendre les valeurs suivantes :
<ul>
<li><tt>tcp</tt>
<li><tt>udp</tt>
<li><tt>icmp</tt>
<li><tt>icmp6</tt>
<li>tout protocole spécifié dans le fichier
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=protocols&amp;sektion=5&amp;manpath=OpenBSD+3.6"
><tt>/etc/protocols</tt></a>
<li>le numéro d'un protocole compris entre 0 et 255
<li>un ensemble de protocoles passé dans une
    <a href="macros.html#lists">liste</a>.
</ul>

<dt><tt><i>src_addr</i></tt>, <tt><i>dst_addr</i></tt> 

<dd>Ces mots-clefs identifient respectivement les adresses source et
    destination du paquet telles que contenues dans son en-tête IP. Ces
    adresses peuvent être spécifiées :
<ul>
<li>sous la forme d'adresse IPv4 ou IPv6.
<li>sous la forme d'un bloc d'adresses
<a href="http://public.pacbell.net/dedicated/cidr.html">CIDR</a>.
<li>sous la forme d'un domaine. Ce dernier fera l'objet d'une résolution
    DNS lors du chargement des règles par PF. La règle s'appliquera
    alors à tous les adresses du domaine.
<li>par l'intermédiaire du nom d'une interface réseau. Toute adresse IP
    affectée à cette interface sera valide pour la règle.
<li>par l'intermédiaire du nom d'une interface réseau suivi d'un masque
    de sous-réseau (<tt>/24</tt>). Toutes les adresses IP correspondant
    au bloc CIDR formé par l'adresse IP de l'interface et le
    <i>netmask</i> seront valides pour cette règle.
<li>sous la forme du nom d'une interface réseau mis entre parenthèses
    <tt>( )</tt>. Cette mise en forme indique à PF qu'il doit mettre ses
    règles à jour en cas de changement de l'adresse IP affectée à
    l'interface en question. Cette technique est très utile dans le cas
    de liaisons PPP ou d'utilisation du protocole DHCP pour
    l'attribution d'adresses IP. Elle évite d'avoir à recharger les
    règles à chaque nouvelle affectation.
<li>grâce au nom d'une interface suivie d'un des paramètres suivants :
  <ul>
  <li><tt>:network</tt> - identifie un bloc CIDR (par exemple :
      192.168.0.0/24)
  <li><tt>:broadcast</tt> - identifie une adresse de multi-diffusion
      (par exemple : 192.168.0.255)
  <li><tt>:peer</tt> - identifie l'adresse d'un pair sur un lien point à
      point.
  </ul>
  <dl>
  <dd>De plus, le paramètre <tt>:0</tt> peut être ajouté aussi bien au
      nom d'une interface qu'à chacun des paramètres présentés
      ci-dessus. PF ne prend alors pas en compte les éventuels alias
      d'adresses IP affectées à l'interface. Ces paramètres peuvent
      aussi être utilisés dans le cas d'une interface entre parenthèses.
      Par exemple: <tt>fxp0:network:0</tt>
  </dl>
<li>à l'aide d'une <a href="tables.html">table</a>.
<li>sous toutes les formes décrites ci-dessus précédées du paramètre
    d'inversion <tt>!</tt> (&quot;not&quot;).
<li>à l'aide d'une <a href="macros.html#lists">liste</a> d'adresses.
<li>grâce au mot-clef <tt>any</tt> qui identifie n'importe quelle
    adresse.
<li>grâce au mot-clef <tt>all</tt> qui est un raccourci pour
    l'expression <tt>from any to any</tt> (n'importe quelle source vers
    n'importe quelles destination).
</ul>

<dt><tt><i>src_port</i></tt>, <tt><i>dst_port</i></tt>
<dd>Ces mots-clefs identifient respectivement les ports source et
    destination qui apparaissent dans les en-têtes des protocoles de
    couche 4. Ces ports peuvent être spécifiés :
<ul>
<li>sous forme numérique par un nombre compris entre 1 et 65535.
<li>par le nom d'un service tel qu'identifié dans le fichier 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=services&amp;sektion=5&amp;manpath=OpenBSD+3.6"
><tt>/etc/services</tt></a>.
<li>sous la forme d'une <a href="macros.html#lists">liste</a>.
<li>sous la forme d'un intervalle de ports construit à l'aide des
    opérateurs suivants :
	<ul>
        <li><tt>!=</tt> (différent)
        <li><tt>&lt;</tt> (inférieur à)
        <li><tt>&gt;</tt> (supérieur à)
        <li><tt>&lt;=</tt> (inférieur ou égal à)
        <li><tt>&gt;=</tt> (supérieur ou égal à)
        <li><tt>&gt;&lt;</tt> (intervalle)
        <li><tt>&lt;&gt;</tt> (intervalle inverse)
        <li><tt>:</tt> (intervalle complet)
        <dl>
        <dd>Les trois derniers opérateurs demandent deux arguments pour
            former un intervalle qui n'inclue pas ces arguments.
        </dl>
        </ul>
</ul>

<dt><tt><i>tcp_flags</i></tt>

<dd>L'activation d'une règle peut être conditionnée à la valeur des
    drapeaux TCP d'un paquet. Cette valeur est spécifiée ainsi :
    <tt>flags <i>check</i>/<i>mask</i></tt>.

Par exemple : <tt>flags S/SA</tt>. Dans ce cas, PF teste la valeur des
drapeaux S et A (SYN et ACK) pour savoir s'ils sont positionnés. Si le
drapeau SYN est positionné, et uniquement ce drapeau, alors la règle est
applicable.

<dt><tt><i>state</i></tt>
<dd>Ce mot-clef indique dans quel état doit être le paquet pour
    satisfaire à une règle.
<ul>
<li><tt>keep state</tt> - s'applique aux protocoles TCP, UDP, et ICMP.
<li><tt>modulate state</tt> - ne s'applique qu'au protocole TCP. PF
    renforcera le caractère aléatoire des numéros de séquence initiaux
    (ISN) générés pour ces paquets.
<li><tt>synproxy state</tt> - PF agit comme mandataire pour les
    connexions TCP entrantes. Cela renforce la protection contre les
    attaques par inondations de paquets SYN en provenance d'adresses
    usurpées. Cette option active implicitement les fonctionnalités
    <tt>keep state</tt> et <tt>modulate state</tt>.
</ul>
</dl>

<a name="defdeny"></a>
<h2>Blocage par défaut</h2>
Il est recommandé d'adopter une approche de blocage par défaut lors de
la configuration d'un pare-feu. Cela signifie que <i>tout</i> est
interdit et que l'on autorise le trafic au cas par cas. Cette approche
est assimilable à l'application d'un principe de précaution et simplifie
l'écriture des règles.

<p>
Cette politique de blocage par défaut repose sur deux règles :
<blockquote>
<tt>
block in &nbsp;all<br>
block out all
</tt>
</blockquote>

<p>
Cela suffit à interdire tout trafic dans un sens comme dans l'autre et
ce sur toutes les interfaces de la machine.

<a name="pass"></a>
<h2>Laisser passer le trafic</h2>

Une fois notre politique restrictive mise en place, il faut spécifier
quelles sont les connexions autorisées. C'est là qu'entrent en jeu les
critères décrits précédemment : adresse et port source et destination,
protocole, etc. Chaque fois qu'un paquet est autorisé à franchir les
murs du pare-feu, les règles correspondantes devront être les plus
restrictives possible : il s'agit de n'autoriser que le trafic voulu et
lui seul.

<p>
Quelques exemples:
<blockquote>
<tt>
# Autoriser le trafic entrant sur l'interface dc0<br>
# en provenance du réseau local 192.168.0.0/24,<br>
# à destination de la machine dont l'adresse IP est 192.168.0.1.<br>
# Dans le même temps, autoriser le trafic sortant par l'interface dc0.<br>
pass in &nbsp;on dc0 from 192.168.0.0/24 to 192.168.0.1<br>
pass out on dc0 from 192.168.0.1 to 192.168.0.0/24<br>
<br>
<br>
# Autoriser le trafic TCP entrant sur l'interface fxp0<br>
# à destination d'un serveur HTTP.<br>
# Le nom de l'interface - fxp0 - est utilisé comme adresse de destination<br>
# pour les paquets autorisés.<br> 
pass in on fxp0 proto tcp from any to fxp0 port www
</tt>
</blockquote>

<a name="quick"></a>
<h2>L'option <tt>quick</tt></h2>
Comme nous l'avons vu, chaque paquet est testé au regard de toutes les
règles de filtrage, de la première à la dernière. Par défaut, un paquet
est marqué à chaque test. Le résultat final peut ainsi changer d'une
règle à l'autre jusqu'à ce que toutes aient été parcourues. Rappelons
que c'est la dernière règle à laquelle correspond un paquet qui
l'emporte sur les autres. Il y a cependant une exception : si l'option
<tt>quick</tt> est présente dans une règle et qu'un paquet correspond
aux critères de cette règle, il n'y a plus de tests : la règle en
question est alors considérée par PF comme étant la dernière. Les
exemples suivants illustrent ce cas de figure :

<p>
Mauvais :
<blockquote>
<tt>
block in on fxp0 proto tcp from any to any port ssh<br>
pass &nbsp;in all
</tt>
</blockquote>

<p>
La ligne <tt>block</tt> n'aura aucun effet. Les paquets seront bien
évalués suivant ses critères, mais la ligne suivante annulera tout effet
de cette première règle.

<p>
Mieux :
<blockquote>
<tt>
block in quick on fxp0 proto tcp from any to any port ssh<br>
pass &nbsp;in all
</tt>
</blockquote>

<p>
A première vue c'est la même chose. Toutefois la présence de l'option
<tt>quick</tt> provoque l'arrêt des tests pour chaque paquet qui
correspond aux critères de la première règle. Les paquets qui n'y
satisfont pas seront quant à eux testés au regard des critères de la
règle suivante.

<a name="state"></a>
<h2>Conserver l'état</h2>

Une des fonctionnalités les plus importantes de PF est sa capacité à
conserver l'état des connexions. PF est capable d'évaluer un paquet non
plus unitairement mais dans le contexte de la connexion à laquelle il
appartient. PF utilise pour cela une table d'état gràce à laquelle PF
peut rapidement déterminer si un paquet fait partie d'une connexion déjà
établie et autorisée. Si tel est le cas, le paquet est transféré sans
test complémentaire.

<p>
Conserver l'état des connexions a pour avantage de simplifier les règles
de filtrage et d'améliorer les performances. PF évalue les paquets
<i>quelque soit leur sens</i> : il n'est alors plus nécessaire d'écrire
les règles pour les paquets des flux retour. PF consacre ainsi beaucoup
moins de temps à inspecter les paquets.

<p>
Quand l'option <tt>keep state</tt> est utilisée dans une règle, le
premier paquet qui déclenche l'activation de celle-ci provoque la
création d'un enregistrement dans la table d'état des connexions en
cours. Par la suite, non seulement les paquets allant de l'expéditeur au
destinataire sont rattachés à cette table et donc autorisés à passer,
mais également les paquets qui appartiennent aux réponses du
destinataire. Par exemple :
<blockquote>
<tt>
pass out on fxp0 proto tcp from any to any keep state
</tt>
</blockquote>

<p>
Cette règle autorise les connexions TCP sortantes sur l'interface
<tt>fxp0</tt> mais aussi les paquets retour. L'option <tt>keep
state</tt> permet donc d'augmenter les performances du pare-feu car la
recherche dans la table d'état est beaucoup plus rapide que l'opération
consistant à évaluer un paquet au regard de toutes les règles de
filtrage.

<p>
L'option <tt>modulate state</tt> fonctionne de la même façon que
l'option <tt>keep state</tt> à ceci près qu'elle ne s'applique qu'aux
paquets TCP sortants. Elle renforce le caractère aléatoire de leurs
numéros de séquence initiaux (ISN). Cette option permet de renforcer la
sécurité de certains systèmes d'exploitation ne sachant pas générer des
ISN suffisamment aléatoires. A partir de la version 3.5 d'OpenBSD, cette
option peut être utilisée pour les autres protocoles que TCP.

<p>
Pour conserver l'état des connexions TCP, UDP et ICMP tout en renforçant
la sécurité des ISN :
<blockquote>
<tt>

pass out on fxp0 proto { tcp, udp, icmp } from any \<br>
&nbsp;&nbsp;&nbsp;&nbsp;to any modulate state<br>
</tt>
</blockquote>

<p>
Un des avantages de conserver l'état des connexions tient à ce que les
messages ICMP relatifs à celles-ci seront traités comme faisant partie
de la connexion. Si des messages ICMP sont émis par une machine pour
signaler une congestion par exemple, et que l'option <tt>keep state</tt>
est activée, les messages seront pris en compte et acceptés par le pare-
feu. Sans cela, ils auraient été être bloqués ou ignorés.

<p>
La portée d'une entrée dans la table d'état dépend des options
<tt>state-policy</tt> d'une manière globale ou bien des options
<tt>if-bound</tt>, <tt>group-bound</tt> et <tt>floating-state</tt> dont
les valeurs sont appliquées règle par règle. Par exemple :

<blockquote>
<tt>
pass out on fxp0 proto { tcp, udp, icmp } from any \<br>
&nbsp;&nbsp;&nbsp;&nbsp;to any modulate state (if-bound)<br>
</tt>
</blockquote>

<p>
Selon cette règle, les paquets ne trouveront une correspondance dans la
table d'état que s'ils transitent par l'interface <tt>fxp0</tt>.


<p>
Il faut noter que les règles <a href="nat.html"><tt>nat</tt></a>, <a href="nat.html#binat"><tt>binat</tt></a> et <a href="rdr.html"><tt>rdr</tt></a> créent implicitement des entrées dans la tables d'état.


<a name="udpstate"></a>
<h2>Conserver l'état des connexions UDP</h2>

On entend souvent dire qu'il est impossible d'utiliser la table d'état
avec UDP car c'est un protocole sans état. S'il est vrai qu'une
connexion UDP n'utilise pas stricto sensu le concept d'état tel que le
fait une connexion TCP (à savoir une ouverture et une terminaison
explicites de la connexion), cela n'a aucune conséquence sur la capacité
qu'a PF de créer et gérer des états pour les connexions UDP. Pour ce
type de protocole sans début ou de fin de connexion explicites, PF
conserve simplement une trace de la durée d'une session. Si il s'écoule
un certain laps de temps sans échange de paquets entre les deux parties,
la table d'état associée à la session est vidée. Ce laps de temps peut
être configuré dans la section
<a href="options.html">options</a> du fichier <tt>pf.conf</tt>.

<a name="tcpflags"></a>
<h2>Les drapeaux TCP</h2>

On utilise souvent les drapeaux TCP dans des règles pour traiter les
ouvertures de sessions. Ces drapeaux et leur signification sont
présentés dans la liste suivante :
<ul>
<li><b>F</b> : FIN  - Fin de session
<li><b>S</b> : SYN  - Synchronize ; correspond à une ouverture de session
<li><b>R</b> : RST  - Reset ; met fin à une session
<li><b>P</b> : PUSH - Push ; le paquet est envoyé immédiatement
<li><b>A</b> : ACK - Acknowledgement ; atteste de l'acquittement d'une
    des parties
<li><b>U</b> : URG  - Urgent
<li><b>E</b> : ECE  - Explicit Congestion Notification Echo ; avis de congestion
<li><b>W</b> : CWR - Congestion Window Reduced ; avis de réduction de la
    fenêtre TCP
</ul>

<p>
Le mot-clef <tt>flags</tt> doit apparaitre dans une règle si l'on
souhaite que PF prenne en compte la valeur des drapeaux TCP d'un paquet.
La syntaxe est la suivante :
<blockquote>
<tt>
flags <i>check</i>/<i>mask</i>
</tt>
</blockquote>

<p>
La partie <tt><i>mask</i></tt> de la règle indique la liste des drapeaux
que PF doit inspecter. La partie <tt><i>check</i></tt> quant à elle
spécifie les drapeaux qui doivent être positionnés pour que la règle
s'applique au paquet traité.
<blockquote>
<tt>
pass in on fxp0 proto tcp from any to any port ssh flags S/SA
</tt>
</blockquote>

<p>
Cette règle s'applique aux paquets TCP dont le drapeau SYN est
positionné. PF limite son inspection aux drapeaux SYN et ACK. La règle
s'applique donc à un paquet dont les drapeaux SYN et ECE sont
positionnés mais pas à un paquet dont les drapeaux SYN et ACK ou dont
seul le drapeau ACK sont positionnés.

<p>
Notez que les précédentes versions d'OpenBSD acceptaient cette syntaxe :
<blockquote>
<tt>
. . . flags S
</tt>
</blockquote>

<p>
Ce qui n'est plus vrai : le masque doit maintenant <i>toujours</i> être
renseigné.

<p>
Les drapeaux sont souvent utilisés avec l'option <tt>keep state</tt>
pour mieux contrôler la création des entrées dans la table d'état :

<blockquote>
<tt>
pass out on fxp0 proto tcp all flags S/SA keep state
</tt>
</blockquote>

<p>
Une entrée est créée pour tous les paquets TCP sortants dont le drapeau
SYN est positionné.

<p>
Il faut manipuler les drapeaux avec prudence et se méfier des mauvais
conseils. Certaines personnes suggèrent de ne créer des entrées que pour
les paquets dont le drapeau SYN est positionné. Ce qui peut aboutir à
cette règle :
<pre>
     . . . flags S/FSRPAUEW  <i>mauvaise pioche !!</i>
</pre>

<p>
En théorie, une session TCP commence par un paquet dont le drapeau SYN
est positionné. Toujours en théorie, il ne faut créer une entrée dans la
table d'état que pour ce genre de paquets. Mais certains systèmes
utilisent le drapeau ECN en début de session. Ces paquets sont rejetés
par la règle précédente. Une meilleure solution est :
<blockquote>
<tt>
. . . flags S/SAFR
</tt>
</blockquote>

<p>
Si le trafic est <a href="scrub.html">normalisé</a>, il peut être
pratique et sûr de ne pas tester la valeur des drapeaux FIN et RST. Dans
ce cas, PF rejette tout paquet entrant dont les drapeaux TCP sont
positionnés de manière illicite (par exemple : SYN et FIN ou SYN et
RST). Il est fortement recommandé de toujours <tt>normaliser</tt>
(scrub) le trafic entrant :
<blockquote>
<tt>

scrub in on fxp0<br>
.<br>
.<br>
.<br>
pass in on fxp0 proto tcp from any to any port ssh flags S/SA \<br>
&nbsp;&nbsp;&nbsp;keep state
</tt>
</blockquote>

<a name="synproxy"></a>
<h2>Mandataire TCP SYN</h2>

<p>
Normalement, quand un client ouvre une connexion TCP vers un serveur, PF
relaie les paquets d'ouverture
(<a href="http://www.inetdaemon.com/tutorials/internet/tcp/connections.html"
>handshake</a>) au fur et à mesure qu'ils arrivent. 
PF peut agir en tant que mandataire (proxy). Dans ce cas, PF va traiter
la demande en lieu et place du serveur et ne transfèrera qu'ensuite les
paquets à ce dernier. Aucun paquet n'est transmis au serveur avant que
le client n'ait terminé l'échange initial (handshake). L'avantage de
cette méthode est de protéger le serveur des attaques par inondation de
paquets SYN lancées à l'aide de paquets falsifiés.

<p>
Le mandataire TCP SYN est activé à l'aide de l'option <tt>synproxy
state</tt> :

<blockquote>
<tt>
pass in on $ext_if proto tcp from any to $web_server port www \<br>
&nbsp;&nbsp;&nbsp;flags S/SA synproxy state
</tt>
</blockquote>

<p>
Toutes les connexions à destination du serveur HTTP seront mandatées par
PF.

<p>
L'option <tt>synproxy state</tt> apporte les mêmes avantages que les
options <tt>keep state</tt> et <tt>modulate state</tt>.

<p>
Par contre, l'option synproxy ne fonctionne pas quand PF est installé en
passerelle transparente
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4&amp;manpath=OpenBSD+3.6"
>bridge(4)</a>).


<a name="antispoof"></a>
<h2>Bloquer les paquets usurpés</h2>

On parle d'usurpation quand un utilisateur mal intentionné maquille son
adresse IP dans le but d'anonymiser ou de cacher son identité afin de
lancer des attaques sans que leur origine soit détectable. Il peut
également essayer et parfois réussir à avoir accès à des services
réservés à certaines adresses.

<p>
PF permet de se prémunir de ce type d'attaques grâce à l'option
<tt>antispoof</tt> :

<blockquote>
<tt>
antispoof [log] [quick] for <i>interface</i> [<i>af</i>]

</tt>
</blockquote>

<dl>
<dt><tt>log</tt>
<dd>Journalise les paquets via 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+3.6"
>pflogd(8)</a>.

<dt><tt>quick</tt>
<dd>Si un paquet correspond à la règle, celle-ci est appliquée
    immédiatement.

<dt><tt><i>interface</i></tt>
<dd>Désigne l'interface sur laquelle s'applique la protection. Il est
    possible de passer une <a href="macros.html#lists">liste</a>
    d'interfaces en paramètre.


<dt><tt><i>af</i></tt>
<dd>Spécifie le type d'adresse : <tt>inet</tt> pour IPv4 ou
    <tt>inet6</tt> pour IPv6.
</dl>

<p>
Exemple:
<blockquote>
<tt>
antispoof for fxp0 inet
</tt>

</blockquote>

<p>
Quand les règles sont chargées, toutes les occurrences du mot
<tt>antispoof</tt> sont décodées dans deux filtres. Si l'interface
<tt>fxp0</tt> dont l'adresse IP est 10.0.0.1 pour un masque de sous-
réseau de 255.255.255.0 (soit /24) est protégée, l'option
<tt>antispoof</tt> sera décodée ainsi :

<blockquote>
<tt>
block in on ! fxp0 inet from 10.0.0.0/24 to any<br>

block in inet from 10.0.0.1 to any
</tt>
</blockquote>

<p>
Cette règle déclenche deux actions :
<ul>
<li>elle bloque tout le trafic en provenance du réseau 10.0.0.0/24 s'il
    ne passe <i>pas</i> par l'interface <tt>fxp0</tt>. Aucun paquet pour
    ce réseau ne devrait en effet être vu ailleurs que sur cette
    interface.
<li>elle bloque tout le trafic entrant dont l'adresse source est
    10.0.0.1, à savoir celle de l'interface <tt>fxp0</tt>. Cette machine
    ne devrait en effet jamais émettre de paquets à travers une
    interface externe et par conséquent ne doit pas recevoir de paquets
    ayant son adresse IP comme adresse source.
</ul>

<p>
<b>REMARQUE</b> : le filtrage activé par l'option <tt>antispoof</tt>
   d'une règle s'applique également aux paquets envoyés sur l'adresse de
   bouclage interne (loopback). Ce trafic doit donc être explicitement
   autorisé :
<blockquote>
<tt>
pass quick on lo0 all<br>
<br>
antispoof for fxp0 inet
</tt>

</blockquote>

<p>
L'utilisation de l'option <tt>antispoof</tt> est réservée aux interfaces
qui possèdent une adresse IP. Dans le cas contraire, on aboutit au
filtrage suivant :
<blockquote>
<tt>
block drop in on ! fxp0 inet all<br>
block drop in inet all
</tt>
</blockquote>

<p>
Avec ce genre de règles, le risque est réel de bloquer <i>tout</i> le
trafic entrant sur <i>toutes</i> les interfaces.

<a name="osfp"></a>
<h2>Reconnaissance passive d'OS par leurs empreintes</h2>

<p>
La reconnaissance passive d'OS par leurs empreintes (&quot;OS
Fingerprinting&quot; ou OSFP) est une méthode qui permet de reconnaitre
à distance quel système d'exploitation tourne sur une machine. Cette
reconnaissance se base sur les caractéristiques des paquets TCP SYN
renvoyés par une machine. Ces informations peuvent être utilisées comme
critères dans des règles de filtrage.

<p>
PF utilise le fichier
<a href="options.html#fingerprints">d'empreintes</a> <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.os&amp;sektion=5&amp;manpath=OpenBSD+3.6"
><tt>/etc/pf.os</tt></a>
pour reconnaitre les systèmes d'exploitation auxquels il a à faire.
Lorsque PF s'exécute, la liste des empreintes reconnues peut être
consultée gràce à la commande suivante :

<blockquote>
<tt>
# pfctl -s osfp
</tt>
</blockquote>

<p>
Dans une règle, une empreinte peut être désignée sous la forme d'une
classe, d'une version ou d'un sous-type d'OS. La liste de ces éléments
est affichée à l'aide de la commande <tt>pfctl</tt>. Pour désigner une
empreinte dans une règle, il faut utiliser le mot-clef <tt>os</tt> :

<blockquote>
<tt>
pass &nbsp;in on $ext_if any os OpenBSD keep state<br>
block in on $ext_if any os "Windows 2000"<br>
block in on $ext_if any os "Linux 2.4 ts"<br>
block in on $ext_if any os unknown
</tt>
</blockquote>

<p>
<tt>unknown</tt> est une classe spéciale désignant les systèmes
d'exploitation dont l'empreinte n'est pas connue.

<p>
<font color="#ff0000">Notez bien que </font>:
<ul>
  <li>La reconnaissance peut échouer face à des paquets spécifiquement
      construits pour tromper la détection d'empreintes.
  <li>L'application de correctifs peut modifier le comportement de la
      pile TCP/IP d'un système d'exploitation et faire également échouer
      ou tromper la reconnaissance de l'OS.
  <li>L'option OSFP n'est applicable qu'aux paquets TCP SYN. Elle est
      inefficace avec d'autres protocoles et pour les sessions déjà
      établies.
</ul>

<a name="ipopts"></a>
<h2>Les options IP</h2>

PF bloque par défaut tous les paquets qui utilisent les options IP. Cela
rend moins aisé le travail des outils de reconnaissance d'empreintes
tels que nmap. Si une application utilise ces options (par exemple IGMP
ou les diffusions multicast) il est possible d'utiliser l'option <tt>allow-
opts</tt> :

<blockquote>
<tt>
pass in quick on fxp0 all allow-opts
</tt>
</blockquote>

<a name="example"></a>
<h2>Exemple de règles de filtrage</h2>

Vous trouverez ci-dessous un exemple de règles de filtrage pour un pare-
feu PF destiné à protèger un petit réseau connecté à Internet. Seules
les règles de filtrage sont mentionées ;
<a href="queueing.html">queueing</a>,
<a href="nat.html"><tt>nat</tt></a>, 
<a href="rdr.html"><tt>rdr</tt></a>, etc. 
ont été volontairement laissées de côté.
<br>

<br>
<table border=0 width="650">
<tr><td nowrap bgcolor="#EEEEEE">
<pre>
ext_if  = "fxp0"
int_if  = "dc0"
lan_net = "192.168.0.0/24"

# déclaration du tableau référençant toutes les adresses IP affectées au
# pare-feu
table &lt;firewall&gt; const { self }

# Normalisation de tous les paquets entrants
scrub in all

# Mise en place d'une politique d'interdiction par défaut
block in  all
block out all

# Autorisation du trafic dans les deux sens sur l'adresse de bouclage
# interne
pass quick on lo0 all

# Activation de la protection contre l'usurpation sur l'interface
# externe.
antispoof quick for $int_if inet

# Les connexions ssh ne sont autorisées qu'en provenance du réseau local
# et de la machine 192.168.0.15. "block return" provoque l'émission d'un
# paquet TCP RST pour mettre fin aux connexions illicites. "quick"
# assure que que cette règle n'est pas contredite par les règles "pass".
block return in quick on $int_if proto tcp from ! 192.168.0.15 \
   to $int_if port ssh flags S/SA

# Autoriser le trafic sortant et entrant sur le réseau local.
pass in  on $int_if from $lan_net to any
pass out on $int_if from any to $lan_net

# Autoriser les connexions sortantes tcp, udp et icmp sur l'interface
# externe.
# Activer le suivi des états pour les protocoles udp et icmp.
# Activer l'option modulate state sur les paquets tcp.

pass out on $ext_if proto tcp all modulate state flags S/SA
pass out on $ext_if proto { udp, icmp } all keep state

# Autoriser les connexions ssh sur l'interface externe du moment
# qu'elles ne sont pas destinées au pare-feu lui-même Journalise le
# paquet qui initie la session afin de pouvoir déterminer qui s'est
# connecté. Activer un service mandataire SYN.
pass in log on $ext_if proto tcp from any to ! &lt;firewall&gt; \
   port ssh flags S/SA synproxy state
</pre>
</td></tr>
</table>

<p>
[<a href="tables.html">Section précédente : Tables</a>]
[<a href="index.html">Index</a>]
[<a href="nat.html">Section suivante : Traduction des Adresses IP (&quot;NAT&quot;)</a>]


<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../../images/back.gif" border="0" alt="[back]"></a> 
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
Originally [OpenBSD: filter.html,v 1.26 ]<br>
$Translation: filter.html,v 1.12 2004/12/29 10:33:01 saad Exp $<br>
$OpenBSD: filter.html,v 1.8 2004/12/29 10:38:26 saad Exp $
</small>

</body>
</html>
