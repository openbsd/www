<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>PF : Exemple : Pare-feu SoHo</title>
<link rev="made" href="mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="resource-type" content="document">
<meta name="description"   content="the OpenBSD FAQ page">
<meta name="keywords"      content="openbsd,faq,pf">
<meta name="distribution"  content="global">
</head>

<!--
Copyright (c) 2003, 2004 Joel Knight <enabled@myrealbox.com>

Permission to use, copy, modify, and distribute this documentation for
any purpose with or without fee is hereby granted, provided that the
above copyright notice and this permission notice appear in all copies.

THE DOCUMENTATION IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
WARRANTIES WITH REGARD TO THIS DOCUMENTATION INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS DOCUMENTATION
-->

<body bgcolor="#ffffff" text="#000000">
<!-- Passes validator.w3.org, please keep it this way;
please, use a max of 72 chars per line -->

<img alt="[OpenBSD]" height=30 width=141 src="../../../images/smalltitle.gif">
<p>
[<a href="authpf.html">Précédent : Authpf: Shell
Utilisateur pour les Passerelles d'Authentification</a>]
[<a href="index.html">Index</a>]

<p>
<h1><font color="#e00000">PF : Exemple : Pare-feu SoHo</font></h1>
<hr>

<h3>Table des Matières</h3>
<ul>
<li><a href="#scenario">Le Scenario</a>
        <ul>
        <li><a href="#network">Le Réseau</a>
        <li><a href="#objective">Les Objectifs</a>
        <li><a href="#prep">Préparation</a>
        </ul>
<li><a href="#ruleset">Le Jeu de Règles</a>
        <ul>
        <li><a href="#macros">Macros</a>
        <li><a href="#options">Options</a>
        <li><a href="#scrub">Scrub</a>
        <li><a href="#nat">Traduction d'Adresses Réseau</a>
        <li><a href="#rdr">Redirection</a>
        <li><a href="#filter">Règles de Filtrage</a>
        </ul>
<li><a href="#allrules">Le Jeu de Règles Complet</a>
</ul>

<hr>

<a name="scenario"></a>
<h2>Le Scenario</h2>
Dans cet exemple, PF fonctionne sur une machine OpenBSD jouant le rôle
de pare-feu et de passerelle NAT pour un réseau SoHo. L'objectif global
est de fournir un accès Internet au réseau local et de fournir un accès
limité au pare-feu depuis Internet. Ce document a pour but de vous
montrer comment on construit un jeu de règles correspondant à l'objectif
précité.

<a name="network"></a>
<h3>Le Réseau</h3>
Le réseau est conçu de la manière suivante :

<pre>
    
  [ COMP1 ]    [ COMP3 ]
      |            |                               ADSL
   ---+------+-----+------- fxp0 [ OpenBSD ] ep0 -------- ( Internet )
             |
         [ COMP2 ]

</pre>

<p>
Il y a un certain nombre de machines sur le réseau interne. Le diagramme
en montre trois mais le vrai nombre n'est pas une donnée utile. Ces
machines sont des stations de travail normales servant à surfer sur le
web, écrire des messages électroniques, participer à des forums de
discussion en ligne, etc à l'exception de COMP3 qui sert aussi de
serveur Web. Le réseau interne utilise le bloc de réseau
192.168.0.0 / 255.255.255.0.

<p>
Le routeur OpenBSD est une machine dotée d'un Pentium 100 et de deux
cartes réseau : une 3Com 3c509B (<tt>ep0</tt>) et d'une Intel
EtherExpress Pro/100 (<tt>fxp0</tt>). Le routeur a une connexion ADSL
vers Internet et utilise la NAT pour partager cette connexion avec le
réseau interne. L'adresse IP de l'interface externe est attribuée
dynamiquement par le Fournisseur d'Accès Internet.

<a name="objective"></a>
<h3>Les Objectifs</h3>
Les objectifs sont les suivants :
<ul>
<li>Fournir un accès Internet sans restriction pour chaque machine du
    réseau interne.
<li>Utiliser un jeu de règles bloquant tout flux par défaut.
<li>Autoriser les flux entrants suivants sur le pare-feu à partir
    d'Internet :
        <ul>
        <li>SSH (port TCP 22) : utilisé pour la maintenance externe du
            pare-feu.
        <li>Auth/Ident (port TCP 113): utilisé par quelques services
            tels que SMTP et IRC.
        <li>Messages ICMP "Echo Request" : Le type de paquet ICMP
            utilisé par
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ping&amp;sektion=8&amp;manpath=OpenBSD+3.5">ping(8)</a>.
        </ul>
<li>Rediriger les tentatives de connexion sur le port TCP 80 (qui sont
    des tentatives d'accès à un serveur Web) vers la machine COMP3. Et
    autoriser aussi le trafic vers le port TCP 80 destiné à COMP3 à
    travers le pare-feu.
<li>Enregistrer des statistiques de filtrage pour l'interface externe.
<li>Par défaut, renvoyer un RST TCP ou un message ICMP "Unreachable"
    pour les paquets bloqués.
<li>S'assurer que le jeu de règles est aussi simple et facile à
    maintenir que possible.
</ul>

<a name="prep"></a>
<h3>Préparation</h3>
Ce document suppose que le hôte OpenBSD a été correctement configuré
pour fonctionner comme routeur : configuration réseau, connexion
Internet, <tt>net.inet.ip.forwarding</tt> avec une valeur de
"<tt>1</tt>" etc.

<a name="ruleset"></a>
<h2>Le Jeu de Règles</h2>
Les sections ci-après détaillent la manière dont le jeu de règles
répondra aux objectifs précités.

<a name="macros"></a>
<h3>Macros</h3>
Les macros suivantes sont définies pour rendre la maintenance et la
lecture du jeu de règles plus faciles :
<blockquote>
<tt>
int_if = "fxp0"<br>
ext_if = "ep0"<br>
<br>
tcp_services = "{ 22, 113 }"<br>
icmp_types = "echoreq"<br>
<br>
priv_nets = "{ 127.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, 10.0.0.0/8 }"
<br>
<br>
comp3 = "192.168.0.3"
</tt>
</blockquote>

<p>
Les deux premières lignes définissent les interfaces réseau sur
lesquelles le filtrage sera effectué. Les deux lignes suivantes listent
les numéros de port TCP des services ouverts depuis Internet (SSH et
ident/auth) et les types de paquets ICMP qui sont autorisés à parvenir
jusqu'aù pare-feu. La cinquième ligne définit le réseau de loopback et
les blocs d'adresses
<a href="http://www.geektools.com/rfc/rfc1918.txt">RFC 1918</a>.
Enfin, la dernière ligne définit l'adresse IP de COMP3.

<p>
<b>Remarque</b> : Si la connexion Internet ADSL nécessite l'utilisation
   de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppoe&amp;sektion=8&amp;manpath=OpenBSD+3.5">PPPoE</a>, 
   le filtrage et la NAT s'effectueront sur l'interface <tt>tun0</tt> au
   lieu de <tt>ep0</tt>.

<a name="options"></a>
<h3>Options</h3>
Les deux options suivantes spécifient la réponse par défaut fournie par
les règles de filtrage <tt>block</tt> et activent la collecte de
statistiques sur l'interface externe :
<blockquote>
<tt>
set block-policy return<br>
set loginterface $ext_if
</tt>
</blockquote>

<a name="scrub"></a>
<h3>Scrub</h3>
Il n'y a aucune raison pour ne pas utiliser la normalisation de paquets
recommandée pour tous les paquets entrants. Il suffit d'utiliser la
ligne suivante :

<blockquote>
<tt>
scrub in all
</tt>
</blockquote>

<a name="nat"></a>
<h3>Traduction d'Adresses Réseau</h3>
Pour effectuer la NAT du réseau interne, la règle de <tt>nat</tt>
suivante est utilisée :

<blockquote>
<tt>
nat on $ext_if from $int_if:network to any -&gt; ($ext_if)
</tt>
</blockquote>

<p>
Vu que l'adresse IP de l'interface externe est attribuée dynamiquement,
des parenthèses sont utilisés autour de l'interface de traduction afin
que PF tienne compte automatiquement des changements d'adresse IP sur
cette interface.

<a name="rdr"></a>
<h3>Redirection</h3>
La première redirection est pour
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftp-proxy&amp;sektion=8&amp;manpath=OpenBSD+3.5">ftp-proxy(8)</a> 
afin de permettre aux clients FTP sur le réseau interne de se connecter
à des serveurs FTP sur Internet.
<blockquote>
<tt>
rdr on $int_if proto tcp from any to any port 21 -&gt; 127.0.0.1 port 8021
</tt>
</blockquote>

<p>
Il est à noter que cette règle ne fonctionnera que pour les connexions
FTP au port 21. Si les utilisateurs se connectent de manière régulière à
des serveurs FTP sur d'autres ports, une liste devra être utilisée pour
spécifier le port de destination, par exemple : <tt>from any to any port
{ 21, 2121 }</tt>.

<p>
La seconde règle de redirection est utilisée pour toutes les tentatives
de connexion sur le port TCP 80 du pare-feu en provenance d'Internet.
Les tentatives légitimes d'accès à ce port seront générées par des
utilisateurs qui essaient d'accèder au serveur web du réseau. Ces
tentatives de connexion doivent être redirigées vers COMP3 :

<blockquote>
<tt>
rdr on $ext_if proto tcp from any to any port 80 -&gt; $comp3
</tt>
</blockquote>

<a name="filter"></a>
<h3>Règles de Filtrage</h3>
Détaillons maintenant les règles de filtrage. Commencez par
l'interdiction par défaut de tout trafic :
<blockquote>
<tt>
block all<br>
</tt>
</blockquote>

<p>
Avec cette règle, aucun trafic ne sera autorisé y compris le trafic
provenant du réseau interne. Les règles ci-après vont ouvrir un certain
nombre de flux sur le pare-feu afin de répondre aux objectifs précités
et d'ouvrir toutes les interfaces virtuelles nécessaires.

<p>
Tout système Unix a une interface de "loopback". C'est une interface
virtuelle représentant un réseau utilisé par les applications pour
établir des canaux de communication locaux à la machine. De manière
générale, tout le trafic au niveau de l'interface de "loopback" doit
être autorisé. Sous OpenBSD, l'interface de "loopback" est
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lo&amp;sektion=4&amp;manpath=OpenBSD+3.5">lo(4)</a>.
<blockquote>
<tt>
pass quick on lo0 all
</tt>
</blockquote>

<p>
Ensuite, les adresses
<a href="http://www.geektools.com/rfc/rfc1918.txt">RFC 1918</a>
doivent être bloquées en entrée et en sortie de l'interface externe. Ces
adresses ne doivent jamais apparaître sur le réseau Internet public.
Leur filtrage permet de s'assurer que le routeur ne divulgue pas les
adresses utilisées par le réseau interne et de bloquer tous les paquets
entrants avec une adresse source appartenant à l'un de ces réseaux.
<blockquote>
<tt>
block drop in &nbsp;quick on $ext_if from $priv_nets to any<br>
block drop out quick on $ext_if from any to $priv_nets
</tt>
</blockquote>

<p>
Il est à noter que <tt>block drop</tt> est utilisé pour dire à PF de ne
pas répondre par un paquet TCP RST ou ICMP "Unreachable". Vu que les
adresses correspondant à la RFC 1918 n'existent pas sur Internet, tout
paquet envoyé vers une de ces adresses ne sera jamais acheminé vers sa
destination de toute façon. L'option <tt>quick</tt> est utilisée pour
dire à PF de ne pas évaluer le reste des règles de filtrage si un paquet
correspond à l'une des règles ci-dessus; les paquets de et vers les
réseaux <tt>$priv_nets</tt> seront immédiatement détruits.

<p>
Maintenant, il faut ouvrir les ports utilisés par les services réseau
disponibles depuis Internet :
<blockquote>
<tt>
pass in on $ext_if inet proto tcp from any to ($ext_if) \<br>
&nbsp;&nbsp;&nbsp;port $tcp_services flags S/SA keep state
</tt>
</blockquote>

<p>
La spécification des ports réseau par le biais de la macro
<tt>$tcp_services</tt> rend l'ouverture de nouveaux services pour des
connexions provenant d'Internet plus facile dans la mesure où il suffira
de modifier la macro et recharger le jeu de règles. Des services UDP
peuvent aussi être mis à disposition en créant la macro
<tt>$udp_services</tt> et en ajoutant une règle de filtrage adéquate
similaire à la règle de filtrage ci-dessus en spécifiant <tt>proto
udp</tt>.

<p>
En plus de la règle <tt>rdr</tt> qui fait suivre tout le trafic web vers
COMP3, nous DEVONS aussi autoriser ce trafic à travers le pare-feu :
<blockquote>
<tt>
pass in on $ext_if proto tcp from any to $comp3 port 80 \<br>
&nbsp;&nbsp;&nbsp;&nbsp;flags S/SA synproxy state
</tt>
</blockquote>

<p>
Pour un niveau de sécurité plus élevé, nous utilisons
<a href="filter.html#synproxy">TCP SYN Proxy</a> pour améliorer la
protection du web serveur.

<p>
Le trafic ICMP doit aussi être permis :
<blockquote>
<tt>
pass in inet proto icmp all icmp-type $icmp_types keep state
</tt>
</blockquote>

<p>
Comme pour la macro <tt>$tcp_services</tt>, la macro
<tt>$icmp_types</tt> peut facilement être modifiée pour changer les
types des paquets ICMP qui doivent être autorisés à atteindre le pare-
feu. Notez que cette règle s'applique à toutes les interfaces réseau.

<p>
Maintenant, le trafic en provenance du réseau interne doit être
autorisé. Nous supposerons que les utilisateurs du réseau interne savent
ce qu'ils font et ne provoqueront pas de problème sur Internet. Ce n'est
pas nécessairement une bonne supposition; pour certains environnements,
il serait plus judicieux d'utiliser un jeu de règles plus restrictif.
<blockquote>
<tt>
pass in on $int_if from $int_if:network to any keep state
</tt>
</blockquote>

<p>
La règle ci-dessus permettra à n'importe quelle machine interne
d'envoyer des paquets à travers le pare-feu; cependant, le pare-feu ne
sera <i>pas</i> autorisé à à initier une connexion vers une machine
interne. Est-ce une bonne idée ? Ceci dépendra de certains détails fins
de la configuration réseau. Si le pare-feu est aussi un serveur DHCP, il
aurait éventuellement besoin de vérifier la présence d'une adresse
("ping") pour voir si elle est disponible avant de l'attribuer à une
machine. Permettre au pare-feu de se connecter au réseau interne veut
dire aussi que quelqu'un qui accéderait en SSH au pare-feu depuis
Internet sera autorisé à accèder aux machines sur le réseau. Gardez à
l'esprit qu'interdire au pare-feu de communiquer directement avec le
réseau n'est pas d'un grand bénéfice du point de vue de la sécurité; si
quelqu'un accède au pare-feu, il pourra très probablement altérer les
règles de filtrage de toute façon. En ajoutant la règle suivante, le 
pare-feu sera capable d'initier des connexions vers le réseau interne :
<blockquote>
<tt>
pass out on $int_if from any to $int_if:network keep state
</tt>
</blockquote>

<p>
Notez que si les deux lignes ci-dessus sont utilisées, l'option <tt>keep
state</tt> n'est pas nécessaire car il y a une règle pour laisser passer
les paquets dans les deux directions. Cependant, si la ligne <tt>pass
out</tt> n'est <i>pas</i> utilisée, la règle <tt>pass in</tt>
<i>doit</i> comporter l'option <tt>keep state</tt>. Garder l'état d'une
connexion permet aussi d'améliorer les performances : Les tables d'état
sont vérifiées avant l'évaluation des règles, et si un état est trouvé,
le passage du paquet à travers le pare-feu est autorisé sans que le jeu
de règles ne soit évalué. Cette méthode de fonctionnement peut offrir de
meilleures performances pour un pare-feu très chargé bien que pour un
système aussi simple, la charge ne sera très certainement pas assez
significative pour que cela fasse une différence.

<p>
Finalement, il faut laisser le trafic sortir de l'interface externe :
<blockquote>
<tt>
pass out on $ext_if proto tcp all modulate state flags S/SA<br>
pass out on $ext_if proto { udp, icmp } all keep state
</tt>
</blockquote>

<p>
Le trafic TCP, UDP, et ICMP à destination d'Internet est autorisé sortir
du pare-feu. L'information sur l'état des connexions est sauvegardée
pour permettre aux paquets de retour de passer à leur tour la barrière
que constitue le pare-feu.

<a name="allrules"></a>
<h2>Le Jeu de Règles Complet</h2>
<table border=0 width="650">
<tr><td nowrap bgcolor="#EEEEEE">
<pre>
# macros
int_if = "fxp0"
ext_if = "ep0"

tcp_services = "{ 22, 113 }"
icmp_types = "echoreq"

priv_nets = "{ 127.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, 10.0.0.0/8 }"
          
comp3 = "192.168.0.3"

# options
set block-policy return
set loginterface $ext_if

# scrub
scrub in all

# nat/rdr
nat on $ext_if from $int_if:network to any -&gt; ($ext_if)
rdr on $int_if proto tcp from any to any port 21 -&gt; 127.0.0.1 \
   port 8021
rdr on $ext_if proto tcp from any to any port 80 -&gt; $comp3

# règles de filtrage
block all

pass quick on lo0 all

block drop in  quick on $ext_if from $priv_nets to any
block drop out quick on $ext_if from any to $priv_nets

pass in on $ext_if inet proto tcp from any to ($ext_if) \
   port $tcp_services flags S/SA keep state

pass in on $ext_if proto tcp from any to $comp3 port 80 \
   flags S/SA synproxy state

pass in inet proto icmp all icmp-type $icmp_types keep state

pass in  on $int_if from $int_if:network to any keep state
pass out on $int_if from any to $int_if:network keep state

pass out on $ext_if proto tcp all modulate state flags S/SA
pass out on $ext_if proto { udp, icmp } all keep state
</pre>
</td></tr>
</table>

<p>
[<a href="authpf.html">Précédent : Authpf: Shell
Utilisateur pour les Passerelles d'Authentification</a>]
[<a href="index.html">Index</a>]

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../../images/back.gif" border="0" alt="[back]"></a> 
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
Originally [OpenBSD: example1.html,v 1.15 ]<br>
$Translation: example1.html,v 1.8 2004/10/11 16:43:24 saad Exp $<br>
$OpenBSD: example1.html,v 1.8 2004/10/12 07:18:40 jufi Exp $
</small>

</body>
</html> 
