<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>6 - Networking</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2005 by OpenBSD.">
</head>

<body bgcolor="#ffffff" text="#000000">
<!-- passes validator.w3.org, please keep it this way -->

<a href="../../nl/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">    
</a>
<p>
<font color="#0000e0">
<a href="index.html">[FAQ Index]</a>
<a href="faq5.html">[Naar Sectie 5 - Het Systeem vanaf Broncode Bouwen]</a>
<a href="faq7.html">[Naar Sectie 7 - Toetsenbord en Scherm Bediening]</a>
</font>

<h1><font color="#e00000">6 - Netwerken</font></h1>
<hr>

<p>
<h3>Inhoudstafel</h3>
<ul>
<li><a href= "#Intro" >6.1 - Voor we verder gaan</a>
<li><a href= "#Setup" >6.2 - Initiële netwerkinstelling</a>
<li><a href= "#PF"    >6.3 - Hoe filter en firewall ik met OpenBSD?</a>
<li><a href= "#DHCP"  >6.4 - Dynamic Host Configuration Protocol (DHCP)</a>
<li><a href= "#PPP"   >6.5 - Point to Point Protocol</a>
<li><a href= "#Tuning">6.6 - Netwerkparameters tunen</a>
<li><a href= "#NFS"   >6.7 - NFS gebruiken</a>
<li><a href= "#Bridge">6.9 - Een bridge opzetten met OpenBSD</a>
<li><a href= "#PXE"   >6.10 - Hoe boot ik met PXE?</a>
<li><a href= "#CARP"  >6.11 - Het Common Address Redundancy Protocol (CARP)</a>
<li><a href="#OpenNTPD">6.12 - OpenNTPD gebruiken</a>
<li><a href="#Wireless">6.13 - Wat zijn mijn draadloze netwerkmogelijkheden?</a>
</ul>

<hr>

<p>
<a name="Intro"></a>
<h2>6.1 - Voor we verder gaan</h2>

<p>
Voor het overgrote deel van dit document helpt het als u de
<a href="faq5.html">Kernel Configuratie en Instelling</a> sectie van de FAQ, de
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a> en
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&amp;sektion=1">
netstat(1)</a> man pagina's gelezen en tenminste gedeeltelijk begrepen hebt.

<p>
Als u een netwerkbeheerder bent, en u bent routeringsprotocols aan het
opzetten, als u uw OpenBSD machine als een router gebruikt, als u diep
moet ingaan op IP networken, moet u echt
<a href="http://www.3com.com/other/pdfs/infra/corpinfo/en_US/501302.pdf">Understanding
IP Addressing</a> lezen.
Dit is een uistekend document.  "Understanding IP Addressing" bevat
fundamentele kennis waarop u kan bouwen wanneer u werkt met IP netwerken,
vooral wanneer u met één of meer netwerken te maken hebt of er
verantwoordelijk voor bent.

<p>
Indien u werkt met toepassingen zoals web servers, ftp servers en
mail servers, kan u uw voordeel doen door
<a href="http://www.rfc-editor.org/rfc.html">de RFC's te lezen</a>.
Waarschijnlijk kan u ze niet allemaal lezen. Kies er een aantal onderwerpen
uit die u interesseren of die u gebruikt in uw netwerkomgeving. Zoek ze op,
kom te weten hoe ze bedoeld zijn om te werken. De RFC's definiëren
vele (duizenden) standaarden voor protocols op het Internet en hoe ze
zouden moeten werken.

<p>
<a name="Setup"></a>
<h2>6.2 - Initiële netwerkinstelling</h2>

<p>
<a name="Setup.1"></a>
<h3>6.2.1 - Het Identificeren en Instellen van Uw Netwerk Interfaces</h3>

<p>
Om te beginnen moet u eerst uw netwerk interfaces identificeren. In
OpenBSD worden interfaces benoemd volgens het kaarttype, niet volgens het
verbindingstype. U kan uw netwerkkaart geïnitialiseerd zien worden tijdens
het bootproces, of na het bootproces door gebruik van het
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)</a>
commando. U hebt ook de gelegenheid om uw netwerk interfaces te zien met het
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a> commando.
Hier is bijvoorbeeld de uitvoer van dmesg voor een Intel Fast Ethernet
netwerkkaart, die de device naam fxp gebruikt.

<blockquote><pre>
fxp0 at pci0 dev 10 function 0 "Intel 82557" rev 0x0c: irq 5, address 00:02:b3:2b:10:f7
inphy0 at fxp0 phy 1: i82555 10/100 media interface, rev. 4
</pre></blockquote>

<p>
Als u niet weet wat uw device naam is, kijk dan naar de
<a href="../../nl/plat.html">ondersteunde hardware lijst</a> voor uw platform.
U zal daar een lijst terugvinden van veel voorkomende kaartnamen en hun
OpenBSD device namen. Combineer de korte alfabetische device naam
(zoals fxp) met een nummer toegekend door de kernel en u hebt een
interface naam (zoals fxp0).

<p>
U kan te weten komen welke netwerk interfaces er geïdentificeerd zijn
met de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
utility. Het volgende commando zal alle netwerk interfaces op een systeem
weergeven. Deze voorbeelduitvoer toont ons slechts één fysische
ethernet interface,
een <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp&amp;sektion=4">fxp(4)</a>.

<blockquote><pre>
$ <strong>ifconfig -a</strong>
lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 33224
        inet 127.0.0.1 netmask 0xff000000
        inet6 ::1 prefixlen 128
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x5
lo1: flags=8008&lt;LOOPBACK,MULTICAST&gt; mtu 33224
fxp0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        address: 00:04:ac:dd:39:6a
        media: Ethernet autoselect (100baseTX full-duplex)
        status: active
        inet 10.0.0.38 netmask 0xffffff00 broadcast 10.0.0.255
        inet6 fe80::204:acff:fedd:396a%fxp0 prefixlen 64 scopeid 0x1
pflog0: flags=0&lt;&gt; mtu 33224
pfsync0: flags=0&lt;&gt; mtu 2020
sl0: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt; mtu 296
sl1: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt; mtu 296
ppp0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500
ppp1: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500
tun0: flags=10&lt;POINTOPOINT&gt; mtu 3000
tun1: flags=10&lt;POINTOPOINT&gt; mtu 3000
enc0: flags=0&lt;&gt; mtu 1536
bridge0: flags=0&lt;&gt; mtu 1500
bridge1: flags=0&lt;&gt; mtu 1500
vlan0: flags=0&lt;&gt; mtu 1500
        address: 00:00:00:00:00:00
vlan1: flags=0&lt;&gt; mtu 1500
        address: 00:00:00:00:00:00
gre0: flags=9010&lt;POINTOPOINT,LINK0,MULTICAST&gt; mtu 1450
carp0: flags=0&lt;&gt; mtu 1500
carp1: flags=0&lt;&gt; mtu 1500
gif0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif1: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif2: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif3: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
</pre></blockquote>

<p>
Zoals u hier kan zien, geeft
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a> 
ons veel meer informatie dan we op dit punt nodig hebben. Maar het laat
ons wel toe om onze interface te zien. In het bovenstaande voorbeeld
is de interface kaart al geconfigureerd. Dit spreekt voor zich omdat er al
een IP netwerk geconfigureerd is op fxp0, vandaar de waarden &quot;inet
10.0.0.38 netmask 0xffffff00 broadcast 10.0.0.255&quot;.  Ook de
<strong>UP</strong> en <strong>RUNNING</strong> vlaggen zijn aangezet.

<p>
Tenslotte zal u merken dat verscheidene andere interfaces standaard
ingeschakeld zijn. Dit zijn virtuele interfaces die voor verschillende
functies dienen. De volgende manual pagina's beschrijven ze:

<ul>
<!-- XXXrelease -->
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lo&amp;sektion=4">lo</a>
 - Loopback Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflog&amp;sektion=4">pflog</a>
 - Packet Filter Logging Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sl&amp;sektion=4">sl</a>
 - SLIP Network Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=4">ppp</a>
 - Point to Point Protocol
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tun&amp;sektion=4">tun</a>
 - Tunnel Network Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=enc&amp;sektion=4">enc</a>
 - Encapsulating Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4">bridge</a>
 - Ethernet Bridge Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vlan&amp;sektion=4">vlan</a>
 - IEEE 802.1Q Encapsulation Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gre&amp;sektion=4">gre</a>
 - GRE/MobileIP Encapsulation Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gif&amp;sektion=4">gif</a>
 - Generic IPv4/IPv6 Tunnel Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=carp&amp;sektion=4">carp</a>
 - Common Address Redundancy Protocol Interface
</ul>

<p>
Als u uw interface nog niet geconfigureerd hebt, is de eerste stap om
een <i>/etc/hostname.xxx</i> bestand aan te maken, waarin de naam van uw
interface de plaats van "xxx" zal innemen. Uitgaande van de informatie in de
bovenstaande voorbeelden, zou de naam <i>/etc/hostname.fxp0</i> zijn.
De layout van dit bestand is eenvoudig:<br>

<blockquote><pre>
address_family address netmask broadcast [andere opties]
</pre></blockquote>

(Veel meer details over het formaat van dit bestand vindt u terug in de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5">hostname.if(5)</a>
man pagina.)

<p>
Een typisch configuratiebestand, geconfigureerd voor een IPv4 adres,
zou er als volgt uitzien:

<blockquote><pre>
$ <strong>cat /etc/hostname.fxp0</strong>
inet 10.0.0.38 255.255.255.0 NONE
</pre></blockquote>

<p>
U zou ook media types voor Ethernet kunnen specificeren, als u bijvoorbeeld
100baseTX full-duplex mode zou willen forceren.

<blockquote><pre>
inet 10.0.0.38 255.255.255.0 NONE media 100baseTX mediaopt full-duplex
</pre></blockquote>

<p>
(Natuurlijk mag u nooit full duplex mode forceren tenzij beide uiteinden
van de verbinding hierop ingesteld zijn! Tenzij er speciale behoeften
zijn, worden de media instellingen beter achterwege gelaten.)

<p>
Of, u wil misschien speciale vlaggen specifiek voor een bepaalde interface
gebruiken. Aan het formaat van het hostname bestand verandert niet veel!

<blockquote><pre>
$ <strong>cat /etc/hostname.vlan0</strong>
inet 172.21.0.31 255.255.255.0 NONE vlan 2 vlandev fxp1
</pre></blockquote>

<p>
Van hier af is de volgende stap het instellen van uw standaard gateway.
Om dit te doen zet u eenvoudigweg het IP adres van uw gateway in het bestand
<i>/etc/mygate</i>. Dit zorgt ervoor dat uw gateway tijdens het opstarten
ingesteld wordt. Van hier af zou u uw nameservers moeten instellen, en uw
<i>/etc/hosts</i> bestand (zie de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hosts&amp;sektion=5">hosts(5)</a>
man pagina). Om uw nameservers in te stellen, creëert u een bestand met
de naam <i>/etc/resolv.conf</i>. U kan meer lezen over het formaat van dit
bestand in de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&amp;sektion=5">resolv.conf(5)</a>
man pagina.
Als u DHCP gebruikt, zal u <a href="#DHCP">6.4 - DHCP</a> willen lezen,
daarbij lettend op
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf.tail&amp;sektion=5">resolv.conf.tail(5)</a>.
Maar voor standaard gebruik volgt hier een voorbeeld.

<p>
In dit voorbeeld zijn uw domein servers 125.2.3.4 en 125.2.3.5.
U behoort ook tot het domein &quot;example.com&quot;.

<blockquote><pre>
$ <strong>cat /etc/resolv.conf</strong>
search example.com
nameserver 125.2.3.4
nameserver 125.2.3.5
lookup file bind
</pre></blockquote>

<p>
Van hieruit kan u ofwel herstarten ofwel het
<strong>/etc/netstart</strong> script uitvoeren. U kan dit doen door
gewoon het volgende (als root) te typen:

<blockquote><pre>
# <strong>sh /etc/netstart</strong>
writing to routing socket: File exists
add net 127: gateway 127.0.0.1: File exists
writing to routing socket: File exists
add net 224.0.0.0: gateway 127.0.0.1: File exists
</pre></blockquote>

<p>
Merk op dat dit enkele fouten produceerde. Door dit script uit te voeren,
herconfigureert u dingen die reeds geconfigureerd waren. Zodoende bestaan
sommige routes al in de kernel routeringstabel. Van hier af zou uw systeem
goed en wel draaiende en on-line moeten zijn. U kan opnieuw nagaan of uw
interface juist werd ingesteld met
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>.
U kan ook uw routes nakijken met
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&amp;sektion=1">netstat(1)</a>
of <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=route&amp;sektion=8">route(8)</a>.
Als u routeringsproblemen hebt, kunt u de -n vlag van route(8) gebruiken,
die de IP adressen weergeeft, veeleer dan een DNS lookup te doen en de
hostname weer te geven. Hier is een voorbeeld van het bekijken van uw
routeringstabellen met beide programma's.

<blockquote><pre>
$ <strong>netstat -rn</strong>
Routing tables

Internet:
Destination        Gateway            Flags     Refs     Use    Mtu  Interface
default            10.0.0.1           UGS         0       86      -  fxp0
127/8              127.0.0.1          UGRS        0        0      -  lo0
127.0.0.1          127.0.0.1          UH          0        0      -  lo0
10.0.0/24          link#1             UC          0        0      -  fxp0
10.0.0.1           aa:0:4:0:81:d      UHL         1        0      -  fxp0
10.0.0.38          127.0.0.1          UGHS        0        0      -  lo0
224/4              127.0.0.1          URS         0        0      -  lo0

Encap:
Source             Port  Destination        Port  Proto SA(Address/SPI/Proto)

$ <strong>route show</strong>
Routing tables

Internet:
Destination      Gateway            Flags
default          10.0.0.1           UG
127.0.0.0        LOCALHOST          UG
localhost        LOCALHOST          UH
10.0.0.0         link#1             U
10.0.0.1         aa:0:4:0:81:d      UH
10.0.0.38        LOCALHOST          UGH
BASE-ADDRESS.MCA LOCALHOST          U
</pre></blockquote>

<p>
<a name="Setup.2"></a>
<h3>6.2.2 - Uw OpenBSD machine instellen als een Gateway</h3>

<p>
Dit is de basisinformatie die u nodig hebt om uw OpenBSD machine in te
stellen als een gateway (ook router genoemd). Als u OpenBSD gebruikt als
een router op het Internet, stellen we voor dat u ook de Packet Filter
setup instructies hieronder leest om mogelijk kwaadwillig verkeer te
blokkeren. Ook kan u, door de lage beschikbaarheid van
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4">IPv4</a>
adressen vanwege netwerk service providers en regionale registers, misschien
eens kijken naar Network Address Translation voor informatie over hoe u
uw IP adresruimte kan bewaren.

<p>
De GENERIC kernel heeft al de mogelijkheid om IP Forwarding toe te laten,
maar dit moet ingeschakeld worden. U doet dit best met de 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
utility. Om dit permanent te wijzigen, bewerkt u het bestand
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5">/etc/sysctl.conf</a>
om IP Forwarding toe te laten. Om dit te doen voegt u de volgende lijn toe
in dat configuratiebestand.

<blockquote><pre>
net.inet.ip.forwarding=1
</pre></blockquote>

<p>
Om deze wijziging door te voeren zonder te herstarten, zou u de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
utility rechtstreeks gebruiken. Onthou echter dat die verandering dan na
het herstarten niet meer van kracht is, en dat dit als root moet uitgevoerd
worden.

<blockquote><pre>
# <strong>sysctl net.inet.ip.forwarding=1</strong>
net.inet.ip.forwarding: 0 -&gt; 1
</pre></blockquote>

<p>
Wijzig nu de routes op de andere hosts aan beide uiteinden. Er zijn vele
mogelijke gebruiken van OpenBSD als een router door software als
OpenBSD's eigen <a href="http://www.openbgpd.org/">OpenBGPD</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=routed&amp;sektion=8">routed(8)</a>,
<a href="http://www.mrtd.net">mrtd</a>,
<a href="http://www.zebra.org">zebra</a> en
<a href="http://www.quagga.net">quagga</a> te gebruiken.
OpenBSD heeft in de ports collectie ondersteuning voor zebra, quagga en mrtd.
OpenBGPD en routed worden geïnstalleerd als onderdeel van het base systeem.
OpenBSD ondersteunt
verscheidene T1, HSSI, ATM, FDDI, Ethernet en seriële (PPP/SLIP) interfaces.

<p>
<a name="Setup.3"></a>
<h3>6.2.3 - Aliases instellen op een interface</h3>

<p>
OpenBSD heeft een eenvoudig mechanisme om IP aliases in te stellen op een
interface. Om dit te doen bewerkt u het bestand
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5"><i>/etc/hostname.&lt;if&gt;</i></a>.
Dit bestand wordt bij het opstarten gelezen door het
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstart&amp;sektion=8">/etc/netstart(8)</a>
script, dat deel uitmaakt van de <a href="faq10.html#rc">rc
opstarthiërarchie</a>. In het voorbeeld veronderstellen we dat de
gebruiker een interface <b>dc0</b> heeft en zich op het netwerk 192.168.0.0
bevindt.
Andere belangrijke informatie:

<ul>
<li>IP voor dc0 is 192.168.0.2
<li>NETMASK is 255.255.255.0
</ul>

<p>
Een paar kanttekeningen bij aliases. In OpenBSD gebruikt u alleen de
interface naam. Er is geen verschil tussen de eerste alias en de tweede
alias. In tegenstelling tot bij sommige andere besturingssystemen,
refereert OpenBSD er niet naar als dc0:0, dc0:1.  Als u met ifconfig
refereert naar een specifiek ge-aliased IP, of wanneer u een alias
toevoegt, zeg dan zeker "<tt>ifconfig int alias</tt>" in plaats van
gewoon "<tt>ifconfig int</tt>" op de commandolijn.
U kan aliases verwijderen met "<tt>ifconfig int delete</tt>".

<p>
In de veronderstelling dat u meerdere IP adressen met aliases gebruikt die
zich in hetzelfde IP subnet bevinden, wordt uw netmask instelling voor elke
alias 255.255.255.255. Ze hoeven niet het netmask te volgen van het eerste
IP dat aan de interface verbonden is. In dit voorbeeld,
<i>/etc/hostname.dc0</i>, worden twee aliases toegevoegd aan het device
dc0, dat trouwens geconfigureerd was als 
192.168.0.2 netmask 255.255.255.0.

<blockquote><pre>
# <b>cat /etc/hostname.dc0</b>
inet 192.168.0.2 255.255.255.0 media 100baseTX
inet alias 192.168.0.3 255.255.255.255
inet alias 192.168.0.4 255.255.255.255
</pre></blockquote>

<p>
Zodra u dit bestand hebt gemaakt, vereist het slechts een herstart
om in werking te treden. U kan echter de aliases met de hand tevoorschijn
toveren met de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
utility. Om de eerste alias te activeren zou u het volgende commando
gebruiken:

<blockquote><pre>
# <b>ifconfig dc0 inet alias 192.168.0.3 netmask 255.255.255.255</b>
</pre></blockquote>

<p>
Om deze aliases te bekijken moet u het volgende commando gebruiken:

<blockquote><pre>
$ <b>ifconfig -A</b>
dc0: flags=8863&lt;UP,BROADCAST,NOTRAILERS,RUNNING,SIMPLEX,MULTICAST&gt;
        media: Ethernet manual
        inet 192.168.0.2  netmask 0xffffff00 broadcast 192.168.0.255
        inet 192.168.0.3 netmask 0xffffffff broadcast 192.168.0.3
</pre></blockquote>


<p>
<a name="NAT"></a>
<a name="PF"></a>
<h2>6.3 - Hoe filter en firewall ik met OpenBSD?</h2>
Packet Filter (voortaan PF genoemd) is OpenBSD's systeem om TCP/IP
verkeer te filteren en om Network Address Translation te doen. PF kan
ook TCP/IP verkeer normaliseren en conditioneren, en bandbreedtecontrole
voorzien en pakketvoorrang regelen. Het kan gebruikt worden om krachtige
en flexibele firewalls te maken.
Het wordt beschreven in de <a href="../pf/nl/index.html"><b>PF
Gebruikersgids</b></a>.


<p> 
<a name= "DHCP"></a>
<h2>6.4 - Dynamic Host Configuration Protocol (DHCP)</h2> 

Dynamic Host Configuration Protocol is een manier om netwerk interfaces
"automatisch" te configureren.
OpenBSD kan een DHCP server zijn (die andere machines configureert), een
DHCP client (geconfigureerd door een andere machine), en in sommige gevallen
kan het beide zijn.

<p>
<h3>6.4.1 DHCP Client</h3>

<p>
Om de DHCP client
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient&amp;sektion=8">dhclient(8)</a>
te gebruiken die bij OpenBSD zit, bewerkt u <tt>/etc/hostname.xl0</tt> (dit
veronderstelt dat uw voornaamste ethernet interface xl0 is.
De uwe zou ep0 of fxp0 of nog iets anders kunnen zijn.)
Al wat u in dit hostname bestand moet zetten is '<tt>dhcp</tt>':

<blockquote><pre>
# <b>echo dhcp &gt;/etc/hostname.xl0</b>
</pre></blockquote>

<p>
Dit zorgt ervoor dat OpenBSD automatisch de DHCP client start bij het
opstarten. OpenBSD zal zijn IP adres, standaard gateway en DNS servers
krijgen van de DHCP server.

<p>
Als u een DHCP client vanaf de commandolijn wil starten, zorg er dan voor
dat <tt>/etc/dhclient.conf</tt> bestaat en probeer vervolgens:

<blockquote><pre>
# <b>dhclient fxp0</b>
</pre></blockquote>

<p>
waarbij <tt>fxp0</tt> de interface is waarop u DHCP wenst te ontvangen.

<p>
Hoe u de DHCP client ook start, u kan het bestand
<tt>/etc/dhclient.conf</tt> aanpassen om uw DNS <b>niet</b> te updaten
volgens de dhcp server zijn idee van DNS door eerst de 'request' lijnen
erin te uncommenten (ze zijn voorbeelden van de standaardinstellingen, maar
u moet ze uncommenten om dhclient's standaardinstellingen te overschrijven.)

<blockquote><pre>
request subnet-mask, broadcast-address, time-offset, routers,
      domain-name, domain-name-servers, host-name, lpr-servers, ntp-servers;
</pre></blockquote>

<p>
en daarna verwijdert u <tt>domain-name-servers</tt>.
Natuurlijk kan het zijn dat u ook <tt>hostname</tt> of andere instellingen
wil verwijderen.

<p>
Door de opties in uw
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient.conf&amp;sektion=5">dhclient.conf(5)</a>
bestand te wijzigen, zegt u de DHCP client hoe hij uw
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&amp;sektion=5">resolv.conf(5)</a>
bestand moet opbouwen.
De DHCP client overschrijft gelijk welke informatie die reeds in
resolv.conf(5) staat door de informatie die hij ontvangt van de DHCP server.
Daarom zal u wijzigingen die u manueel aanbracht in resolv.conf, verliezen.

<p>
Er zijn twee mechanismen beschikbaar om dit te voorkomen:

<ul>
<li>
<tt><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient.conf&amp;sektion=5#OPTION+MODIFIERS">OPTION
MODIFIERS</a></tt>
(<b>default</b>, <b>supersede</b>, <b>prepend</b> en <b>append</b>)
laten u toe gelijk welke van de opties in dhclient.conf(5) op te heffen.

<li>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf.tail&amp;sektion=5"><tt>resolv.conf.tail(5)</tt></a>
laat u toe om gelijk wat u wil toe te voegen aan het resolv.conf(5) bestand
aangemaakt door dhclient(8).
</ul>

<p>
Een voorbeeld zou zijn wanneer u DHCP gebruikt maar <tt>lookup file bind</tt>
wil toevoegen aan de resolv.conf(5) aangemaakt door dhclient(8).
Er is hiervoor geen optie in <tt>dhclient.conf</tt> zodat u
<tt>resolv.conf.tail</tt> moet gebruiken om dit te behouden.

<blockquote><pre>
# <b>echo "lookup file bind" &gt /etc/resolv.conf.tail</b>
</pre></blockquote>

Nu zou uw resolv.conf(5) aan het einde "lookup file bind" moeten bevatten.
<blockquote><pre>
nameserver 192.168.1.1
nameserver 192.168.1.2
lookup file bind
</pre></blockquote>

<p>
<h3>6.4.2 DHCP Server</h3>

<p>
Als u OpenBSD als een DHCP server
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd&amp;sektion=8">dhcpd(8)</a>,
wil gebruiken, bewerk dan <tt>/etc/rc.conf.local</tt> zodat het de lijn
<tt>dhcpd_flags=""</tt> bevat.
Zet de interfaces waarvan u wil dat dhcpd er op <b>luistert</b> in
<tt>/etc/dhcpd.interfaces</tt>.

<pre>
     # <b>echo xl1 xl2 xl3 &gt;/etc/dhcpd.interfaces</b>
</pre>

<p>
Bewerk daarna <tt>/etc/dhcpd.conf</tt>.
De opties spreken vrijwel voor zich.

<pre>
        option  domain-name "example.com";
        option  domain-name-servers 192.168.1.3, 192.168.1.5;

        subnet 192.168.1.0 netmask 255.255.255.0 {
                option routers 192.168.1.1;

                range 192.168.1.32 192.168.1.127;
        }
</pre>

<p>
Dit zegt uw DHCP clients dat het domein om aan DNS requests toe te voegen
example.com is (dus, als de gebruiker 'telnet joe' intypt dan zal het
hem naar joe.example.com verwijzen). Het zal hen verwijzen naar DNS
servers 192.168.1.3 en 192.168.1.5. Voor hosts die zich op hetzelfde
netwerk bevinden als een ethernet interface op de OpenBSD machine,
die in het 192.168.1.0/24 bereik staat, zal het hen een IP adres toekennen
tussen 192.168.1.32 en 192.168.1.127. Het zal hun standaard gateway
instellen als 192.168.1.1.

<p>
Als u dhcpd(8) vanaf de commandolijn wil starten, probeer dan na het
bijwerken van
<tt>/etc/dhcpd.conf</tt>:

<pre>
     # <b>touch /var/db/dhcpd.leases</b>
     # <b>dhcpd fxp0</b>
</pre>

<p>
De <tt>touch</tt> lijn is nodig om een leeg
<tt>dhcpd.leases</tt> bestand aan te maken voordat dhcpd(8) kan starten.
De OpenBSD <a href="faq10.html#rc">startup scripts</a> zullen dit bestand
indien nodig bij het opstarten aanmaken, maar als u dhcpd(8) manueel
start, moet u het eerst aanmaken.
<tt>fxp0</tt> is een interface waarop u een DHCP server wil starten.

<p>
Als u DHCP diensten voor een Windows machine aanbiedt, wil u misschien dat
dhcpd(8) de client een 'WINS' server adres meegeeft. Om dit te laten gebeuren,
voegt u gewoon de volgende lijn toe aan uw
<tt>/etc/dhcpd.conf</tt>:

<pre>
     option    netbios-name-servers    192.168.92.55;
</pre>

<p>
(waarin <tt>192.168.92.55</tt> het IP van uw Windows of Samba
server is.) Zie
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcp-options&amp;sektion=5">dhcp-options(5)</a>
voor meer opties die uw DHCP clients misschien willen.


<p>
<a name="PPP"></a>
<h2>6.5 - PPP </h2>

<p>
Het Point to Point Protocol (PPP) is in het algemeen wat gebruikt wordt om
een verbinding op te zetten naar uw ISP via een inbelmodem. OpenBSD heeft 2
manieren om dit te doen:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppd&amp;sektion=8">pppd(8)</a>
 - de kernel PPP daemon
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8">ppp(8)</a>
 - de userland PPP daemon 
</ul>

<p>
ppp en pppd voeren allebei gelijkaardige functies uit, op verschillende
manieren.
pppd werkt met de kernel
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=4">ppp(4)</a>
driver, terwijl ppp in userland werkt met
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tun&amp;sektion=4">tun(4)</a>.
Dit document zal enkel de userland PPP daemon behandelen, omdat deze
gemakkelijker is om te debuggen en om mee te interageren. Om te beginnen
zal u enkele eenvoudige gegevens over uw ISP nodig hebben. Hier is een lijst
van nuttige informatie die u zal nodig hebben.

<ul>
<li>Het inbelnummer van uw ISP
<li>Uw nameserver 
<li>Uw gebruikersnaam en wachtwoord
<li>Uw gateway
</ul>

<p>
U kan zonder sommige hiervan, maar het zou helpen bij het opzetten van ppp.
De userland PPP daemon gebruikt het bestand
<a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.conf.sample">/etc/ppp/ppp.conf</a>
als configuratiebestand. Er staan heel wat nuttige bestanden in
<i>/etc/ppp</i> die verschillende instellingen kunnen hebben voor vele
verschillende situaties. U kan best eens grasduinen in deze directory.

<p>
<h3>Initiële Instelling - voor PPP(8)</h3>

<p>
Initiële Instelling voor de userland PPP daemon bestaat uit het aanpassen
van het <i>/etc/ppp/ppp.conf</i> bestand. Dit bestand bestaat standaard
niet, maar er is een bestand <i>/etc/ppp/ppp.conf.sample</i> dat u gewoon
kan bewerken om uw eigen <i>ppp.conf</i> bestand te maken. Hier zal ik
beginnen met de eenvoudigste en waarschijnlijk meest gebruikte setup. Hier
is een snel gemaakt <i>ppp.conf</i> bestand dat gewoon enkele
standaardwaarden instelt:

<blockquote>
<pre>
default:
set log Phase Chat LCP IPCP CCP tun command     
set device /dev/cua01                           
set speed 115200     
set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \"\" AT OK-AT-OK ATE1Q0 OK \\dATDT\\T TIMEOUT 40 CONNECT"
</pre>
</blockquote>

<p>
De sectie onder het <tt>default:</tt> label wordt elke keer uitgevoerd.
Hier stellen we al onze essentiële informatie in. Met &quot;set
log&quot; stellen we onze logging niveau's in. Dit kan veranderd worden:
verwijs naar
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8">ppp(8)</a>
voor meer info over logging niveau's instellen. Ons device wordt ingesteld
met &quot;set device&quot;. Dit is het device waarop de modem staat. In
dit voorbeeld staat de modem op com poort 2. Daarom zou com poort 1
<i>/dev/cua00</i> zijn. Met &quot;set speed&quot; stellen we de snelheid van
onze inbelverbinding in en met &quot;set dial&quot; stellen we onze
inbelparameters in. Hiermee kunnen we onze timeout tijd instellen, enz.
Deze lijn zou echter min of meer moeten blijven zoals ze is.

<p>
Nu kunnen we overgaan tot het instellen van de informatie, specifiek voor
onze ISP. We doen dit door nog een label toe te voegen onder onze
<tt>default:</tt> sectie. Dit label mag u noemen zoals u wil - het
makkelijkst is om gewoon de naam van uw ISP te gebruiken.
Hier zal ik <tt>myisp:</tt> als ons label gebruiken dat refereert naar onze ISP.
Hier is een eenvoudige instelling die alles omvat wat we nodig hebben om
verbonden te geraken:

<blockquote>
<pre>
myisp:
set phone 1234567   
set login "ABORT NO\\sCARRIER TIMEOUT 5 ogin:--ogin: ppp word: ppp"
set timeout 120   
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
add default HISADDR 
enable dns
</pre>
</blockquote>

<p>
We hebben hier de essentiële info ingesteld voor die specifieke ISP.
De eerste optie &quot;set phone&quot; stelt het inbelnummer van uw ISP in.
De &quot;set login&quot; stelt onze login opties in. Hier hebben we een
timeout van 5 ingesteld; dit betekent dat we onze loginpoging staken na
5 seconden als er geen carrier gevonden wordt. Anders zal hij wachten tot
&quot;login:&quot; verstuurd wordt en vervolgens uw gebruikersnaam en
wachtwoord doorsturen.

<p>
In dit voorbeeld is onze
Username = ppp en Password = ppp. Deze waarden moeten veranderd worden.
De lijn &quot;set timeout&quot; stelt de idle timeout in op 120 seconden
voor de volledige duur van de verbinding. De &quot;set ifaddr&quot; lijn
is een beetje lastig. Hieronder volgt een meer uitvoerige uitleg.

<blockquote><pre>
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
</pre></blockquote>

<p>
In de bovenstaande lijn hebben we het ingesteld volgens het formaat
&quot;<b>set ifaddr
[myaddr[/nn] [hisaddr[/nn] [netmask [triggeraddr]]]]</b>&quot;.
Dus het eerst vermelde IP is wat we als ons IP willen. Als u een statisch
IP hebt, stelt u dat hier in. In ons voorbeeld gebruiken we /0 wat zegt
dat er geen bits van dit IP adres moeten overeenkomen en dat het hele ding
mag vervangen worden. Het tweede vermelde IP is wat we verwachten als
hun IP. Als u dit kent mag u het specificeren. Opnieuw weten we in onze
lijn niet wat er toegekend zal worden, dus we laten het aan hen over om
het ons te zeggen. De derde optie is ons netmask, hier ingesteld op
255.255.255.0.  Als triggeraddr gespecificeerd wordt, wordt het gebruikt
in plaats van myaddr in de initiële IPCP negotiatie. Er zal echter
alleen een adres aanvaard worden dat in het myaddr bereik ligt. Dit is nuttig
wanneer genegotieerd wordt met bepaalde PPP implementaties die geen IP
nummer toekennen tenzij hun peer ``0.0.0.0'' aanvraagt.

<p>
De volgende optie is &quot;add default HISADDR&quot; die onze standaard
route naar hun IP instelt. Dit is 'sticky', wat betekent dat als hun IP
adres verandert, onze route automatisch wordt aangepast. Met &quot;enable
dns&quot; vragen we onze ISP om onze nameserver adressen te authenticeren.
Doe dit NIET als u een lokale DNS draait, aangezien ppp het gebruik ervan
gewoon zal omzeilen door enkele nameserver lijnen te plaatsen in
<i>/etc/resolv.conf</i>.

<p>
In plaats van traditionele login methodes gebruiken vele ISP's nu ofwel
CHAP ofwel PAP authenticatie. Als dit het geval is, zal onze configuratie
er lichtjes anders uitzien:

<blockquote>
<pre>
myisp:
set phone 1234567   
set authname ppp
set authkey ppp
set login
set timeout 120   
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
add default HISADDR 
enable dns
</pre>
</blockquote>

<p>
In het bovenstaande voorbeeld specificeren we onze gebruikersnaam (ppp)
en paswoord (ppp) met respectievelijk authname en authkey. Het is niet nodig
om te specificeren of CHAP of PAP gebruikt wordt - dit wordt automatisch
genegotieerd. "set login" geeft louter aan om proberen in te loggen
met de voorheen opgegeven gebruikersnaam en paswoord.

<p>
<h3>PPP(8) gebruiken</h3>

<p>
Nu we ons <i>ppp.conf</i> bestand hebben ingesteld, kunnen we beginnen met
een verbinding naar onze ISP proberen te maken. Ik zal enkele veelgebruikte
argumenten van ppp toelichten:

<ul>
<li><tt>ppp -auto myisp</tt> - Dit voert ppp uit, configureert uw interfaces,
verbindt naar uw ISP en gaat dan in de achtergrond.
<li><tt>ppp -ddial myisp</tt> - Dit lijkt op -auto, maar als uw verbinding
verbroken wordt zal het proberen opnieuw te verbinden.
</ul>

<p>
Als het bovenstaande niet werkt, probeer dan <i>/usr/sbin/ppp</i> zonder
opties uit te voeren - dit zal ppp in interactieve modus draaien.
De opties kunnen één voor één gespecificeerd
worden om fouten of andere problemen op te sporen. Met de instellingen van
hierboven zal ppp loggen naar /var/log/ppp.log. Die log zal, net als de
man pagina, alle nuttige informatie bevatten.

<p>
<h3>ppp(8) extra's</h3>

<p>
In sommige situaties wil u misschien commando's uitvoeren terwijl uw
verbinding gemaakt of verbroken wordt. Er zijn twee bestanden die u kan
aanmaken precies voor deze situaties:
<i>/etc/ppp/ppp.linkup</i> en <i>/etc/ppp/ppp.linkdown</i>.
Voorbeeldconfiguraties kunt u hier bekijken:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkup.sample">ppp.linkup</a>
<li><a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkdown.sample">ppp.linkdown</a>
</ul>

<p>
<h3>ppp(8) variaties</h3>

<p>
Vele ISP's bieden nu xDSL diensten aan, die sneller zijn dan traditionele
inbelmethodes. Dit omvat varianten zoals ADSL en SDSL.
Hoewel er geen fysisch bellen plaatsvindt, is de verbinding nog steeds gebaseerd
op het Point to Point Protocol. Voorbeelden zijn:

<ul>
<li>PPPoE
<li>PPPoA
<li>PPTP
</ul>

<p>
<h3>PPPoE/PPPoA</h3>

<p>
Het Point to Point Protocol over Ethernet (PPPoE) is een methode om PPP
pakketten in Ethernet frames te versturen.
Het Point to Point Protocol over ATM (PPPoA) wordt typisch gedraaid op ATM
netwerken, zoals die in het VK en België.

<p>
Typisch betekent dit dat u een verbinding met uw ISP kan maken door een
standaard Ethernet kaart en Ethernet-gebaseerde DSL modem te gebruiken
(in tegenstelling tot een enkel-USB modem).

<p>
Als u een modem hebt die PPPoE/PPPoA spreekt, is het mogelijk om de modem
in te stellen om het verbinden te doen. Als alternatief, indien de modem een
`bridge' modus heeft, is het mogelijk om deze in te schakelen en de modem
de pakketten te laten "passeren" naar een machine die PPPoE software draait.

<p>
De voornaamste software interface tot PPPoE/PPPoA op OpenBSD is
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppoe&amp;sektion=8">pppoe(8)</a>,
een userland implementatie (nogal gelijkaardig aan hoe we
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8">ppp(8)</a>
hierboven beschreven hebben).
Een kernel PPPoE implementatie,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppoe&amp;sektion=4">pppoe(4)</a>,
werd in OpenBSD 3.7 ingevoerd.

<p>
<h3>PPTP</h3>

<p>
Het Point to Point Tunneling Protocol (PPTP) is een proprietair Microsoft
protocol.
Een pptp client is beschikbaar, die interfacet met
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppd&amp;sektion=8">pppd(8)</a>
en kan verbinden met de PPTP-gebaseerde Virtual Private Networks (VPN)
gebruikt door sommige kabel en xDSL providers.
pptp zelf moet geïnstalleerd worden vanuit <a href="faq8.html#Ports">ports</a>
of <a href="faq8.html#Packages">packages</a>.
Verdere instructies over het instellen en het gebruiken van pptp zijn
beschikbaar in de man pagina die samen met het pptp package geïnstalleerd
wordt.

<p>
<a name="Tuning"></a>
<h2>6.6 - Netwerkparameters tunen</h2>
<!-- XXXrelease -->

<p>
<h3>6.6.1 - Hoe kan ik de kernel tweaken zodat er een groter aantal
retries en langere timeouts zijn voor TCP sessies?</h3>

<p>
U gebruikt dit normaal om rekening te houden met routerings- of
verbindingsproblemen.
Natuurlijk, om het meest effectief te zijn, moeten beide uiteinden van
de verbinding gelijkaardige waarden gebruiken.

<p>
Om dit te tweaken, gebruikt u <tt>sysctl</tt> en verhoogt u de waarden van:

<pre>
net.inet.tcp.keepinittime
net.inet.tcp.keepidle
net.inet.tcp.keepintvl
</pre>

<p>
Met sysctl -a kan u de huidige waarden van deze (en vele andere) parameters
bekijken. Om er een te veranderen, doet u iets als
<tt>sysctl net.inet.tcp.keepidle=28800</tt>.

<p>
<h3>6.6.2 - Hoe kan ik directed broadcasts aanzetten?</h3>

<p>
Normaal gezien wil u dit niet doen. Dit laat toe dat iemand verkeer naar
het broadcast adres(sen) van uw verbonden netwerk(en) stuurt indien u
OpenBSD gebruikt als een router.

<p>
Er zijn enkele gevallen, in gesloten netwerken, waarin dit nuttig zou
kunnen zijn, vooral wanneer er oudere implementaties van het NetBIOS
protocol in gebruik zijn. Dit is nog een andere sysctl.
<tt>sysctl net.inet.ip.directed-broadcast=1</tt> zet dit aan. Lees over
<a href="http://www.netscan.org">smurf aanvallen</a> als u wil weten
waarom dit standaard is uitgeschakeld.

<p>
<h3>6.6.3 - Ik wil niet dat de kernel dynamisch een bepaalde poort
toewijst</h3>

<p>
Ook hiervoor is er een sysctl. Uit
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>:

<pre>
Set the list of reserved TCP ports that should not be allocated by the
kernel dynamically.  This can be used to keep daemons from stealing a
specific port that another program needs to function.  List elements may
be separated by commas and/or whitespace.

 #  <strong>sysctl net.inet.tcp.baddynamic=749,750,751,760,761,871</strong>

It is also possible to add or remove ports from the current list.

 #  <strong>sysctl net.inet.tcp.baddynamic=+748</strong>
 #  <strong>sysctl net.inet.tcp.baddynamic=-871</strong>
</pre>


<p>
<a name="NFS"></a>
<h2>6.7 - Eenvoudig NFS gebruik</h2>

<p>
NFS, of Network File System, wordt gebruikt om bestandssystemen over het
netwerk te delen. Hier zijn een aantal aangewezen man pagina's om te
lezen alvorens een NFS server op te zetten:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nfsd&amp;sektion=8">nfsd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mountd&amp;sektion=8">mountd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&amp;sektion=5">exports(5)</a>
</ul>

<p>
Deze sectie zal de stappen doorlopen voor een eenvoudige setup van NFS.
Dit voorbeeld behandelt de server in een LAN, met clients die NFS
gebruiken in deze LAN.
Beveiliging van NFS wordt hier niet behandeld. We gaan er van uit dat u
al pakket filtering of andere firewall bescherming hebt opgezet, om toegang
van buitenaf te beletten. Als u toegang van buitenaf tot uw NFS server
toelaat, en er staat gevoelige informatie op, dan raden we
ten zeerste aan dat u IPsec gebruikt. Anders kunnen mensen mogelijk uw
NFS verkeer te zien krijgen. Iemand zou zich ook kunnen voordoen als het
IP adres dat u toelaat tot uw NFS server. Er zijn verscheidene aanvallen
mogelijk. Wanneer het goed geconfigureerd is, beschermt IPsec tegen deze
soort aanvallen.

<p>
Een andere belangrijke bemerking omtrent beveiliging. Voeg niet gewoon een
bestandssysteem toe aan 
<i>/etc/exports</i> zonder een soort lijst van toegelaten host(s).
Zonder een lijst van hosts die een bepaalde directory kunnen mounten,
kan iedereen die uw host kan bereiken, zomaar uw NFS exports mounten.

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=portmap&amp;sektion=8">portmap(8)</a>
moet draaien opdat NFS zou kunnen werken.  Portmap(8) is standaard
uitgeschakeld op OpenBSD 3.2 en later, dus u moet deze lijn

<blockquote><pre>
portmap=YES
</pre></blockquote>

toevoegen aan
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf.local&amp;sektion=8">rc.conf.local(8)</a>
en herstarten. 

<p>
De instelling bestaat uit een server met als IP <b>10.0.0.1</b>. Deze server
zal NFS aanbieden enkel aan clients binnen dat netwerk. De eerste stap om NFS
in te stellen is om uw <i>/etc/exports</i> bestand in te stellen. Dit bestand
bevat een lijst van bestandssystemen waartoe u via NFS toegang wenst en
definieert wie er toegang toe heeft. Er zijn vele opties die u kan gebruiken
in uw <i>/etc/exports</i> bestand, en u kan best de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&amp;sektion=5">exports(5)</a>
man pagina lezen. Voor dit voorbeeld ziet onze <i>/etc/exports</i> er als
volgt uit:

<blockquote><pre>
#
# NFS exports Database
# See exports(5) for more information.  Be very careful, misconfiguration
# of this file can result in your filesystems being readable by the world.
/work -alldirs -ro -network 10.0.0 -mask 255.255.255.0
</pre></blockquote>

<p>
Dit betekent dat het lokale bestandssysteem <tt>/work</tt> beschikbaar zal
gemaakt worden via NFS. <tt>-alldirs</tt> geeft aan dat clients op gelijk
welk punt onder het <tt>/work</tt> mount point zullen kunnen mounten.
<tt>-ro</tt> geeft aan dat het enkel zal toegelaten zijn om read-only te
mounten. De laatste twee argumenten geven aan dat enkel clients binnen het
10.0.0.0 netwerk met een netmask van 255.255.255.0 geauthoriseerd zullen
worden om dit bestandssysteem te mounten.
Dit is belangrijk voor sommige servers die langs verschillende netwerken
toegankelijk zijn.

<p>
Zodra uw <i>/etc/exports</i> bestand ingesteld is, kan u verder gaan met het
instellen van uw NFS server. U moet nakijken of de opties NFSSERVER &amp;
NFSCLIENT in uw kernel configuratie staan. (GENERIC kernel heeft deze
opties inbegrepen.) Vervolgens voegt u de lijn <tt>nfs_server=YES</tt> toe aan
<i>/etc/rc.conf.local</i>. Dit zal zowel nfsd(8) als mountd(8) opstarten als
u herstart. Nu kan u echter verder gaan en de daemons zelf opstarten. Deze
daemons moeten als root gestart worden, en u moet er zeker van zijn dat
portmap(8) op uw systeem draait. Hier is een voorbeeld om nfsd(8) te starten
die zowel op TCP als op UDP luistert met 4 daemons. U kan best een gepast
aantal NFS server daemons instellen om het maximum aantal gelijktijdige
client requests dat u wenst, af te handelen.

<blockquote><pre>
# <strong>/sbin/nfsd -tun 4</strong>
</pre></blockquote>

<p>
U moet niet enkel de nfsd(8) server opstarten, maar u moet ook mountd(8)
opstarten. Dit is de daemon die werkelijk de mount requests op NFS bedient.
Om mountd(8) te starten, zorg ervoor dat een leeg mountdtab bestand
bestaat, en start de daemon:

<blockquote><pre>
# <strong>echo -n &gt;/var/db/mountdtab</strong>
# <strong>/sbin/mountd</strong>
</pre></blockquote>

<p>
Als u wijzigingen aanbrengt in /etc/exports terwijl NFS reeds draait, moet
u mountd hierover inlichten. HUP het gewoon:

<blockquote><pre>
# <strong>kill -HUP `cat /var/run/mountd.pid`</strong>
</pre></blockquote>

<p>
<h3>Statistieken over NFS nakijken</h3>

<p>
Van hier af kan u controleren om zeker te zijn dat al deze daemons goed
en wel draaien en geregistreerd bij RPC. Om dit te doen, gebruikt u
rpcinfo(8).

<blockquote><pre>
$ <strong>rpcinfo -p 10.0.0.1</strong>
   program vers proto   port
    100000    2   tcp    111  portmapper
    100000    2   udp    111  portmapper
    100005    1   udp    633  mountd
    100005    3   udp    633  mountd
    100005    1   tcp    916  mountd
    100005    3   tcp    916  mountd
    100003    2   udp   2049  nfs
    100003    3   udp   2049  nfs
    100003    2   tcp   2049  nfs
    100003    3   tcp   2049  nfs
</pre></blockquote>

<p>
Bij normaal gebruik zijn er nog enkele andere hulpmiddelen die u
toelaten om te zien wat er gebeurt met NFS. Eén ervan is
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=showmount&amp;sektion=8">showmount(8)</a>, 
dat u kan laten zien wat er momenteel gemount is en door wie. Er is ook
nfsstat(8) dat veel uitgebreidere statistieken toont.
Om showmount(8) te gebruiken, probeer <tt>/usr/bin/showmount -a host</tt>.
Bijvoorbeeld:

<blockquote><pre>
$ <strong>/usr/bin/showmount -a 10.0.0.1</strong>
All mount points on 10.0.0.1:
10.0.0.37:/work
</pre></blockquote>

<p>
<h3>NFS Bestandssystemen Mounten</h3>

<p>
NFS bestandssystemen worden gemount met mount(8), of meer bepaald,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount_nfs&amp;sektion=8">mount_nfs(8)</a>.
Om een bestandssysteem <i>/work</i> op host 10.0.0.1 te mounten op een
lokaal filesysteem <i>/mnt</i>, voert u dit uit (merk op dat u geen IP adres
hoeft te gebruiken; mount zoekt hostnamen op):

<blockquote><pre>
# <strong>mount -o ro -t nfs 10.0.0.1:/work /mnt</strong>
</pre></blockquote>

<p>
Om uw systeem te laten mounten bij het opstarten, voegt u iets als dit
toe aan uw <i>/etc/fstab</i>:

<blockquote><pre>
10.0.0.1:/work /mnt nfs ro 0 0
</pre></blockquote>

<p>
Het is belangrijk dat u aan het einde van deze lijn <tt>0 0</tt> gebruikt
zodat uw computer bij het starten niet probeert om het NFS filesystem te
fsck'en!!!!
De andere standaard beveiligingsopties, zoals noexec, nodev en nosuid,
worden ook best gebruikt indien ze van toepassing zijn. Bijvoorbeeld:

<blockquote><pre>
10.0.0.1:/work /mnt nfs ro,nodev,nosuid 0 0
</pre></blockquote>

<p>
Op deze manier kunnen devices of setuid programma's op de NFS server
geen beveiligingsmaatregelen op de NFS client ondermijnen. Als u geen
programma's mount die u verwacht te draaien op de NFS client, voegt u
dan noexec toe aan deze lijst.


<a name="Bridge"></a>
<h2>6.9 - Een netwerk bridge opzetten in OpenBSD</h2>

<p>
Een <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4">bridge</a>
is een verbinding tussen twee of meer afzonderlijke netwerken. In
tegenstelling tot een router, worden pakketten door de bridge "onzichtbaar"
overgedragen -- logisch gezien lijkt het alsof de twee netwerksegmenten
één segment zijn voor knooppunten aan gelijk welke zijde van de
bridge. De bridge zal enkel pakketten doorsturen die van het ene naar het
andere segment moeten, dus ze bieden onder andere een gemakkelijke manier
om in een complex netwerk het verkeer te verlagen en laten toch toe om elk
knooppunt indien nodig toegang te verschaffen tot gelijk welk ander
knooppunt.

<p>
Merk op dat door deze "onzichtbare" aard een interface in een bridge
al dan niet een eigen IP adres kan hebben. Als het er een heeft, dan
heeft de interface effectief twee werkingsmodi, één als deel
van een bridge, de andere als een normale, alleenstaande NIC.
Als geen van de interfaces een IP adres heeft, stuurt de bridge
netwerkdata door, maar zal van buitenaf niet onderhouden kunnen worden
(wat een nuttige eigenschap kan zijn).

<p>
<h3>Een voorbeeld van een bridge toepassing</h3>

<p>
Eén van mijn computer rekken bevat een aantal oudere systemen, waarvan
geen enkel een ingebouwde 10BASE-TX NIC heeft. Hoewel ze allemaal een
AUI of AAUI connector hebben, is mijn voorraad transceivers beperkt tot
coax. Een van de machines in dit rek is een OpenBSD-gebaseerde terminal
server die altijd aan staat en met het hogesnelheidsnetwerk verbonden is.
Door een tweede NIC met een coax poort toe te voegen zal ik deze machine
als een bridge naar het coax netwerk kunnen gebruiken.

<p>
Dit systeem heeft nu twee NICs, een Intel EtherExpress/100
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp&amp;sektion=4"><tt>fxp0</tt></a>)
en een 3c590-Combo kaart
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&amp;sektion=4"><tt>ep0</tt></a>)
voor de coax poort.  <tt>fxp0</tt> is de verbinding met de rest van
mijn netwerk en zal dus een IP adres hebben, <tt>ep0</tt> zal
enkel voor bridging dienen en zal geen IP adres hebben.
Machines verbonden met het coax segment zullen communiceren alsof ze op
de rest van mijn netwerk zaten. Hoe laten we dit nu gebeuren?

<p>
Het bestand <tt>hostname.fxp0</tt> bevat de configuratie info voor
de <tt>fxp0</tt> kaart. Deze machine is ingesteld met DHCP, dus het
bestand ziet er als volgt uit:

<blockquote>
<pre>
$ <b>cat /etc/hostname.fxp0</b>
dhcp NONE NONE NONE NONE
</pre>
</blockquote>

<p>
Geen verrassingen hier.

<p>
De <tt>ep0</tt> kaart is een beetje verschillend, zoals u al kon raden:

<blockquote>
<pre>
$ <b>cat /etc/hostname.ep0</b>
up media 10base2
</pre>
</blockquote>

<p>
Hier dragen we het systeem op om deze interface te activeren met
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
en hem op 10BASE-2 (coax) in te stellen. IP adres of gelijkaardige informatie
hoeft voor deze interface niet gespecificeerd te worden. De opties die de
<tt>ep</tt> kaart aanvaardt, staan uitgebreid in de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&amp;sektion=4">man pagina</a> ervan.

<p>
Nu moeten we de bridge instellen. Bridges worden geïnitialiseerd door
het bestaan van een bestand met een naam als
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridgename.if&amp;sektion=5"><tt>bridgename.bridge0</tt></a>. 
Hier is een voorbeeld voor mijn situatie hier:

<blockquote>
<pre>
$ <b>cat /etc/bridgename.bridge0</b>
add fxp0
add ep0
up
</pre>
</blockquote>

<p>
Dit zegt: stel een bridge in die bestaat uit de twee NICs, fxp0 en ep0,
en activeer ze. Doet het ertoe in welke volgorde de kaarten staan? Neen,
onthou dat een bridge heel symmetrisch is -- pakketten stromen in en uit
in beide richtingen.

<p>
Dat is het! Herstart, en u hebt nu een werkende bridge.

<p>
<h3>Filteren op een bridge</h3>

Hoewel een eenvoudige bridge als deze zeker nuttig kan zijn, is het
waarschijnlijk dat u iets wil DOEN met de pakketten wanneer ze doorheen
uw bridge gaan. Zoals u kon verwachten, kan
<a href="#PF">Packet Filter</a> gebruikt worden om beperkingen op te leggen
aan het verkeer dat doorheen uw bridge gaat.

<p>
Hou in het achterhoofd dat, door de aard van een bridge, dezelfde gegevens
door beide interfaces stromen, zodat u slechts op één interface
hoeft te filteren. Uw standaard "Pass all" opdrachten zouden er ongeveer zo
kunnen uitzien:

<blockquote>
<pre>
pass in  on ep0  all
pass out on ep0  all
pass in  on fxp0 all
pass out on fxp0 all
</pre>
</blockquote>

<p>
Nu, stel dat ik graag het verkeer dat deze oude machines zien, wil
filteren, ik wil dat alleen Web en SSH verkeer ze bereikt. In dit geval
zullen we alle verkeer in en uit de <tt>ep0</tt> interface laten, maar filteren
op de <tt>fxp0</tt> interface, gebruik makend van <tt>keep state</tt> om de
antwoordgegevens te behandelen:

<blockquote>
<pre>
# Pass all traffic through ep0
pass in quick on ep0 all
pass out quick on ep0 all

# Block fxp0 traffic
block in  on fxp0 all
block out on fxp0 all

pass in quick on fxp0 proto tcp from any to any port {22, 80} \
     flags S/SA keep state
</pre>
</blockquote>

<p>
Merk op dat deze regelset belet dat er ook maar iets, behalve ingaand
HTTP en SSH verkeer, ofwel de bridge ofwel gelijk welk ander knooppunt
"erachter" bereikt. Andere resultaten zouden kunnen bekomen worden door
op de andere interface te filteren.

<p>
Om de bridge die u gemaakt hebt in de gaten te houden en te beheren,
gebruikt u het
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=brconfig&amp;sektion=8">brconfig(8)</a>
commando, dat ook kan gebruikt worden om een bridge te maken na het
opstarten.

<p>
<h3>Tips voor bridging</h3>

<ul>
<li>Het is TEN ZEERSTE aangeraden dat u slechts op één enkele
interface filtert.
Hoewel het mogelijk is om op allebei te filteren, moet u dit echt heel
goed begrijpen om het juist te doen.

<li>Door de <i>blocknonip</i> optie van 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=brconfig&amp;sektion=8">brconfig(8)</a>
of in
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridgename.if&amp;sektion=5">bridgename.bridge0</a>
te gebruiken,
kan u beletten dat niet-IP verkeer (zoals IPX of NETBEUI) langs uw filters
glipt. Dit kan belangrijk zijn in sommige situaties, maar u moet weten dat
bridges werken voor alle soorten verkeer, niet enkel IP.

<li>Bridging vereist dat de NICs in een "Promiscuous mode" staan -- ze
luisteren naar ALLE netwerkverkeer, niet alleen datgene gericht naar de
interface. Dit zal de processor en bus onder een grotere belasting plaatsen
dan men zou verwachten. Sommige NICs werken niet naar behoren in deze
modus, de TI ThunderLAN chip
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tl&amp;sektion=4">tl(4)</a>)
is een voorbeeld van een chip die niet wil werken als onderdeel van een bridge. 
</ul>

<a name="PXE"></a>
<h2>6.10 - Hoe boot ik met PXE? (i386, amd64)</h2>
De Preboot Execution Environment, of PXE, is een manier om een computer te
starten via het netwerk, veeleer dan via een harde schijf, een diskette of een
CD-ROM. De technologie werd aanvankelijk ontwikkeld door Intel, maar wordt nu
door de meeste grote netwerkkaart- en computerfabrikanten ondersteund.
Merk op dat er verschillende netwerk bootprotocols zijn, PXE is relatief
recent.
Traditioneel gebeurt PXE booting met ROMs op de NIC of het moederbord van
het systeem, maar er zijn via verschillende bronnen bootdiskettes
beschikbaar, die ook PXE booting toelaten.
Veel ROMs op oudere NICs ondersteunen netwerk booting maar ondersteunen
PXE NIET;
OpenBSD/i386 of amd64 kan momenteel door deze kaarten niet via het netwerk
gestart worden.


<p>
<h3>Hoe werkt PXE booting?</h3>
Eerst en vooral is het verstandig om te begrijpen hoe
<a href="faq14.html#Boot386">OpenBSD start</a> op i386 en amd64 platformen.
Bij aanvang van het bootproces, broadcast de PXE-capabele NIC een DHCP request
over het netwerk.
De DHCP server zal de adapter een IP adres toekennen, en geeft hem een
bestandsnaam die via een
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tftp&amp;sektion=1"
>tftp(1)</a> server moet teruggevonden worden en uitgevoerd.
Dit bestand leidt dan de rest van het boot proces.
Voor OpenBSD is dit bestand
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pxeboot&amp;sektion=8&amp;arch=i386"
>pxeboot</a>, dat de plaats inneemt van het standaard
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">
boot(8)</a> bestand.
pxeboot(8) kan dan een kernel inladen en uitvoeren (zoals
<tt>bsd</tt> of <a href="faq4.html#bsd.rd"><tt>bsd.rd</tt></a>) vanaf
dezelfde tftp(1) server.

<h3>Hoe doe ik het?</h3>
De eerste vanzelfsprekende stap is dat u een PXE-boot capabele computer
of netwerkadapter moet hebben.
Sommige documentatie zal aangeven dat alle moderne NICs en computers
PXE capabel zijn, maar dit is duidelijk niet waar -- veel goedkope
systemen bevatten geen PXE ROMs of gebruiken een ouder netwerk boot protocol.
U hebt ook een netjes geconfigureerde <a href="#DHCP">DHCP</a> en TFTP
server nodig.

<p>
In de verondestelling dat een OpenBSD machine de bron van de bootbestanden
is (dit is NIET vereist), moet uw DHCP server
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd.conf&amp;sektion=5">dhcpd.conf</a>
bestand de volgende lijn bevatten:
<pre>
    filename "pxeboot";
</pre>
om de DHCP server dit bestand te laten aanbieden aan het bootende werkstation.
Bijvoorbeeld:

<pre>
    shared-network LOCAL-NET {
            option  domain-name "example.com";
            option  domain-name-servers 192.168.1.3, 192.168.1.5;

            subnet 192.168.1.0 netmask 255.255.255.0 {
                    option routers 192.168.1.1;
                    <b>filename "pxeboot";</b>
                    range 192.168.1.32 192.168.1.127;
                    default-lease-time 86400;
                    max-lease-time 90000;
            }
    }
</pre>

<p>
U zal ook de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tftpd&amp;sektion=8">tftpd(8)</a>
daemon moeten activeren. Dit gebeurt typisch via
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inetd&amp;sektion=8"
>inetd(8)</a>.
De standaard OpenBSD installatie heeft een voorbeeldlijn in
<tt>inetd.conf</tt> die het mooi voor u doet:
<pre>
    #tftp  dgram   udp  wait  root  /usr/libexec/tftpd   tftpd -s /tftpboot
</pre>

waarin het '#' teken eenvoudigweg verwijderd moet worden. Stuur inetd(8)
een -HUP signaal om het <tt>/etc/inetd.conf</tt> te laten herladen.
tftpd(8) biedt bestanden aan vanuit een welbepaalde directory, in het geval
van deze lijn, is die directory <tt>/tftpboot</tt>, wat we in dit voorbeeld
zullen gebruiken.
Vanzelfsprekend moet deze directory aangemaakt en bevolkt worden.
Typisch moet u daar slechts enkele bestanden hebben voor PXE booting:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pxeboot&amp;sektion=8&amp;arch=i386"
>pxeboot</a>, de PXE boot loader (die dezelfde functie vervult als
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386"
>boot</a> op een schijf-gebaseerd systeem).
<li><a href="faq4.html#bsd.rd">bsd.rd</a>, de installatiekernel of <tt>bsd</tt>,
een aangepaste kernel.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot.conf&amp;sektion=8&amp;arch=i386"
>/etc/boot.conf</a>, een boot configuratiebestand.
</ul>

Merk op dat <tt>/etc/boot.conf</tt> enkel nodig is als de kernel die u wenst
te starten niet <tt>bsd</tt> heet, of als de andere pxeboot standaardwaarden
niet zijn wat u nodig hebt (u wenst bijvoorbeeld een seriële console
te gebruiken).
U kan uw tftpd(8) server testen met een
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tftp&amp;sektion=1"
>tftp(1)</a> client, en nagaan of u de nodige bestanden kan afhalen.

<p>
Wanneer uw DHCP en TFTP servers draaien, bent u klaar om het te proberen.
U zal de PXE boot op uw systeem of netwerkkaart moeten activeren;
raadpleeg hiervoor uw systeemdocumentatie.
Zodra u dit ingeschakeld hebt, zou u iets moeten zien dat lijkt op het
volgende:

<pre>
    Intel UNDI, PXE-2.0 (build 067)
    Copyright (C) 1997,1998 Intel Corporation

    For Realtek RTL 8139(X) PCI Fast Ethernet Controller v1.00 (990420)

    DHCP MAC ADDR: 00 E0 C5 C8 CF E1
    CLIENT IP: 192.168.1.76  MASK: 255.255.255.0  DHCP IP: 192.168.1.252
    GATEWAY IP: 192.168.1.1
    probing: pc0 com0 com1 apm pxe![2.1] mem[540k 28m a20=on]
    disk: hd0*
    net: mac 00:e0:c5:c8:cf:e1, ip 192.168.1.76, server 192.168.1.252
    >> OpenBSD/i386 PXEBOOT 1.00
    boot>
</pre>

Op dit punt hebt u de standaard OpenBSD boot prompt.
Als u hier gewoon "<tt>bsd.rd</tt>" typt, zal u het bestand
<tt>bsd.rd</tt> van de TFTP server afhalen.

<pre>
    >> OpenBSD/i386 PXEBOOT 1.00
    boot> bsd.rd
    booting tftp:bsd.rd: 4375152+733120 [58+122112+105468]=0x516d04
    entry point at 0x100120

    Copyright (c) 1982, 1986, 1989, 1991, 1993
            The Regents of the University of California.  All rights reserved.

    Copyright (c) 1995-2005 OpenBSD.  All rights reserved.  http://www.OpenBSD.org

    OpenBSD 3.7 (RAMDISK_CD) #573: Sun Mar 20 00:27:05 MST 2005
      ...
</pre>

De <a href="faq4.html#bsd.rd">bsd.rd installatiekernel</a> zal nu opstarten.

<p>

<h3>Kan ik nog andere soorten kernels starten met PXE, behalve
<tt>bsd.rd</tt>?</h3>

Ja, hoewel met de tools momenteel in OpenBSD 3.7, PXE booting in eerste
instantie bedoeld is om het besturingssysteem te installeren.


<a name="CARP"></a>
<h2>6.11 - Het Common Address Redundancy Protocol (CARP)</h2>
<h3>6.11.1 - Wat is CARP en hoe werkt het?</h3>
<!-- This article written by Sunny Raspet, slr@mordac.info, and
released under the BSD license -->

<p>
CARP is een hulpmiddel om systeemredundantie te helpen bereiken, door meerdere
computers onderling een enkele virtuele netwerkinterface te laten aanmaken,
zodat als gelijk welke machine faalt, een andere in de plaats kan antwoorden,
en/of een graad van belastingsverdeling tussen systemen toe te laten.
CARP is een verbetering ten opzichte van de Virtual Router Redundancy Protocol
(VRRP) standaard.
Het werd ontwikkeld nadat VRRP niet vrij genoeg geacht werd wegens een
mogelijk overlappend Cisco patent.
Voor meer informatie over de oorsprong van CARP en de juridische problemen
omtrent VRRP, bezoekt u alstublieft <a href="../../lyrics.html#35">deze pagina</a>.

<p>
Om juridische conflicten te vermijden, ontwierp Ryan McBride (met de hulp van
Michael Shalayeff, Marco Pfatschbacher en Markus Friedl) CARP zo dat het
fundamenteel verschillend zou zijn.
De opname van cryptografie is de meest prominente verandering, maar toch
slechts één van de vele.

<p>
Hoe het werkt: CARP is een multicast protocol.
Het groepeert verscheidene fysische computers samen onder één
of meer virtuele adressen.
Van deze is één systeem de master en antwoordt op alle pakketten
bestemd voor de groep, de andere systemen fungeren als "hot spares".
Wat het IP en MAC adres van de lokale fysische interface ook zijn, pakketten
verstuurd naar het CARP adres worden teruggezonden met de CARP informatie.

<p>
Op configureerbare intervals kondigt de master zijn werking op IP protocol
nummer 112 aan.
Als de master offline gaat, beginnen de andere systemen in de CARP groep
met aankondigen.
De host die het vaakst kan aankondigen, wordt de nieuwe master.
Wanneer het hoofdsysteem opnieuw on-line komt, wordt het standaard een
backup host, als het echter meer wenselijk is om één host
altijd master te laten zijn wanneer mogelijk (bv. één host is
een snelle Sun Fire V120 en de andere zijn in vergelijking trage SPARCstation
IPCs), dan kan u ze zo instellen.

<p>
Hoewel hoogredundante en fout-tolerante hardware de nood aan CARP
minimaliseert, neemt het deze niet weg.
Er bestaat geen hardware fouttolerantie die kan helpen als iemand een
stroomkabel uitsnokt, of als uw systeembeheerder in het verkeerde venster
<tt>reboot</tt> typt.
CARP maakt het ook gemakkelijker om de patch en reboot cyclus transparant te
maken voor gebruikers, en gemakkelijker om een software of hardware upgrade
te testen--als het niet werkt, kan u terugvallen op uw "spare" totdat het
opgelost is.

<p>Er zijn echter situaties waarin CARP niet zal helpen.
Het ontwerp van CARP vereist dat de leden van een groep op hetzelfde fysische
subnet zitten, en elke interface vereist een echt, statisch IP adres, bovenop
een statisch CARP IP adres.
Gelijkaardig zullen diensten die een voortdurende verbinding met de server
vereisen (zoals SSH of IRC) niet transparant naar het andere systeem
overgezet worden--hoewel in dit geval CARP kan helpen met de down-tijd te
minimaliseren.
CARP op zichzelf synchroniseert geen gegevens tussen toepassingen, dit moet
gedaan worden door "alternatieve kanalen" zoals
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pfsync&amp;sektion=4">pfsync(4)</a>
(voor redundante filtering), het manueel dupliceren van gegevens tussen
machines met <a href="http://rsync.samba.org/">rsync</a>, of wat er ook
geschikt is voor uw toepassing.

 

<h3>6.11.2 - Configuratie</h3>

<p>
De bediening van CARP staat op twee plaatsen:
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
en
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>.
Laten we eerst naar de sysctls kijken.

<p>De eerste sysctl, <tt>net.inet.carp.allow</tt>, definieert of de host
überhaupt CARP pakketten behandelt.
Dit is duidelijk noodzakelijk om CARP te gebruiken.
Deze sysctl is standaard ingeschakeld.

<p>
De tweede, <tt>net.inet.carp.arpbalance</tt>, wordt gebruikt voor load
balancing.
Als deze functionaliteit is ingeschakeld, voert CARP een "source-hash" uit
op het bron-IP van een aanvraag.
De hash wordt vervolgens gebruikt om een virtuele host te selecteren uit de
beschikbare pool om de aanvraag af te handelen.
Dit is standaard uitgeschakeld.

<p>De derde, <tt>net.inet.carp.log</tt>, logt CARP fouten.
Standaard uitgeschakeld.

<p>De vierde, <tt>net.inet.carp.preempt</tt> schakelt natuurlijke selectie
tussen CARP hosts in.
De meest geschikte voor de job (dat betekent, het meest frequent kunnen
aankondigen) zal master worden.
Standaard uitgeschakeld, wat betekent dat een systeem dat geen master is
niet zal proberen om (opnieuw) master status te winnen.

<p>
Al deze sysctl variabelen zijn gedocumenteerd in
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=3">sysctl(3)</a>.

<p>Voor de rest van de configuratie van CARP, verlaten we ons op
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>.
Twee van de vier CARP-specifieke commando's, <tt>advbase</tt> en
<tt>advskew</tt>, hebben te maken met het interval tussen CARP aankondigingen.
De formule (in seconden) is <tt>advskew</tt> gedeeld door 255, vervolgens
opgeteld bij <tt>advbase</tt>.
<tt>advbase</tt> kan gebruikt worden om het netwerkverkeer te verlagen of
om langere latentie toe te laten alvorens een backup host overneemt;
<tt>advskew</tt> laat u bepalen welke host master zal zijn zonder veel
"failover" vertraging (als dat vereist zou zijn).

<p>Vervolgens stelt <tt>pass</tt> een wachtwoord in, en stelt <tt>vhid</tt> het
virtuele host identifier nummer van de CARP groep in.
U moet een uniek nummer toekennen voor elke CARP groep, zelfs als (voor
load balancing doeleinden) ze hetzelfde IP adres delen.
CARP is beperkt tot 255 groepen.

<p>Laten we al deze instellingen samenbrengen in een basisconfiguratie.
Stel dat u twee identiek geconfigureerde Web servers gebruikt,
<i>rachael</i> (192.168.0.5) en <i>pris</i> (192.168.0.6), om een ouder
systeem te vervangen dat op 192.168.0.7 stond.  De commando's:

<blockquote><pre>
rachael# <b>ifconfig carp0 create</b>
rachael# <b>ifconfig carp0 vhid 1 pass tyrell 192.168.0.7</b>
</pre></blockquote>

<p>maken de carp0 interface en geven ze een vhid van 1, een wachtwoord
<i>tyrell</i>, en het IP adres 192.168.0.7.
Om dit blijvend te maken na het herstarten, kan u een
<tt>/etc/hostname.carp0</tt> bestand aanmaken dat er zo uitziet:

<blockquote><pre>
inet 192.168.0.7 255.255.255.0 192.168.0.255 vhid 1 pass tyrell 
</pre></blockquote>

<p>
Doe hetzelfde op <i>pris</i>. Welk systeem ook de CARP interface het eerst
on-line brengt, zal master zijn.

<p>
Merk op dat in een machine met meerdere interfaces, de CARP interface op
hetzelfde subnet zit als de fysische interface.

<p>
Maar stel dat u niet vanaf nul begint met opstellen.
<i>Rachael</i> was reeds op haar plaats op het adres 192.168.0.7.
Hoe zou u daar omheen werken?
Gelukkig kan CARP met deze situatie omgaan. U kent gewoon het adres toe aan
de CARP interface en in een CARP groep, zodat het niet nodig is de
commando's hierboven te veranderen.
Het is gewoonlijk echter netter om voor elk systeem een IP te hebben-- dit
maakt individuele monitoring en toegang veel eenvoudiger.

<p>Laten we nog een laag complexiteit toevoegen; we willen dat <i>rachael</i>
wanneer mogelijk master blijft.
Er zijn verscheidene redenen waarom we dit zouden kunnen willen:
hardwareverschillen, eenvoudig vooroordeel, "als dit systeem geen master is,
is er een probleem," of de standaard master kennen zonder met scripts de
uitvoer van ifconfig te verwerken en via e-mail te versturen.

<p>Op <i>rachael</i> zullen we de sysctl gebruiken die we hoger aangemaakt
hebben, en vervolgens <tt>/etc/sysctl.conf</tt> bewerken om het blijvend te
maken.

<blockquote><pre>
rachael# <b>sysctl net.inet.carp.preempt=1</b>
</pre></blockquote>

<p>We zullen ook op <i>pris</i> de configuratie doen:

<blockquote><pre>
pris# <b>ifconfig carp0 advskew 100</b>
</pre></blockquote>

<p>Dit vertraagt lichtjes de aankondigingen van <i>pris</i>, wat betekent dat
<i>rachael</i> master zal zijn indien levend.

<p>
Merk op dat indien u PF gebruikt op een ge-CARPte computer, u "proto carp"
moet meegeven aan alle betrokken interfaces, met een lijn gelijkaardig aan:
<blockquote><pre>
pass on fxp0 proto carp keep state
</pre></blockquote>

<h3>6.11.3 - Load balancing</h3>

<p>Blik enkele maanden vooruit. Ons bedrijf uit het voorgaande voorbeeld is
gegroeid tot op het punt waar een enkele interne Web server het maar net
redt onder de belasting. Wat te doen? CARP ter hulp. Het is tijd om load
balancing uit te proberen. Creëer een nieuwe CARP interface en groep
op <i>rachael</i>:

<blockquote><pre>
rachael# <b>ifconfig carp1 create</b>
rachael# <b>ifconfig carp1 vhid 2 advskew 100 pass bryant 192.168.0.7</b>
</pre></blockquote>

<p>Ook op <i>pris</i> zullen we de nieuwe groep en interface aanmaken, en
vervolgens de "preempt" sysctl instellen:

<blockquote><pre>
pris# <b>ifconfig create carp1</b>
pris# <b>ifconfig carp1 vhid 2 pass bryant 192.168.0.7</b>
pris# <b>sysctl net.inet.carp.preempt=1</b>
</pre></blockquote>

<p>Nu hebben we twee CARP groepen met hetzelfde IP adres. Elke groep wordt
naar een verschillende host gedraaid, wat betekent dat <i>rachael</i> master
zal blijven van de oorspronkelijke groep, maar <i>pris</i> zal de nieuwe
overnemen.

<p>Al wat we nu nog moeten doen is op beide machines de sysctl voor load
balancing inschakelen die we voorheen besproken hebben:

<blockquote><pre>
# <strong>sysctl net.inet.carp.arpbalance=1</strong>
</pre></blockquote>

<p>Hoewel dit voorbeelden zijn voor een twee-machine cluster, zijn dezelfde
principes van toepassing op meer systemen.
Bemerk echter alstublieft, dat er niet verwacht wordt dat u perfect 50/50
verdeling zal bekomen tussen de twee machines--CARP gebruikt een hash van
het bron-IP adres om te bepalen welk systeem de aanvraag afhandelt, veeleer
dan volgens belasting.

<h3>6.11.4 - Meer informatie over CARP</h3>
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=carp&amp;sektion=4">carp(4)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=3">sysctl(3)</a>
<li><a href="http://www.countersiege.com/doc/pfsync-carp/">Firewall
Failover met pfsync en CARP</a> door Ryan McBride
</ul>

<a name="OpenNTPD"></a>
<h2>6.12 - OpenNTPD gebruiken</h2>
Nauwkeurige tijd is belangrijk voor veel computertoepassingen.
Veel mensen hebben echter gemerkt dat hun horloge van $5 beter de tijd
kan bijhouden dan hun $2000 computer.
Bovenop te weten hoe laat het is, is het ook vaak belangrijk om
computers te synchroniseren zodat ze het allemaal eens zijn over hoe
laat het is.
Een tijd lang heeft <a href="http://www.ntp.org">ntp.org</a>
een Network Time Protocol
(<a href="http://www.ietf.org/rfc/rfc1305.txt">RFC1305</a>,
<a href="http://www.ietf.org/rfc/rfc2030.txt">RFC2030</a>)
toepassing geproduceerd, beschikbaar via <a href="faq8.html#Ports">ports</a>,
die kan gebruikt worden om klokken van computers via het Internet te
synchroniseren. Het is echter een niet-triviaal programma om in te stellen,
het heeft een moeilijke broncode om te controleren, en heeft grote
geheugenvereisten.
In het kort vervult het een belangrijke rol voor sommige mensen, maar het
is verre van een oplossing voor iedereen.

<p>
<a href="http://www.openntpd.org">OpenNTPD</a> is een poging om sommige van
deze problemen op te lossen, door een triviaal te beheren, veilige en
eenvoudige NTP-compatibele manier te voorzien om op uw computer over
nauwkeurige tijd te beschikken.
OpenBSD's 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ntpd&amp;sektion=8">ntpd(8)</a>
wordt beheerd met een eenvoudig te begrijpen configuratiebestand,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ntpd.conf&amp;sektion=5"><tt>/etc/ntpd.conf</tt></a>.

<p>
Gewoon ntpd(8) activeren via <a href="faq10.html#rc">rc.conf.local</a>
zal ertoe leiden dat uw computer zichzelf synchroniseert met de
<a href="http://www.pool.ntp.org/">pool.ntp.org</a> servers,
een verzameling publiek beschikbare tijdservers.
Zodra uw klok nauwkeurig gezet is, zal ntpd ze op een hoge nauwkeurigheidsgraad
houden.

<a name="OpenNTPDaccurate"></a>
<h3>6.12.1 - "Maar OpenNTPD is niet zo nauwkeurig als de ntp.org daemon!"</h3>
Dat kan zijn.
Dat was niet de
<a href="http://www.openntpd.org/goals.html">ontwerpdoelstelling</a> van
OpenNTPD, het was bedoeld om vrij, eenvoudig, betrouwbaar en veilig te zijn.
Als u echt microseconde precisie meer nodig hebt dan de voordelen van
OpenNTPD, staat het u vrij om ntp.org's ntpd te gebruiken, want deze blijft
beschikbaar via ports en packages.
Er is geen plan of verlangen om OpenNTPD te overladen met elke denkbare
mogelijkheid.

<a name="OpenNTPDharmful"></a>
<h3>6.12.2 - "Iemand heeft beweerd dat OpenNTPD 'schadelijk' is!"</h3>
Sommige mensen hebben de doelstellingen van OpenNTPD niet begrepen -- een
eenvoudige, veilige en gemakkelijk te onderhouden manier om de klok van uw
computer nauwkeurig te houden.
Als het nauwkeurig bijhouden van de tijd belangrijk is: een aantal mensen
hebben al betere resultaten met OpenNTPD dan met ntp.org's ntpd gemeld.
Als veiligheid belangrijk is: de broncode van OpenNTPD is veel leesbaarder
(en dus controleerbaar) en werd geschreven met "native" OpenBSD 
functie-aanroepen zoals
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=strlcpy&amp;sektion=3">strlcpy</a>,
veeleer dan meer portable functies als
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=strcpy&amp;sektion=3">strcpy</a>,
en werd vanaf het begin geschreven om veilig te zijn, niet "achteraf veilig
gemaakt".
Als het waardevol is om meer mensen tijdssynchronisatie te laten gebruiken,
maakt OpenNTPD het veel gemakkelijker voor grotere aantallen mensen om het te
gebruiken. Als dit "schadelijk" is, dan zijn we er allemaal voor.

<p>
Er zijn toepassingen waarbij de ntp.org ntpd meer gepast is; er wordt echter
vastgesteld dat voor de andere 95% van de gebruikers OpenNTPD meer dan
voldoende is.

<p>
Een meer volledig antwoord hierop door een van de maintainers van OpenNTPD
kan
<a href="http://www.advogato.org/person/dtucker/diary.html?start=52">hier</a>
gelezen worden.

<a name="Wireless"></a>
<!-- XXX remove "new" for 3.8 -->
<h2>6.13 - Wat zijn mijn draadloze netwerkmogelijkheden?</h2>
OpenBSD heeft ondersteuning voor een aantal draadloze chipsets:
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=awi&amp;sektion=4">awi(4)</a>
AMD 802.11 PCnet Mobile
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=an&amp;sektion=4">an(4)</a>
Aironet Communications 4500/4800
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wi&amp;sektion=4">wi(4)</a>
Prism2/2.5/3
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=atw&amp;sektion=4">atw(4)</a>
ADMtek ADM8211
<li><i>Nieuw</i> <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ath&amp;sektion=4">ath(4)</a>
driver voor Atheros IEEE 802.11a/b/g.
<li><i>Nieuw</i> <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=iwi&amp;sektion=4">iwi(4)</a>
Intel PRO/Wireless 2200BG/2225BG/2915ABG IEEE 802.11a/b/g.
<li><i>Nieuw</i> <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipw&amp;sektion=4">ipw(4)</a>
Intel PRO/Wireless 2100 IEEE 802.11b.
<li><i>Nieuw</i> <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=atu&amp;sektion=4">atu(4)</a>
Atmel AT76C50x USB IEEE 802.11b.
<li><i>Nieuw</i> <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ral&amp;sektion=4">ral(4)</a>
en <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ural&amp;sektion=4">ural(4)</a> [USB]
Ralink Technology RT25x0 IEEE 802.11a/b/g.
<li><i>Nieuw</i> <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rtw&amp;sektion=4">rtw(4)</a>
Realtek 8180 IEEE 802.11b.

</ul>
  
Adapters gebaseerd op deze chips kunnen gebruikt worden zoals gelijk welke
andere netwerkadapter om een OpenBSD systeem met een bestaand draadloos
netwerk te verbinden (kijk alstublieft in de manual pagina's voor details).
Sommige van deze kaarten kunnen ook in de
"Host-Based Access Point" mode gebruikt worden, wat hen toelaat om een
draadloos toegangspunt te vormen voor uw netwerk als onderdeel van uw
firewall.

<p>
Een andere mogelijkheid om te overwegen om uw OpenBSD-gebaseerde firewall
draadloze toegang te laten voorzien, is om een conventionele NIC en een
extern bridging Access Point te gebruiken.
Dit heeft het bijkomend voordeel dat het u toelaat om gemakkelijk de antenne
te plaatsen waar die het meest effectief is, wat meestal niet direct aan
de achterzijde van uw firewall is.

<p>
Merk op dat om de Intel-gebaseerde kaarten te gebruiken, u de firmware
bestanden zal moeten bekomen, waarvan Intel de
<a href="faq1.html#ReallyFree">vrije</a> distributie weigert toe te laten,
zodat ze niet kunnen opgenomen worden in OpenBSD.
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=iwi&amp;sektion=4#FILES">Neem
contact op met Intel</a> om hen te laten weten hoe u hier tegenover staat,
of om hen te laten weten welk ander product u in de plaats hebt aangekocht.

<p>
Andere fabrikanten, zoals Broadcom, Texas Instruments en Connexant
hebben actief onze pogingen bevochten om vrije drivers te ontwikkelen voor
hun producten.
We moedigen u aan hun wensen te respecteren door hun producten niet te kopen.
Realtek, Ralink, Atmel, ADMtek en Atheros maken goede producten en steunen
het verlangen van de open bron gemeenschap naar vrije drivers, en hebben
onze steun en zaken verdiend.


<p>
<font color="#0000e0">
<a href="index.html">[FAQ Index]</a>
<a href="faq5.html">[Naar Sectie 5 - Het Systeem vanaf Broncode Bouwen]</a>
<a href="faq7.html">[Naar Sectie 7 - Toetsenbord en Scherm Bediening]</a>
</font>

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../images/back.gif" border="0" alt="[terug]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: faq6.html,v 1.222 ]<br>
$Translation: faq6.html,v 1.13 2005/05/24 13:40:32 smestdag Exp $<br>
-->
$OpenBSD: faq6.html,v 1.13 2005/05/25 04:52:29 saad Exp $
</small>

</body>
</html>
