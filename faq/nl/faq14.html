<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>14 - Inrichting van de Schijf</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2009 by OpenBSD.">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
</head>

<body bgcolor= "#ffffff" text= "#000000">

<a href="../../nl/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">    
</a>
<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ Index]</a>
<a href= "faq13.html">[Naar Sectie 13 - Multimedia]</a>
<a href= "faq15.html">[Naar Sectie 15 - Packages en Ports]</a>
</font>

<h1><font color="#e00000">14 - Inrichting van de Schijf</font></h1><hr>

<h3>Inhoudsopgave</h3>
<ul>
<li><a href="#disklabel"  >14.1 - OpenBSD's disklabel(8) gebruiken</a>
<li><a href="#fdisk"      >14.2 - OpenBSD's fdisk(8) gebruiken</a>
<li><a href="#NewDisk"    >14.3 - Extra schijven toevoegen in OpenBSD</a>
<li><a href="#Swap"       >14.4 - Hoe wordt swap gebruikt?</a>
<li><a href="#SoftUpdates">14.5 - Soft Updates</a>
<li><a href="#Boot386"    >14.6 - Hoe boot OpenBSD/i386?</a>
<li><a href="#LargeDrive" >14.7 - Wat zijn de problemen met grote schijven
    in OpenBSD?</a>
<li><a href="#InstBoot"   >14.8 - Installeren van Bootblocks - i386/amd64
    specifiek</a>
<li><a href="#Backup"     >14.9 - Zich op het ergste voorbereiden: Backup en
    Restore vanaf tape.</a>
<li><a href="#MountImage" >14.10 - Schijfimages mounten in OpenBSD</a>
<li><a href="#pciideErr"  >14.11 - Help! Ik krijg fouten met IDE DMA!</a>
<li><a href="#RAID"       >14.13 - RAID opties in OpenBSD</a>
<li><a href="#NegSpace"   >14.14 - Waarom vertelt <tt>df(1)</tt> me dat ik
    meer dan 100% van mijn schijf in gebruik heb?</a>
<li><a href="#OhBugger"   >14.15 - Partities herstellen na het verwijderen
    van het disklabel</a>
<li><a href="#foreignfs"  >14.16 - Kan ik gegevens benaderen op andere
    bestandssystemen dan FFS?</a>
<ul>
  <li><a href="#foreignfsafter">14.16.1 - De partities staan niet in mijn
      disklabel! Wat moet ik doen?</a>
</ul>
<li><a href="#flashmem"   >14.17 - Kan ik een flash geheugentoestel gebruiken
    met OpenBSD?</a>
  <ul>
  <li><a href="#flashmemPortable">14.17.1 - Flashgeheugen als draagbaar
    opslagtoestel</a> 
  <li><a href="#flashmemBoot">14.17.2 - Flashgeheugen als bootable opslag</a>
  <li><a href="#flashmemLive">14.17.3 - Hoe kan ik een "Live" bootable USB
    toestel maken?</a>
  </ul>
<li><a href="#DiskOpt"    >14.18 - Schijfprestaties optimaliseren</a>
<li><a href="#Async"      >14.19 - Waarom gebruiken we geen async mounts?</a>
</ul>
<hr>

<a name="disklabel"></a>
<h2>14.1 - OpenBSD's disklabel(8) gebruiken</h2>
<a name="disklabel.1"></a>
<h3>Wat is disklabel(8)?</h3>
  
<p>
Lees zeker eerst de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
man pagina.

<p>
De details van het instellen van schijven in OpenBSD varieert enigszins
tussen platformen.
Voor <a href="../../i386.html">i386</a>,
<a href="../../amd64.html">amd64</a>,
<a href="../../macppc.html">macppc</a>,
<a href="../../zaurus.html">zaurus</a>,
en <a href="../../armish.html">armish</a>
gebeurt de schijfinstelling in twee stadia.
Eerst wordt de OpenBSD "slice" van de harde schijf gedefinieerd met fdisk(8),
vervolgens wordt die slice onderverdeeld in OpenBSD partities met
disklabel(8).

<p>
Alle OpenBSD platformen gebruiken echter disklabel(8) als de primaire
manier om OpenBSD partities te beheren.
Platformen die ook fdisk(8) gebruiken, plaatsen al de disklabel(8) partities
in één enkele fdisk partitie.

<p>
Labels bevatten bepaalde informatie over uw schijf, zoals uw schijfgeometrie
en informatie over de bestandssystemen op de schijf.
Ze bevatten ook informatie over uw schijf zelf, zoals de draaisnelheid,
"interleave", enz., die er om historische redenen in zit, en vaak onjuist is.
Maak u hierover geen zorgen.
De disklabel wordt vervolgens gebruikt door het bootstrap-programma om
toegang te krijgen tot de schijf en om te weten waar bestandssystemen zich
op de schijf bevinden.
U kan meer gedetailleerde informatie over disklabel lezen in de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=5">disklabel(5)</a>
man pagina.

<p>
Op sommige platformen helpt disklabel architectuurbeperkingen qua
schijfpartitionering te overwinnen.
Op i386 bijvoorbeeld, kan u slechts 4 primaire partities hebben, maar met
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
gebruikt u één van deze 'primary' partities om *al* uw OpenBSD
partities (bv. 'swap', '/', '/usr' en '/var', enz.) in te bewaren.
En dan hebt u nog 3 partities over, beschikbaar voor andere besturingssystemen.

<a name="disklabel.2"></a>
<h3>disklabel(8) tijdens de OpenBSD installatie</h3>

<p>
Een van de grote onderdelen van de OpenBSD installatie is het initieel
aanmaken van labels.
Tijdens de installatie gebruikt u disklabel(8) om uw afzonderlijke
partities aan te maken.
Als onderdeel van het installatieproces kan u uw "mount points" definiëren
vanuit disklabel(8), maar u kan deze later ook wijzigen nog tijdens of na
de installatie.

<p>
Er is niet één "juiste" manier om een schijf te labelen, maar er zijn
veel foute manieren.
Alvorens te proberen uw schijf te labelen, zie
<a href="faq4.html#Partitioning">deze discussie</a> over partitioneren
en partitiegroottes.

<p>
Voor een voorbeeld van het gebruik van disklabel(8) tijdens de installatie,
zie het
<a href="faq4.html#Disks">Schijven instellen</a> onderdeel van de
<a href="faq4.html">Installatiegids</a>.


<p>

<a name="disklabel.3"></a>
<h3>disklabel(8) gebruiken na de installatie</h3>

<p>
Na de installatie zal één van de meest voorkomende redenen om disklabel(8)
te gebruiken zijn: bekijken hoe uw schijf georganiseerd is.
Het volgende commando zal u de huidige disklabel tonen, zonder hem te
wijzigen:

<blockquote><pre>
# <b>disklabel wd0</b> &lt;-- <i>Of welke schijf device u graag zou bekijken</i>
# Inside MBR partition 3: type A6 start 63 size 29880837
# /dev/rwd0c:
type: ESDI
disk: ESDI/IDE disk
label: Maxtor 51536H2  
flags:
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 16383
total sectors: 29888820
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # microseconds
track-to-track seek: 0  # microseconds
drivedata: 0 

16 partitions:
#             size        offset  fstype [fsize bsize  cpg]
  a:        614817            63  4.2BSD   2048 16384  328 # Cyl     0*-   609 
  b:        409248        614880    swap                   # Cyl   610 -  1015 
  c:      29888820             0  unused      0     0      # Cyl     0 - 29651*
  d:       6291936       1024128  4.2BSD   2048 16384  328 # Cyl  1016 -  7257 
  e:        409248       7316064  4.2BSD   2048 16384  328 # Cyl  7258 -  7663 
  f:       1024128       9822960  4.2BSD   2048 16384  328 # Cyl  9745 - 10760 
  h:       2097648       7725312  4.2BSD   2048 16384  328 # Cyl  7664 -  9744 
</pre></blockquote>

<p>
Merk op hoe bij deze schijf momenteel slechts een deel van de capaciteit
is toegekend.

Disklabel biedt twee verschillende modi om de disklabel aan te passen:
een ingebouwde commandogestuurde editor (dit is hoe u OpenBSD oorspronkelijk
installeerde), en een volwaardige editor zoals
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vi&amp;sektion=1">vi(1)</a>.
U zal misschien de commandogestuurde editor "gemakkelijker" vinden, aangezien
hij u doorheen alle stappen gidst en op verzoek hulp biedt, maar de
volwaardige editor heeft zeker ook nut.

<p>
Laten we aan het bovenstaande systeem een partitie toevoegen.

<p>
<blockquote>
<i>Waarchuwing: Wanneer u aan uw disklabel begint te peuteren, brengt u
alle gegevens op uw schijf in gevaar.
Zorg ervoor dat uw gegevens gebackupt zijn alvorens een bestaande disklabel
te wijzigen!</i>
</blockquote>

<p>
We zullen de ingebouwde commandogestuurde editor gebruiken, die aangeroepen
wordt met de "-E" optie van disklabel(8).

<blockquote><pre>
# <b>disklabel -E wd0</b>
...
> a k
offset: [10847088] 
size: [19033812] 2g
Rounding to nearest cylinder: 4194288
FS type: [4.2BSD] 
> p m
device: /dev/rwd0c
type: ESDI
disk: ESDI/IDE disk
label: Maxtor 51536H2  
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 16383
total bytes: 14594.2M
free bytes: 7245.9M
rpm: 3600

16 partitions:
#             size        offset  fstype [fsize bsize  cpg]
  a:        300.2M          0.0M  4.2BSD   2048 16384  328 # Cyl     0*-   609 
  b:        199.8M        300.2M    swap                   # Cyl   610 -  1015 
  c:      14594.2M          0.0M  unused      0     0      # Cyl     0 - 29651*
  d:       3072.2M        500.1M  4.2BSD   2048 16384  328 # Cyl  1016 -  7257 
  e:        199.8M       3572.3M  4.2BSD   2048 16384  328 # Cyl  7258 -  7663 
  f:        500.1M       4796.4M  4.2BSD   2048 16384  328 # Cyl  9745 - 10760 
  h:       1024.2M       3772.1M  4.2BSD   2048 16384  328 # Cyl  7664 -  9744 
  k:       2048.0M       5296.4M  4.2BSD   2048 16384   16 # Cyl 10761 - 14921 
> q
Write new label?: [y]
</pre></blockquote>

In dit geval was disklabel(8) vriendelijk genoeg om een goede start "offset"
te berekenen voor de partitie.
In veel gevallen zal het dit kunnen doen, maar als u "gaten" hebt in de
disklabel (dus u hebt een partitie verwijderd, of u houdt er gewoon van om
uw leven ellendig te maken) kan het gebeuren dat u met pen en papier de
juiste offset moet berekenen.
Merk op dat hoewel disklabel(8) een beetje gezondheidscontrole uitvoert,
het heel goed mogelijk is om hier heel verkeerde dingen te doen.
Wees voorzichtig, begrijp de betekenis van de getallen die u ingeeft.

<p>
Op de meeste OpenBSD platformen zijn er zestien disklabel-partities
beschikbaar, aangeduid van "a" tot "p".
(bepaalde "speciale" systemen kunnen er slechts acht hebben).
Elke disklabel zou een 'c' partitie moeten hebben, met een "fstype" van
"unused", die de gehele fysische schijf bedekt.
Als uw disklabel er niet zo uitziet, moet hij hersteld worden, de "D" optie
(zie hieronder) kan helpen.
Probeer nooit de "c" partitie te gebruiken voor iets anders dan toegang te
krijgen tot de "raw" sectoren van de schijf, probeer niet om een
bestandssysteem aan te maken op "c".
Op de boot device wordt "a" gereserveerd voor de rootpartitie, en is "b"
de swappartitie, maar alleen de boot device maakt dit onderscheid.
Andere devices kunnen alle vijftien partities behalve "c" gebruiken voor
bestandssystemen.

<p>
<h3>Disklabel trucs en tips</h3>
<ul>
<li><b>Zoek hulp:</b>  In de commandogestuurde modus, geeft het induwen van
"?" een lijst van beschikbare commando's.
"M" zal de man pagina voor disklabel(8) tonen.

<li><b>Terugzetten naar standaard:</b> In sommige gevallen kan u wensen om
volledig van nul te beginnen en alle bestaande disklabel informatie te
verwijderen.
Het "D" commando zal de label terugzetten op de standaard, alsof er nooit
een disklabel op de schijf was geweest.

<li><b>Een disklabel dupliceren:</b> In sommige gevallen kan u wensen de
partitionering van één schijf naar een andere kopiëren, maar niet exact
(u wenst bijvoorbeeld dezelfde partities te hebben, maar op verschillende
schijfgroottes).
Gebruik de '-e' (volwaardige editor) modus van disklabel(8) om de partities
van de "model"schijf te kopiëren, plak ze in de nieuwe schijf, verwijder
de 'c' partitie van het model, bewaar, en u hebt de schijflayout naar de
andere schijf gekopieerd zonder haar basisparameters te wijzigen.

<li>(sparc/sparc64) <b>Zet swap niet aan het begin van uw schijf.</b>

<li>(i386, amd64) <b>Laat de eerste track vrij:</b>
Op sommige platformen laat u best de eerste logische track ongebruikt, zowel
in disklabel(8) als in fdisk(8).
Deze richtlijn wordt soms vervalst tot "begin de partities op sector 63"
maar dit is ALLEEN waar als dat op uw hardware de grootte is van een track.
Maak niet die veronderstelling, ze is niet altijd juist, disklabel zal u
zeggen wat het denkt dat het aantal sectoren per track is.
Vele andere platformen verwachten dat de OpenBSD partities beginnen op
sector 0.

<li><b>Devices zonder een disklabel:</b>
Als een device momenteel geen OpenBSD disklabel heeft maar een ander
bestandssysteem (bijvoorbeeld een schijf met een vooraf bestaand FAT32
bestandssysteem), zal de OpenBSD kernel er één "creëren" in het geheugen,
en die kan de basis vormen voor een formele OpenBSD disklabel om op de
schijf opgeslagen te worden.
Als er echter een disklabel aangemaakt en naar de schijf weggeschreven
wordt, en er later een niet-OpenBSD bestandssysteem wordt toegevoegd,
dan zal de disklabel niet automatisch geüpdatet worden.
U moet dit zelf doen als u wil dat OpenBSD toegang krijgt tot dat
bestandssysteem.
Meer daarover <a href="faq14.html#foreignfsafter">hieronder</a>.

<li><b>"q" vs. "x":</b>
Om historische redenen bewaart "q" in de commandogestuurde modus van de
editor de wijzigingen en verlaat het programma, en "x" gaat er uit zonder
te bewaren.
Dit is het tegenovergestelde van wat vele mensen nu gewoon zijn in andere
omgevingen.
disklabel(8) waarschuwt wel alvorens de wijzigingen te bewaren, maar het
zal er snel en stil uit gaan met "x".

</ul>


<a name="fdisk"></a>
<h2>14.2 - fdisk(8) gebruiken</h2>

Bekijk zeker de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
man pagina.

<p>
fdisk(8) wordt op sommige platformen (i386, amd64, macppc, zaurus en armish)
gebruikt om een partitie aan te maken die herkend wordt door de boot ROM
van het systeem, en waarin de OpenBSD disklabel partities geplaatst kunnen
worden.
Andere platformen hebben fdisk(8) niet nodig en gebruiken het niet.
fdisk(8) kan ook gebruikt worden voor het manipuleren van de Master Boot
Record (MBR), en dat kan een impact hebben voor alle besturingssystemen
op een computer.
In tegenstelling tot de fdisk-achtige programma's op sommige andere
besturingssytemen, veronderstelt OpenBSD's fdisk dat u weet wat u wil doen.
Voor het overgrote deel zal het u laten doen wat u moet doen, en dit maakt
het een krachtig hulpmiddel om bij de hand te hebben.
Het zal u ook dingen laten doen die u beter niet doet of waarvan het niet
de bedoeling was dat u ze deed, dus het moet voorzichtig gebruikt worden.

<p>
Normaal zal er slechts één OpenBSD fdisk partitie op een schijf geplaatst
worden.
Die partitie zal dan door <a href="#disklabel">disklabel</a> onderverdeeld
worden in OpenBSD bestandssysteempartities.

<p>

<p>
Om gewoon uw partitietabel te bekijken met fdisk, gebruikt u:

<blockquote><pre>
# <b>fdisk sd0</b><br>
</pre></blockquote>

<p>
Dat zal een uitvoer gelijkaardig aan deze geven:

<blockquote><pre>
Disk: sd0       geometry: 553/255/63 [8883945 Sectors]
Offset: 0       Signature: 0xAA55
         Starting       Ending       LBA Info:
 #: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
*0: A6    3   0  1 -  552 254 63 [       48195:     8835750 ] OpenBSD     
 1: 12    0   1  1 -    2 254 63 [          63:       48132 ] Compaq Diag.
 2: 00    0   0  0 -    0   0  0 [           0:           0 ] unused      
 3: 00    0   0  0 -    0   0  0 [           0:           0 ] unused      
</pre></blockquote>

<p>
In dit voorbeeld bekijken we de fdisk uitvoer van de eerste SCSI schijf.
We kunnen de OpenBSD partitie (A6) en haar grootte zien. De * vertelt ons
dat de OpenBSD partitie een bootable partitie is.

<p>
In het voorgaande voorbeeld bekeken we alleen onze informatie. Wat als we
onze partietabel willen bewerken? Wel, om dat te doen moeten we de <b>-e</b>
vlag gebruiken. Dit zal een commandoregel prompt tevoorschijn brengen om met
fdisk te interageren.

<blockquote><pre>
# <b>fdisk -e wd0</b>
Enter 'help' for information
fdisk: 1&gt; <b>help</b>
        help            Command help list
        manual          Show entire OpenBSD man page for fdisk
        reinit          Re-initialize loaded MBR (to defaults)
        setpid          Set the identifier of a given table entry
        disk            Edit current drive stats
        edit            Edit given table entry
        flag            Flag given table entry as bootable
        update          Update machine code in loaded MBR
        select          Select extended partition table entry MBR
        swap            Swap two partition entries
        print           Print loaded MBR partition table
        write           Write loaded MBR to disk
        exit            Exit edit of current MBR, without saving changes
        quit            Quit edit of current MBR, saving current changes
        abort           Abort program without saving current changes
fdisk: 1&gt; 
</pre></blockquote>

<p>

<p>Hier is een overzicht van de commando's die u kan gebruiken wanneer u de
<b>-e</b> vlag kiest.

<ul>
<li><b>help</b>  Toon een lijst van commando's die fdisk gebruikt in de
interactieve edit modus.
<li><b>reinit</b>  Initialiseer de momenteel geselecteerde, in-het-geheugen
kopie van de boot block.
Dit is een handige manier om snel een "full-disk" OpenBSD partitie op zijn
plaats te zetten, de bootcode te updaten, en in het algemeen het systeem
klaar te maken voor OpenBSD (en niets anders dan OpenBSD).
<li><b>disk</b>  Toon de huidige schijfgeometrie die fdisk onderzocht heeft.
U krijgt de gelegenheid om deze te bewerken indien u dat wenst.
<li><b>setpid</b>  Verander de partitie identifier van de gegeven partitietabel
entry. Dit commando is bepaald handig om een bestaande partitie opnieuw toe
te kennen aan OpenBSD.
<li><b>edit</b>  Bewerk een gegeven tabel entry in de geheugenkopie van de
huidige boot block. U kan bewerken ofwel in BIOS geometrie modus, of in
sector offsets en groottes.
<li><b>flag</b>  Maak de gegeven partitietabel entry bootable. Slechts
één entry kan bootable gemarkeerd worden. Als u van een
"extended" partitie wenst te booten, zal u de partitietabel entry voor de
extended partitie bootable moeten markeren.
(OpenBSD zelf kan alleen vanaf primaire partities gestart worden, maar u
kan gelijk welke partitie als bootable markeren.)
<li><b>update</b>  Update de machinecode in de geheugenkopie van de
momenteel geselecteerde boot block.
<li><b>select</b>  Selecteer en laad in het geheugen de boot block waarnaar
verwezen wordt door de extended partitie tabel entry in de huidige boot block.
<li><b>swap</b>  Verwisselt twee MBR entries, zodat u de MBR kan herschikken.
<li><b>print</b>   Vertoon de momenteel geselecteerde in-het-geheugen kopie
van de boot block en zijn MBR tabel op het scherm.
<li><b>write</b>   Schrijf de in-het-geheugen kopie van de boot block naar
de schijf. U zal gevraagd worden om deze handeling te bevestigen.
<li><b>exit</b>  Verlaat het huidige niveau van fdisk, ofwel door terug te keren
naar de voorheen geselecteerde in-het-geheugen kopie van een boot block, ofwel
door het programma te verlaten indien er geen is.
<li><b>quit</b>  Verlaat het huidige niveau van fdisk, ofwel door terug te keren
naar de voorheen geselecteerde in-het-geheugen kopie van een boot block, ofwel
door het programma te verlaten indien er geen is. In tegenstelling tot exit
schrijft dit de gewijzigde block weg.
<li><b>abort</b>   Verlaat het programma zonder de huidige wijzigingen te
bewaren.
</ul>

<h3>fdisk trucs en tips</h3>
<ul>
<!-- <li>On OpenBSD platforms which use fdisk, you should leave the first
track free.
This leaves room for the Master Boot Record, which is where the fdisk
partition table resides.  (not sure if this is true) -->
<li>fdisk(8) biedt de mogelijkheid om partities te wijzigen in "raw sector"
en Cylinder/Head/Sector formaten.
Beide opties worden gegeven voor een reden -- sommige taken worden
gemakkelijker vervuld op de ene manier, andere op de andere manier.
Beperk uzelf niet tot het gebruik van slechts één optie.
<li>Bij een volledig blanco schijf zal de bootcode van de master boot record
naar de schijf geschreven moeten worden alvorens ze kan booten.
U kan hiervoor de "reinit" of "update" opties gebruiken.
Als u nalaat om dit te doen, kan u een geldige partitietabel schrijven met
fdisk, maar geen bootable schijf hebben.
Het kan dat u de bestaande bootcode wil updaten als u onzeker bent van de
oorsprong ervan.
<li>Als uw systeem een "maintenance" of "diagnostic" partitie heeft, wordt
het aanbevolen dat u die op zijn plaats laat of deze installeert VOORDAT
u OpenBSD installeert.
<li>Om historische redenen bewaart "q" de wijzigingen en verlaat het
programma, en "x" verlaat het programma zonder te bewaren.
Dit is het tegenovergestelde van wat vele mensen nu gewoon zijn in andere
omgevingen.
fdisk(8) waarschuwt niet alvorens wijzigingen te schrijven, dus gebruik
het met voorzorg.

</ul>


<a name="NewDisk"></a>
<h2>14.3 - Extra schijven toevoegen in OpenBSD</h2>
<!-- XXX whoa. this section needs rework -->
<p>
Zodra u uw schijf <b>JUIST</b> geïnstalleerd krijgt, moet u
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
(<i>alleen i386</i>) en
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
gebruiken om uw schijf in te stellen in OpenBSD.

<p>
Voor i386 mensen, begin met fdisk. Andere architecturen kunnen dit negeren.
In het onderstaande voorbeeld voegen we een derde SCSI schijf toe aan het
systeem.

<blockquote><pre>
# <b>fdisk -i sd2</b>
</pre></blockquote>

Dit zal de "echte" partitietabel van de schijf initialiseren voor exclusief
gebruik door OpenBSD.
Vervolgens moet u er een disklabel voor aanmaken. Dit zal verwarrend lijken.

<blockquote><pre>
# <b>disklabel -e sd2</b>

<i>(scherm wordt leeg, uw $EDITOR verschijnt)</i>
type: SCSI
<i>...bla...</i>
sectors/track: 63
total sectors: 6185088
<i>...bla...</i>
16 partitions:
#        size   offset    fstype   [fsize bsize   cpg]
  c:  6185088        0    unused        0     0         # (Cyl.    0 - 6135)
  d:  1405080       63    4.2BSD     1024  8192    16   # (Cyl.    0*- 1393*)
  e:  4779945  1405143    4.2BSD     1024  8192    16   # (Cyl. 1393*- 6135)
</pre></blockquote>

Ten eerste, negeer de 'c' partitie, die is er altijd en dient om programma's
als disklabel te laten functioneren!
Fstype voor OpenBSD is 4.2BSD.
Total sectors is de totale grootte van de schijf.  Stel dat dit
een 3 gigabyte schijf is.  Drie gigabytes betekent in schijffabrikant-termen
3000 megabytes.  Deel dus 6185088/3000 (gebruik
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bc&amp;sektion=1">bc(1)</a>).
U bekomt 2061. Om dus partitiegroottes te verzinnen voor a, d, e, f, g, ...
vermenigvuldigt u gewoon X*2061 om X megabytes ruimte te krijgen op die
partitie.
De offset voor uw eerste nieuwe partitie moet hetzelfde zijn als de
"sectors/track" eerder vermeld in de uitvoer van disklabel. Voor ons is dit
63.  De offset voor elke volgende partitie moet een combinatie zijn van de
grootte van elke partiite en de offset van elke partitie (behalve de 'c'
partitie, aangezien die geen rol speelt in deze vergelijking.)

<p>
Of, als u gewoon één partitie op de schijf wil, stel dat u
het hele ding voor webruimte of een home directory of zoiets wil gebruiken,
neem dan gewoon de totale grootte van de schijf en trek het aantal sectoren
per track ervan af.
6185088-63 = 6185025.  Uw partitie is

<blockquote><pre>
    d:  6185025       63    4.2BSD     1024  8192    16 
</pre></blockquote>>

<b>Als dit allemaal nodeloos complex lijkt, kan u gewoon disklabel -E gebruiken
om dezelfde paritioneringsmodus te krijgen die u op uw installatieschijf heeft
verkregen!</b>
Daar kan u gewoon "96M" gebruiken om "96 megabytes" te specificeren, of
96G voor 96 gigs.

<p>
Dat was veel. Maar u bent nog niet klaar. Tenslotte moet u een bestandssysteem
aanmaken op die schijf met
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&amp;sektion=8">newfs(8)</a>.

<blockquote><pre>
# <b>newfs sd2d </b>
</pre></blockquote>

<p>
Of hoe uw schijf ook werd genoemd door OpenBSD's schijfnummeringsschema.
(Kijk naar de uitvoer van
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)</a>
om te zien hoe uw schijf genoemd werd door OpenBSD.)

<p>
Zoek nu uit waar u deze nieuwe partitie die u net gemaakt hebt, gaat mounten.
Stel dat u ze op /u wil plaatsen. Maak eerst de directory /u. Mount ze
vervolgens.

<blockquote><pre>
# <b>mount /dev/sd2d /u</b>
</pre></blockquote>

<p>
Voeg dit tenslotte toe aan
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a>.

<blockquote><pre>
/dev/sd2d /u ffs rw 1 1
</pre></blockquote>

<p>
Wat als u een bestaande directory zoals /usr/local moet migreren? U kan
best de nieuwe schijf in /mnt mounten en <tt>cpio -pdum</tt> gebruiken om de
/usr/local naar de /mnt directory te kopiëren. Bewerk het
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a>
bestand om aan te geven dat de /usr/local partitie nu /dev/sd2d is (uw
vers geformatteerde partitie). Voorbeeld:

<blockquote><pre>
<b>/dev/sd2d /usr/local ffs rw 1 1</b>
</pre></blockquote>

<p>
Herstart in single user modus met <b>boot -s</b>, verplaats de bestaande
/usr/local naar /usr/local-backup (of verwijder het als het vandaag uw
geluksdag is)
en maak een lege directory /usr/local aan. Herstart vervolgens het systeem,
en voila, de bestanden zijn er!


<a name="SwapFile"></a>
<a name="Swap"></a>
<h2>14.4 - Hoe wordt swap gebruikt?</h2>

<h3>14.4.1 - Over swap</h3>
In het verleden werden er allerlei regels uitgestort over beheerders
over de hoeveelheid swap die op hun machines ingesteld moest worden.
Het probleem is uiteraard, dat er weinig "normale" applicaties zijn.

<p>
Een niet voor de hand liggend gebruik van swap is om een plek te bieden aan
de kernel om een kopie te dumpen van wat er in de core zit in het geval van
een system panic voor latere analyse. Om dit te laten werken, moet u een
swap-partitie hebben (geen swap-file) die minstens zo groot is als de
hoeveelheid RAM.
Het systeem bewaart standaard een kopie van deze dump in <tt>/var/crash</tt>
wanneer het opstart, dus als u dit automatisch wilt kunnen doen, dan moet
er voldoende <i>vrije</i> ruimte zijn op <tt>/var</tt>.
U kunt het systeem echter ook booten in sinlge-user mode en
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=savecore&amp;sektion=8">savecore(8)</a>
gebruiken om de demp elders op te slaan.

<p>
Veel typen systemen kunnen correct geconfigureerd zijn met helemaal
geen swap.
Een firewall bijvoorbeeld zou niet moeten swappen bij normaal gebruik.
Machines met flash opslag zouden in het algemeen niet moeten swappen.
Als uw firewall op flash is gebaseerd, heeft u wellicht een (klein)
voordeel door geen swap partitie te alloceren, maar in de meeste andere
gevallen kan een swap partitie absoluut geen kwaad; de meeste schijven
hebben meer dan genoeg ruimte om een beetje swap te alloceren.

<p>
Er zijn allerlei soorten tips over het optimaliseren van swap (waar op
de schijf, aparte schijven, etc.), maar als u in een situatie zit waarbij
het optimaliseren van swap een probleem is, dan heeft u waarschijnlijk meer
RAM nodig.
De beste optimalisatie voor swap is in het algemeen om het niet nodig te
hebben.

<p>
In OpenBSD wordt swap beheerd met het
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=swapctl&amp;sektion=8">swapctl(8)</a>
programma, dat swap devices en bestanden toevoegt, verwijdert, laat zien en
prioriteiten toekent.


<h3>14.4.2 - Swappen naar een partitie</h3>
<p>
Op OpenBSD wordt de 'b' partitie op de boot disk standaard en automatisch
gebruikt voor swap.
Hiervoor is geen configuratie nodig.
Als u geen swap op de boot disk wilt gebruiken, definieer dan geen 'b'
partitie.
Als u wilt swappen op andere partities of andere schijven, dan moet u
deze partities in <tt>/etc/fstab</tt> definiëren met regels als:

<blockquote><pre>
/dev/sd3b none swap sw 0 0
/dev/sd3d none swap sw 0 0
</pre></blockquote>


<h3>14.4.3 - Swapping to a file</h3>

(Opmerking: als u naar een bestand wil swappen omdat u
&quot;virtual memory exhausted&quot; fouten krijgt, kan u best eerst de
per-proces limieten proberen te verhogen met
csh's <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=unlimit&amp;sektion=1">unlimit(1)</a>,
of
sh's <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ulimit&amp;sektion=1">ulimit(1)</a>.)

<p>
Soms blijkt uw eerste gok over de hoeveelheid swap die u nodig heeft
niet te kloppen en moet u extra swapruimte toevoegen, soms met spoed
(bijvoorbeeld: "Gut, als we met deze snelheid de swap opstoken, worden
we binnen 5 minuten geplet").
Als u zich in deze positie bevindt, kan het toevoegen van swapruimte in een
bestand op een bestaand filesystem een snelle oplossing bieden.

<p>
Het bestand mag niet op een bestandssysteem staan
dat SoftUpdates ingeschakeld heeft (dit is standaard uitgeschakeld). Om te
beginnen kan u zien hoeveel swap u momenteel hebt en hoeveel u gebruikt met de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=swapctl&amp;sektion=8">swapctl(8)</a>
utility. U kan dit doen met het commando:

<blockquote><pre>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
</pre></blockquote>

<p>
Dit toont de devices die momenteel gebruikt worden om te swappen en hun
huidige statistieken. In het bovenstaande voorbeeld is er slechts
één device, met name &quot;swap_device&quot;.
Dit is het voorgedefinieerde gebied op de schijf dat gebruikt wordt om te
swappen. (Verschijnt als partitie b bij het bekijken van disklabels.) Zoals
u ook kan zien in het bovenstaande voorbeeld, wordt dat device momenteel
niet veel gebruikt, maar voor de bedoeling van dit document zullen we doen
alsof er 32M extra benodigd is.

<p>
De eerste stap om een bestand als een swap device in te stellen, is om een
bestand aan te maken. Het beste is om dit te doen met de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&amp;sektion=1">dd(1)</a>
utility. Hier is een voorbeeld van het aanmaken van het bestand
<i>/var/swap</i> dat 32M groot is.

<blockquote><pre>
$ <b>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</b>
32768+0 records in
32768+0 records out
33554432 bytes transferred in 20 secs (1677721 bytes/sec)
</pre></blockquote>

<p>
Zodra dit gebeurd is, kunnen we swappen naar dat device aanzetten. Gebruik
het volgende commando om het swappen naar dit device aan te zetten

<blockquote><pre>
$ <b>sudo chmod 600 /var/swap</b>
$ <b>sudo swapctl -a /var/swap</b>
</pre></blockquote>

<p>
Nu moeten we controleren om te zien of het juist werd toegevoegd aan de lijst
van onze swap devices.

<blockquote><pre>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
/var/swap        65536        0    65536     0%    0
Total           131056        8   131048     0%
</pre></blockquote>

<p>
Nu het bestand is ingesteld en het swappen gebeurt, moet u een lijn toevoegen
aan uw <i>/etc/fstab</i> bestand zodat dit bestand geconfigureerd wordt ook
de volgende keer als u start. Als deze lijn niet toegevoegd wordt, zal dit
swap device niet geconfigureerd worden.

<blockquote><pre>
$ <b>cat /etc/fstab</b>
/dev/wd0a / ffs rw 1 1
/var/swap /var/swap swap sw 0 0
</pre></blockquote>


<a name="SoftUpdates"></a>
<h2>14.5 - Soft Updates</h2>

<p>
Soft Updates is gebaseerd op een idee voorgesteld door
<a href="http://www.ece.cmu.edu/~ganger/papers/CSE-TR-254-95/">Greg Ganger
en Yale Patt</a> en ontwikkeld voor FreeBSD door
<a href="http://www.mckusick.com/softdep/">Kirk McKusick</a>.
SoftUpdates legt een gedeeltelijke schikking op aan de buffer cache operaties
die toelaat de vereiste voor het synchroon schrijven van directory entries
te verwijderen uit de FFS code. Dus, een grote performantiestijging wordt
waargenomen in schijf-schrijfprestatie.

<p>
Soft updates inschakelen moet gedaan worden met een mount-optie. Bij het
mounten van een partitie met de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a> 
utility, kan u specificeren dat u soft updates wenst in te schakelen op die
partitie. Hieronder is een voorbeeld
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a></i> 
lijn die één partitie <i>sd0a</i> heeft die we graag zouden
mounten met soft updates.

<blockquote><pre>
/dev/sd0a / ffs rw,softdep 1 1
</pre></blockquote>

<p>
Opmerking voor sparc gebruikers: Schakel soft updates niet in op sun4 of
sun4c machines. Deze architecturen ondersteunen slechts een heel beperkte
hoeveelheid kernelgeheugen en kunnen deze functionaliteit niet gebruiken.
sun4m machines zijn echter wel goed.

<a name="Boot386"></a>
<h2>14.6 - Hoe boot OpenBSD/i386?</h2>
Het bootproces voor OpenBSD/i386 is niet triviaal, en begrijpen hoe het werkt,
kan nuttig zijn om een probleem te onderzoeken wanneer er dingen niet werken.
Er zijn vier sleutelelementen voor het bootproces:
<ol>
<li><b><i>Master Boot Record (MBR):</i></b> De Master Boot Record is de
eerste fysische sector (512 bytes) op de schijf.
Deze bevat de primaire partitietabel en een klein programma om de
Partition Boot Record (PBR) te laden.
Merk op dat in sommige omgevingen, de term "MBR" gebruikt wordt om alleen
naar het code-gedeelte van dit eerste blok op de schijf te verwijzen,
veeleer dan naar het volledige eerste blok (inclusief de partietabel).
Het is cruciaal om de betekenis te begrijpen van "de MBR initaliseren" -- in
de terminologie van OpenBSD zou dit het herschrijven van de volledige MBR
sector inhouden, niet alleen de code, zoals het op sommige systemen zou kunnen
betekenen.
U zal dit zelden willen doen.
Gebruik in de plaats fdisk(8)'s "-u" commandoregeloptie
("<tt>fdisk -u wd0</tt>").

<p>
Hoewel OpenBSD een MBR bevat, bent u niet verplicht om deze te gebruiken,
aangezien praktisch gelijk welke MBR OpenBSD kan booten.
De MBR wordt gemanipuleerd door het fdisk(8) programma, dat gebruikt wordt
zowel om de partitietabel de bewerken, als om de MBR code op de schijf te
installeren.

<p>
OpenBSD's MBR kondigt zichzelf aan met de boodschap:

<blockquote><pre>
    Using drive 0, partition 3.
</pre></blockquote>

wat de schijf en de partitie toont waar het de PBR vandaan zal laden.
Bovenop het vanzelfsprekende, toont dit ook een punt (".") achteraan, wat
aangeeft dat de machine LBA vertaling kan gebruiken om te booten.
Als de machine geen LBA translatie kon gebruiken, zou het bovenstaande
punt vervangen geweest zijn door een kommapunt (";"), dat CHS vertaling
aangeeft:

<blockquote><pre>
Using drive 0, partition 3;
</pre></blockquote>

Merk op dat het punt of kommapunt achteraan gebruikt kan worden als een
indicator van de "nieuwe" OpenBSD MBR, geïntroduceerd in OpenBSD 3.5.

<li><b><i>Partition Boot Record (PBR):</i></b>
De Partition Boot Record, ook PBR genoemd of
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8&amp;arch=i386">biosboot(8)</a>
(volgens de naam van het bestand dat de code bevat) is de eerste fysische
sector van de OpenBSD partitie op de schijf.
De PBR is de "first-stage boot loader" voor OpenBSD.
Deze wordt geladen door de MBR code,
en heeft de taak om de OpenBSD second-stage boot loader,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">boot(8)</a> in te laden.
Net als de MBR is de PBR een heel kleine sectie van code en gegevens,
in totaal slechts 512 bytes.
Dat is niet voldoende om een volledige bestandssysteem-bewuste toepassing
te hebben, dus veeleer dan de PBR <tt>/boot</tt> te laten lokaliseren op de
schijf, wordt de BIOS-toegankelijke locatie van <tt>/boot</tt> fysisch
in de PBR gecodeerd bij de installatie.

<p>
De PBR wordt geïnstalleerd door
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=installboot&amp;sektion=8&amp;arch=i386">installboot(8)</a>,
dat <a href="faq14.html#InstBoot">verder in dit document</a>
nader beschreven wordt.
De PBR kondigt zichzelf aan met de boodschap:
<blockquote><pre>
    Loading...
</pre></blockquote>
en geeft daarbij een punt weer voor elk bestandssysteem-blok dat het probeert
te laden.
Ook hier, de PBR toont of hij LBA of CHS gebruikt om te laden, als hij CHS
vertaling moet gebruiken, toont hij een boodschap met een kommapunt:
<blockquote><pre>
    Loading;... 
</pre></blockquote>
De oudere (pre v3.5) biosboot(8) vertoonde de boodschap "<tt>reading
boot...</tt>".


<li><b><i>Second Stage Boot Loader, <tt>/boot</tt>:</i></b> <tt>/boot</tt>
wordt geladen door de PBR, en heeft de taak om toegang te krijgen tot het
OpenBSD bestandssysteem via de BIOS van de machine, en om de eigenlijke
kernel te localiseren en te laden.
boot(8) geeft ook verscheidene opties en informatie door aan de kernel.
<p>
boot(8) is een interactief programma. Nadat het laadt, probeert het
<tt>/etc/boot.conf</tt> te localiseren en te lezen, indien het bestaat (dit
is niet het geval op een standaardinstallatie), en verwerkt de commando's
daarin. Tenzij anders opgelegd door <tt>/etc/boot.conf</tt>, geeft het
vervolgens een prompt aan de gebruiker:

<blockquote><pre>
probing: pc0 com0 com1 apm mem[636k 190M a20=on]
disk: fd0 hd0+
>> OpenBSD/i386 BOOT 3.02
boot>
</pre></blockquote>

Het geeft de gebruiker (standaard) vijf seconden om het andere taken te
geven, maar als er geen gegeven worden voor de timeout, begint het zijn
standaardgedrag: de kernel, <tt>bsd</tt>, inladen vanaf de root partitie
van de eerste harde schijf.
De second-stage boot loader onderzoekt uw systeem hardware via de BIOS
(aangezien de OpenBSD kernel niet geladen is).
Hierboven kan u enkele dingen zien die het gezocht en gevonden heeft:
<ul>
<li><b>pc0</b> - de standaard toetsenbord en video display van een i386 systeem.
<li><b>com0, com1</b> - Twee seriële poorten
<li><b>apm</b> - Advanced Power Management BIOS functies
<li><b>636k 190M</b> - De hoeveelheid conventioneel (onder 1M) en
extended (boven 1M) geheugen die het gevonden heeft
<li><b>fd0 hd0+</b> - De gevonden BIOS schijf devices, in dit geval, een
diskette en een harde schijf.
</ul>

Het '+' teken na de "hd0" geeft aan dat de BIOS tegen <tt>/boot</tt> gezegd
heeft dat deze schijf toegankelijk is via LBA.
Bij het uitvoeren van een eerste installatie zult u soms een '*' zien na een
harde schijf -- dit geeft een schijf aan die geen geldige OpenBSD disklabel
heeft.


<li><b><i>Kernel: <tt>/bsd</tt></i>:</b>  Dit is het doel van het bootproces,
om de OpenBSD kernel in RAM te laden en juist te laten draaien.
Zodra de kernel geladen is, heeft OpenBSD rechtstreeks toegang tot de
hardware, niet langer via de BIOS.

</ol>

Dus, het prille begin van het bootproces kan er als volgt uitzien:

<blockquote><pre>
Using drive 0, partition 3.                      <b><i>&lt;- MBR</i></b>
Loading....                                      <b><i>&lt;- PBR</i></b>
probing: pc0 com0 com1 apm mem[636k 190M a20=on] <b><i>&lt;- /boot</i></b>
disk: fd0 hd0+
>> OpenBSD/i386 BOOT 3.02
boot>
booting hd0a:/bsd 4464500+838332 [58+204240+181750]=0x56cfd0
entry point at 0x100120

[ using 386464 bytes of bsd ELF symbol table ]
Copyright (c) 1982, 1986, 1989, 1991, 1993       <b><i>&lt;- Kernel</i></b>
        The Regents of the University of California.  All rights reserved.
Copyright (c) 1995-2008 OpenBSD.  All rights reserved.  http://www.OpenBSD.org

OpenBSD 4.6 (GENERIC.MP) #89: Thu Jul  9 21:32:39 MDT 2009
    deraadt@i386.openbsd.org:/usr/src/sys/arch/i386/compile/GENERIC.MP
   ...
</pre></blockquote>


<h3>What kan er verkeerd gaan</h3>
<ul>
<li><b>Slechte/ongeldige/incompatibele MBR:</b>
Gewoonlijk heeft een gebruikte harde schijf al wat MBR code op zijn plaats,
maar als de schijf nieuw is of verplaatst wordt vanuit een verschillend
platform, EN u antwoordt niet "w" op de "Use (W)hole disk or (E)dit the MBR?"
vraag van het <a href="faq4.html#InstDisks">installatieproces</a>, kan u
komen te zitten met een schijf zonder geldige MBR, en deze zal dus niet
bootable zijn, ook al heeft ze een geldige partitietabel.

<p>
U kan de OpenBSD MBR op uw schijf installeren met het fdisk programma.
Boot vanaf uw installatiemedium, kies "Shell" om een commandoprompt te krijgen:

<blockquote><pre>
# <b>fdisk -u wd0</b>
</pre></blockquote>

U kan met fdisk ook een specieke MBR naar de schijf schrijven:
<blockquote><pre>
# <b>fdisk -u -f /usr/mdec/mbr wd0 </b>
</pre></blockquote>

dit zal het bestand <tt>/usr/mdec/mbr</tt> installeren als MBR van uw systeem.
Dit welbepaald bestand is op een standaard OpenBSD installatie toevallig de
standaard MBR die ook in fdisk ingebouwd zit, maar gelijk welke andere
MBR zou hier kunnen gespecificeerd worden.

<li><b>Ongeldige <tt>/boot</tt> locatie geïnstalleerd in PBR:</b>
Wanneer installboot(8) de partition boot record installeert, schrijft het het
bloknummer en offset van de inode van <tt>/boot</tt> in de PBR.
Daarom zal het verwijderen en vervangen van <tt>/boot</tt> zonder opnieuw
<a href="faq14.html#InstBoot">installboot(8)</a> uit te voeren, ervoor zorgen
dat uw systeem niet bootable is, aangezien de PBR zal inladen wat er toevallig
aangeduid wordt door de inode die er in gespecificeerd is, wat bijna zeker
niet langer de gewenste second-stage boot loader zal zijn!

Aangezien <tt>/boot</tt> gelezen wordt met BIOS aanroepen, waren oude versies
van de PBR gevoelig aan BIOS schijfvertaling. Als u de schijfgeometrie
veranderde (bv. u nam ze uit een computer die CHS vertaling gebruikt en
verplaatste ze naar een die LBA vertaling gebruikt, of u veranderde zelfs
een vertalingsoptie in uw BIOS), dan zou het <i>voor de BIOS lijken</i>
alsof het op een andere locatie stond (een ander numeriek blok moet
opgevraagd worden om dezelfde gegevens van de schijf te krijgen), dus u had
installboot(8) moeten uitvoeren alvorens het systeem kon herstart worden.
De nieuwe (vanaf OpenBSD 3.5 en later) PBR is veel toleranter voor
veranderingen in vertaling.
</ul>

Aangezien de PBR heel klein is, is zijn bereik van foutboodschappen vrij
beperkt, en een beetje cryptisch. De meest waarschijnlijke boodschappen zijn:

<ul>
<li><b>ERR R</b> -- BIOS gaf een fout bij het proberen lezen van een blok
vanaf de schijf.
Gewoonlijk betekent dit precies wat het zegt: uw schijf was niet leesbaar.
<li><b>ERR M</b> -- Er werd een ongeldig
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=magic&amp;sektion=5">magic(5)</a>
nummer gelezen in de hoofding van de second-stage bootloader's.
Dit betekent in het algemeen dat wat er ook ingelezen werd, NIET
<tt>/boot</tt> was, wat gewoonlijk betekent dat installboot(8) niet juist
werd uitgevoerd, het /boot bestand aangepast werd, of u de mogelijkheid
van uw BIOS om een <a href="#LargeDrive">grote schijf</a> te lezen, oversteeg.

</ul>
Andere foutboodschappen worden uitgebreid uitgelegd in de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8&amp;arch=i386">biosboot(8)</a>
manual pagina.

<p>
Voor meer informatie over het i386 bootproces, zie
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot_i386&amp;sektion=8&amp;arch=i386">boot_i386(8)</a>
<li><a href="http://www.ata-atapi.com/hiw.html">http://www.ata-atapi.com/hiw.html</a>
  Hale Landis' "How it Works" documenten.
</ul>

<a name="LargeDrive"></a>
<h2>14.7 - Wat zijn de problemen met grote schijven in OpenBSD?</h2>

<p>
OpenBSD ondersteunt zowel FFS als FFS2 (ook bekend als UFS en UFS2)
bestandssystemen.
FFS is het historische OpenBSD bestandssysteem, FFS2 is nieuw vanaf 4.3.
Alvorens de grenzen van elk systeem te bekijken, moeten we enkele meer
algemene systeemgrenzen bekijken.

<p>
Natuurlijk zijn de mogelijkheden van bestandssystemen en de mogelijkheden van
bepaalde hardware twee verschillende dingen.
Een nieuwe 250G harde schijf kan problemen hebben op oudere (pre >137G
standaarden) interfaces (hoewel ze voor het grootste deel gewoon prima werken),
en bij sommige heel oude SCSI adapters werden
problemen gezien met meer moderne schijven, en sommige oudere BIOSen zullen
vasthangen wanneer ze een harde schijf met moderne grootte tegenkomen.
U moet natuurlijk de mogelijkheden van uw hardware respecteren.

<h3>Partitiegrootte en -locatie beperkingen</h3>
Jammer genoeg is de volledige mogelijkheid van het besturingssysteem niet
beschikbaar tot NADAT het besturingssysteem in het geheugen geladen is.
Het boot proces moet het boot RAM van het systeem gebruiken (en wordt
er dus door beperkt).
 
<p>
Om deze reden moet het volledige /bsd bestand (de kernel) op de schijf staan
binnen de door het boot ROM adresseerbare gebied.
Dit betekent dat op sommige oudere i386 systemen, de root partitie volledig
binnen de eerste 504M moet vallen, maar nieuwere computers kunnen beperkingen
van 2G, 8G, 32G, 128G of meer hebben.
Het is de moeite waard om op te merken dat vele relatief nieuwe computers die
schijven groter dan 128G ondersteunen, in feite BIOS beperkingen hebben
waardoor ze enkel van binnen de eerste 128G kunnen booten.
U kan deze systemen met grotere schijven gebruiken, maar uw root partitie
moet vallen binnen de ruimte die ondersteund wordt door het boot ROM.
 
<p>
Merk op dat het mogelijk is om een 40G schijf op een oude 486 te installeren
en OpenBSD er op te laden als één grote partitie, en te denken
dat u met succes de bovenstaande regel overtreden hebt. Het kan u echter
op de meest onaangename manier komen kwellen:

<ul>
  <li>U installeert op de 40G / partitie.  Het werkt, omdat het basis
besturingssysteem en alle bestanden ervan (/bsd inbegrepen) binnen de eerste
504M staan.
  <li>U gebruikt het systeem, en bekomt hierop uiteindelijk meer dan 504M aan
bestanden.
  <li>U doet een upgrade, bouwt uw eigen kernel, wat dan ook, en kopieert
uw nieuwe /bsd over de oude.
  <li>U herstart.
  <li>U krijgt een boodschap als "ERR M" of andere problemen bij het booten.
</ul>
<p>
Waarom? Omdat wanneer u het nieuwe /bsd bestand "over" kopieerde, dit niet
het oude overschreef, het werd een nieuwe locatie toegekend op de schijf,
waarschijnlijk buiten het 504M bereik dat het BIOS ondersteunt. De
boot loader kon het bestand /bsd niet opvragen, en het systeem hing vast.

<p>
Om OpenBSD te kunnen booten, moeten de boot loaders (biosboot(8) en
<tt>/boot</tt> in het geval van i386/amd64) en de kernel (<tt>/bsd</tt>)
binnen het door het BIOS ondersteunde bereik zitten, en binnen hun eigen
mogelijkheden.
Om op veilig te spelen, is de regel eenvoudig:

<p>
<b>de volledige root partitie moet binnen de door het BIOS van de computer
(of door het boot ROM) adresseerbare ruimte vallen.</b>

<p>
Sommige niet-i386 gebruikers denken dat ze hier immuun voor zijn, maar
de meeste platformen hebben een vorm van boot ROM beperking voor schijfgrootte.
Helemaal zeker te weten komen wat die beperking is, kan echter moeilijk zijn.

<p>
Dit is nog een andere goede reden om <a href="faq4.html#Partitioning">uw schijf
te partitioneren</a>, veeleer dan één grote partitie te
gebruiken.

<h3>fsck(8) tijd- en geheugenvereisten</h3>
Een andere overweging i.v.m. grote bestandssystemen is de tijd en het
geheugen vereist om
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)</a>
uit te voeren op het bestandssysteem na een crash of stroomonderbreking.
Men kan beter niet een 120G bestandssysteem zetten op een systeem met 32M RAM
en verwachten dat het met succes fsck(8) uitvoert na een crash.
Een grove richtlijn is dat het systeem ten minste 1M beschikbaar geheugen
zou moeten hebben voor elke 1G aan schijfruimte om met succes fsck uit te
voeren op de schijf.
Swap kan hier gebruikt worden, maar met een aanzienlijk performantieverlies,
zo erg dat het gewoonlijk onaanvaardbaar is, tenzij in speciale gevallen.

<p>
De tijd vereist om fsck op de schijf uit te voeren, kan een probleem worden
naarmate het bestandssysteem uitbreidt, maar u hoeft alleen de schijfruimte
te fsck'en die werkelijk gealloceerd is aan gemounte bestandssystemen.
Dit is nog een reden waarom u NIET al uw schijfruimte wil toekennen gewoon
omdat ze er is.
Bestandssystemen mounten met RO of ze niet mounten helpt om te vermijden
dat ze gefsck(8)ed moeten worden na het struikelen over een stroomdraad.

<p>
Vergeet niet dat als u meerdere schijven in het systeem hebt, het zou kunnen
dat ze allemaal terzelfdertijd gefsck(8)ed worden na een crash, dus dat zou
meer RAM kunnen vergen dan een enkele schijf.

<p>
Zodra men een bestandssysteem wat groter dan 1TB bereikt met standaard
fragment- en blokgroottes, zal fsck 1GB RAM vereisen om te draaien, wat de
limiet is voor applicaties onder OpenBSD.
Grotere fragmenten en/of blokken zullen het aantal inodes terugdringen
en grotere bestandssystemen toelaten.

<h3>FFS vs. FFS2</h3>
Met FFS ondersteunt OpenBSD een individueel bestandssysteem tot
2<sup>31</sup>-1, ofwel 2,147,483,647 sectoren, en aangezien elke sector
512 bytes groot is, is dat iets minder dan 1T.
FFS2 kan veel grotere bestandssystemen aan, hoewel andere grenzen zullen
bereikt worden lang voordat de grenzen van het bestandssysteem bereikt zijn.

<p>
De boot/installatiekernels <i>ondersteunen alleen FFS</i>, niet FFS2, dus
systeempartities met een sleutelrol (<tt>/, /usr, /var, /tmp</tt>) mogen niet
FFS2 zijn, of ernstige onderhoudsproblemen kunnen zich voordoen (er zou toch
geen reden mogen zijn waarom die partities zo groot moeten zijn).
Om deze reden worden heel grote partities best alleen gebruikt worden voor
"niet-systeem" partities, bijvoorbeeld <tt>/home, /var/www/,
/bigarray</tt>, etc.

<p>
Voor het uitvoeren van upgrades zal u FFS2 partities als "noauto" willen
aanduiden om te vermijden dat ze verkeerd behandeld worden door de
installatiekernel (die geen FFS2 partities ondersteunt).

<p>
Merk op dat niet alle controllers en drivers grote schijven ondersteunen.
Bijvoorbeeld,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ami&amp;sektion=4">ami(4)</a>
heeft een begrenzing van 2TB per logisch volume.
Vele werden gewoon nog niet getest, bij dit schrijven waren er geen >1TB IDE
of SATA drives beschikbaar voor tests, dus we kunnen nog niet met zekerheid
zeggen dat alles perfect werkt.

<a name="InstBoot"></a>
<h2>14.8 - Installeren van Bootblocks - i386/amd64 specifiek</h2>

<p>
Moderne versies van OpenBSD (3.5 en recenter) hebben een heel robuuste
bootloader die veel onverschilliger is voor schijfgeometrie dan de oudere
bootloader; ze zijn echter gevoelig aan waar het
<tt><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386"
>/boot</a></tt> bestand zich op de schijf bevindt.
Als u iets doet waardoor boot(8) verplaatst wordt naar een nieuwe plek
op de schijf (eigenlijk een nieuwe inode), dan zal u uw systeem "breken",
het zal niet juist meer kunnen opstarten.
Om uw boot block
te herstellen zodat u normaal kan booten, plaatst u eerst een bootdiskette
in uw diskettestation (of gebruik een bootable CD-ROM) en typ op de boot
prompt "b hd0a:/bsd" om het te dwingen vanaf de eerste harde schijf (en
niet vanaf de diskette) te booten. Uw machine zou zoals normaal moeten
opstarten.
Nu moet u de first-stage bootloader
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8&amp;arch=i386"
>biosboot(8)</a>) herinstalleren op basis van de positie van het
<tt>/boot</tt> bestand, met het
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=installboot&amp;sektion=8&amp;arch=i386"
>installboot(8)</a> programma.

<p>
Ons voorbeeld zal veronderstellen dat uw boot schijf sd0 is (maar voor
IDE zou het wd0, enz. zijn):

<blockquote><pre>
# <b>cd /usr/mdec; ./installboot /boot biosboot sd0</b>
</pre></blockquote>

<p>
Als een nieuwere versie van bootblocks vereist is, zal u deze zelf moeten
compileren. Hiervoor doet u eenvoudigweg:

<blockquote><pre>
# <b>cd /sys/arch/i386/stand/</b>
# <b>make &amp;&amp; make install </b>
# <b>cd /usr/mdec; cp ./boot /boot</b>
# <b>./installboot /boot biosboot sd0</b> (of welk device uw harde schijf ook is)
</pre></blockquote>

<a name="Backup"></a>
<h2>14.9 - Zich op het ergste voorbereiden: Backup en Restore vanaf tape</h2>

<h3>Inleiding:</h3>

<p>
Als u van plan bent om iets te draaien dat een productieserver zou kunnen
genoemd worden, is het aan te raden om een vorm van backup te hebben voor
het geval één van uw vaste schijven het begeeft.

<p>
Deze informatie zal u de standaard
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>/<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>
utilities helpen gebruiken die voorzien zijn in OpenBSD.
Een meer geavanceerde backup utility,
"<a href="http://www.amanda.org">Amanda</a>" genoemd, is ook beschikbaar via
<a href="faq15.html#PkgMgmt">packages</a> om meerdere servers naar één
tape drive te backup'en.
In de meeste omgevingen is
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>/<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>
voldoende. Als u echter meerdere machines moet backupen, kan
het de moeite lonen om Amanda te bekijken.

<p>
De device voorbeelden in dit document zijn voor een configuratie die
SCSI schijven en tape gebruikt. In een productie-omgeving worden SCSI schijven
aanbevolen eerder dan IDE vanwege de manier waarop ze slechte blokken
behandelen.
Dat wil niet zeggen dat deze informatie nutteloos is als u een IDE schijf
of een ander type van tape drive gebruikt, uw device-namen zullen gewoon
lichtjes verschillen. Zo zou sd0a bijvoorbeeld wd0a zijn in een
IDE-gebaseerd systeem.

<h3>Backup naar tape:</h3>

<p>
Backup naar tape vereist kennis van waar uw bestandssystemen gemount zijn.
U kan te weten komen hoe uw bestandssystemen gemount zijn met het
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>
commando op uw shell prompt. U zou uitvoer moeten krijgen gelijkaardig aan:

<blockquote><pre>
# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0h on /usr type ffs (local)
</pre></blockquote>

<p>
In dit voorbeeld staat het root (/) bestandssysteem fysisch op sd0a
dat aangeeft: SCSI vaste schijf 0, partitie a. Het /usr bestandssysteem
verblijft op sd0h, wat aangeeft: SCSI vaste schijf 0, partitie h.

<p>
Een ander voorbeeld van een meer geavanceerde mount-tabel zou kunnen zijn:

<blockquote><pre>
# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0d on /var type ffs (local)
/dev/sd0e on /home type ffs (local)
/dev/sd0h on /usr type ffs (local)
</pre></blockquote>

<p>
In dit meer geavanceerde voorbeeld staat het root (/) bestandssysteem
fysisch op sd0a. Het /var bestandssysteem staat op sd0d, het /home
bestandssysteem op sd0e en tenslotte /usr op sd0h.

<p>
Om uw machine te backup'en zal u dump de naam moeten meegeven van elke
vaste schijfpartitie. Hier is een voorbeeld van de commando's nodig voor
een backup van de eenvoudigere mount-tabel die hoger getoond werd:

<blockquote><pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h</b>
# <b>mt -f /dev/rst0 rewind  </b>
</pre></blockquote>

<p>
Voor het voorbeeld van de meer geavanceerde mount tabel, zou u iets gebruiken
dat lijkt op:

<blockquote><pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h  </b>
# <b>mt -f /dev/rst0 rewind  </b>
</pre></blockquote>

<p>
U kan de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>
man pagina bekijken om precies te leren wat elke commandolijn-optie doet. Hier
is een korte omschrijving van de parameters die hierboven gebruikt werden:

<ul>
<li><b>0</b> - Voer een level 0 dump uit, neem alles
<li><b>a</b> - Probeer automatisch de lengte van het tape medium te bepalen
<li><b>u</b> - Update het bestand /etc/dumpdates om aan te geven wanneer de
laatste backup uitgevoerd werd
<li><b>f</b> - Welk tape device te gebruiken (/dev/nrst0 in dit geval)
</ul>

<p>
Tenslotte welke partitie te backup'en (/dev/rsd0a, etc.)

<p>
Aan het einde wordt het
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mt&amp;sektion=1">mt(1)</a>
commando gebruikt om de tape terug te spoelen. Bekijk de mt man
pagina voor meer opties (zoals eject).

<p>
Als u niet zeker bent van uw tape devicenaam, gebruik dan dmesg om hem te
localiseren. Een voorbeeld van een tape drive entry in dmesg zou hierop
kunnen lijken:

<blockquote><pre>
st0 at scsibus0 targ 5 lun 0: &lt;ARCHIVE, Python 28388-XXX, 5.28&gt;
</pre></blockquote>

<p>
U hebt misschien opgemerkt dat bij de backup, toegang tot de tape gebeurt
via de devicenaam "<tt>nrst0</tt>" in plaats van de "<tt>st0</tt>" naam die
in dmesg gezien wordt.
Wanneer u <tt>st0</tt> als <tt>nrst0</tt> benadert, benadert u dezelfde
fysische tape maar zegt u daarbij dat hij niet moet terugspoelen aan het
einde van de taak en benadert u het device in "raw" modus. Om meerdere
bestandssystemen naar een enkele tape te backup'en, gebruik dan zeker het
non-rewind device, als u een rewind device (<tt>rst0</tt>) gebruikt om
meerdere bestandssystemen te backup'en, zal u uiteindelijk het vorige door
het volgende bestandssysteem overschrijven dat dump naar tape probeert te
schrijven. U kan een meer uitgebreide beschrijving van verschillende tape
devices terugvinden in de dump man pagina.

<p>
Als u een klein script met de naam "backup" wou schrijven, zou dit er
ongeveer zou kunnen uitzien:

<blockquote><pre>
echo "  Starting Full Backup..."
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h
echo
echo -n "  Rewinding Drive, Please wait..."
mt -f /dev/rst0 rewind
echo "Done."
echo
</pre></blockquote>

<p>
Als geplande nachtelijke backups gewenst zijn, zou
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cron&amp;sektion=8">cron(8)</a>
gebruikt kunnen worden om uw backup script automatisch te starten.

<p>
Het zal ook nuttig zijn om te documenteren (op een stukje papier) hoe groot
elk bestandssysteem moet zijn. U kan "<tt>df -h</tt>" gebruiken om te bepalen
hoeveel ruimte elke partitie momenteel gebruikt. Dit zal handig zijn als de
schijf het begeeft en u uw partitietabel op de nieuwe schijf opnieuw moet
maken.

<p>
Uw gegevens herstellen zal ook fragmentatie helpen reduceren. Om er zeker
van te zijn dat u alle bestanden meeneemt, is de beste manier voor een backup
het systeem rebooten in single user modus. Bestandssystemen hoeven niet
gemount te zijn om gebackupt te worden. Vergeet niet om root (/) r/w te
mounten na het booten van uw systeem in single user modus of uw dump zal
mislukken wanneer hij dumpdata probeert weg te schrijven. Geef
"<tt>bsd -s</tt>" in op de boot&gt; prompt voor single user modus.

<h3>De inhoud van een dump tape bekijken:</h3>


<p>
Nadat u voor het eerst uw bestandssystemen gebackupt hebt, zou het een
goed idee zijn om kort uw tape te testen en er zeker van te zijn dat de
gegevens er op staan zoals u verwacht.

<p>
U kan het volgende voorbeeld gebruiken om een catalogus van bestanden op
een dump tape te na te kijken:

<blockquote><pre>
# <b>/sbin/restore -tvs 1 -f /dev/rst0</b>
</pre></blockquote>

<p>
Dit zorgt ervoor dat een lijst van bestanden verschijnt die op de 1ste
partitie van de dump tape staan. Volgens de bovenstaande voorbeelden,
zou 1 uw root (/) bestandssysteem zijn.

<p>
Om te zien wat er op de 2de tape partitie staat en de uitvoer naar een
bestand te sturen, zou u een commando gelijkaardig aan dit gebruiken:

<blockquote><pre>
# <b>/sbin/restore -tvs 2 -f /dev/rst0 > /home/me/list.txt</b>
</pre></blockquote>

<p>
Als u een mount-tabel hebt zoals de eenvoudige, zou 2 /usr zijn, als de uwe
een meer geavanceerde mount-tabel is, zou 2 /var of een ander fs kunnen zijn.
Het sequentienummer stemt overeen met de volgorde waarin de bestandssystemen
naar tape geschreven worden.


<h3>Restore vanaf tape:</h3>

<p>
Het voorbeeldscenario hieronder zou nuttig zijn als uw vaste schijf het
volledig heeft laten afweten. Voor het geval u een enkel bestand vanaf
tape wil restoren, kijk de restore man pagina na en let daarbij op de
interactive mode instructies.

<p>
Als u zich goed hebt voorbereid, kan een schijf vervangen en uw gegevens
restoren een heel snel proces zijn. De standaard OpenBSD installatie/boot
diskette bevat reeds de vereiste restore utility en ook de binaries vereist
om uw nieuwe schijf te partitioneren en bootable te maken. In de meeste
gevallen zijn deze diskette en uw meest recente dump tape al wat u zal nodig
hebben om weer aan de slag te geraken.

<p>
Na het fysisch vervangen van de kapotte schijf, zijn de basisstappen om uw
gegevens te restoren de volgende:

<ul>
<li>
<p>
Boot vanaf de OpenBSD installatie/boot diskette. Bij de menuselectie kiest
u Shell. Bescherm uw tape tegen overschrijven en plaats hem in de lezer.
<br>
<li>
<p>
Maak met het
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
commando een primaire OpenBSD partitie op deze nieuw geïnstalleerde
schijf. Voorbeeld:

<blockquote><pre>
# <b>fdisk -e sd0</b>
</pre></blockquote>

<p>
Zie <a href="#fdisk">fdisk FAQ</a> voor meer info.

<li>
<p>
Maak met het disklabel commando opnieuw uw OpenBSD partitietabel binnen die
primaire OpenBSD partitie die u net met fdisk hebt aangemaakt.
Voorbeeld:

<blockquote><pre>
# <b>disklabel -E sd0</b>
</pre></blockquote>

<p>
(Vergeet swap niet, zie <a href="#disklabel">disklabel FAQ</a> voor meer info)

<li>
<p>
Gebruik het newfs commando om een proper bestandssysteem te bouwen op elke
partitie die u in de vorige stap aanmaakte. Voorbeeld:

<blockquote><pre>
# <b>newfs /dev/rsd0a</b>
# <b>newfs /dev/rsd0h</b>
</pre></blockquote>

<li>
<p>
Mount uw zonet voorbereid root (/) bestandssysteem op /mnt. Voorbeeld:

<blockquote><pre>
# <b>mount /dev/sd0a /mnt</b>
</pre></blockquote>

<li>
<p>
Ga naar dat gemounte root bestandssysteem en start het restore proces.
Voorbeeld:

<blockquote><pre>
# <b>cd /mnt</b>
# <b>restore -rs 1 -f /dev/rst0</b>
</pre></blockquote>

<li>
<p>
U zal willen dat deze nieuwe schijf bootable is, gebruik het volgende om
een nieuwe MBR naar uw schijf te schrijven. Voorbeeld:

<blockquote><pre>
# <b>fdisk -i sd0</b>
</pre></blockquote>

<li>
<p>
Bovenop het wegschrijven van een nieuwe MBR naar de schijf, zal u er
boot blocks moeten op installeren. Het volgende is een kort voorbeeld:

<blockquote><pre>
# <b>cp /usr/mdec/boot /mnt/boot</b>
# <b>/usr/mdec/installboot -v /mnt/boot /usr/mdec/biosboot sd0</b>
</pre></blockquote>

<li>
<p>
Uw nieuw root bestandssysteem op de vaste schijf zou moeten klaar zijn zodat
u het kan booten en verder gaan met de rest van uw bestandssystemen te
restoren. Aangezien uw besturingssysteem nog niet volledig is, zorgt u er
voor om in single user modus te booten. Voer op de shell prompt de volgende
commando's uit om het systeem te unmounten en te stoppen:

<blockquote><pre>
# <b>umount /mnt</b>
# <b>halt</b>
</pre></blockquote>

<li>
<p>
Verwijder de installatie/boot diskette uit het station en herstart uw systeem.
Voer op de OpenBSD boot&gt; prompt het volgende commando uit:

<blockquote><pre>
boot&gt; <b>bsd -s</b>
</pre></blockquote>

<p>
De bsd -s zal ervoor zorgen dat de kernel in single user modus gestart wordt,
wat alleen een root (/) bestandssysteem vereist.

<li>
<p>
In de veronderstelling dat u de bovenstaande stappen correct hebt uitgevoerd
en er niets verkeerd gegaan is, zou u moeten terechtkomen op een prompt die
u vraagt om een shell pad in te geven of return te duwen. Duw return om sh
te gebruiken. Vervolgens zal u root in r/w willen hermounten in tegenstelling
tot read only. Voer het volgende commando uit:

<blockquote><pre>
# <b>mount -u -w /</b>
</pre></blockquote>

<li>
<p>
Zodra u / in r/w modus gehermount hebt kan u verdergaan met uw andere
bestandssystemen te restoren. Voorbeeld:

<blockquote><pre>
<i>(eenvoudige mount-tabel)</i>
# <b>mount /dev/sd0h /usr; cd /usr; restore -rs 2 -f /dev/rst0</b>

<i>(meer geavanceerde mount-tabel)</i>
# <b>mount /dev/sd0d /var; cd /var; restore -rs 2 -f /dev/rst0</b>
# <b>mount /dev/sd0e /home; cd /home; restore -rs 3 -f /dev/rst0</b>
# <b>mount /dev/sd0h /usr; cd /usr; restore -rs 4 -f /dev/rst0</b>
</pre></blockquote>

<p>
U zou "<b>restore rvsf</b>" kunnen gebruiken in plaats van gewoon rsf om
de namen van objecten te zien terwijl ze vanaf de dump set uitgepakt worden.

<li>
<p>
Tenslotte, nadat u klaar bent met al uw andere bestandssystemen op schijf
te restoren, kan u herstarten in multi-user modus. Als alles ging zoals
gepland, zal uw systeem weer in de toestand zijn waarin het zich bevond
ten tijde van uw meest recente backup, en opnieuw klaar om te gebruiken.
</ul>

<a name="MountImage"></a>
<h2>14.10 - Schijfimages mounten in OpenBSD</h2>

<p>
Om een schijfimage (ISO images, schijfimages gemaakt met dd, enz.) te mounten
in OpenBSD, moet u een
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnd&amp;sektion=4">vnd(4)</a>
device configureren. Bijvoorbeeld, als u een ISO image hebt staan in
<i>/tmp/ISO.image</i>, zou u de volgende stappen volgen om de image te mounten.

<blockquote><pre>
# <b>vnconfig svnd0 /tmp/ISO.image</b>
# <b>mount -t cd9660 /dev/svnd0c /mnt</b>
</pre></blockquote>

<p>
Merk op dat aangezien dit een ISO-9660 image is, zoals gebruikt door CD's
en DVD's, u als type <i>cd9660</i>
moet specificeren bij het mounten. Dit geldt ongeacht het type, u moet bv.
type <i>ext2fs</i> gebruiken bij het mounten van Linux schijfimages.

<p>
Gebruik de volgende commando's om de image te unmounten.

<blockquote><pre>
# <b>umount /mnt</b>
# <b>vnconfig -u svnd0</b>
</pre></blockquote>

<p>
Raadpleeg voor meer informatie de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&amp;sektion=8">vnconfig(8)</a>
man pagina.


<a name="pciideErr"></a>
<h2>14.11 - Help! Ik krijg fouten met IDE DMA!</h2>

<p>
DMA IDE transfers, ondersteund door
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pciide&amp;sektion=4">pciide(4)</a>
zijn onbetrouwbaar bij vele combinaties van hardware. Tot voor kort werden
de meeste "mainstream" besturingssystemen die beweerden DMA transfers met
IDE schijven te ondersteunen, niet geleverd met die functionaliteit
standaard ingeschakeld, vanwege onbetrouwbare hardware.
Nu worden veel van diezelfde machines gebruikt voor OpenBSD.

<p>
OpenBSD is aggressief en probeert de hoogste DMA Mode die het kan configureren.
Dit zal corruptie van gegevenstransfers veroorzaken in sommige configuraties
vanwege buggy moederbord chipsets, buggy schijven, en/of ruis op de
kabels. Gelukkig beschermt Ultra-DMA gegevenstransfers met een CRC om
corruptie te detecteren. Wanneer de Ultra-DMA CRC mislukt, zal OpenBSD
een foutboodschap geven en de operatie opnieuw proberen.

<blockquote><pre>
wd2a:  aborted command, interface CRC error reading fsbn 64 of 64-79
(wd2 bn 127; cn 0 tn 2 sn 1), retrying
</pre></blockquote>

<p>
Na enkele keren te falen, zal OpenBSD "downgraden" naar een tragere
(hopelijk meer betrouwbare) Ultra-DMA mode. Als Ultra-DMA mode 0 bereikt
is, dan zal de schijf downgraden naar PIO mode.

<p>
UDMA fouten worden vaak veroorzaakt door lage kwaliteits- of beschadigde kabels.
Kabelproblemen zouden gewoonlijk de eerste verdachte moeten zijn indien u
veel DMA fouten of onverwacht lage DMA prestatie krijgt.
Het is ook een slecht idee om de CD-ROM op hetzelfde kanaal als een harde
schijf te zetten.

<p>
Als het vervangen van de kabels het probleem niet oplost en OpenBSD niet
met succes downgrade't, of het proces zorgt ervoor dat uw machine hard
vasthangt, of veroorzaakt buitensporig veel boodschappen op de console en
in de logs, dan wil u misschien het systeem dwingen tot het standaard
gebruiken van een lager DMA of UDMA level.
Dit kan gedaan worden met <a href="faq5.html#BootConfig">UKC</a> of
<a href="faq5.html#config">config(8)</a> om de vlaggen van het
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wd&amp;sektion=4">wd(4)</a>
device te veranderen.


<a name="RAID"></a>
<h2>14.13 - RAID opties voor OpenBSD</h2>
RAID (Redundant Array of Inexpensive Disks) biedt een mogelijkheid om meerdere
schijven te gebruiken om betere prestaties, capaciteit en/of redundantie te
geven dan men uit een enkele schijf alleen kan verkrijgen. Hoewel een
volledige discussie van de voordelen en risico's van RAID buiten het bestek
van dit artikel vallen, zijn er enkele punten die belangrijk zijn om hier
uit te leggen:

<ul>
<li>RAID heeft niets te maken met backup.
<li>Op zichzelf zal RAID down-tijd niet elimineren.
</ul>

Als deze informatie nieuw is voor u, is dit geen goed vertrekpunt voor
uw verkenning van RAID.

<h3>Software Opties</h3>
OpenBSD ondersteunt
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=softraid&amp;sektion=4">softraid(4)</a>,
een raamwerk dat vele soorten I/O-transformaties ondersteunt, inclusief
RAID en encryptie disciplines.
Softraid(4) wordt beheerd door
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bioctl&amp;sektion=8">bioctl(8)</a>.

<p>
OpenBSD bevat ook RAIDframe
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">raid(4)</a>,
vereist een aangepaste kernel) en
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccd&amp;sektion=4">ccd(4)</a>
als historische manieren om RAID te implementeren, maar op dit moment wil
OpenBSD niet suggereren om dit te gebruiken als RAID-oplossing voor nieuwe
installaties of herinstallaties.

<h3>Hardware Opties</h3>
<p>
Veel OpenBSD <a href="../../nl/plat.html">platformen</a> bevatten ondersteuning voor
verschillende hardware RAID producten. De opties variëren volgens
platform, zie de gepaste hardware support pagina
(<a href="../../nl/plat.html">hier</a> getoond).

<p>
Merk op dat veel ondersteunde RAID-controllers beheerd kunnen worden met de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bio&amp;sektion=4">bio(4)</a>
driver en de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bioctl&amp;sektion=8">bioctl(8)</a>
applicatie.
Dit laat u het RAID-systeem monitoren en besturen op een gestandaardiseerde
manier vanuit OpenBSD.

<p>
Een andere optie die beschikbaar is voor vele platformen is een van de vele
producten die meerdere schijven zich als een enkele IDE of SCSI schijf laten
voordoen, en vervolgens in een standaard IDE of SCSI adapter gestoken worden.
Deze apparaten kunnen werken op bijna gelijk welk hardware platform dat ofwel
SCSI of IDE ondersteunt.

<p>
Enkele fabricanten van deze producten:
<ul>
<li><a href="http://www.arcoide.com/">Arco</a>
<li><a href="http://www.accusys.com.tw/">Accusys</a>
<li><a href="http://www.maxtronic.com/">Maxtronic</a>
<li><a href="http://www.infortrend.com/">Infortrend</a>
</ul>
(Opmerking: dit zijn gewoon producten waarvan OpenBSD gebruikers hun gebruik
gemeld hebben -- dit is helemaal geen steunbetuiging, noch een volledige
lijst.)


<h3>Niet-Opties</h3>
<p>
Een vaak gestelde vraag op de <a href="../../nl/mail.html">mailinglijsten</a> is
"Worden de goedkope IDE of SATA RAID controllers (zoals degene die Highpoint,
Promise of Adaptec HostRAID chips gebruiken) ondersteund?". Het antwoord
is "Neen". Deze kaarten en chips zijn geen echte hardware RAID controllers,
maar eerder BIOS-geassisteerde boot van een software RAID. Aangezien
OpenBSD reeds software RAID ondersteunt op een hardware-onafhankelijke
manier, is er niet veel verlangen onder OpenBSD ontwikkelaars om speciale
ondersteuning voor deze kaarten te implementeren.

<p>
Bijna alle on-board SATA of IDE "RAID" controllers zijn van deze
software-gebaseerde stijl, en zullen typisch goed werken als een SATA of
IDE controller met de standaard IDE driver
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pciide&amp;sektion=4">pciide(4)</a>),
maar zullen niet werken als een hardware RAID systeem op OpenBSD.

<a name="NegSpace"></a>
<h2>14.14 - Waarom vertelt <tt>df(1)</tt> me dat ik meer dan 100% van mijn
schijf in gebruik heb?</h2>
Mensen worden soms verrast om te ontdekken dat ze <i>negatieve</i>
beschikbare schijfruimte hebben, of meer dan 100% van een bestandssysteem
in gebruik, zoals getoond door
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=df&amp;sektion=1">df(1)</a>.

<p>
Wanneer een bestandssysteem gemaakt wordt met
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&amp;sektion=8">newfs(8)</a>,
wordt een beetje van de beschikbare ruimte op reserve gehouden weg van
normale gebruikers. Dit biedt een foutenmarge wanneer u per ongeluk de
schijf vult, en helpt om schijffragmentering tot een minimum te beperken.
Standaard hiervoor is 5% van de schijfcapaciteit, dus als de root gebruiker
achteloos de schijf aan het vullen geweest is, kan u tot 105% van de
beschikbare capaciteit in gebruik zien.

<p>
Als de waarde van 5% niet gepast is voor u, kan u ze veranderen met het
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tunefs&amp;sektion=8">tunefs(8)</a>
commando.

<a name="OhBugger"></a>
<h2>14.15 - Partities herstellen na het verwijderen van het disklabel</h2>

<p>
Als u een beschadigde partitietabel hebt, zijn er verschillende dingen die
u kan proberen om ze te herstellen.

<p>
Ten eerste, panikeer.
Dit doet u gewoonlijk toch, dus u kan er maar beter komaf mee maken.
Doe gewoon niets doms.
Panikeer weg van uw machine.
Ontspan vervolgens, en kijk of de onderstaande stappen u niet helpen.

<p>
Er wordt voor elke schijf een kopie van het disklabel bewaard
in <tt>/var/backups</tt> als onderdeel van het dagelijkse systeemonderhoud.
In de veronderstelling dat u nog steeds de var partitie hebt, kan u
eenvoudigweg de uitvoer lezen en terugplaatsen in het disklabel.

<p>
In het geval u die partitie niet langer kan zien, zijn er twee opties.
Herstel voldoende van de schijf zodat u ze kan zien, of herstel voldoende
van de schijf zodat u uw gegevens er kan afhalen.

Afhankelijk van wat er gebeurde, kan het ene of het andere te verkiezen zijn
(bij stervende schijven wil u eerst de data, met vuile vingers kan u gewoon
het label hebben).

<p>
De eerste tool die u nodig hebt is
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=scan_ffs">scan_ffs(8)</a>
(bemerk de underscore, het heet niet "scanffs").
scan_ffs(8) zal een schijf bekijken, en proberen partities te vinden en u ook
zeggen welke informatie het erover terugvindt.
U kan deze informatie gebruiken om het disklabel te reconstrueren.
Als u gewoon <tt>/var</tt> terug wil, kan u de partitie voor <tt>/var</tt>
opnieuw aanmaken, en dan het backup-label herstellen en de rest van daar uit
toevoegen.

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel;sektion=8">disklabel(8)</a>
zal de kernel zijn begrip van het disklabel updaten, en
ook het label naar de schijf proberen te schrijven.
Daarom zal u, zelfs als het gebied van de schijf dat het disklabel bevat
onleesbaar is, het kunnen
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount;sektion=8">mount(8)</a>en
tot de volgende reboot.


<a name="foreignfs"></a>
<h2>14.16 - Kan ik gegevens benaderen op andere bestandssystemen dan FFS?</h2>
<!-- This article written by Steven Mestdagh,
steven@openbsd.org, and released under the BSD license -->

Ja. Andere ondersteunde bestandssystemen zijn: ext2 (Linux), ISO9660 en UDF
(CD-ROM, DVD media), FAT (MS-DOS en Windows), NFS, NTFS (Windows), AmigaDOS.
Sommige ervan hebben beperkte, bijvoorbeeld read-only, ondersteuning.

<p>
We zullen een algemeen overzicht geven van het gebruik van één van deze
bestandssystemen onder OpenBSD.
Om een bestandssysteem te kunnen gebruiken, moet het gemount worden.
Raadpleeg voor details en mountopties alstublieft de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>
manual pagina, en die van het mount commando voor het bestandssysteem dat u
zal mounten, bv. mount_msdos, mount_ext2fs, ...

<p>
Eerst moet u weten op welk device uw bestandssysteem zich bevindt. Dit kan
gewoon uw eerste harde schijf, <tt>wd0</tt> of <tt>sd0</tt>, zijn maar het
kan ook minder voor de hand liggend zijn.
Alle herkende en geconfigureerde devices op uw systeem worden vermeld in
de uitvoer van het
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=1">dmesg(1)</a>
commando: een devicenaam, gevolgd door een beschrijving op één lijn van het
device.
Mijn eerste CD-ROM lezer wordt bijvoorbeeld als volgt herkend:

<blockquote><pre>
cd0 at scsibus0 targ 0 lun 0: &lt;COMPAQ, DVD-ROM LTD163, GQH3&gt; SCSI0 5/cdrom removable
</pre></blockquote>

<p>
Voor een veel kortere lijst van beschikbare schijven kan u het
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
commando gebruiken.
Het commando

<blockquote><pre>
# sysctl hw.disknames
</pre></blockquote>

zal alle schijven tonen die uw systeem momenteel kent, bijvoorbeeld:

<blockquote><pre>
hw.disknames=cd0,cd1,wd0,fd0,cd2
</pre></blockquote>

<p>
Op dit punt is het tijd om te weten te komen welke partities er op het device
zijn, en in welke partitie het gewenste bestandssysteem zit.
Daarvoor onderzoeken we het device met
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>.
De disklabel bevat een lijst van partities, met een maximum aantal van 16.
Partitie c duidt altijd het volledige device aan.
Partities a-b en d-p worden gebruikt door OpenBSD.
Partities i-p kunnen automatisch toegewezen worden aan bestandssystemen van
andere besturingssystemen.
In dit geval zal ik de disklabel van mijn harde schijf bekijken, die een
aantal verschillende bestandssystemen bevat.

<p>
<b>OPMERKING: OpenBSD werd na de andere besturingssystemen geïnstalleerd</b>
op dit systeem, en tijdens de installatie werd een disklabel op de schijf
geïnstalleerd die partities bevat voor zowel de "native" als de vreemde
bestandssystemen.
Als u echter vreemde bestandssystemen installeert nadat de OpenBSD disklabel
reeds geïnstalleerd is op de schijf, moet u ze nadien handmatig toevoegen of
wijzigen. Dit zal uitgelegd worden in <a href="#foreignfsafter">deze
subsectie</a>.

<blockquote><pre>
# <b>disklabel wd0</b>

# using MBR partition 2: type A6 off 20338290 (0x1365672) size 29318625 (0x1bf5de1)
# /dev/rwd0c:
type: ESDI
disk: ESDI/IDE disk
label: ST340016A       
flags:
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 16383
total sectors: 78165360
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # microseconds
track-to-track seek: 0  # microseconds
drivedata: 0 

16 partitions:
#             size        offset  fstype [fsize bsize  cpg]
  a:        408366      20338290  4.2BSD   2048 16384   16 # Cyl 20176*- 20581 
  b:       1638000      20746656    swap                   # Cyl 20582 - 22206 
  c:      78165360             0  unused      0     0      # Cyl     0 - 77544 
  d:       4194288      22384656  4.2BSD   2048 16384   16 # Cyl 22207 - 26367 
  e:        409248      26578944  4.2BSD   2048 16384   16 # Cyl 26368 - 26773 
  f:      10486224      26988192  4.2BSD   2048 16384   16 # Cyl 26774 - 37176 
  g:      12182499      37474416  4.2BSD   2048 16384   16 # Cyl 37177 - 49262*
  i:         64197            63 unknown                   # Cyl     0*-    63*
  j:      20274030         64260 unknown                   # Cyl    63*- 20176*
  k:       1975932      49656978   MSDOS                   # Cyl 49262*- 51223*
  l:       3919797      51632973 unknown                   # Cyl 51223*- 55111*
  m:       2939832      55552833  ext2fs                   # Cyl 55111*- 58028*
  n:       5879727      58492728  ext2fs                   # Cyl 58028*- 63861*
  o:      13783707      64372518  ext2fs                   # Cyl 63861*- 77535*

</pre></blockquote>

<p>
Zoals gezien kan worden in de bovenstaande uitvoer, worden eerst de OpenBSD
partities opgesomd.
Daarbuiten zijn er een aantal ext2 partities en één MSDOS partitie, en ook
enkele 'onbekende' partities. Op i386 en amd64 systemen kan u daarover
gewoonlijk meer te weten komen met de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
utility.
Voor de nieuwsgierige lezer: partitie i is een onderhoudspartitie aangemaakt
door de verkoper, partitie j is een NTFS partitie en partitie l is een Linux
swappartitie.

<p>
Zodra u bepaald hebt welke partitie het is die u wil gebruiken, kan u
overgaan tot de laatste stap: het bestandssysteem dat er in zit mounten.
De meeste bestandssystemen worden ondersteund in de GENERIC kernel: kijk
maar eens naar het kernelconfiguratiebestand, te vinden in de
<tt>/usr/src/sys/arch/&lt;<i>arch</i>&gt;/conf</tt> directory.
Sommige zijn echter niet ondersteund, bv. de NTFS ondersteuning is
experimenteel en daarom niet opgenomen in GENERIC.
Als u één van de bestandssystemen wil gebruiken die niet ondersteund zijn
in GENERIC, zal u <a href="faq5.html#Options">een aangepaste kernel moeten
bouwen</a>.

<p>
Wanneer u de benodigde informatie hebt verzameld zoals hierboven vermeld,
is het tijd om het bestandssysteem te mounten.
Laten we aannemen dat een directory <tt>/mnt/anderfs</tt> bestaat, die we
zullen gebruiken als mountpunt waar we het gewenste bestandssysteem zullen
mounten.
In dit voorbeeld zullen we het ext2 bestandssysteem in partitie m mounten:

<blockquote><pre>
# <b>mount -t ext2fs /dev/wd0m /mnt/anderfs</b>
</pre></blockquote>

<p>
Als u van plan bent dit bestandssysteem regelmatig te gebruiken, kan u
uzelf wat tijd besparen door er een lijn voor in <tt>/etc/fstab</tt> te
plaatsen, bijvoorbeeld iets als:

<blockquote><pre>
/dev/wd0m /mnt/anderfs ext2fs rw,noauto,nodev,nosuid 0 0
</pre></blockquote>

Bemerk de 0 waarden in het vijfde en zesde veld.
Dit betekent dat we niet vereisen dat het bestandssysteem gedumpt moet
worden, en gecontroleerd met fsck.
In het algemeen zijn dat dingen die u wil laten afhandelen door het
moeder-besturingssyssteem geassocieerd met het bestandssysteem.

<a name="foreignfsafter"></a>
<h3>14.16.1 - De partities staan niet in mijn disklabel! Wat moet ik doen?</h3>

Als u vreemde bestandssystemen op uw systeem installeert (vaak het resultaat
van het toevoegen van een nieuw besturingssysteem) nadat u reeds OpenBSD
hebt geïnstalleerd, dan zal er reeds een disklabel aanwezig zijn, en deze
zal niet automatisch geüpdatet worden om de nieuwe vreemde
bestandssysteem-partities te bevatten.
Als u ze wil gebruiken, moet u deze partities handmatig toevoegen of wijzigen
met
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>.

<p>
Als voorbeeld heb ik één van mijn bestaande ext2 partities gewijzigd: met
het Linux fdisk programma heb ik de grootte van de 'o' partitie (zie
disklabel uitvoer hierboven) gereduceerd tot 1G.
We zullen ze gemakkelijk kunnen herkennen aan haar startpositie
(offset: 64372518) en grootte (13783707).
Merk op dat deze waarden sectornummers zijn, en dat het gebruik van
sectornummers (niet megabytes of gelijk welke andere maat) de meest exacte
en veiligste manier is om deze informatie uit te lezen.

<p>
Vóór de wijziging zag de partitie er als volgt uit met OpenBSD's
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
utility (alleen relevante uitvoer overlatend):

<blockquote><pre>
# fdisk wd0
. . .
Offset: 64372455        Signature: 0xAA55
         Starting       Ending       LBA Info:
 #: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
 0: 83 4007   1  1 - 4864 254 63 [    64372518:    13783707 ] Linux files*
. . .
</pre></blockquote>

Zoals u kan zien, zijn de startpositie en grootte precies die die eerder
door disklabel(8) vermeld werden.
(Laat u niet misleiden door de waarde aangeduid door "Offset": ze verwijst
naar de startpositie van de "extended" partitie waarin de ext2 partitie
vervat zit.)

<p>
Na het wijzigen van de partitiegrootte vanuit Linux, ziet ze er zo uit:

<blockquote><pre>
# fdisk wd0
. . .
Offset: 64372455        Signature: 0xAA55
         Starting       Ending       LBA Info:
 #: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
 0: 83 4007   1  1 - 4137 254 63 [    64372518:     2104452 ] Linux files*
. . .
</pre></blockquote>

Nu moet dit veranderd worden met disklabel(8).
U kan bijvoorbeeld <tt>disklabel -e wd0</tt> ingeven, wat een editor zal
opstarten gespecificeerd door de EDITOR omgevingsvariabele (standaard is vi).
Verander binnen de editor de laatste lijn van de disklabel zodat ze de
nieuwe grootte bevat:

<blockquote><pre>
  o:       2104452      64372518  ext2fs
</pre></blockquote>

Bewaar de disklabel op de schijf wanneer u klaar bent.
Nu de disklabel opnieuw up to date is, zou u uw partities moeten kunnen
mounten zoals hoger beschreven werd.

<p>
U kan een heel gelijkaardige procedure volgen om nieuwe partities toe te
voegen.


<a name="flashmem"></a>
<h2>14.17 - Kan ik een flash geheugentoestel gebruiken met OpenBSD?</h2>
<a name="flashmemPortable"></a>
<h3>14.17.1 - Flashgeheugen als draagbaar opslagtoestel</h3>
<!-- This article written by Steven Mestdagh,
steven@openbsd.org, and released under the BSD license -->

Normaal moet het geheugentoestel herkend worden wanneer u het in een poort
van uw machine steekt.
Kort na het insteken worden door de kernel een aantal boodschappen naar de
console geschreven.
Wanneer ik bijvoorbeeld mijn USB flash geheugentoestel insteek, zie ik het
volgende op mijn console:

<blockquote><pre>
umass0 at uhub1 port 1 configuration 1 interface 0
umass0: LEXR PLUG DRIVE LEXR PLUG DRIVE, rev 1.10/0.01, addr 2
umass0: using SCSI over Bulk-Only
scsibus2 at umass0: 2 targets
sd0 at scsibus2 targ 1 lun 0: &lt;LEXAR, DIGITAL FILM, /W1.&gt; SCSI2 0/direct removable
sd0: 123MB, 123 cyl, 64 head, 32 sec, 512 bytes/sec, 251904 sec total
</pre></blockquote>

Deze lijnen geven aan dat de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=umass&amp;sektion=4">umass(4)</a>
(USB mass storage) driver vastgehangen werd aan het geheugentoestel, en dat
hij het SCSI systeem gebruikt.
De laatste twee lijnen zijn de belangrijkste: ze zeggen op welke device node
het geheugentoestel vastgemaakt werd, en wat de totale hoeveelheid
opslagruimte is.
Als u op één of andere manier deze lijnen gemist hebt, kan u ze nadien nog
steeds zien met het
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=1">dmesg(1)</a>
commando.
De gerapporteerde CHS geometrie is eerder fictief, aangezien het flash
geheugen behandeld wordt als gelijk welke gewone SCSI schijf.

<p>
We zullen hieronder twee scenario's bespreken.

<h4>Het toestel is nieuw/leeg en u wil het alleen met OpenBSD gebruiken</h4>

U zal een disklabel op het toestel moeten initialiseren, en ten minste
één partitie aanmaken.
Lees alstublieft <a href="#disklabel">OpenBSD's disklabel gebruiken</a> en de 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
manual pagina voor details hierover.

<p>
In dit voorbeeld maakte ik gewoon één partitie <i>a</i> waarin ik een FFS
bestandssysteem zal plaatsen:

<blockquote><pre>
# <b>newfs sd0a</b>
Warning: inode blocks/cyl group (125) >= data blocks (62) in last
    cylinder group. This implies 1984 sector(s) cannot be allocated.
/dev/rsd0a:     249856 sectors in 122 cylinders of 64 tracks, 32 sectors
        122.0MB in 1 cyl groups (122 c/g, 122.00MB/g, 15488 i/g)
super-block backups (for fsck -b #) at:
 32,
</pre></blockquote>

Laten we het bestandssysteem dat we in de <i>a</i> partitie aanmaakten,
mounten op <tt>/mnt/flashmem</tt>.
Maak het mountpunt eerst aan als het niet bestaat.

<blockquote><pre>
# <b>mkdir /mnt/flashmem</b>
# <b>mount /dev/sd0a /mnt/flashmem</b>
</pre></blockquote>

<h4>U kreeg het geheugentoestel van iemand met wie u gegevens wil uitwisselen</h4>

<p>
Er is een aanzienlijke kans dat de andere persoon niet OpenBSD gebruikt,
dus er kan een vreemd bestandssysteem op het geheugentoestel staan.
Daarom zullen we eerst moeten te weten komen welke partities er op het toestel
staan, zoals beschreven in
<a href="#foreignfs">FAQ 14 - Vreemde Bestandssystemen</a>.

<blockquote><pre>
# <b>disklabel sd0</b>

# /dev/rsd0c:
type: SCSI
disk: SCSI disk
label: DIGITAL FILM    
flags:
bytes/sector: 512
sectors/track: 32
tracks/cylinder: 64
sectors/cylinder: 2048
cylinders: 123
total sectors: 251904
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # microseconds
track-to-track seek: 0  # microseconds
drivedata: 0 

16 partitions:
#             size        offset  fstype [fsize bsize  cpg]
  c:        251904             0  unused      0     0      # Cyl     0 -   122 
  i:        250592            32   MSDOS                   # Cyl     0*-   122*
</pre></blockquote>

Zoals kan gezien worden in de disklabel uitvoer hierboven, is er slechts
één partitie <i>i</i>, die een FAT bestandssysteem bevat, aangemaakt op een
Windows machine.
Zoals gewoonlijk geeft de <i>c</i> partitie de volledige device weer.

<p>
Laten we nu het bestandssysteem in de <i>i</i> partitie mounten op
<tt>/mnt/flashmem</tt>.

<blockquote><pre>
# <b>mount -t msdos /dev/sd0i /mnt/flashmem</b>
</pre></blockquote>

Nu kan u het beginnen gebruiken net zoals gelijk welke andere schijf.

<p>
<b>WAARSCHUWING:</b>
U moet het bestandssysteem <b>altijd unmounten</b> <b>voor het uittrekken</b>
van het geheugentoestel.
Als u dit niet doet, kan het bestandssysteem in een inconsistente toestand
achterblijven, wat kan leiden tot corrupte gegevens.

<p>
Bij het uittrekken van het geheugentoestel uit uw machine zal u opnieuw
zien dat de kernel hierover boodschappen naar de console schrijft:

<blockquote><pre>
umass0: at uhub1 port 1 (addr 2) disconnected
sd0 detached
scsibus2 detached
umass0 detached
</pre></blockquote>

<a name="flashmemBoot"></a>
<h3>14.17.2 - Flashgeheugen als bootable opslag</h3>
<!-- This article written by Nick Holland
nick@openbsd.org, and released under the BSD license -->
Men kan flashgeheugen op verschillende manieren ook gebruiken als bootable
schijf met OpenBSD.
Dit kan worden gedaan met zowel USB-apparaten (ervanuitgaande dat uw
computer kan booten vanaf USB, dat kunnen ze niet allemaal) als met niet-USB
(zoals CF) apparaten met een IDE of SATA adapter.
(Niet-USB apparaten aangesloten met een USB-adapter worden behandeld als
USB-apparaten).
In sommige gevallen kunt u een apparaat op beide manieren gebruiken (de
media laden in een USB-adapter, maar gebruiken in een IDE-adapter).

<p>
Een flashapparaat dat is aangesloten op een USB-poort zal verschijnen als een
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sd&amp;sektion=4">sd(4)</a>
SCSI-achtig apparaat.
Als het is aangesloten op een IDE-adapter, dan zal het verschijnen als een
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wd&amp;sektion=4">wd(4)</a>
apparaat.

<p>
In het geval van flashmedia in een IDE-adapater, dan kan ieder systeem ervan
booten dat kan booten van een IDE harde schijf.
Op alle mogelijke wijzen ziet het systeem de flashmedia als een IDE schijf.
Configureer de hardware simpelweg op de juiste manier en installeer OpenBSD
op de flashschijf zoals gebruikelijk.

<p>
In het geval van booten vanaf een USB-device moet uw systeem kunnen booten
vanaf het USB-device zonder te worden afgeleid door andere apparaten
op het systeem.
Merk op dat als u de intentie heeft om een draagbare boot-omgeving op een
USB-apparaat te maken, dat het USB-apparaat zal verschijnen als een SCSI-disk,
meestal sd0.
Als u dit apparaat verbindt met een systeem dat al enkele SCSI-achtige
apparaten heeft, dan zal het een andere identificatie toegewezen krijgen,
wat het rouleren van systeem naar systeem zal compliceren, omdat u
<tt>/etc/fstab</tt> moet aanpassen.

<p>
Enkele opmerkingen:
<ul>
<li><b>Snelheid:</b> Over het algemeen zijn flash-apparaten veel langzamer
dan harde schijven, vooral als het om schrijven gaat.
Het gebruik van <a href="#SoftUpdates">soft updates</a> helpt aanzienlijk,
net als het gebruik van de "noatime" mount-optie.

<li><b>"Schrijfmoeheid":</b>
Er is veel geschreven over het eindig aantal keren dat een individuele
flash-cel kan worden beschreven totdat deze faalt.
Praktisch gezien zijn er echter vele manieren waarop een flash-apparaat kan
falen, schrijfmoeheid is er slechts één van.
Moderne flash-apparaten verifiëren de schrijfacties en in het geval van
falen zullen de falende sectoren worden vervangen door één van de vele
reservesectoren.
De meeste gebruikers van de meeste flash-apparaten hoeven zich geen zorgen
te maken om "schrijfmoeheid".
U zult waarschijnlijk meer storingsminuten ervaren door "slimme" trucs
toe te passen om schrijven naar de flash-schijf te voorkomen, dan door
de schijven gewoon te gebruiken als lees-schrijf media.

<li><b>Betrouwbaarheid:</b>
Het feit dat flash-media geen bewegende delen bevatten heeft ertoe geleid
dat veel mensen denken dat flash-media inherent betrouwbaarder zijn dan
harde schijven.
Het is waarschijnlijk niet slim om aan te nemen dat de overstap naar
flash betekent dat u zich geen zorgen meer hoeft te maken over dataverlies
of het falen van schijven.
Er zijn behoorlijke variaties gerapporteerd in de kwaliteit van flash-media,
het is waarschijnlijk het beste om flash-opslag te zien als een stil en
energiezuinig alternatief voor schijven dan als een fout-vrij opslagmedium.

<li><b>Het maken van een bootable USB-flashdrive:</b>
Hoewel een USB-apparaat alleen kan worden gebruikt om op te starten op een
machine die kan opstarten van USB-schijven, kan hij gemaakt worden op iedere
machine met ondersteunde USB-hardware.
Uiteraard kan uw werk pas getest worden totdat u toegang heeft tot een
systeem dat van USB kan booten.

<li><b>Van IDE naar USB-interfaces:</b>
Aangezien de media lees- en schrijfbaar zijn van zowel USB als IDE-adapters,
kunt u een medium aanmaken voor booten in een IDE-adapter maar het beheren
in een USB-adapter op een andere machine (of omgekeerd).

<li><b>Mengen van OpenBSD and andere partities op een apparaat:</b>
OpenBSD behandelt een flash-schijf zoals iedere andere schijf dus men kan
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8">fdisk(8)</a>
gebruiken om een flash-schijf te partitioneren, net als iedere harde schijf.
U kunt vervolgens OpenBSD-bestandssystemen op één partitie zetten en een
andere partitie gebruiken voor een ander bestandssysteem, bijvoorbeeld FAT32.
Niet alle besturingssystemen behandelen USB-apparaten echter als
"gelijkwaardig".
Windows, in ieder geval, zal niet proberen om een partitie te gebruiken
of aan te maken die niet begint aan het begin van het apparaat, noch
zal de Windows partitionerings-utility u toestaan de schijf te partitioneren,
al zal het bestaande partities respecteren.
Dus als u een USB-flash-apparaat wilt creëren dat bootable is met OpenBSD,
maar ook functioneert als een FAT32-geschikt apparaat voor andere
besturingssystemen, dan kunt u zoiets doen:

  <ol>
  <li>Partitioneer het medim met OpenBSD's fdisk, met een partitie
    van het type dat u wenst te gebruiken met Windows aan het begin van
    de schijf en een OpenBSD-partitie aan het einde van de schijf.
  <li>Installeer OpenBSD als gebruikelijk op de OpenBSD-partitie, vergeet
    niet om de OpenBSD-partitie als "Active" te markeren om te kunnen
    booten.
  <li>Formatteer de andere partitie.
    Dit kan (en zou misschien ook moeten) worden gedaan vanuit het "doel"
    besturingssysteem (Windows in dit geval).
  </ol>

Merk op dat indien het type van de andere partitie geschikt is gekozen, het
mogelijk is om OpenBSD toegang te laten hebben tot beide partities op het
apparaat.
Dus een Windows-gebruiker kan de FAT32-partitie vullen met MP3-bestanden
die afgespeeld kunnen worden wanneer er geboot wordt vanaf de OpenBSD-partitie.

</ul>

<a name="flashmemLive"></a>
<h3>14.17.3 - Hoe kan ik een "Live" bootable USB toestel maken?</h3>
Het is erg makkelijk om een bootalble USB flash (of andere!) schijf te maken
die kan worden gebruikt als een "live" OpenBSD-systeem zonder OpenBSD
te installeren op de lokale harde schijf van een machine.
Vanzelfsprekend moet de doelmachine van een USB toestel kunnen booten,
maar het initiële laden kan worden gedaan vanaf iedere machine met een
USB interface.

<p>
Enkele redenen waarom u dit wellicht zou willen:
<ul>
<li>Een draagbare, veilige "machine" die u in uw zak kan dragen.

<li>Oplossen van problemen in OpenBSD of andere installaties met hulpmiddelen
die niet beschikbaar zijn met <a href="faq4.html#bsd.rd">bsd.rd</a>.

<li>Evalueren van hardware voor compatibiliteit met OpenBSD op het moment
van aankoop.

<li>Installeren van machines waarbij ieder ander bootmedium ontbreekt.

<li>Verzamelen van <a href="faq4.html#SendDmesg">dmesg</a> uitvoer van de
computers van uw vrienden!
(Aangezien de dmesg van OpenBSD nuttig is voor het identificeren van hardware
kan dit een goede manier zijn om u voor te bereiden op het installeren van
een ANDER besturingssysteem op een machine -- verzeker u ervan dat u
alle benodigde drivers heeft alvorens te beginnen).

</ul>

Het maken van zo'n "live OpenBSD schijf" is eenvoudig.
<ul>
<li>Mount uw USB schijf op de machine waar u de installatie uitvoert.
<li>Boot uw favoriete OpenBSD installatiemedium.
<li><a href="faq4.html">Installeer</a> zoals gebruikelijk, erop lettend
dat u de flashdisk kiest als het doel voor de installatie.
<li>Boot van uw nieuw gecreëerde USB toestel.
</ul>

Dat is alles!

<p>
Er zijn enkele zaken die u wellicht wilt doen na de installatie om uw
resultaten te verbeteren:

<ul>
<li>Installeer alle packages en hulpmiddelen die u waarschijnlijk beschikbaar
wilt hebben.
<li>Verschillende doelmachines hebben waarschijnlijke verschillende NIC's.
U kunt een stapel
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5">hostname.if(5)</a>
bestanden in <tt>/etc</tt> aanmaken, met in ieder slechts <tt>dhcp</tt>, voor
alle NIC's die u waarschijnlijk tegenkomt (fxp0, re0, rl0, bge0, bnx0, em0,
etc.) op USB-bootable machines, plus misschien enkele voorbeeldconfiguraties
voor draadloze netwerken.
OpenBSD negeert alle hostname.if(5) bestanden voor devices die niet
aanwezig zijn tijdens het booten.

<li>U wilt misschien een kopie van de installatiebestanden en wellicht ook
gewenste package .tgz bestanden zodat u de schijf als een installatiemedium
kunt gebruiken (boot bsd.rd in plaats van normaal booten).

<li> Op veel machines zal X "gewoon werken" zonder een configuratiebestand,
maar u wilt misschien X configuratiebestanden verzamelen voor de systemen
die ze nodig hebben.

<li><a href="#SoftUpdates">Soft updates</a> is iets dat u zult willlen
gebruiken.

<li>Voor maximale flexibiliteit wilt u waarschijnlijk liever
<a href="../../i386.html">i386</a> dan
<a href="../../amd64.html">amd64</a> gebruiken.
Echter, als u het als een installatiemedium wilt gebruiken, dan kunt
een amd64 bsd.rd en installatiebestanden gebruiken naast i386.

<li>Als uw doelmachine een
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ahci&amp;sektion=4">ahci(4)</a>
of SCSI interface heeft, zult u merken dat de aanduiding van de USB-schijf
waarschijnlijk wijzigt.
Het hebben van meerdere versies van uw <tt>/etc/fstab</tt> bestand maakt
het makkelijker om dit te "repareren" (in single user mode).

<li>Wellicht vindt u het wenselijk om een FAT partitie op de USB schijf te
hebben, maak deze aan zoals <a href="#flashmemBoot">hierboven</a> beschreven.

<li>Wellicht wilt u
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=softraid&amp;sektion=4">softraid(4)</a>
gebruiken om een datapartitie te versleutelen.

</ul>


<p>
<a name= "DiskOpt"></a>
<h2>14.18 - Schijfprestaties optimaliseren</h2>

<p>
Schijfprestatie is een veelbetekenende factor in de globale snelheid van
uw computer. Het wordt nog belangrijker wanneer uw computer een multi-user
(alle soorten gebruikers, van zij die interactief inloggen tot zij die
u zien als fileserver of webserver) omgeving host.
Gegevensopslag heeft voortdurend aandacht nodig, vooral wanneer uw
partities ruimte tekort komen of als uw schijven het laten afweten.
OpenBSD heeft enkele mogelijkheden om de snelheid van uw
schijfoperaties te vergroten.

<p>
<ul>
<li><a href="#Optsoftu">Soft Updates</a>
<li><a href="#Optmaxvnodes">Grootte van de namei() cache</a>
</ul>

<p>
<a name="Optsoftu"></a>
<h3>14.18.1 - Soft updates</h3>

Een belangrijke tool die gebruikt kan worden om uw systeem te versnellen is
softupdates.  Een van de traagste operaties in het traditionele BSD
bestandssysteem is het updaten van metainfo (wat onder meer gebeurt wanneer
u bestanden en directories aanmaakt of verwijdert). Softupdates
probeert metainfo te updaten in RAM in plaats van elke metainfo update
naar de harde schijf te schrijven. Een ander effect hiervan is
dat de metainfo op de schijf altijd volledig zou moeten zijn, hoewel deze
niet altijd up-to-date is.
U kan meer lezen over softupdates in de
<a href="#SoftUpdates">Softupdates FAQ</a> paragraaf.

<p>
<a name="Optmaxvnodes"></a>
<h3>14.18.2 - Grootte van de namei() cache</h3>

De naam-naar-inode vertaling (ook bekend als <!-- need to write the manual
page first... <a href="">namei(3)</a> --> namei()) cache controleert de
snelheid van padnaam naar
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inode&amp;sektion=5">inode(5)</a>
vertaling.
Een redelijke manier om een waarde voor de cache af te leiden, mocht een
groot aantal namei() "cache misses" opgemerkt worden met een tool zoals
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=systat&amp;sektion=1">systat(1)</a>,
is om de huidige door het systeem berekende waarden te onderzoeken met
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>,
(dat deze parameter "<tt>kern.maxvnodes</tt>" noemt) en om deze waarde te
verhogen tot ofwel de namei() cache hit rate verbetert of het bepaald wordt dat
het systeem geen aanzienlijk voordeel uit een verhoging van de grootte van de
namei() cache. Nadat de waarde bepaald is, kan u ze bij de systeemstart
instellen met
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5">sysctl.conf(5)</a>.

<p>
<a name= "Async"></a>
<h2>14.19 - Waarom gebruiken we geen async mounts?</h2>

<p>
Vraag: "Ik doe gewoon "mount -u -o async /" wat een pakket dat ik gebruik  
(dat er op staat om van tijd tot tijd enkele honderden dingen aan te raken)
bruikbaar maakt.

Waarom staat men afkeurend tegenover async mounten en is het niet standaard
ingeschakeld (zoals het op enkele andere unixen wel is)?
Is het niet een veel eenvoudigere, en daarom, veiligere manier om de
prestatie in sommige toepassingen te verbeteren?"

<p>
Antwoord: "Async mounts zijn inderdaad sneller dan sync mounts, maar ze zijn
ook minder veilig. Wat gebeurt er in het geval van een stroompanne? Of een
hardware probleem? De zoektocht naar snelheid zou de betrouwbaarheid en de
stabiliteit van het systeem niet mogen opofferen. Bekijk de man pagina van
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>."

<pre>
	     async   All I/O to the file system should be done asynchronously.
		     This is a dangerous flag to set since it does not guaran-
		     tee to keep a consistent file system structure on the
		     disk.  You should not use this flag unless you are pre-
		     pared to recreate the file system should your system
		     crash.  The most common use of this flag is to speed up
		     restore(8) where it can give a factor of two speed in-
		     crease.
</pre>

<p>
Aan de andere kant, wanneer u met tijdelijke gegevens te maken hebt die u
vanaf nul opnieuw kan maken na een crash, kan u snelheid winnen door een
afzonderelijke partitie te gebruiken voor alleen die gegevens en deze async
te mounten. Opnieuw, doe dit <i>alleen als</i> u het verlies van alle gegevens
in de partitie niet erg vindt als er iets verkeerd gaat. Om deze reden worden
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=mfs&amp;sektion=8">mfs(8)</a>
partities asynchroon gemount, aangezien ze bij een herstart toch gewist en
opnieuw gemaakt worden.


<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ Index]</a>
<a href= "faq13.html">[Naar Sectie 13 - Multimedia]</a>
<a href= "faq15.html">[Naar Sectie 15 - Packages en Ports]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt="[terug]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: faq14.html,v 1.198 ]<br>
$Translation: faq14.html,v 1.69 2010/03/05 12:02:45 maurice Exp $<br>
-->
$OpenBSD: faq14.html,v 1.58 2010/03/08 12:37:15 ajacoutot Exp $
</small>

</body>
</html>
