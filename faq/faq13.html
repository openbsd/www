<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>13 - Using IPsec</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 2000-2003 by OpenBSD">
</head>

<body bgcolor= "#ffffff" text= "#000000">
<img alt="[OpenBSD]" height=30 width=141 src="../images/smalltitle.gif">
<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ Index]</a>
<a href= "faq12.html">[To Section 12 - For Advanced Users]</a>
<a href= "faq14.html">[To Section 14 - Using disks in OpenBSD]</a>
</font>

<h1><font color="#e00000">13 - Using IPsec (IP Security Protocol)</font></h1>
<hr>

<p>
<h3>Table of Contents</h3>
<ul>
<li><a href="#What"     >13.1 - What is IPsec?</a>
<li><a href="#Why"      >13.2 - That's nice, but why do I want to use IPsec?</a>
<li><a href="#Protocols">13.3 - What are the protocols behind IPsec?</a>
<li><a href="#Wire"     >13.4 - On the wire format</a>
<li><a href="#Config"   >13.5 - Configuring IPsec</a>
<li><a href="#ManKey"   >13.6 - How do I set up IPsec with manual keying?</a>
<li><a href="#isakmpd"  >13.7 - How do I set up isakmpd?</a>
<li><a href="#x509"     >13.8 - How do I use isakmpd with X.509 certificates?</a>
<li><a href="#IKEcl"    >13.9 - What IKE clients are compatible with isakmpd?</a>
<li><a href="#Trouble"  >13.10 - Troubleshooting IPsec/VPN</a>
<li><a href="#SeeAlso"  >13.11 - Related Documentation</a>
</ul>

<p>
<font size="-1">
Portions of this document were taken from:
</font>
<ul style="font-size: small">
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipsec&amp;sektion=4">ipsec(4)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vpn&amp;sektion=8">vpn(8)</a>
<li><a href="http://www.freebsd.org/~julian/IPSEC_4_Dummies.html">IPsec for Dummies</a> by Julian Elischer
<li><a href="http://www.secureops.com/vpn/vpn.html">ISAKMP Howto</a> by Patrick Ethier
<li><a href="http://hem.passagen.se/hojg/isakmpd/">X.509v3 certificates with isakmpd</a> by J&ouml;rgen Granstam
</ul>

<hr>

<p>
<a name= "What"></a>
<a name= "13.1"></a>
<h2>13.1 - What is IPsec?</h2>

<p>
IPsec is a set of extensions to the IP protocol family.   It provides
cryptographic security services.  These services allow for authentication,
integrity, access control, and confidentiality.  IPsec provides
similar services as SSL, but at the network layer, in a way that is completely
transparent to your applications, and much more powerful.  We say this
because your applications do not have to have any knowledge of IPsec to be
able to use it.
You can use <a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/protocols?rev=1.13">any IP protocol</a> over IPsec.  You can create encrypted tunnels (VPNs), or just do encryption between computers.
Since you have so many options, IPsec is rather complex (much more so than SSL!)

<p>
Before you start using IPsec, we strongly recommend that you check out
the "recommended reading" of <a href="faq6.html">part 6</a> of the FAQ.
In particular, if you don't already understand it, the 
<a href="http://www.3com.com/corpinfo/en_US/technology/tech_paper.jsp?DOC_ID=135">Understanding
IP Addressing</a> (or 
<a href="http://www.3com.com/other/pdfs/infra/corpinfo/en_US/501302.pdf">here</a>)
document is highly recommended.

<p>
In a logical sense, IPsec works in any of these three ways:

<ul>
<li>Host-to-Host
<li>Host-to-Network
<li>Network-to-Network
</ul>

<p>
In every scenario that involves a network, we mean to imply
router.  As in, Host-to-Router (and this router controls and encrypts
traffic for a particular <i>Network</i>).

<p>
As you can see, IPsec can be used to tunnel traffic for VPN connections.
However, its utility reaches beyond VPNs.  With a central Internet Key Exchange
registry, every machine on the Internet could talk to another one
and employ powerful encryption and authentication!

<p>
<a name= "Why"></a>
<a name= "13.2"></a>
<h2>13.2 - That's nice, but why do I want to use IPsec?</h2>

<p>
The internet protocol, IP, aka IPv4, does not inherently provide any protection
to your transferred data.  It does not even guarantee that the
sender is who he says he is.  IPsec tries to remedy this.  These services 
are considered distinct, but the IPsec supports them in a uniform manner. 

<p>
<h4>Confidentiality</h4> Ensure it is hard for anyone but the receiver
to understand what data has been communicated.  For example, ensuring
the secrecy of passwords when logging into a remote machine over the
Internet.

<p>
<h4>Integrity</h4> Guarantee that the data does not get changed on the
way.  If you are on a line carrying invoicing data you probably
want to know that the amounts and account numbers are correct and
not altered while in-transit.

<p>
<h4>Authenticity</h4> Sign your data so that others can see that it is really
you that sent it.  It is clearly nice to know that documents
are not forged.

<p>
<h4>Replay protection</h4> We need ways to ensure a datagram is
processed only once, regardless of how many times it is received.
I.e. it should not be possible for an attacker to record a transaction
(such as a bank account withdrawal), and then by replaying it verbatim
cause the peer to think a new message (withdrawal request) had been
received.  <i>WARNING: as per the standards specification, replay
protection is not performed when using manual-keyed IPsec (e.g., when
using <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipsecadm&amp;sektion=8">ipsecadm(8)</a>)</i>.

<p>
<a name= "Protocols"></a>
<a name= "13.3"></a>
<h2>13.3 - What are the protocols behind IPsec?</h2>

<p>
IPsec provides confidentiality, integrity, authenticity, and replay
protection through two new protocols.  These protocols are called
Authentication Header (AH), and Encapsulating Security Payload (ESP).

<p>
AH provides authentication, integrity, and replay protection (but not
confidentiality).  The main difference between the authentication
features of AH and ESP is that AH also authenticates portions of the
IP header of the packet (such as the source/destination addresses).
ESP authenticates only the packet payload.

<p>
ESP can provide authentication, integrity, replay protection, and
confidentiality of the data (it secures everything in the packet that follows
the  header). Replay protection requires authentication and integrity
(these two go always together). Confidentiality (encryption) can be used
with or without authentication/integrity. Similarly, one could use
authentication/integrity with or without confidentiality.

<p>In practice, it is recommended that ESP be used for most applications.

<p>
<a name= "Wire"></a>
<a name= "13.4"></a>
<h2>13.4 - On the wire format</h2>

<p>
The <b>Authentication Header</b>
(AH) comes after the basic IP header and contains cryptographic
hashes of the data and identification information. The hashes can
also cover the invariant parts of the IP header itself. There are
several different RFCs giving a choice of actual algorithms to use in the
AH, however they all must follow the guidelines specified in <a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2402.html">RFC2402</a>.

<p>
The <b>Encapsulating
Security Payload</b> (ESP) header, allows for rewriting of the payload
in encrypted form. The ESP header does not consider the fields of the IP
header before it and therefore makes no guarantees about anything except
the payload. The various types of ESP applicable must follow <a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2406.html">RFC2406</a>.
An ESP header can also provide authentication for the payload, (but not
the outer header).

<p>
An orthogonal (mostly) division of IPsec functionality is applied depending
on whether the endpoint doing the IPsec encapsulation is the original source
of the data or a gateway:

<ul>
<li><b>Transport</b> mode is used by a host that is generating the packets.
In transport mode, the security headers are added before the transport
layer (e.g . TCP, UDP) headers, before the IP header is prepended to the
packet. In other words an AH added to the packet will cover the hashing
of the TCP header and some fields of the end-to-end IP header, and an ESP
header will cover the encryption of the TCP header and the data, but
not the end-to-end IP header.

<li><b>Tunnel</b> mode is used when the end-to-end IP header is already
attached to the packet, and one of the ends of the secure connection is
only a gateway. In this mode, the AH and ESP headers are used to cover
the entire packet including the end-to-end header, and a new IP header
is prepended to the packet that covers just the hop to the other end of
the secure connection (though that may of course be several IP hops away).
</ul>

<p>IPsec secured links are defined in terms of <b>Security Associations
</b>(SAs). Each SA is defined for a single unidirectional flow of data,
and usually (ignoring multicast) from one single point to another, covering
traffic distinguishable by some <b>unique selector</b>. All traffic flowing
over a single SA is treated the same. Some traffic may be subject to several
SAs, each of which applies some transform. Groups of SAs are called an
SA <b>Bundle</b>. Incoming packets can be assigned to a particular SA by
the three defining fields, (<b>Destination IP address, Security Parameter
Index, security protocol</b>). SPI can be considered a cookie that is handed
out by the receiver of the SA when the parameters of the connection are
negotiated. The security protocol must be either AH or ESP. Since the IP
address of the receiver is part of the triple, this is a guaranteed unique
value. They can be found from the outer IP header and the first security
header (which contains the SPI and the security protocol).

<p>
An example of a tunnel mode AH packet is:

<p>
<table border="1">
<tr>
<td><b>IPhdr</b></td>
<td><b>AH</b></td>
<td>IPhdr2</td>
<td>TCPhdr</td>
<td>data</td>
</tr>
</table>

<p>
An example of a transport mode AH packet is:

<p>
<table border="1">
<tr>
<td><b>IPhdr</b></td>
<td><b>AH</b></td>
<td>TCPhdr</td>
<td>data</td>
</tr>
</table>

<p>
Because an ESP header cannot authenticate the outer IP header,
it is useful to combine an AH and an ESP header to get the following:

<p>
<table border="1">
<tr>
<td><b>IPhdr</b></td>
<td><b>AH</b></td>
<td><b>ESP</b></td>
<td><i>TCPhdr</i></td>
<td><i>data</i></td>
</tr>
</table>

<p>This is called <b>Transport Adjacency</b>. The tunneling version would
look like:

<p>
<table border="1">
<tr>
<td><b>IPhdr</b></td>
<td><b>AH</b></td>
<td><b>ESP</b></td>
<td><i>IPhdr2</i></td>
<td><i>TCPhdr</i></td>
<td><i>data</i></td>
</tr>
</table>

<p>
However it is not specifically mentioned in the RFC. As with Transport
adjacency, this would authenticate the entire packet except a few headers
in the IP header and also encrypt the payload (seen in italics). When
an AH and an ESP header are directly applied together like this,
the order of the headers should be as shown. It is possible in tunnel mode,
to do arbitrary recursive encapsulation so that order is not specified.

<p>
<a name= "Config"></a>
<a name="13.5"></a>
<h2>13.5 - Configuring IPsec</h2>

<p>
How the IPsec systems and gateways are configured is to some extent
left to the designer, however the RFC has some strong recommendations as
to how this should be implemented, so as to minimize confusion.

<p>
There are two administrative entities that control what happens to a
packet. One is the <b>Security Association Database</b> (SAD, referred
to as TDB or TDB table throughout OpenBSD's IPsec source code)
and the other is the <b>Security Policy Database</b> (SPD).

<p>
They are similar in that given a number of selectors that describe some
traffic, they will deliver an entry that describes the processing needed.
However, the SPD is two steps removed from the actual processing: the
SPD is used for outgoing packets, to decide what SAD entries should
be used, and the SAD entries in turn describe the actual process and the
parameters for it. The SPD entries specify the existing SAD entries
to use (if it's a bundle there can be more than 1), but if there is not
already a suitable one, it is used to create new ones. The fields of the
SA being created can be taken either from the SPD entry or from the packet
that initiated the creation.

<p>
Outgoing packets go from the SPD entry to the specific SA, to get encoding
parameters. Incoming packets get to the correct SA directly using the
SPI/DestIP/Proto triple, and from there get to the SPD entry.

<p>
The SPD can also specify what traffic should bypass IPsec and what should
be dropped, so it must also be consulted for incoming non-IPsec traffic.
SPD entries must be explicitly ordered as several might match a particular
packet, and the processing must be reproducible.

<p>
The SPD can be thought of as similar to a packet filter where the actions
decided upon are the activation of SA processes. Selectors can include
src and dest address, port numbers if relevant, application and user IDs
if available (only on host based transport SAs), hostnames, security
sensitivity levels, protocols, etc.

<p>
A SAD entry would include:

<ul>
<li>Dest IP address
<li>IPsec proto (AH or ESP)
<li>SPI (cookie)
<li>Sequence counter
<li>Seq O/F flag
<li>Anti-replay window info
<li>AH type and info
<li>ESP type and info
<li>Lifetime info
<li>Tunnel/transport mode flags
<li>Path MTU info
</ul>

<p>
A SPD entry would contain:

<ul>
<li>Pointer to active SAs
<li>Selector fields
</ul>

<p>
Each SA can define one ESP header and one AH header.
An IPsec session must have one or the other or both, but cannot be defined
with neither - otherwise there would be no headers to specify the SPI
to look up the SA. The RFC doesn't say what would happen if the
AH and ESP headers disagree about the SPI value. One would presume
this would imply multiple SAs in a bundle.

<p>
The SPD in OpenBSD is managed through the <tt>ipsecadm flow</tt> command.
(You would only make changes to it if you were using manual keying.)
SAD entries can be set manually with
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipsecadm&amp;sektion=8">ipsecadm(8)</a>,
however the IETF has also defined automatic mechanisms
for initialization of sessions and such things as key exchange.
OpenBSD implements ISAKMP automatic key exchange
(<a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2407.html">RFC2407</a>,
<a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2408.html">RFC2408,</a> and
<a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2409.html">RFC2409</a>)
in the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=isakmpd&amp;sektion=8">isakmpd(8)</a>
daemons.

<p>
<a name= "ManKey"></a>
<a name= "13.6"></a>
<h2>13.6 - How do I set up IPsec with manual keying?</h2>

<p>
Manual keying is the easiest way to get started with IPsec.
You can set up encryption between networks, to create VPNs using this
method.  After you have read this section, you may want to
investigate using <a href="http://www.openbsd.org/cgi-bin/cvsweb/src/share/ipsec/rc.vpn?rev=1.15">/usr/share/ipsec/rc.vpn</a>
to set this up for you automatically.

<p>
First, you need to ensure that the IP ESP protocol is
enabled in the OpenBSD kernel. Though it is enabled by default,
you should verify this fact by doing the following:

<blockquote><tt>
# <b>sysctl net.inet.esp.enable</b><br>
net.inet.esp.enable = 1<br>
</tt></blockquote>

<p>Similarly, if AH is required, verify that it has been enabled:
<blockquote><tt>
# <b>sysctl net.inet.ah.enable</b><br>
net.inet.ah.enable = 1
</tt></blockquote>


<p>
 If necessary,
these protocols may be enabled using the <i>-w</i> option to
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8"
>sysctl(8)</a>.

<p>
You can edit <tt>/etc/sysctl.conf</tt> to turn these on (or off) at boot time.
You need to remove the <i>#</i> mark from in front of <i>net.inet.esp.enable</i> and/or
<i>net.inet.ah.enable</i>
(depending on which you plan to use) and make sure they are set to 1.

<p>
Note that in most cases, such as with the <i>rc.vpn</i> script or with the
example below, only ESP is required.  In these cases, <i>you do not
need to enable AH</i>. In fact, there may be security concerns
related to enabling AH if you are not using it.

<p>
Next, you will need to generate your manual keys.
Since the security of the VPN is based on these keys being unguessable,
it is very important that the keys be chosen using a strong random
source.  One practical method of generating them is by using the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=random&amp;sektion=4">random(4)</a>
device. To produce 160 bits (20 bytes) of randomness, for example, do:

<blockquote><tt>
# <b>openssl rand 20 | hexdump -e '20/1 "%02x"'</b>
</tt></blockquote>

<p>
The number of bits produced is important.  Different cipher types may require different sized keys.

<pre>
Cipher    Key Length
DES       56 bits
3DES      168 bits
BLF       Variable (160 bits recommended)
CAST      Variable (40-128 bits recommended)
SKIPJACK  80 bits
</pre>

<p>
Now, you need to set up SAs, or Security Associations.
A Security Association is a combination of your IP addresses, an SPI, and
your security protocol (AH and/or ESP). The IP addresses are both your
own and that of your destination.  The SPI, or Security Parameter
Index, is a number that OpenBSD uses to classify different SAs.

<p>
<i>These examples only use ESP to encrypt your traffic.  ESP includes
authentication of the contained encrypted data, but does not authenticate
the surrounding IP header, as AH would.  This "limited authentication"
is nevertheless quite sufficient in most cases, especially for ESP in a
tunnel environment.</i>

<blockquote><tt>
# <b>ipsecadm new esp -spi SPI_OUT -src MY_EXTERNAL_IP -dst PEER_EXTERNAL_IP
-forcetunnel -enc blf -auth sha1 -key ENC_KEY -authkey AUTH_KEY</b>
</tt></blockquote>

<p>
Let's put this into practice with two routers, 192.168.5.1 and 192.168.25.9.

<p>
On Host 192.168.5.1:

<blockquote><tt>
# <b>ipsecadm new esp -spi 1000 -src 192.168.5.1 -dst 192.168.25.9 -forcetunnel -enc blf -auth sha1 -key 7762d8707255d974168cbb1d274f8bed4cbd3364 -authkey 6a20367e21c66e5a40739db293cf2ef2a4e6659f</b><br>
# <b>ipsecadm new esp -spi 1001 -dst 192.168.5.1 -src 192.168.25.9 -forcetunnel -enc blf -auth sha1 -key 7762d8707255d974168cbb1d274f8bed4cbd3364 -authkey 6a20367e21c66e5a40739db293cf2ef2a4e6659f</b>
</tt></blockquote>

<p>
On Host 192.168.25.9:

<blockquote><tt>
# <b>ipsecadm new esp -spi 1001 -src 192.168.25.9 -dst 192.168.5.1 -forcetunnel -enc blf -auth sha1 -key 7762d8707255d974168cbb1d274f8bed4cbd3364 -authkey 6a20367e21c66e5a40739db293cf2ef2a4e6659f</b><br>
# <b>ipsecadm new esp -spi 1000 -dst 192.168.25.9 -src 192.168.5.1 -forcetunnel -enc blf -auth sha1 -key 7762d8707255d974168cbb1d274f8bed4cbd3364 -authkey 6a20367e21c66e5a40739db293cf2ef2a4e6659f</b>
</tt></blockquote>

<p>
Notice that the SPIs are different.  See <a href="#Wire">On the wire format</a> for a complete description of what the SPI is and where it is used.

<p>
Now that you have your Security Associations in place,
set up your flows.

<p>
On 192.168.5.1:

<p>
So, right here, <b>two</b> flows will be created, one the local
source address, which covers all packets originating from the local host
to the destination, as well as a flow from the destination back to the local
host.

<blockquote><tt>
# <b>ipsecadm flow -proto esp -dst 192.168.25.9 -spi 1000 -addr 192.168.5.1 255.255.255.255 192.168.25.9 255.255.255.255</b>
</tt></blockquote>

<p>
On 192.168.25.9:

<blockquote><tt>
# <b>ipsecadm flow -proto esp -dst 192.168.5.1 -spi 1001 -addr 192.168.25.9 255.255.255.255 192.168.5.1 255.255.255.255</b>
</tt></blockquote>

<p>
If you want less overhead on your Host-to-Host VPNs, creating the SPI
without <tt>-forcetunnel</tt> will let you use transport mode (whereas, <tt>-forcetunnel</tt>
makes sure all of the IP packet, including the IP header, are encapsulated
by SPI).  If either
the source or destination is a network, you will have to use tunnel
mode.  Creating an SA to and/or from a network will automatically ensure
tunnel mode SPIs are being created.

<p>
This is a simple way to start using IPsec.

<p>
You can use IPsec to tunnel private IP address spaces over the Internet.
Here is a good example... We want to tunnel 192.168.99.0/24, which is behind
208.1.1.1, to 208.1.2.0/24 and 208.1.5.0/24 which are behind 208.2.2.2.
These examples were generated using the <a href="http://www.openbsd.org/cgi-bin/cvsweb/src/share/ipsec/rc.vpn?rev=1.3">rc.vpn</a> script.

<p>
As you can see, when you are using manual keying with IPsec,
you have to specify <b>exactly</b> what you want done.
It won't guess for you.  Look at these examples...


<h2>On 208.1.1.1:</h2>
First, set up the security associations (SAs):<br>
(This sets up the SPIs, encryption methods, and keys.) 

<blockquote><tt>
# <b>ipsecadm new esp -src 208.1.1.1 -dst 208.2.2.2 -forcetunnel -spi 1001 -enc blf -auth sha1 -key 7762d8707255d974168cbb1d274f8bed4cbd3364 -authkey 67e21c66e5a40739db293cf2ef2a4e6659f</b><br>
# <b>ipsecadm new esp -src 208.2.2.2 -dst 208.1.1.1 -forcetunnel -spi 1000 -enc blf -auth sha1 -key 7762d8707255d974168cbb1d274f8bed4cbd3364 -authkey 67e21c66e5a40739db293cf2ef2a4e6659f</b><br>
</tt></blockquote>

<p>
Next, set up a flow from 208.1.1.1 to 208.2.2.2

<blockquote><tt>
# <b>ipsecadm flow -proto esp -dst 208.2.2.2 -spi 1001 -addr 208.1.1.1 255.255.255.255 208.2.2.2 255.255.255.255</b><br>
</tt></blockquote>

<p>
Next, set up a flow from 208.1.2.0/24, which is behind 208.2.2.2, to 192.168.99.0/24

<blockquote><tt>
# <b>ipsecadm flow -proto esp -dst 208.2.2.2 -spi 1001 -addr 192.168.99.0 255.255.255.0 208.1.2.0 255.255.255.0</b><BR>
</tt></blockquote>

<p>
Next, set up a flow from 208.1.5.0/24, which is behind 208.2.2.2, to 192.168.99.0/24

<blockquote><tt>
# <b>ipsecadm flow -proto esp -dst 208.2.2.2 -spi 1001 -addr 192.168.99.0 255.255.255.0 208.1.5.0 255.255.255.0</b><br>
</tt></blockquote>

<p>
Now, set up a flow from 208.1.2.0/24, which is behind 208.2.2.2 to the router 208.1.1.1.

<blockquote><tt>
# <b>ipsecadm flow -proto esp -dst 208.2.2.2 -spi 1001 -addr 208.1.1.1 255.255.255.255 208.1.2.0 255.255.255.0</b><br>
</tt></blockquote>

<p>
OK, set up a flow from 208.1.5.0/24, which is behind 208.2.2.2, to the router 208.1.1.1

<blockquote><tt>
# <b>ipsecadm flow -proto esp -dst 208.2.2.2 -spi 1001 -addr 208.1.1.1 255.255.255.255 208.1.5.0 255.255.255.0</b><br>
</tt></blockquote>

<p>
Finally, set up a flow from the router 208.2.2.2 to 192.168.99.0/24

<blockquote><tt>
# <b>ipsecadm flow -proto esp -dst 208.2.2.2 -spi 1001 -addr 192.168.99.0 255.255.255.0 208.2.2.2 255.255.255.255</b><br>
</tt></blockquote>


<h2>On 208.2.2.2:</h2>

<p>
Same as before, we set up the SAs...

<blockquote><tt>
# <b>ipsecadm new esp -src 208.2.2.2 -dst 208.1.1.1 -forcetunnel -spi 1000 -enc blf -auth sha1 -key 7762d8707255d974168cbb1d274f8bed4cbd3364 -authkey 67e21c66e5a40739db293cf2ef2a4e6659f</b><br>
# <b>ipsecadm new esp -src 208.1.1.1 -dst 208.2.2.2 -forcetunnel -spi 1001 -enc blf -auth sha1 -key 7762d8707255d974168cbb1d274f8bed4cbd3364 -authkey 67e21c66e5a40739db293cf2ef2a4e6659f</b><br>
</tt></blockquote>

<p>
Now, this is the reverse side...
Set up a flow from the router 208.2.2.2 to 208.1.1.1

<blockquote><tt>
# <b>ipsecadm flow -proto esp -dst 208.1.1.1 -spi 1000 -addr 208.2.2.2 255.255.255.255 208.1.1.1 255.255.255.255</b><br>
</tt></blockquote>

<p>
Set up a flow from the network 192.168.99.0/24, which is behind 208.1.1.1, to 208.1.2.0/24

<blockquote><tt>
# <b>ipsecadm flow -proto esp -dst 208.1.1.1 -spi 1000 -addr 208.1.2.0 255.255.255.0 192.168.99.0 255.255.255.0</b><br>
</tt></blockquote>

<p>
Set up a flow from the network 192.168.99.0/24, which is behind 208.1.1.1, to 208.1.5.0/24

<blockquote><tt>
# <b>ipsecadm flow -proto esp -dst 208.1.1.1 -spi 1000 -addr 208.1.5.0 255.255.255.0 192.168.99.0 255.255.255.0</b><br>
</tt></blockquote>

<p>
Now, set up a flow from 192.169.99.0/24, which is behind 208.1.1.1, to the router 208.2.2.2

<blockquote><tt>
# <b>ipsecadm flow -proto esp -dst 208.1.1.1 -spi 1000 -addr 208.2.2.2 255.255.255.255 192.168.99.0 255.255.255.0</b><br>
</tt></blockquote>

<p>
We're almost done...
Two flows left to get 208.1.2.0/24 and 208.1.5.0/24 from the router 208.2.2.2
to the router 208.1.1.1.

<blockquote><tt>
# <b>ipsecadm flow -proto esp -dst 208.1.1.1 -spi 1000 -addr 208.1.2.0 255.255.255.0 208.2.2.2 255.255.255.255 -ingress</b><br>
# <b>ipsecadm flow -proto esp -dst 208.1.1.1 -spi 1000 -addr 208.1.5.0 255.255.255.0 208.2.2.2 255.255.255.255 -ingress</b><br>
</tt></blockquote>

<p>
If you have been using ipsecadm, and you want to get rid of any work
that you've done, and start from scratch, do

<blockquote><tt>
# <b>ipsecadm flush</b>
</tt></blockquote>

<p>
This will flush all IPsec info (SPIs, flows, routing entries) from your system.


<p>
<a name= "isakmpd"></a>
<h2>13.7 - How do I set up isakmpd?</h2>

<p>
If you are thinking about VPNs or other traditional applications
of IPsec, you probably are going to use ISAKMP.  Some commercial
implementations of IPsec do not provide any manual keying ability, instead
they require you to use some form of ISAKMP.


<p>
<h3>13.7.1 - What is isakmpd?</h3>

<p>
ISAKMP is the Internet Security Association and Key Management
Protocol. It is sometimes referred to as IKE, or Internet Key Exchange.  It
is the standard key exchange mechanism for IPsec. It
addresses security concerns using the methods mentioned in 
<a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2407.html">RFC 2407</a>,
<a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2408.html">RFC 2408,</a>
and
<a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2409.html">RFC 2409</a>.
ISAKMP manages the exchange of cryptographic keys that you
would normally have to manage with <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipsecadm&amp;sektion=8">ipsecadm(8)</a>.
It employs a two-phase process for establishing the IPsec parameters
between two IPsec nodes.

<p>
<b>Phase 1</b> - The two ISAKMP peers establish a secure,
authenticated channel upon which to communicate between two daemons. This
establishes a Security Association (SA) between both hosts. <b>Main
Mode</b> and <b>Aggressive Mode</b> are the methods used to establish this
channel. Main Mode sends the various authentication information in a
certain sequence, providing identity protection. Aggressive Mode does not
provide identity protection because all of the authentication information
is sent at the same time. Aggressive mode should only be used in such
cases where network bandwidth is of concern, as it can expose identity
information to an eavesdropper.

<p>
<b>Phase 2</b> - Security Associations are negotiated on behalf of IPsec.
Phase 2 establishes tunnels or endpoint SAs between IPsec hosts.
<b>Quick Mode</b> is used in Phase 2 because there is no need to repeat a
full authentication; Phase 1 has already established the SAs.

<p>
In brief, Phase 1 is used to get a secure channel in which to do the
(quicker) phase 2 setups.  There can be multiple phase 2 setups within the 
same phase 1 channel.  Phase 2 is used to set up the actual tunnels.
In Phase 1, your IPsec nodes establish a connection
where they exchange authentication (Either a X.509 certificate or a
pre-shared secret). This allows each end to make sure the other end is
authenticated.  Phase 2 is an exchange of keys to determine how the data
between the two will be encrypted.

<h3>13.7.2 - How do I get started with isakmpd?</h3>

<p>
By default, OpenBSD comes with the all the necessary binaries for ISAKMP
and the IPsec stack. Example configuration files may be found in
<tt>/usr/share/ipsec/isakmpd</tt>.
For the purposes of this example, copy <i>policy</i>
to <tt>/etc/isakmpd/isakmpd.policy</tt>.  Copy <i>VPN-east.conf</i> to
<tt>/etc/isakmpd/isakmpd.conf</tt>.
Here we attempt to show you how to set up a VPN (tunnel).  If you want to
use isakmpd between single hosts, there are other configuration files in
the <i>samples</i> directory.
The manual pages have detailed information..  Don't forget
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=isakmpd.conf&amp;sektion=5">isakmpd.conf(5)</a> and 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=isakmpd.policy&amp;sektion=5">isakmpd.policy(5)</a>.

<p>
Although both the ESP and AH protocols are enabled in the kernel by default,
you should verify the protocols you need are available by the procedure
outlined in the FAQ section on <a href="#ManKey">
Manual Keying</a>.
Next, you need to edit <tt>/etc/isakmpd/isakmpd.policy</tt>.  
This file tells ISAKMP who can access IPsec. In this scenario, the policy file states that anybody who sends data
using Encapsulating Security Payload (ESP), and has authenticated with the passphrase <i>mekmitasdigoat</i> (or whatever
passphrase you determine), is allowed to communicate with isakmpd.  You can modify this file to let ISAKMP know that we only
want to allow data signed with certain digital certificates or using a certain encryption transform. You could also
allow anybody to access IPsec.  This is only recommended for testing.
To do this, edit your policy file to contain only the following lines:

<blockquote><pre>
KeyNote-Version: 2
Authorizer: &quot;POLICY&quot;
</pre></blockquote>

<p>
The same policy file contains two lines that start with the $ character.
You need to remove these lines before using it; they are only for cvs.  

<p>
A more useful policy file for this example looks like this:

<blockquote><pre>
KeyNote-Version: 2
Comment: This policy accepts ESP SAs from a remote that uses the right password
Authorizer: &quot;POLICY&quot;
Licensees: &quot;passphrase:mekmitasdigoat&quot;
Conditions: app_domain == &quot;IPsec policy&quot; &amp;&amp;
            esp_present == &quot;yes&quot; -&gt; &quot;true&quot;; 
</pre></blockquote>

<p>
Implementing this will give you a basic VPN (tunnel) using ESP only.
On host A, edit <tt>/etc/isakmpd/isakmpd.conf</tt>.  The 249.2.2.2 sample IP address
should be replaced with the external IP address of host A.

<blockquote><pre>
[General] 
Retransmits=		5
Exchange-max-time=	120
Listen-on=		249.2.2.2
</pre></blockquote>

<p>
Do similar for isakmpd.conf on host B.  249.3.3.3 represents the
external IP address for host B.

<blockquote><pre>
[General]
Retransmits=		5
Exchange-max-time=	120
Listen-on=		249.3.3.3
</pre></blockquote>

<p>
This is where you can set up the variables that will affect the main behavior of isakmpd. It is okay to 
use the defaults here.
The <b>Listen-on</b>= value specifies the IP 
that isakmpd should listen on. Only the Internet IP of your gateway is necessary.
If you have multiple external interfaces on your gateway, 
you could list which interfaces you want to listening on by entering them using a comma separated list.

<p>
Next, on host A, edit isakmpd.conf again.

<blockquote><pre>
[Phase 1]
249.3.3.3=		HostB
</pre></blockquote>

<p>
On host B:

<blockquote><pre>
[Phase 1]
249.2.2.2=		HostA
</pre></blockquote>

<p>
This section describes the IP addresses to accept in order to negotiate the phase 1 connection. 
Its value points to the section below (Remember that phase 1 simply 
authenticates the remote peer to make sure they are who they say they are). You can list multiple peers with additional lines in the format of
IP_Address=<i> &lt;PEER-NAME&gt;.</i>

<p>
Next, on host A:

<blockquote><pre>
[Phase 2]
Connections=		HostA-HostB
</pre></blockquote>

<p>
On host B:

<blockquote><pre>
[Phase 2]
Connections=		HostB-HostA
</pre></blockquote>

<p>
This describes Phase 2 of the connection. This is the phase that determines what protocols the two 
peers will use to communicate.

<p>
The <b>Connections</b>= tag refers to the section below. 
It initiates the requirements or the accepted methods to set up Phase 2. This also tells ISAKMPD which 
connections to initiate once started. Note that you can have multiple sections
as illustrated below 
if you are to connect with multiple peer hosts.

<p>
If you do not have the IP address of the remote host, you can specify a Default= that points 
to a section describing a generic entry that will be referenced by any 
incoming IP that is not listed in the <b>Connections</b>= tag.

<p>
On host A:

<blockquote><pre>
[HostB]
Phase=			1
Transport=		udp
Local-address=		249.2.2.2
Address=		249.3.3.3
Configuration=		Default-main-mode
Authentication=		mekmitasdigoat
#Flags=
</pre></blockquote>

<p>
On host B:

<blockquote><pre>
[HostA]
Phase=			1
Transport=		udp
Local-address=		249.3.3.3
Address=		249.2.2.2
Configuration=		Default-main-mode
Authentication=		mekmitasdigoat
#Flags=
</pre></blockquote>

<p>
These represent the sections referred to by the Phase 1 section above. They each 
describe the requirements that the peer gateway must fulfill in order to proceed to Phase 2. There are 
many other options here but the ones mentioned above are the minimum requirements.

<ul>
<li><b>Phase=1 </b>is required because the ISAKMPD code uses the same procedures to process Phase 1 and 
Phase 2. It must be <b>1</b> or nothing will work.
<li><b>Transport= </b> gives you different possibilities for different peers. It's 
suggested that udp be used here so we'll leave it at that.
Please note that some peers may be behind a firewall that doesn't let UDP traffic through.  Obviously, this needs to be determined before setup.
<li><b>Local-address </b>is the destination address that the incoming packets point to. In some cases, you 
can be listening on different Interfaces for Phase 1 connections.
In this example, there is only 1 interface listening, therefore this is the IP of the listening 
interface on this peer.
<li><b>Address= </b>is the address that points to the source IP of the incoming packets. This usually points 
to the peer gateway. 
This needs further explanation, because the source IP address of the peer may be unknown!
<li><b>Configuration= </b>points to the section below. You can specify 
multiple sections like this. We use the default one 
specified by the sample file.
<li><b>Authentication=</b> is the pre-shared secret to be used for this particular peer. It is more or less 
a passphrase that each peer uses. This passphrase gets passed to policy to verify whether this 
peer is allowed to use IPSEC with this host. If you change this phrase, you must also change it in the 
policy file because the sample file provides for this passphrase. If you decided to go with a 
minimum policy file then you can specify whatever you want here.
<li><b>Flags=</b> is not currently being used. The RFCs leave room for extra options to be specified for 
phase 1.
<p>There are other tags here that will allow for other options to be set. Refer to 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=isakmpd.conf&amp;sektion=5">isakmpd.conf(5)</a>
for descriptions.
</ul>

<p>
On Host A:

<blockquote><pre>
[HostA-HostB]
Phase=			2
ISAKMP-peer=		HostB
Configuration=		Default-quick-mode
Local-ID=		Net-A
Remote-ID=		Net-B
</pre></blockquote>

<p>
On Host B:

<blockquote><pre>
[HostB-HostA]
Phase=			2
ISAKMP-peer=		HostA
Configuration=		Default-quick-mode
Local-ID=		Net-B
Remote-ID=		Net-A
</pre></blockquote>

<p>
These represent the sections referred to by the Phase 2 section above. They are the 
individual settings that ISAKMPD must use to talk between the two gateways for the particular 
connection.

<ul>
<li><b>Phase=2</b> is required because ISAKMPD code uses the same functions to authenticate Phase 1 and Phase 
2. This is required for the VPN to work.
<li><b>ISAKMPD-Peer=</b> is the name of Host section above. This means that we are 
talking to that particular peer to establish a Phase 2 connection. This is provided because you can have 
multiple sections to describe isakmp peers and connections.
<li><b>Configuration=</b> refers to the section below that describes the 
standards by which this host and the particular peer for this connection must abide.
<li><b>Local-ID=</b> refers to an IPsec-ID section below that describes our Private Network to 
the peer gateway. This is the portion that is passed so that the other gateway can set up the proper 
routing table that will transfer data over the VPN to our network.
<li><b>Remote-ID=</b> refers to an IPsec-ID section below that describes what is supposed to be 
the remote Private Network to our host. This portion is interpreted to set up the proper routing tables 
that will transfer data from our Private Network over the VPN to the remote Private Network.
<p>There is another tag that is supported here called Flags=. If you require this tag, read 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=isakmpd.conf&amp;sektion=5">isakmpd.conf(5)</a>.
</ul>

<p>
This is the IPsec-ID section.  These entries need to exist
in the isakmpd.conf files for both Host A and Host B.  This example
will set up 192.168.1.0/255.255.255.0 for Host A (which was connected
to Net-A above) and 192.168.20.0/255.255.255.0 for Host B (Net-B above).

<blockquote><pre>
[Net-A]
ID-type=		IPV4_ADDR_SUBNET
Network=		192.168.1.0
Netmask=		255.255.255.0

[Net-B]
ID-type=		IPV4_ADDR_SUBNET
Network=		192.168.20.0
Netmask=		255.255.255.0
</pre></blockquote>

<p>
These two sections are in the <b>conf</b> file of each host. They are the sections referenced by the 
<b>Local-ID</b> and <b>Remote-ID</b> identifiers. They describe the 
routes that should be set up to allow traffic from one private network to another.
<b>ID-type</b>= can be <b>IPV4_ADDR_SUBNET</b> or <b>IPV4_ADDR</b> (RFC2708 mentions more possible values. Currently only IPv4 is supported in the OpenBSD implementation.  IPv6 may be supported in OpenBSD-current. )
 
<p>
Now, on both hosts, the sample file should read:

<blockquote><pre>
[Default-main-mode]
DOI=			IPSEC
EXCHANGE_TYPE=		ID_PROT
Transforms=		3DES-SHA
</pre></blockquote>

<p>
This section describes the requirements for the encryption methods of Phase 1 connections. The name 
reflects the value of <i>Configuration=</i> variable.  As we can see here, we are stating our 
Domain of Interest which is IPSEC. The <b>EXCHANGE_TYPE</b> variable is set to <b>ID_PROT</b> for Phase 1, 
which identifies the protocols to be covered by this Authentication.
<b>Transforms=</b> is the transform required (or assigned) for this exchange. In this case, this points to 
the section below in the configuration file that says we are receiving a packet 
encrypted with 3DES and a checksum verifiable with SHA. There are a bunch of different transforms defined 
inside the sample <b>VPN-east.conf</b>. These are provided because 3DES and SHA are not always supported 
across different platforms. For OpenBSD there should be no reason to change this for a basic setup. Feel 
free to create multiples of this section and change the transform. The only requirement is that you change  the Configuration= variable.

<blockquote><pre>
[Default-quick-mode]
DOI=			IPSEC
EXCHANGE_TYPE=		QUICK_MODE
Suites=			QM-ESP-3DES-SHA-PFS-SUITE,QM-ESP-DES-MD5-PFS-SUITE
</pre></blockquote>

<p>
This section describes the requirements for the encryption of the data to be sent through the VPN and 
is referred to by <i>Configuration</i> above. Note the difference between this 
section and the Phase 1 equivalent just above is that the <b>EXCHANGE_TYPE</b> is <b>QUICK_MODE</b>. 
This is always the case for Phase 2.
<b>Suites=</b> points to a IPsec Suite section describing the different encryption 
schemes available between the two hosts.
There is much more to be said about ISAKMP and IPsec. By using the above basic descriptions you should 
be able to create a simple but solid VPN that cares and feeds itself.
This is the bare <i>minimum</i> 
<b>isakmpd.conf</b> for both hosts here.
 
<h3>13.7.3 - Starting isakmpd</h3>

<p>
You may wish to use

<blockquote><tt>
# <b>isakmpd -d -DA=90</b>
</tt></blockquote>

<p>
the first time you decide to run this daemon. The daemon will not be
running in daemon mode but as a regular (foreground) process. It will log
everything to your terminal.  To stop isakmpd and flush the routes,
you need to kill the isakmpd process on each node, and run <b>ipsecadm
flush</b>.


<p>
<a name= "x509"></a>
<h2>13.8 - How do I use isakmpd with X.509 certificates?</h2>

<p>
Setting up isakmpd to use certificates instead of pre-shared keys is
not really that much harder in a big network with many untrusted peers
than it would be with a small network. It may actually simplify
configuration, and more importantly, makes key management much more
flexible.


<h2>Generating certificates.</h2>

<p>
There is a good description of how to generate keys and certificates
in the
<a href="http://www.openbsd.org/cgi-bin/cvsweb/src/sbin/isakmpd/README.PKI?rev=1.7">README.PKI</a>
 file in the isakmpd source directory.  You need to
have a CA key, a corresponding CA X.509 certificate, one private key
for each computer on the network that will use isakmpd and one X.509
certificate for each such key.

<p>
In order to be usable by isakmpd, the X.509 certificates need to have
a Subject Alternative Name (subjectAltName) extension added to them.
This extension describes the certificate holder's identity, and may be
added by using either <a 
href="http://www.openbsd.org/cgi-bin/man.cgi?query=certpatch&amp;sektion=8"
>certpatch(8)</a>,
or a custom openssl configuration file such as
<tt>/etc/ssl/x509v3.cnf</tt>. The examples in
<a href="http://www.openbsd.org/cgi-bin/cvsweb/src/sbin/isakmpd/README.PKI?rev=1.7">README.PKI</a>
describe this process using IP addresses as subjectAltName identifiers.

<p>
Though IP addresses are the default mechanism for subjectAltName
extensions, certpatch also supports using either a FQDN (Fully
Qualified Domain Name) or a UFQDN (User FQDN). These can be very
useful for mobile users. An example of an FQDN
might be <tt>www.openbsd.org</tt>. An example of an UFQDN could be an
email address, such as <tt>Jorgen.Granstam@abc.se</tt>. It should be
noted that unlike IP-based identifiers, isakmpd performs no
verification of the data presented in FQDN or UFQDN-based
identification; the identifiers are treated simply as strings.

<p>
The following examples will use FQDNs as subjectAltNames.

<p>
To insert an FQDN subjectAltName into a certificate one would do
something like this:

<blockquote><tt>
$ <b>/usr/sbin/certpatch -t fqdn -i home.mysite.se -k ca.key originalcert.crt newcert.crt</b>
</tt></blockquote>

<p>
Here the ca.key is the private key of the CA, thus this can only be
done by whoever has access to the CA private key. The (fictional) 
home.mysite.se is the FQDN to be inserted into the certificate. The
originalcert.crt and newcert.crt filenames may be the same name in
which case the original file will be overwritten by the new modified
certificate. 

<p>
These keys and certificates should then be moved to their appropriate
directories. The default locations for the keys and certificates are
as follows:

<p>
<table>
<tr><td><tt>/etc/isakmpd/ca</tt></td>
<td>public-key (PEM-format) certificates of trusted CAs</td></tr>
<tr><td><tt>/etc/isakmpd/certs</tt></td>
<td>trusted public-key (PEM-format) certificates (with subjectAltName extensions)</td></tr>
<tr><td><tt>/etc/isakmpd/private</tt></td>
<td>Private Keys. These should have corresponding public keys in the
<tt>cert</tt> directory, above</td></tr>
</table>

<p>
These locations may be overridden by values in the
[X509-certificates] section of
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=isakmpd.conf&amp;sektion=5">isakmpd.conf(5)</a>.

<p>
Note that if the CA infrastructure is to be trusted, the CA private
key (<tt>/etc/isakmpd/ca/ca.key</tt>) should be kept in a safe place,
should be of an appropriate bit length (i.e. 2048-bit), and should be
encrypted with a strong passphrase.


<h2>Configuration of isakmpd</h2>

<p>
Lets now look at the <tt>/etc/isakmpd/isakmpd.conf</tt> configuration file.  It
was originally taken from the example file in
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=isakmpd.conf&amp;sektion=5">isakmpd.conf(5)</a>
but has been heavily modified. I will also use a much shorter file
here than the example file in the man page to make it easier to
understand. I have also added some commenting
(some comments are left as in the isakmpd.conf(5)) and changed some
names. None of the domain names used here exist as far as I know.

<p>
Actually since everyone who reads this already has a working
configuration for the pre-shared keys case (see previous section) there won't be
many surprises in this file. I won't explain this in every detail,
check isakmpd.conf(5) for descriptions of the parts I don't
comment on. 

<p>
Let's assume our setup looks something like this

<p>
<center>
<pre>
one.mysite.se                                        one.worksite.se
 192.168.1.2--+    10.0.0.1====/======10.0.0.2     +--192.168.2.2 
              |  gw.mysite.se       gw.worksite.se |
              +--192.168.1.1         192.168.2.1---+
two.mysite.se |                                    | two.worksite.se
 192.168.1.3--+                                    +--192.168.2.3
</pre>
</center>

<p>
That is, two networks that should be connected using an IPsec tunnel over an 
otherwise insecure network. Ignore the fact that I am using IP
addresses reserved for private Internets here (RFC1918), I have to use
something. I won't explain how to use isakmpd in combination with NAT
or similar (because I haven't tried that myself).

<p>
Now, let's look at the configuration file. This is the file for the
security gateway gw.mysite.se:

<blockquote><pre>

# *****************************************************************
# ************* Start of the gw.mysite.se isakmpd.conf ************
# *****************************************************************

# A configuration sample for the isakmpd ISAKMP/Oakley (aka IKE) daemon.
[General]
Policy-File=            /etc/isakmpd/isakmpd.policy
Retransmits=            5
Exchange-max-time=      120
Listen-on=              10.0.0.1


# The name work-gw here is used just as a section name and a tag for
# use in this configuration file below and need not actually be the 
# real hostname or domain name of the peer (but it could be). The IP 
# address however needs to be correct. Phase 1, as you might already
# know, is to negotiate an ISAKMP security association (SA). There 
# should of course be one IP and name for each peer we want to
# communicate with.
[Phase 1]
10.0.0.2=               work-gw


# Now phase 2 is negotiating IPsec SAs. As in phase 1, the name here
# is a section name to be used later. Actually, it can be a comma
# separated list of section names here. Thus if traffic from many
# networks (or individual hosts) should be forwarded through this
# tunnel, more section names would be added (and of course corresponding 
# new sections further down). 
[Phase 2]
Connections=            work-gw-my-gw


# Now, here are some parameters for the ISAKMP SA negotiations. Almost 
# self documenting. The section name is from [Phase 1] above. The most 
# interesting tag might be the ID tag. The ID tag is set to the name
# of the section where the identity information about this host that 
# will be presented to connecting peers, can be found. If the ID tag 
# is not available, isakmpd will assume that it will identify itself 
# using the IP address. You might also notice that there is no longer 
# any authentication tag here in this configuration. The authentication
# data is currently used only in the pre-shared key case. 
[work-gw]
Phase=                  1
Transport=              udp
Local-address=          10.0.0.1                # Local address
Address=                10.0.0.2                # Peer address
ID=                     my-ID
Configuration=          Default-main-mode


# This is the identity data. ID-type may also be IPV4_ADDR (the
# default), IPV4_ADDR_SUBNET or UFQDN. The Name tag is used for 
# FQDN and UFQDN, for IPV4_ADDR an Address tag would be used instead.
# For IPV4_ADDR_SUBNET a Network and a Netmask tag would be used.  
[my-ID]
ID-type=                FQDN
Name=                   gw.mysite.se


# This is the section for the IPsec connection. The section name is
# from the list in the [Phase 2] section above. The ISAKMP-peer is,
# of course, the tag of our peer from section [Phase 1] above. The 
# Local-ID and Remote-ID tags should be section names describing which
# packages should be forwarded over the IPsec tunnel to the remote 
# network.
[work-gw-my-gw]
Phase=                  2
ISAKMP-peer=            work-gw
Configuration=          Default-quick-mode
Local-ID=               Net-west
Remote-ID=              Net-east

# Any packet originating from a computer on the network described
# here... 
[Net-west]
ID-type=                IPV4_ADDR_SUBNET
Network=                192.168.1.0
Netmask=                255.255.255.0

# ... and with a destination matching the network described here, 
# will be encrypted and forwarded over the IPsec tunnel to the remote 
# system. 
[Net-east]
ID-type=                IPV4_ADDR_SUBNET
Network=                192.168.2.0
Netmask=                255.255.255.0

# Main mode descriptions


# Here are the data for main mode. Using DES here for real purposes
# is not very smart since DES is no longer considered a secure
# encryption algorithm. 3DES is generally considered to have much better
# security since it has enough bits in the key to be considered secure. 
# Transforms is a list of tags describing main mode transforms. In 
# this example we have only one.
[Default-main-mode]
DOI=                    IPSEC
EXCHANGE_TYPE=          ID_PROT
Transforms=             3DES-MD5


# Certificates stored in PEM format
# This is important when using certificates. The CA certificates should 
# be in the CA-directory (but not the CA private key of course).
# The Cert-directory should have at least the certificate for the
# local host but other certificates are also allowed. The private key 
# should be the private key of the local host. 
[X509-certificates]
CA-directory=           /etc/isakmpd/ca/
Cert-directory=         /etc/isakmpd/certs/
Private-key=            /etc/isakmpd/private/local.key

# Main mode transforms
######################

# Here is our main mode transform. The important thing here is to use
# RSA_SIG as authentication method when using certificates. It is the
# only method supported when using certificates so far. Commercial
# entities in the US will thus have to wait until September 2000 to
# use this due to the RSA patent. Luckily, I am not living in the US. 
# Also important is the GROUP_DESCRIPTION tag. It must match the
# GROUP_DESCRIPTION tag in the Quick mode transforms further down. 
# The Life tag here could possibly be modified. The LIFE_60_SECS might 
# be shorter than necessary for normal use. 

[3DES-MD5]
ENCRYPTION_ALGORITHM=   3DES_CBC
HASH_ALGORITHM=         MD5
AUTHENTICATION_METHOD=  RSA_SIG
GROUP_DESCRIPTION=      MODP_1024
Life=                   LIFE_60_SECS,LIFE_1000_KB

# Quick mode description
########################

[Default-quick-mode]
DOI=                    IPSEC
EXCHANGE_TYPE=          QUICK_MODE
Suites=                 QM-ESP-3DES-MD5-PFS-SUITE

# Quick mode protection suites
##############################
# 3DES

[QM-ESP-3DES-MD5-PFS-SUITE]
Protocols=              QM-ESP-3DES-MD5-PFS

# 3DES

[QM-ESP-3DES-MD5-PFS]
PROTOCOL_ID=            IPSEC_ESP
Transforms=             QM-ESP-3DES-MD5-PFS-XF

# Quick mode transforms

# Don't forget. The GROUP_DESCRIPTION must match the GROUP_DESCRIPTION 
# in main mode above. For forwarding packets between two networks (or
# from a host to a network) we use TUNNEL mode. Between two hosts we
# may also use TRANSPORT mode instead. 
[QM-ESP-3DES-MD5-PFS-XF]
TRANSFORM_ID=           3DES
ENCAPSULATION_MODE=     TUNNEL
AUTHENTICATION_ALGORITHM=       HMAC_MD5
GROUP_DESCRIPTION=      MODP_1024
Life=                   LIFE_60_SECS


# As we know from the isakmpd.config manpage the LIFE_DURATION here is 
# an offer value (60), a minimum acceptable value (45) and a maximum
# acceptable value. The isakmpd.conf example has this set to 
# 600,450/720 instead. That might be a better value for normal use.
[LIFE_60_SECS]
LIFE_TYPE=              SECONDS
LIFE_DURATION=          60,45:72

[LIFE_1000_KB]
LIFE_TYPE=              KILOBYTES
LIFE_DURATION=          1000,768:1536

# *****************************************************************
# ************* End of the gw.mysite.se isakmpd.conf **************
# *****************************************************************
</pre></blockquote>

<p>
So far the configuration for the local system. The remote system is
configured just the same way only opposite. Thus only the first part
of the isakmpd.conf file differs. Let's just look at that first part 
of the isakmpd.conf file for the security gateway gw.worksite.se:

<blockquote><pre>
# *****************************************************************
# ************* Start of the gw.worksite.se isakmpd.conf **********
# *****************************************************************

[General]
Policy-File=            /etc/isakmpd/isakmpd.policy
Retransmits=            5
Exchange-max-time=      120
Listen-on=              10.0.0.2

[Phase 1]
10.0.0.1=               my-gw

[Phase 2]
Connections=            work-gw-my-gw

[my-gw]
Phase=                  1
Transport=              udp
Local-address=          10.0.0.2                # Local address
Address=                10.0.0.1                # Peer address
ID=                     work-ID
Configuration=          Default-main-mode

[work-ID]
ID-type=                FQDN
Name=                   gw.worksite.se

[work-gw-my-gw]
Phase=                  2
ISAKMP-peer=            my-gw
Configuration=          Default-quick-mode
Local-ID=               Net-east
Remote-ID=              Net-west

# *****************************************************************
# ********************** ... to be continued **********************
# *****************************************************************
</pre></blockquote>

<p>
Now that wasn't so hard, just a bit boring to read perhaps. A
slightly more interesting part next.


<h2>The policy file.</h2>

<p>
Actually, the policy file might be slightly confusing for anyone who has
not used it before, especially if things do not work as expected. The man-page
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=isakmpd.policy&amp;sektion=5">isakmpd.policy(5)</a>
is not really that bad. It might perhaps be a
little bit unclear in some parts but generally it's good. 

<p>
The simplest possible working policy file would contain just a
single line:

<blockquote><pre>
authorizer: &quot;POLICY&quot;
</pre></blockquote>

<p>
This basically means that there are no policy limitations on who
would be allowed to connect. Thus not a very secure setup. The
authorizer tag here means the one who has the authorization to decide
the policy. The special authorizer &quot;POLICY&quot; has the ultimate and
unlimited authority on policy. Any other authorizer must first be
authorized by &quot;POLICY&quot; to have any authority here.

<p>
There can also be a set of conditions for what is allowed. The
following policy thus would mean that only someone using the ESP
protocol with some real encryption would be authorized (oh well,
someone using DES would also be authorized here although DES could
almost be considered snake oil today, it is left as an exercise for the
reader to change this policy into not allowing DES either). Note
that anyone who does encrypts with ESP would still be allowed.

<blockquote><pre>
authorizer: &quot;POLICY&quot;
conditions: app_domain == &quot;IPsec policy&quot; &amp;&amp;
            esp_present == &quot;yes&quot; &amp;&amp;
            esp_enc_alg != &quot;null&quot; -&gt; &quot;true&quot;;

</pre></blockquote>

<p>
It is also possible to "sublicense" authority to someone else (might
be one or more entities). The simple case would be the pre-shared key
case. In that case, anyone who knows the pre-shared passphrase is
authorized. Thus:

<blockquote><pre>
authorizer: &quot;POLICY&quot;
licensees:  &quot;passphrase:something really secret&quot;
conditions: app_domain == &quot;IPsec policy&quot; &amp;&amp;
            esp_present == &quot;yes&quot; &amp;&amp;
            esp_enc_alg != &quot;null&quot; -&gt; &quot;true&quot;;
</pre></blockquote>

<p>
This would authorize anyone who knows this passphrase to connect and
comply with the conditions (but remember that the passphrase must also
be set in the Authentication tag in isakmpd.conf).

<p>
Nothing difficult so far. Now to the interesting stuff. First there
can be many licensees, although all must be authorized by &quot;POLICY&quot;.
Further, authorized licensees can sublicense to other licensees. A
licensee can be just a string in case it is further described in the
policy file:

<blockquote><pre>
authorizer: &quot;POLICY&quot;
licensees:  &quot;subpolicyAH&quot; ||  &quot;subpolicyESP&quot;
conditions: app_domain == &quot;IPsec policy&quot; -&gt; &quot;true&quot;;

authorizer: &quot;subpolicyESP&quot; 
licensees:  &quot;passphrase:something more secret&quot;
conditions: esp_present == &quot;yes&quot; -&gt; &quot;true&quot;;

authorizer: &quot;subpolicyAH&quot; 
licensees:  &quot;passphrase:something really secret&quot;
conditions: ah_present == &quot;yes&quot; -&gt; &quot;true&quot;;
</pre></blockquote>

<p>
And now to what everyone has been waiting for. Policy can also be
sub-licensed or delegated to a key. In this case it is usually a
X.509 certificate. The simple use of certificates would be to use
them like the passphrases. Just insert individual users certificates
in the policy file:

<blockquote><pre>
keynote-version: 2
comment: This is an example of a policy delegating to a key.
authorizer: &quot;POLICY&quot;
licensees: &quot;x509-base64:\
        MIIBsTCCARoCAQAwDQYJKoZIhvcNAQEEBQAwITELMAkGA1UEBhMCc2UxEjAQBgNV\
        BAMTCUlLRUxBQiBDQTAeFw0wMDAxMjgxNzQyMTZaFw0wMTAxMjcxNzQyMTZaMCEx\
        CzA           This is would be a user certificate           AQEB\
        BQA                                                         IUuz\
        eOW8P5UGJUH2JVkiA2CTDryFf0CHYwd2P003dtVYw5RvET7XLMpRZiCcWtBdxneW\
        ct+016zUBP/cQMMl+KownxAUq9ezA8GvTyUWC97SOMOgoVj/QR3FHmEjpUi3AgMB\
        AAEwDQYJKoZIhvcNAQEEBQADgYEALGShaAxHvGncev0iFnKrJI4x5T4vlaMP1ad+\
        iWLV5q9H3wickVGN0NPerq0YLwx/VA9WaecYN8V+ALtNKYPuDiT11zwvE8GQeaai\
        NuzgmQ9hh3GifEgN9VEiC3j4kTytonKr0Q+vTLM7xYzheOxvrtUErRwZ9Xs1KzHe\
        yiXHSU8=&quot;
conditions: app_domain == &quot;IPsec policy&quot; &amp;&amp;
            esp_present == &quot;yes&quot; &amp;&amp;
            esp_enc_alg != &quot;null&quot; -&gt; &quot;true&quot;;
</pre></blockquote>

<p>
Now, this is obviously a stupid idea if there are a lot of users. The
certificates that isakmpd reads from the CA- and Certificate
directories, and the certificates received from the peer is converted
into pseudo credentials. Such certificates converted into pseudo
credentials essentially would look something like:

<blockquote><pre>

authorizer: &quot;x509-base64:\
        MIIBsTCCARoCAQAwDQYJKoZIhvcNAQEEBQAwITELMAkGA1UEBhMCc2UxEjAQBgI2\
	CzA  This is would be the public key/certificate of the     AQEB\
        BQA signer of the user certificate (i.e. the CA certificate)IUuz\
        eOW8P5UGJUH2JVkiA2CTDryFf0CHYwd2P003dtVYw5RvET7XLMpRZiCcWtBdxneW\
        ct+016zUBP/cQMMl+KownxAUq9ezA8GvTyUWC97SOMOgoVj/QR3FHmEjpUi3AgMB\
        AAEwDQYJKoZIhvcNAQEEBQADgYEALGShaAxHvGncev0iFnKrJI4x5T4vlaMP1ad+\
        iWLV5q9H3wickVGN0NPerq0YLwx/VA9WaecYN8V+ALtNKYPuDiT11zwvE8GQeaai\
        NuzgmQ9hh3GifEgN9VEiC3j4kTytonKr0Q+vTLM7xYzheOxvrtUErRwZ9Xs1KzHe\
        yiXHSU8=&quot;
licensees:  &quot;x509-base64:\
        MIIBsTCCARoCAQAwDQYJKoZIhvcNAQEEBQAwITELMAkGA1UEBhMCc2UxEjAQBgNV\
        BAMTCUlLRUxBQiBDQTAeFw0wMDAxMjgxNzQyMTZaFw0wMTAxMjcxNzQyMTZaMCEx\
        CzA      This is would be the key of the subject of the     AQEB\
        BQA                        certificate                      IUuz\
        eOW8P5UGJUH2JVkiA2CTDryFf0CHYwd2P003dtVYw5RvET7XLMpRZiCcWtBdxneW\
        ct+016zUBP/cQMMl+KownxAUq9ezA8GvTyUWC97SOMOgoVj/QR3FHmEjpUi3AgMB\
        AAEwDQYJKoZIhvcNAQEEBQADgYEALGShaAxHvGncev0iFnKrJI4x5T4vlaMP1ad+\
        iWLV5q9H3wickVGN0NPerq0YLwx/VA9WaecYN8V+ALtNKYPuDiT11zwvE8GQeaai\
        NuzgmQ9hh3GifEgN9VEiC3j4kTytonKr0Q+vTLM7xYzheOxvrtUErRwZ9Xs1KzHe\
        yiXHSU8=&quot;
conditions: app_domain == &quot;IPsec policy&quot; -&gt; &quot;true&quot;;
</pre></blockquote>

<p>
Now note that these are not authorized by &quot;POLICY&quot; and thus won't have
any effect without a policy authorizing them somehow. Further, this
showed what happens to certificates internally. The above credential
is thus not seen in the policy file. However, it is possible to
sublicense to such credentials. Remember sub-licensing above. It is
thus possible to license all certificates that are signed by a certain
CA by putting the CA certificate as a licensee to &quot;POLICY&quot;:

<blockquote><pre>
keynote-version: 2
comment: This is an example of a policy delegating to a key.
authorizer: &quot;POLICY&quot;
licensees: &quot;x509-base64:\
        MIIBsTCCARoCAQAwDQYJKoZIhvcNAQEEBQAwITELMAkGA1UEBhMCc2UxEjAQBgNV\
        BAMTCUlLRUxBQiBDQTAeFw0wMDAxMjgxNzQyMTZaFw0wMTAxMjcxNzQyMTZaMCEx\
        CzA               This would be the CA certificate          AQEB\
        BQA                                                         IUuz\
        eOW8P5UGJUH2JVkiA2CTDryFf0CHYwd2P003dtVYw5RvET7XLMpRZiCcWtBdxneW\
        ct+016zUBP/cQMMl+KownxAUq9ezA8GvTyUWC97SOMOgoVj/QR3FHmEjpUi3AgMB\
        AAEwDQYJKoZIhvcNAQEEBQADgYEALGShaAxHvGncev0iFnKrJI4x5T4vlaMP1ad+\
        iWLV5q9H3wickVGN0NPerq0YLwx/VA9WaecYN8V+ALtNKYPuDiT11zwvE8GQeaai\
        NuzgmQ9hh3GifEgN9VEiC3j4kTytonKr0Q+vTLM7xYzheOxvrtUErRwZ9Xs1KzHe\
        yiXHSU8=&quot;
conditions: app_domain == &quot;IPsec policy&quot; &amp;&amp;
            esp_present == &quot;yes&quot; &amp;&amp;
            esp_enc_alg != &quot;null&quot; -&gt; &quot;true&quot;;
</pre></blockquote>

<p>
Thus the above policy is a simple example of a policy that delegates
to a CA. Thus any user that has a certificate that is signed by the CA
that has this certificate and otherwise comply to other conditions set
by the policy and the configuration file would be authorized.


<h2>Almost secure...is not secure!</h2>

<p>
Now, to be really safe, this is not enough unfortunately. There are
ways to attack a security gateway that is configured in this way. If
you really don't want the details, skip a to the next section now. To
everyone else, let's try to understand why this is not secure. It's
not hard.

<p>
Consider what information one of the isakmpds has access to at this
stage. From the configuration file, isakmpd knows which IP-address its
peer will send from (in the [Phase 1] section). From the information
it gets at the phase 1 negotiation it knows the ID that the peer
presents itself with and the certificate it gets from the peer proves
that the peer really have this ID. Looks fine so far?

<p>
Well, if the ID information were the IP (the default situation if we
do not provide a phase 1 ID section) everything would be fine. The CA
would have tied the IP to the cert and the IP in the configuration
would be all information we need. It would be possible for an
imposter to use the same IP from another computer in some cases
(e.g. if both computers were on the same local network and the
computer that usually have this IP is down for some reason). It
should however not be possible for an imposter to be able to have a
certificate and a corresponding private key that (falsely) proves
that this IP belongs to the imposter.

<p>
If that ever happened, the imposter would have managed to either steal the
private key from the real owner of the IP, or the imposter would have
managed to fool the CA into issuing a certificate containing false
information somehow. If any of these things happened, then either the
private key had not been protected well enough, the CA had failed
to check the identity of the imposter well enough (or the ID info for
the cert) or the CA private key had not been well enough protected.
Since all these are prerequisites for security to work at all, none
of these situations can be allowed to ever occur.

<p>
Now, in our example the situation is different. Here we actually have
an FQDN in the certificate instead of an IP address. Since we still
have an IP address in the [Phase 1] section this will result in a
possible security problem. What now would happen during an ISAKMP
phase 1 negotiation would be that we could check that the peer was
sending from the expected IP (but as explained earlier that could
possibly be forged in some situations). We could check that the ID
our peer presents actually belongs to our peer. But what we can not
check now is if that ID really is the ID we expect our peer to have,
because isakmpd have never been told what ID that should be.

<p>
Someone now might say that the DNS system ties the IP to the FQDN for
the host. That is true, however today's DNS system is not secure and
can, under some circumstances, be fooled to give out false
information (or, it could be subject to a denial of service (DoS)
attack by an attacker, and the attacker's computer might be able to
fake the DNS server's answer). Secure DNS will come in the future, but
it is not here yet (at least most DNS servers are not secure yet),
thus today, using DNS to check if the FQDN in the cert corresponds to
the expected IP is no guarantee. In fact isakmpd does not check this
with DNS. Even if DNS was secure, checking this would not help in the
case of using an UFQDN.

<p>
Thus in the case of having an FQDN as ID, it could be possible for an
attacker to get an own private key and having this key signed by the
same CA that we use (but with the attacker's own FQDN, of course). Then
launch a DoS attack on our peer so that it goes down (in fact, there
are some flaws in the ISAKMP protocol itself that possibly could be
used to launch a remote DoS against the peer an make it go down,
although I don't know how sensitive isakmpd is to those attacks). Then
the attacker could configure its own computer in the same way as our
peer, connect it to our peers network and try to connect using its
own ID, private key and certificate.

<p>
Since our own isakmpd has not been informed about what ID to our peer (and it is because the attacker is identically configured as
our peer besides the certificate, ID and private key). Further our
isakmpd can check that the certificate was signed by the same CA (but
most CAs sign lots of certs, a cert might not be hard to get), and that
the presented ID is the same as the ID in the cert. However it would
not, with the configuration presented so far, check that this ID is the
expected ID. Thus the attacker would be allowed to connect.


<h3>Preventing the attack.</h3>

<p>
The question now thus is, how can we inform isakmpd about what ID to
expect? This is fortunately easy, and documented in the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=isakmpd.policy&amp;sektion=5">isakmpd.policy(5)</a>.
We must do the check in the policy. Like
this:

<blockquote><pre>
keynote-version: 2
comment: This is an example of a policy delegating to a key.
authorizer: &quot;POLICY&quot;
licensees: &quot;x509-base64:\
        MIIBsTCCARoCAQAwDQYJKoZIhvcNAQEEBQAwITELMAkGA1UEBhMCc2UxEjAQBgNV\
        BAMTCUlLRUxBQiBDQTAeFw0wMDAxMjgxNzQyMTZaFw0wMTAxMjcxNzQyMTZaMCEx\
        CzA               This would be the CA certificate          AQEB\
        BQA                                                         IUuz\
        eOW8P5UGJUH2JVkiA2CTDryFf0CHYwd2P003dtVYw5RvET7XLMpRZiCcWtBdxneW\
        ct+016zUBP/cQMMl+KownxAUq9ezA8GvTyUWC97SOMOgoVj/QR3FHmEjpUi3AgMB\
        AAEwDQYJKoZIhvcNAQEEBQADgYEALGShaAxHvGncev0iFnKrJI4x5T4vlaMP1ad+\
        iWLV5q9H3wickVGN0NPerq0YLwx/VA9WaecYN8V+ALtNKYPuDiT11zwvE8GQeaai\
        NuzgmQ9hh3GifEgN9VEiC3j4kTytonKr0Q+vTLM7xYzheOxvrtUErRwZ9Xs1KzHe\
        yiXHSU8=&quot;
conditions: app_domain == &quot;IPsec policy&quot; &amp;&amp;
            esp_present == &quot;yes&quot; &amp;&amp;
            esp_enc_alg != &quot;null&quot; &amp;&amp;
            remote_id == &quot;gw.worksite.se&quot; -&gt; &quot;true&quot;;
</pre></blockquote>

<p>
Now only gw.worksite.se should be able to get an IPsec connection.
More allowed IDs could easily be added by adding more alternative
remote_id checks, e.g. by having conditions like these in the policy:

<blockquote><pre>
conditions: app_domain == &quot;IPsec policy&quot; &amp;&amp;
            esp_present == &quot;yes&quot; &amp;&amp;
            esp_enc_alg != &quot;null&quot; &amp;&amp;
            (remote_id == &quot;gw.worksite.se&quot;  ||
               remote_id == &quot;gw.whatsite.se&quot;) -&gt; &quot;true&quot;;
</pre></blockquote>

<p>
With this policy either of gw.worksite.se, gw.somesite.se or 
gw.whatsite.se could connect.

<p>
Some might say that is unfortunate that there has to be entire
certificates inserted in the policy. It requires some work to
reformat the certificates into the format in the policy and it makes
the policy rather unreadable. If someone by mistake replaced a user
certificate with the corresponding CA certificate somewhere in a
complex policy it might cause unauthorized users to be allowed to
connect in some cases and worse, it would not be easily detectable by
reading through the policy file (since X.509 certificates are not in
a human readable format). 

<p>
Now, for the really bleeding edge people out there a solution to this
problem is available. It is now possible to use the certificate
Distinguished Name (DN) instead of a certificate in the policy (the
corresponding certificate must of course be available from the certs
or ca directories on disk so that isakmpd can find it). With this
format the policy above might look like something like this instead:

<blockquote><pre>  
keynote-version: 2
comment: This is an example of a policy delegating to a key.
authorizer: &quot;POLICY&quot;
licensees: &quot;DN:/C=se/CN=IKELAB CA&quot;
conditions: app_domain == &quot;IPsec policy&quot; &amp;&amp;
            esp_present == &quot;yes&quot; &amp;&amp;
            esp_enc_alg != &quot;null&quot; &amp;&amp;
            (remote_id == &quot;gw.worksite.se&quot;  ||
             remote_id == &quot;gw.somesite.se&quot;  ||
             remote_id == &quot;gw.whatsite.se&quot;) -&gt; &quot;true&quot;;
</pre></blockquote>

<p>
Much more readable, isn't it? The information about what the exact DN
for a certificate is can be found by looking at the certificate using
the openssl utility. Something like:

<blockquote><tt>
$ <b>openssl x509 -text &lt; ca.crt</b>
</tt></blockquote>

<p>
More complicated policy configurations are of course possible but
this is a start anyway, and there is another example in the next
section. 

<p>
This should provide the necessary information about the certificate in
ca.crt. Now this is good as long as we have a small or at least
reasonably small policy. It is however still not too great if we have
a gigantic site with lots of users that should be allowed to connect.


<h2>Multiuser configurations and/or centrally managed authorization.</h2>

<p>
Now, lets look at some really cool features of isakmpd. Previously we
assumed that the expected peer was well known and had a static IP
address. This is not always the case. Lots of people use dynamically
assigned IPs or use many different computers. In other cases (like
for a server) we might not know for sure who wants to connect. 

<p>
Therefore one very nice feature of isakmpd is the ability to use a
default tag instead of an IP in the [Phase 1] section, thus allowing
isakmpd negotiations from any IP. This might thus look something like
this:

<blockquote><pre>
[phase 1]
Default=        work-gw
</pre></blockquote>

<p>
First, it should be said that this configuration might not be secure
from DoS attacks. As said before, there are some flaws in the
ISAKMP/IKE protocols. Anyway, using a default [phase 1] section also
enable us to use a kind of &quot;authorization certificates&quot; instead.

<p>
Consider the case where we have a lot of authorized users but when we
would not accept just any user.  Like at a company. We would like
company employees to be allowed to connect but nobody else. Now,
imagine a big company where there might be thousands of employees. We
might like them to all be able to connect from any computer (not only
from within the company network) but everyone should not be allowed to
do anything. It should now be possible to write a policy like this:

<blockquote><pre>
keynote-version: 2
authorizer: &quot;POLICY&quot;
licensees: &quot;telnet@work&quot; || &quot;telnet@lab&quot; || &quot;pop3@work&quot; 
conditions: app_domain == &quot;IPsec policy&quot; &amp;&amp;
            esp_present == &quot;yes&quot; &amp;&amp;
            esp_enc_alg != &quot;null&quot; &amp;&amp;
            remote_id_type == &quot;UFQDN&quot; &amp;&amp;
            (remote_id == &quot;telnet@worksite.se&quot;  ||
             remote_id == &quot;pop3@worksite.se&quot;  ||
             remote_id == &quot;telnet@lab.worksite.se&quot;) -&gt; &quot;true&quot;;

authorizer: &quot;telnet@work&quot;
licensees: &quot;DN:/C=se/CN=IKELAB CA&quot;
conditions: remote_id == &quot;telnet@worksite.se&quot; &amp;&amp;
            local_filter_type == &quot;IPv4 address&quot; &amp;&amp;
            local_filter_port == &quot;23&quot; &amp;&amp;
            local_filter == &quot;192.168.002.003&quot;

authorizer: &quot;telnet@lab&quot;
licensees: &quot;DN:/C=se/CN=IKELAB CA&quot;
conditions: remote_id == &quot;telnet@lab.worksite.se&quot; &amp;&amp;
            local_filter_type == &quot;IPv4 address&quot; &amp;&amp;
            local_filter_port == &quot;23&quot; &amp;&amp;
            local_filter == &quot;192.168.002.002&quot; -&gt; &quot;true&quot;;

authorizer: &quot;pop3@work&quot;
licensees: &quot;DN:/C=se/CN=IKELAB CA&quot;
conditions: local_filter_type == &quot;IPv4 address&quot; &amp;&amp;
            local_filter_port == &quot;110&quot; &amp;&amp;
            local_filter == &quot;192.168.002.003&quot; &amp;&amp;
            remote_id == &quot;telnet@worksite.se&quot; -&gt; &quot;true&quot;;

</pre> </blockquote>

<p>
This might not be exactly how it should be. This is as far as I know
completely untested (in fact, these filter conditions might not work
at all as I expect). Also, a policy such as this one (in fact any
with default as peer IP), would require rewrites of the isakmpd.conf
file too. This would have some security implications too. Further,
for this kind of connections where anyone should be allowed to
connect, it would probably be desirable to log the DN of anyone who
connected. Isakmpd does not yet support that to my knowledge. Also
this probably could have other security implications.  You are on 
your own, you have been warned.  The basic idea should be clear anyway.

<p> 
Just in case someone missed the really interesting possibilities this would
have. If all computers using ISAKMP/IKE this way had a standard set of
conditions for all services the users might like to use from remote, the CA
could actually authorize users by just putting the right subjectAltName
extensions in their certificates. Further, the expiration time for such
certificates could be set to expire relatively often although the users
would be able to download new reissued certificates when their current
certificate is getting old. If the users misuse their authorizations, just
stop reissuing the certificates and they won't get in more after it has
expired. No need to change policy files on all computers just because an
employee e.g. quits their job. The same scheme should work for other
purposes than ISAKMP/IPsec too (including authorization for off-line
systems!) although that would require special software. In any case, any
organization doing this would probably want to be their own CA.

<p>
Multiuser configurations (mobile users) like these are possible with
pre-shared keys too, but then it is required that AGGRESSIVE mode is
used instead of ID_PROT mode since we then must be able to choose the
right password phrase based on ID since we do not know that from what
the IP is in this case (in AGGRESSIVE mode the ID is sent over at an
earlier stage of the negotiation, but it is sent unencrypted, thus
AGGRESSIVE mode is faster because it needs fewer message exchanges,
but it also is a bit less secure since the ID is sent in clear).


<p>
<a name= "IKEcl"></a>
<h2>13.9 - What IKE clients are compatible with isakmpd?</h2>

<p>
<tt>isakmpd</tt> is the ISAKMP/Oakley key management daemon that comes with OpenBSD.
We suspect that it interoperates, at least partially, with most ISAKMP
implementations, but the following have actually been tested.   Note that some
isakmp software out there is actually based on the OpenBSD isakmp daemon.

<p>
The following MS-Windows clients have been reported to be compatible:

<ul>
<!-- <li><a href="http://www.timestep.com/">TimeStep</a> PERMIT/Client -->
<li><a href="http://www.ashleylaurent.com/">Ashley Laurent</a> VPN software
<li><a href="http://www.pgp.com/">PGP VPN</a> software
<li><a href="http://www.ssh.com/">SSH Sentinel</a> IPSec client
<li><a href="http://www.cisco.com/">Cisco</a> IRE client
<li><a href="http://www.microsoft.com">Microsoft</a> Windows 2000, XP
</ul>

<p>
The following gateways/routers have been reported to be compatible:

<ul>
<li><a href="http://www.cisco.com/">Cisco</a> IOS
<li><a href="http://www.cisco.com/">Cisco</a> PIX
<li><a href="http://www.intel.com/">Intel</a> LanRover
<!-- <li><a href="http://www.timestep.com/">TimeStep</a> PERMIT/Gate -->
<li><a href="http://www.cendio.com/">Cendio</a> Fuego
<li><a href="http://www.kame.net/">KAME</a> for FreeBSD
<li><a href="http://www.xs4all.nl/~freeswan/">FreeS/WAN</a> for Linux
<li><a href="http://www.symantec.com/">Symantec</a> Raptor
<li><a href="http://www.ericsson.com/">Ericsson</a> eBox
<li><a href="http://www.f-secure.com/">F-Secure</a> VPN+
<li><a href="http://www.teamware.com/">Teamware</a> TWISS
<li><a href="http://www.3com.com/">3com</a> Pathbuilder
<li><a href="http://www.nortelnetworks.com/">Nortel</a> Contivity
<li><a href="http://www.checkpoint.com/">CheckPoint</a> FW-1
<li><a href="http://www.watchguard.com/">Watchguard</a> Firebox III
<li><a href="http://www.lucent.com/">Lucent</a> Access Point
</ul>

<p>
<a name= "Trouble"></a>
<h2>13.10 - Troubleshooting IPsec/VPN</h2>

<p>
Your first tool for troubleshooting IPsec is <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcpdump&amp;sektion=8">tcpdump(8)</a>.
Use <tt>tcpdump</tt> to look for several things.

<p>
First, if you are using tcpdump from 
OpenBSD, you have an enhanced version of tcpdump which can show some
information about ESP and AH packets.  If you are using tcpdump from OpenBSD
2.5 or on another operating system, chances are you have an older
version that will simply show the protocol number for AH or ESP.
(ESP is IP protocol 50, AH is 51)

<ul>
<li>
With tcpdump, look and see if traffic is using AH/ESP or cleartext.
If your traffic is in cleartext, then your flows are set up incorrectly
or your isakmp is not negotiating properly.  Use <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ping&amp;sektion=8">ping(8)</a>
to generate simple traffic.
<p>
For instance, I have two hosts, 208.1.1.1 and 208.2.2.2.  
Logged in to 208.2.2.2, I am doing this:
<pre>
# <b>ping -c 3 208.1.1.1</b>
PING esp.mil (208.1.1.1): 56 data bytes
64 bytes from 208.1.1.1: icmp_seq=0 ttl=255 time=190.155 ms
64 bytes from 208.1.1.1: icmp_seq=1 ttl=255 time=201.040 ms
64 bytes from 208.1.1.1: icmp_seq=2 ttl=255 time=165.481 ms
--- esp.mil ping statistics ---
3 packets transmitted, 3 packets received, 0% packet loss
round-trip min/avg/max = 165.481/185.558/201.040 ms
</pre>
<p>
And in another session, I can see my encapsulated pings:
<pre>
# <b>tcpdump -ni fxp7 host 208.1.1.1</b>
tcpdump: listening on fxp7
14:12:19.630274 esp 208.2.2.2 &gt; 208.1.1.1 spi 0x00001000 seq 4535 len 116
14:12:19.813519 esp 208.1.1.1 &gt; 208.2.2.2 spi 0x00001001 seq 49313 len 116
14:12:20.630277 esp 208.2.2.2 &gt; 208.1.1.1 spi 0x00001000 seq 4536 len 116
14:12:20.832458 esp 208.1.1.1 &gt; 208.2.2.2 spi 0x00001001 seq 49314 len 116
14:12:21.630273 esp 208.2.2.2 &gt; 208.1.1.1 spi 0x00001000 seq 4537 len 116
<b>^C</b>
1831 packets received by filter
0 packets dropped by kernel
</pre>
<p>
<li>ISAKMP runs on UDP port 500.  If this is locked out through a firewall
or packet filter, then you need to change it!
<blockquote><pre>
# Passing in ISAKMP traffic from the security gateways
pass in on ne0 proto udp from gatewB/32 port = 500 to gatewA/32 port = 500
pass out on ne0 proto udp from gatewA/32 port = 500 to gatewB/32 port = 500

# Passing in encrypted traffic from security gateways
pass in proto esp from gatewB/32 to gatewA/32
pass out proto esp from gatewA/32 to gatewB/32
</pre></blockquote>
<p>
<li>
To turn on all useful debugging in isakmpd, start it as
<blockquote><tt>
# <b>/sbin/isakmpd -d -DA=90</b>
</tt></blockquote>
<p>
or (to skip the most detailed timer debug info)
<blockquote><tt>
# <b>/sbin/isakmpd -d -DA=90 -D1=70</b>
</tt></blockquote>
<p>
<li>You need to allow traffic which has been processed by IPsec from netB
into your local firewalled netA.
<blockquote><pre>
# Passing in traffic from the designated subnets.
pass in on enc0 from netB/netBmask to netA/netAmask
</pre></blockquote>
<p>
<li>With tcpdump on OpenBSD, you can decode most cleartext parts of Internet
Key Exchange sessions.  Tcpdump will also show AH payload data.
<p>
<li>Mount a /kern filesystem (if you don't use one by default already.)
<blockquote><tt>
# <b>mkdir /kern; mount -t kernfs /kern /kern</b>
</tt></blockquote>
<p>
In /kern, there is a table of current SA/SPIs, including which have flows
(outgoing SAs) or not (incoming SAs).
There are also traffic counters which you can use to see what traffic is going
where.
<p>
<li>Finally, you can use <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&amp;sektion=1">netstat(1)</a> to see your SAs.
<blockquote><pre>
$ <b>netstat -rn -f encap</b>
Routing tables

Encap:
Source             Port  Destination        Port  Proto SA(Address/SPI/Proto) 
0.0.0.0/32         0     192.168.99/24      0     0     208.1.1.1/00001000/50
0.0.0.0/32         0     208.1.1.1/32       0     0     208.1.1.1/00001000/50
208.1.2.0/24       0     192.168.99/24      0     0     208.1.1.1/00001000/50
208.1.2.0/24       0     208.1.1.1/32       0     0     208.1.1.1/00001000/50
208.1.5.0/24       0     192.168.99/24      0     0     208.1.1.1/00001000/50
208.1.5.0/24       0     208.1.1.1/32       0     0     208.1.1.1/00001000/50
208.2.2.2/32       0     192.168.99/24      0     0     208.1.1.1/00001000/50
208.2.2.2/32       0     208.1.1.1/32       0     0     208.1.1.1/00001000/50
</pre></blockquote>
<p>
<li>
If all else fails, recompile your kernel with <tt>option ENCDEBUG</tt>.
Then, set the sysctl <tt>net.inet.ip.encdebug</tt> to 1.  Look in your dmesg for
warnings or errors, and report them using <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sendbug&amp;sektion=1">sendbug(1)</a>
to the OpenBSD developers.  Alternately, if you are not sure you have
actually run into a bug, you may want to send a message to one of the <a href="../mail.html">mailing lists</a>.
</ul>


<p>
<a name= "SeeAlso"></a>
<h2>13.11 - Related Documentation</h2>

<p>
IPsec is partially documented in the 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vpn&amp;sektion=8">vpn(8)</a>
man page.  There are various configuration templates in <a href="http://www.openbsd.org/cgi-bin/cvsweb/src/share/ipsec/">/usr/share/ipsec/</a>
directory which can also assist you.  The manual pages for
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=enc&amp;sektion=4">enc(4)</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipsec&amp;sektion=4">ipsec(4)</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipsecadm&amp;sektion=8">ipsecadm(8)</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=isakmpd&amp;sektion=8">isakmpd(8)</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=isakmpd.conf&amp;sektion=5">isakmpd.conf(5)</a> and
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=isakmpd.policy&amp;sektion=5">isakmpd.policy(5)</a>
are detailed and can assist in setup and operation of IPsec.

<p>
Other links...

<ul>
<li><a href="http://www.ietf.org/html.charters/ipsec-charter.html">IETF IPsec Working Group</a>
<li><a href="http://isakmp-test.ssh.fi/">SSH IPsec interoperability Test Node</a>
<li><a href="http://ipsec-wit.antd.nist.gov/">NIST IPsec Web Based Interoperability Tester</a>
<li><a href="http://www.r4k.net/ipsec/">A port of OpenBSD's IPsec to FreeBSD</a>
<li><a href="http://www.xs4all.nl/~freeswan/">FreeS/WAN - IPsec for Linux</a>
<li><a href="http://www.pintday.org/hack/docs/vpn-24-minifaq.shtml">OpenBSD 2.4 VPN Configuration Mini-FAQ</a>
</ul>

<p> 
<a name="rfc">
And on to the RFCs...
</a>

<ul>
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc1320.html">RFC 1320</a> - The MD4 Message-Digest Algorithm
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc1321.html">RFC 1321</a> - The MD5 Message-Digest Algorithm
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc1828.html">RFC 1828</a> - IP Authentication using Keyed MD5
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc1829.html">RFC 1829</a> - The ESP DES-CBC Transform
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2040.html">RFC 2040</a> - The RC5, RC5-CBC, RC5-CBC-Pad, and RC5-CTS Algorithms
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2085.html">RFC 2085</a> - HMAC-MD5 IP Authentication with Replay Prevention
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2104.html">RFC 2104</a> - HMAC: Keyed-Hashing for Message Authentication
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2144.html">RFC 2144</a> - The CAST-128 Encryption Algorithm 
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2202.html">RFC 2202</a> - Test Cases for HMAC-MD5 and HMAC-SHA-1 
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2207.html">RFC 2207</a> - RSVP Extensions for IPsec Data Flows
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2268.html">RFC 2268</a> - A Description of the RC2 Encryption Algorithm 
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2367.html">RFC 2367</a> - PF_KEY Key Management API, Version 2
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2401.html">RFC 2401</a> - Security Architecture for the Internet Protocol (<b>IPsec</b>)
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2402.html">RFC 2402</a> - IP Authentication Header (<b>AH</b>)
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2403.html">RFC 2403</a> - The Use of HMAC-MD5-96 within ESP and AH
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2404.html">RFC 2404</a> - The Use of HMAC-SHA-1-96 within ESP and AH
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2405.html">RFC 2405</a> - The ESP DES-CBC Cipher Algorithm With Explicit IV
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2406.html">RFC 2406</a> - IP Encapsulating Security Payload (<b>ESP</b>)
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2407.html">RFC 2407</a> - The Internet IP Security Domain of Interpretation for ISAKMP
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2408.html">RFC 2408</a> - Internet Security Association and Key Management Protocol (<b>ISAKMP</b>)
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2409.html">RFC 2409</a> - The Internet Key Exchange (<b>IKE</b>)
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2410.html">RFC 2410</a> - The NULL Encryption Algorithm and Its Use With IPsec (ha ha...)
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2411.html">RFC 2411</a> - IP Security Document Roadmap
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2412.html">RFC 2412</a> - The OAKLEY Key Determination Protocol
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2451.html">RFC 2451</a> - The ESP CBC-Mode Cipher Algorithms
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2631.html">RFC 2631</a> - Diffie-Hellman Key Agreement Method
<li><a href="http://www.cis.ohio-state.edu/htbin/rfc/rfc2709.html">RFC 2709</a> - Security Model with Tunnel-mode IPsec for NAT Domains
</ul>

<font color= "#0000e0">
<a href= "index.html">[FAQ Index]</a>
<a href= "faq12.html">[To Section 12 - For Advanced Users]</a>
<a href= "faq14.html">[To Section 14 - Using disks in OpenBSD]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../images/back.gif" border= "0" alt="[back]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>$OpenBSD: faq13.html,v 1.76 2003/06/15 01:56:38 nick Exp $</small>

</body>
</html>
