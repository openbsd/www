<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>6 - Networking</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2003 by OpenBSD.">
</head>

<body bgcolor="#ffffff" text="#000000">
<!-- passes validator.w3.org, please keep it this way -->

<img alt="[OpenBSD]" height=30 width=141 src="../images/smalltitle.gif">
<p>
<font color="#0000e0">
<a href="index.html">[FAQ Index]</a>
<a href="faq5.html">[To Section 5 - Building the System from Source</a>
<a href="faq7.html">[To Section 7 - Keyboard and Display Controls]</a>
</font>

<h1><font color="#e00000">6 - Networking</font></h1>
<hr>

<p>
<h3>Table of Contents</h3>
<ul>
<li><a href= "#Intro" >6.0.1 - Before we go any further</a>
<li><a href= "#Setup" >6.1 - Initial network setup</a>
<li><a href= "#PF"    >6.2 - Packet Filter (PF)</a>
<li><a href= "#NAT"   >6.3 - Network Address Translation</a>
<li><a href= "#DHCP"  >6.4 - Dynamic Host Configuration Protocol</a>
<li><a href= "#PPP"   >6.5 - Point to Point Protocol</a>
<li><a href= "#Tuning">6.6 - Tuning networking parameters</a>
<li><a href= "#NFS"   >6.7 - Using NFS</a>
<li><a href= "#DNS"   >6.8 - Domain Name Service  - DNS, BIND, and named</a>
<li><a href= "#PPTP"  >6.9 - Setting up a PPTP connection in OpenBSD</a>
<li><a href= "#Bridge">6.10 - Setting up a bridge with OpenBSD</a>
</ul>

<hr>

<p>
<a name="Intro"></a>
<a name="6.0.1"></a>
<h2>6.0.1 - Before we go any further</h2>

<p>
For the bulk of this document, it helps if you have read and
at least partially understood the <a href="faq5.html">Kernel
Configuration and Setup</a> section of the FAQ, and the
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a> and
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&amp;sektion=1">
netstat(1)</a> man pages.

<p>
If you are a network administrator, and you are setting up routing
protocols, if you are using your OpenBSD box as a router, if you need to
go in depth into IP networking, you really need to read
<a href="http://www.3com.com/other/pdfs/infra/corpinfo/en_US/501302.pdf">Understanding
IP Addressing</a>.
This is an excellent document.  "Understanding IP Addressing" contains
fundamental knowledge to build upon when working with IP networks,
especially when you deal with or are responsible for more than one network.

<p>
If you are working with applications such as web servers, ftp servers,
and mail servers, you may benefit greatly by
<a href="http://the.rfceditor.org/rfc.html">reading the RFCs</a>.
Most likely, you can't read all of them.  Pick some topics that you are
interested in, or that you use in your network environment.  Look them
up, find out how they are intended to work.  The RFCs define many
(thousands of) standards for protocols on the Internet and how they are
supposed to work.

<p>
<a name="Setup"></a>
<a name="6.1"></a>
<h2>6.1 - Initial Network Setup</h2>

<p>
<a name="Setup.1"></a>
<a name="6.1.1"></a>
<h3>6.1.1 - Identifying and Setting Up Your Network Interfaces</h3>

<p>
To start off, you must first identify your network interface.  In
OpenBSD, interfaces are named for the type of card, not for the type of
connection. You can see your network card get initialized during the
booting process, or after the booting process using the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)</a>
command.  You also have the chance of seeing your network interface
using the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a> command.
For example, here is the output of dmesg for a Intel Fast Ethernet
network card, which uses the device name fxp.

<blockquote><pre>
fxp0 at pci0 dev 10 function 0 "Intel 82557" rev 0x0c: irq 5, address 00:02:b3:2b:10:f7
inphy0 at fxp0 phy 1: i82555 10/100 media interface, rev. 4
</pre></blockquote>

<p>
If you don't know what your device name is, please look at the
<a href="../plat.html">supported hardware list</a> for your platform.
You will find a list of many common card names and their OpenBSD device
names here.  Combine the short alphabetical device name (such as fxp)
with a number assigned by the kernel and you have an interface name
(such as fxp0).

<p>
You can find out what network interfaces have been identified by using the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
utility. The following command will show all network interfaces on a
system.  This sample output shows us only one physical ethernet interface,
an <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp&amp;sektion=4">fxp(4)</a>.
</p>

<blockquote><pre>
$ <strong>ifconfig -a</strong>
lo0: flags=8049<UP,LOOPBACK,RUNNING,MULTICAST> mtu 33224
        inet 127.0.0.1 netmask 0xff000000
        inet6 ::1 prefixlen 128
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x5
lo1: flags=8008<LOOPBACK,MULTICAST> mtu 33224
fxp0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
        address: 00:04:ac:dd:39:6a
        media: Ethernet autoselect (100baseTX full-duplex)
        status: active
        inet 192.168.1.35 netmask 0xffffff00 broadcast 192.168.1.255
        inet6 fe80::204:acff:fedd:396a%fxp0 prefixlen 64 scopeid 0x1
pflog0: flags=0<> mtu 33224
pfsync0: flags=0<> mtu 2020
sl0: flags=c010<POINTOPOINT,LINK2,MULTICAST> mtu 296
sl1: flags=c010<POINTOPOINT,LINK2,MULTICAST> mtu 296
ppp0: flags=8010<POINTOPOINT,MULTICAST> mtu 1500
ppp1: flags=8010<POINTOPOINT,MULTICAST> mtu 1500
tun0: flags=10<POINTOPOINT> mtu 3000
tun1: flags=10<POINTOPOINT> mtu 3000
enc0: flags=0<> mtu 1536
bridge0: flags=0<> mtu 1500
bridge1: flags=0<> mtu 1500
vlan0: flags=0<> mtu 1500
        address: 00:00:00:00:00:00
vlan1: flags=0<> mtu 1500
        address: 00:00:00:00:00:00
gre0: flags=9010<POINTOPOINT,LINK0,MULTICAST> mtu 1450
gif0: flags=8010<POINTOPOINT,MULTICAST> mtu 1280
gif1: flags=8010<POINTOPOINT,MULTICAST> mtu 1280
gif2: flags=8010<POINTOPOINT,MULTICAST> mtu 1280
gif3: flags=8010<POINTOPOINT,MULTICAST> mtu 1280
</pre></blockquote>

<p>
As you can see here, 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a> 
gives us a lot more information than we need at this point. But, it
still allows us to see our interface. In the above example, the
interface card is already configured. This is obvious because an IP
network is already configured on fxp0, hence the values &quot;inet
10.0.0.38 netmask 0xffffff00 broadcast 10.0.0.255&quot;.  Also, the
<strong>UP</strong> and <strong>RUNNING</strong> flags are set.

<p>
Finally, you will notice several other interfaces come enabled by
default.  These are virtual interfaces that serve various functions.
The following manual pages describe them:

<ul>
<!-- XXXrelease -->
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lo&amp;sektion=4">lo</a>
 - Loopback Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflog&amp;sektion=4&amp;manpath=OpenBSD+3.3">pflog</a>
 - Packet Filter Logging Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sl&amp;sektion=4">sl</a>
 - SLIP Network Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=4">ppp</a>
 - Point to Point Protocol
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tun&amp;sektion=4">tun</a>
 - Tunnel Network Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=enc&amp;sektion=4">enc</a>
 - Encapsulating Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4">bridge</a>
 - Ethernet Bridge Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vlan&amp;sektion=4">vlan</a>
 - IEEE 802.1Q Encapsulation Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gre&amp;sektion=4">gre</a>
 - GRE/MobileIP Encapsulation Interface
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gif&amp;sektion=4">gif</a>
 - Generic IPv4/IPv6 Tunnel Interface
</ul>

<p>
If you don't have your interface configured, the first step is to create
the <i>/etc/hostname.xxx</i> file, where the name of your interface will
take the place of xxx. From the information in the examples above, the
name would be <i>/etc/hostname.fxp0</i>. The layout of this file is
simple:<br>

<blockquote><pre>
address_family address netmask broadcast [other options]
</pre></blockquote>

(Much more detail about the format of this file can be found in the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5">hostname.if(5)</a>
man page.)

<p>
A typical interface configuration file, configured for an IPv4 address,
would look like this:

<blockquote><pre>
$ <strong>cat /etc/hostname.fxp0</strong>
inet 10.0.0.38 255.255.255.0 NONE
</pre></blockquote>

<p>
You could also specify media types for Ethernet, say, if you wanted to
force 100baseTX full-duplex mode.

<blockquote><pre>
inet 10.0.0.38 255.255.255.0 NONE media 100baseTX mediaopt full-duplex
</pre></blockquote>

<p>
(Of course, you should never force full duplex mode unless both sides of
the connection are set to do this! In the absence of special needs,
media settings should be excluded.)

<p>
Or, you may want to use special flags specific to a certain interface.
The format of the hostname file doesn't change much!

<blockquote><pre>
$ <strong>cat /etc/hostname.vlan0</strong>
inet 172.21.0.0 255.255.255.0 NONE vlan 2 vlandev fxp1
</pre></blockquote>

<p>
The next step from here is to setup your default gateway. To do this, simply put
the IP of your gateway in the file <i>/etc/mygate</i>. This will allow
for your gateway to be set upon boot. From here you should setup your
nameservers, and your <i>/etc/hosts</i> file (see the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hosts&amp;sektion=5">hosts(5)</a>
man page). To setup your nameservers, you will create a file called
<i>/etc/resolv.conf</i>. You can read more about the format of this file
in the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&amp;sektion=5">resolv.conf(5)</a>
man page. But for a standard usage, here is an example. In this example
your domain servers are 125.2.3.4 and 125.2.3.5. You also belong in the
domain &quot;example.com&quot;.

<blockquote><pre>
$ <strong>cat /etc/resolv.conf</strong>
search example.com
nameserver 125.2.3.4
nameserver 125.2.3.5
lookup file bind
</pre></blockquote>

<p>
From here, you can either reboot or run the
<strong>/etc/netstart</strong> script. You can do this by simply typing
(as root):

<blockquote><pre>
# <strong>sh /etc/netstart</strong>
writing to routing socket: File exists
add net 127: gateway 127.0.0.1: File exists
writing to routing socket: File exists
add net 224.0.0.0: gateway 127.0.0.1: File exists
</pre></blockquote>

<p>
Notice that a few errors were produced.  By running this script, you are
reconfiguring things which are already configured.  As such, some routes
already exist in the kernel routing table.  From here your system should
be up and running. Again, you can check to make sure that your interface
was setup correctly with
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>.
You can also check your routes via
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&amp;sektion=1">netstat(1)</a>
or <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=route&amp;sektion=8">route(8)</a>.
If you are having routing problems, you may want to use the -n flag
to route(8) which prints the IP addresses rather than doing a DNS
lookup and displaying the hostname.
Here is an example of viewing your routing tables using both programs.

<blockquote><pre>
$ <strong>netstat -rn</strong>
Routing tables

Internet:
Destination        Gateway            Flags     Refs     Use    Mtu  Interface
default            10.0.0.1           UGS         0       86      -  fxp0
127/8              127.0.0.1          UGRS        0        0      -  lo0
127.0.0.1          127.0.0.1          UH          0        0      -  lo0
10.0.0/24          link#1             UC          0        0      -  fxp0
10.0.0.1           aa:0:4:0:81:d      UHL         1        0      -  fxp0
10.0.0.38          127.0.0.1          UGHS        0        0      -  lo0
224/4              127.0.0.1          URS         0        0      -  lo0

Encap:
Source             Port  Destination        Port  Proto SA(Address/SPI/Proto)

$ <strong>route show</strong>
Routing tables

Internet:
Destination      Gateway            Flags
default          10.0.0.1           UG
127.0.0.0        LOCALHOST          UG
localhost        LOCALHOST          UH
10.0.0.0         link#1             U
10.0.0.1         aa:0:4:0:81:d      UH
10.0.0.38        LOCALHOST          UGH
BASE-ADDRESS.MCA LOCALHOST          U
</pre></blockquote>

<p>
<a name="Setup.2"></a>
<a name="6.1.2"></a>
<h3>6.1.2 - Setting up your OpenBSD box as a Gateway</h3>

<p>
This is the basic information you need to set up your OpenBSD box as a
gateway (also called a router). If you are using OpenBSD as a router on
the Internet, we suggest that you also read the Packet Filter setup
instructions below to block potentially malicious traffic. Also, due to
the low availability of
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4">IPv4</a>
addresses from network service providers and regional registries, you may
want to look at Network Address Translation for information on
conserving your IP address space.

<p>
The GENERIC kernel already has the ability to allow IP Forwarding, but
needs to be turned on. You should do this using the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
utility. To change this permanently you should edit the file 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5">/etc/sysctl.conf</a>
to allow for IP Forwarding. To do so add this line in that configuration
file.

<blockquote><pre>
net.inet.ip.forwarding=1
</pre></blockquote>

<p>
To make this change without rebooting you would use the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
utility directly. Remember though that this change will no longer exist
after a reboot, and needs to be run as root.

<blockquote><pre>
# <strong>sysctl -w net.inet.ip.forwarding=1</strong>
net.inet.ip.forwarding: 0 -&gt; 1
</pre></blockquote>

<p>
Now modify the routes on the other hosts on both sides.  There are many
possible uses of OpenBSD as a router, using software such as
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=routed&amp;sektion=8">routed(8)</a>,
<a href="http://www.gated.org">gated</a>, <a href="http://www.mrtd.net">mrtd</a>,
and <a href="http://www.zebra.org">zebra</a>.  OpenBSD has support in
the ports collection for zebra, gated and mrtd.  OpenBSD supports
several T1, HSSI, ATM, FDDI, Ethernet, and serial (PPP/SLIP) interfaces.

<p>
<a name="Setup.3"></a>
<a name="6.1.3"></a>
<h3>6.1.3 - Setting up aliases on an interface</h3>

<p>
OpenBSD has a simple mechanism for setting up ip aliases on an
interface. To do this simply edit the file
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5"><i>/etc/hostname.&lt;if&gt;</i></a>.
This file is read upon boot by the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&amp;sektion=8">/etc/rc(8)</a>
script, which is part of the <a href="faq10.html#rc">rc startup
hierarchy</a>.  For the example, we assume that the user has an
interface <b>dc0</b> and is on the network 192.168.0.0. Other important
information:

<ul>
<li>IP for dc0 is 192.168.0.2
<li>NETMASK is 255.255.255.0
</ul>

<p>
A few side notes about aliases. In OpenBSD you use the interface name
only. There is no difference between the first alias and the second
alias. Unlike some other operating systems, OpenBSD doesn't refer to
them as dc0:0, dc0:1.  If you are referring to a specific aliased IP
address with ifconfig, or adding an alias, be sure to say "<tt>ifconfig
int alias</tt>" instead of just "<tt>ifconfig int</tt>" at the command
line.  You can delete aliases with "<tt>ifconfig int delete</tt>".

<p>
Assuming you are using multiple IP addresses which are in the same IP
subnet with aliases, your netmask setting for each alias becomes
255.255.255.255.  They do not need to follow the netmask of the first IP
bound to the interface.  In this example, <i>/etc/hostname.dc0</i>, two
aliases are added to the device dc0, which, by the way, was configured
as 192.168.0.2 netmask 255.255.255.0.

<blockquote><pre>
# <b>cat /etc/hostname.dc0</b>
inet 192.168.0.2 255.255.255.0 media 100baseTX
inet alias 192.168.0.3 255.255.255.255
inet alias 192.168.0.4 255.255.255.255
</pre></blockquote>

<p>
Once you've made this file, it just takes a reboot for it to take
effect. You can, however, bring up the aliases by hand using the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
utility. To bring up the first alias you would use the command:

<blockquote><pre>
# <b>ifconfig dc0 inet alias 192.168.0.3 netmask 255.255.255.255</b>
</pre></blockquote>

<p>
To view these aliases you must use the command:

<blockquote><pre>
$ <b>ifconfig -A</b>
dc0: flags=8863&lt;UP,BROADCAST,NOTRAILERS,RUNNING,SIMPLEX,MULTICAST&gt;
        media: Ethernet manual
        inet 192.168.0.2  netmask 0xffffff00 broadcast 192.168.0.255
        inet 192.168.0.3 netmask 0xffffffff broadcast 192.168.0.3
</pre></blockquote>


<p>
<a name="6.2"></a>
<a name="PF"></a>
<h2>6.2 - Packet Filter (PF)</h2>
<!-- XXXrelease -->

<p>
The Packet Filter subsystem, which was introduced in OpenBSD 3.0,
performs two tasks: dealing with packet level forwarding permissions,
and mapping hosts/subnets to a range of external addresses.
The configuration file for this service is
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+3.3">/etc/pf.conf(5)</a></i>. 

<p>
(Note: in OpenBSD 3.0 and 3.1 there was an additional configuration file,
<i>/etc/nat.conf</i>.
Its functions are now incorporated into <i>/etc/pf.conf</i>.)

<p>
The
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5"><i>/etc/pf.conf(5)</i></a>
file has four parts:

<ul>
<li><b>Options:</b> Various options to control how PF works.
<li><b>Scrub:</b> Reprocessing packets to normalize and defragment
  them.
<li><b><a href="#NAT">NAT and Redirection Rules:</a></b> NAT allows many machines to access
  the Internet through one IP address.  Redirection allows incoming
  requests to be forwarded to a particular machine behind the NAT.
<li><b>Filter Rules:</b> Allows the selective filtering or blocking
  of packets as they pass through any of the interfaces.
</ul>

None of these sections are required to exist, but those that do must 
be in the above order.

<p>
To start these services with your system, you need to edit
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&amp;sektion=8">/etc/rc.conf(8)</a></i>
and set the line to:

<blockquote><pre>
pf=YES
</pre></blockquote>

<p>
If you are using NAT, you will most likely also need to set
the <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
value <tt>net.inet.ip.forwarding</tt> to 1. You can do this by
uncommenting the relevant lines in 
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5">/etc/sysctl.conf(5)</a></i>
and rebooting your computer.

<p>
If you have Packet Filter compiled into your kernel, but you
don't have it turned on in your
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&amp;sektion=8">/etc/rc.conf(8)</a></i>
file, you can still activate it with the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pfctl&amp;sektion=8&amp;manpath=OpenBSD+3.3">pfctl(8)</a> command.

<blockquote><pre>
# <b>pfctl -f /etc/pf.conf</b>
# <b>pfctl -e</b>
</pre></blockquote>

<p>
The first line sets up filtering and NAT, using <i>/etc/pf.conf</i> and
the second line activates PF.

<p>
This can also be combined into one command line:

<blockquote><pre>
# <strong>pfctl -f /etc/pf.conf -e</strong>
</pre></blockquote>

<p>
If you make changes to <i>/etc/pf.conf</i> after 
PF is started, you can reload your rules by reloading the 
file:

<blockquote><pre>
# <b>pfctl -f /etc/pf.conf</b>
</pre></blockquote>

<p>
This document will cover some basic 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+3.3">pf.conf(5)</a>
configurations below.  You can also look at the <a href="#sample_pf.conf">resulting 
ruleset</a> that includes all the tweaks explained below in more detail.
You can find other Packet Filter information
at the <a href="http://www.benzedrine.cx/pf.html">Packet Filter web site</a> 
and in the 
<a href="http://www.inebriated.demon.nl/pf-howto/">Packet Filter HOWTO</a>. 

<p>
<h3>Packet Filter</h3>

<p>
In order to enable Packet Filter at boot, you will need to 
modify <i>/etc/rc.conf</i> so that it reads <tt>pf=YES</tt>.  Packet Filter (pf)
is controlled by <i>/etc/pf.conf</i>, which is read at boot. For a 
more detailed explanation, see 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+3.3">pf.conf(5)</a>. 
In the examples that follow, <tt>fxp0</tt> will represent the external 
interface to the internet. It will be different for you, 
based on the ethernet adapter present in your computer. These 
rules will assume full-time internet connectivity, such as 
you would see on a webserver.

<p>
Packet Filter rules are processed sequentially from top to bottom; 
it helps to visualize each packet having to traverse every 
rule before it reaches its destination.

<p>
For example, the default ruleset provided allows all packets 
to travel in, and all packets to travel out:

<blockquote><pre>
pass out all 
pass in all
</pre></blockquote>

<p>
This is shorthand, for:

<blockquote><pre>
pass in from any to any
pass out from any to any
</pre></blockquote>

<p>
which can be read as &quot;pass incoming packets from any source to 
any destination&quot;, with an implied &quot;on any interface (which is 
always implied if a specific interface isn't specified) of any
address family, <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inet&amp;sektion=4">inet (v4)</a> or <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inet6&amp;sektion=4">inet6 (v6)</a>&quot;.

<p>
Obviously, this isn't much of a filter.  More useful filtering
will be based on the address family (IPv4 or IPv6), protocol(s) 
and port(s) used by the services
you wish to filter.  Any of the protocols listed in
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=protocols&amp;sektion=5">/etc/protocols(5)</a></i>
can be specified, by either name or number, but we will
concern ourselves with
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcp&amp;sektion=4">tcp(4)</a>,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=udp&amp;sektion=4">udp(4)</a> and
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp&amp;sektion=4">icmp(4)</a>.

<p>
Now let's say we don't want to allow any incoming IPv4 connections to 
TCP port 3306 (MySQL) because the database should only be connected 
to from localhost. Our ruleset would look like this:

<blockquote><pre>
pass out all
pass in all
block in on fxp0 inet proto tcp from any to any port 3306
</pre></blockquote>

<p>
This says &quot;block in all IPv4 (inet) incoming packets, from 
any source to 
any destination bound for tcp port 3306.&quot;  Note that 
it is required that you specify a protocol with any port-based
filter, and recommended that you specify the address family.  
For services defined in the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=services&amp;sektion=5">/etc/services(5)</a>
file, you can also use the service names, such as <em>www</em>
or <em>mysql</em>.
A packet destined for tcp port 3306 on interface 
<tt>fxp0</tt> will pass the first &quot;pass in&quot; rule and then 
be dropped by the &quot;block 
in port 3306&quot; rule. If you reversed the order of our 
incoming rules (remember, order is important):

<blockquote><pre>
pass out all
block in on fxp0 inet proto tcp from any to any port 3306
pass in all
</pre></blockquote>

<p>
Packets destined for tcp port 3306 would pass because the last rule 
in the set allows all packets to pass. It is important to keep 
this in mind when writing packet filter rules:
<b>The last matching rule wins</b>.

<p>
Of course, there are exceptions to every rule. The <em>quick</em> 
option drops the packet at the first rule that matches. Let's 
look at our above flawed example, if we add <em>quick</em> to 
the &quot;block in&quot; rule:

<blockquote><pre>
pass out all
block in quick on fxp0 inet proto tcp from any to any port 3306
pass in all
</pre></blockquote>

<p>
A packet destined for our host on tcp port 3306 will hit the 
&quot;block in quick&quot; rule and be dropped immediately. All 
packets destined for other ports or protocols won't find a rule match until 
they reach our &quot;pass in&quot; rule that allows all packets 
to pass.

<p>
<b>Default Deny</b>
<p>
The safest packet filtering policy is a default deny policy. 
All traffic not explicitly allowed is denied. This policy is far 
safer than explicitly denying each protected service, allows for 
smaller rulesets, and can protect from an accidentally 
misconfigured service that has been left exposed.

<p>
Let's now look at another example ruleset and explain 
things line by line. Here's an example for a webserver with a 
default deny policy that only allows ssh connections (for 
administration) and connections to http (port 80) and https 
(port 443).

<blockquote><pre>
block in on fxp0 all
pass  in on fxp0 inet proto tcp from any to any port 22
pass  in on fxp0 inet proto tcp from any to any port 80
pass  in on fxp0 inet proto tcp from any to any port 443
pass out on fxp0 all
</pre></blockquote>

<p>
This will allow incoming connections from anywhere to tcp ports 
22(ssh), 80(http), and 443(https). It will drop all other 
connection attempts, and allow all outgoing connections. This 
is a pretty tight ruleset.  But what if you only wanted to 
allow internal hosts on your 1.1.1.0 address block to connect 
to ssh, but allow outside connections to http and https?

<blockquote><pre>
block in on fxp0 all
pass  in on fxp0 inet proto tcp from 1.1.1.0/24 to any port 22
pass  in on fxp0 inet proto tcp from any to any port 80
pass  in on fxp0 inet proto tcp from any to any port 443
pass out on fxp0 all
</pre></blockquote>

<p>
Pretty good, but what if we only want to allow one machine 
(1.1.1.1) to administer the web server remotely?
In that case, we can change this:

<blockquote><pre>
pass  in on fxp0 inet proto tcp from 1.1.1.0/24 to any port 22
</pre></blockquote>

<p>
to this:

<blockquote><pre>
pass  in on fxp0 inet proto tcp from 1.1.1.1/32 to any port 22
</pre></blockquote>

<p>
<b>Sample Rules</b>
<p>
Here are some good rules for everyone to use (assuming that 
fxp0 is the external internet-connected interface). First we 
will set up a simple address spoofing protection.  These addresses
shouldn't (normally) be floating around the Internet, 
and if they are, it is rarely good, so we block them:

<blockquote><pre>
block in quick on fxp0 inet from { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 } to any
block out quick on fxp0 inet from any to { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 }
</pre></blockquote>

<p>
Our ruleset is starting to look pretty good; when we put 
it together, here is what it looks like:

<blockquote><pre>
# don't allow anyone to spoof non-routeable addresses
block in quick on fxp0 inet from { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 } to any
block out quick on fxp0 inet from any to { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 }

# only allow our administration machine to connect via ssh
pass in quick on fxp0 inet proto tcp from 1.1.1.1/32 to any port 22

# allow others to use http and https
pass in quick on fxp0 inet proto tcp from any to any port 80
pass in quick on fxp0 inet proto tcp from any to any port 443

# finally lock the rest down with a default deny
block in quick on fxp0 from any to any

# and let out-going traffic out
pass out on fxp0 from any to any
</pre></blockquote>

<p>
<b>Packet Logging</b>
<p>
Now that's pretty good, but it could be better. What if we want to 
log any connection attempts to port 22(ssh) that get blocked by 
our firewall? Easy, Packet Filter can handle this with the <em>log</em> keyword:

<blockquote><pre>
pass in quick on fxp0 inet proto tcp from 1.1.1.1/32 to any port 22
block in log quick on fxp0 inet proto tcp from any to any port 22
</pre></blockquote>

<p>
This rule will allow our remote administration machine to connect 
to port 22, but deny and log all other attempts to connect to 
port 22.

<p>
Logged packets are sent to the pflog0 interface, which is monitored
by 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+3.3">pflogd(8)</a>,
which typically dumps the packets to <i>/var/log/pflog</i> in 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcpdump&amp;sektion=8&amp;manpath=OpenBSD+3.3">tcpdump(8)</a>
binary format.  pflogd(8) is started by default by
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&amp;sektion=8">/etc/rc(8)</a></i>
if pf is enabled in
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&amp;sektion=8">/etc/rc.conf(8)</a></i>.
You can read these log files using the following command:

<blockquote><pre>
# <b>tcpdump -n -e -ttt -r /var/log/pflog</b>
</pre></blockquote>

<p>
One should be aware that using tcpdump to watch the pflog file does 
NOT give a real-time display.  If you wish a real-time display, you 
can use this command:

<blockquote><pre>
# <b>tcpdump -i pflog0</b>
</pre></blockquote>

<p>
One could also use tcpdump to narrow down the focus to facilitate
debugging:

<blockquote><pre>
# <b>tcpdump -e -i pflog0 port 80</b>
</pre></blockquote>

<p>
Doing this does NOT impact the data that is put to the file 
<i>/var/log/pflog</i>.  

<p>
When examining one's logs, especial care should be taken
with tcpdump's verbose protocol decoding (activated via the -v command
line option).  Tcpdump's protocol decoders do not have a perfect
security history.  At least in theory, a delayed attack could be
possible via the partial packet payloads recorded by the logging
device.

<p>
Additional care should be taken about access to the logs.  Pflogd
will capture 96 bytes of the packet and log it.  Access to the logs
could provide partial access to sensitive packet payloads (like
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=telnet&amp;sektion=1">telnet(1)</a> or
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftp&amp;sektion=1">ftp(1)</a> logins).

<p>
<b>Packet Logging through syslog</b>
<p>
In many situations it is desirable to have the firewall logs available
in ASCII format and/or to send them to a remote logging server.
All this can be accomplished with 2 small shell scripts and with minor changes
of the OpenBSD configuration files.

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=syslogd&amp;sektion=8&amp;manpath=OpenBSD+3.3">Syslogd(8)</a>
is the standard daemon for logging, it logs in ASCII and is also able
to log to a remote logging server.

<p>
First we have to create a user <em>pflogger</em> with a .nologin. shell.
The easiest way to create this user is with
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=adduser&amp;sektion=8&amp;manpath=OpenBSD+3.3">adduser(8)</a>.

<p>
After creating the user <em>pflogger</em> create the following two scripts:

<p>
<i>/etc/pflogrotate</i>

<blockquote><pre>
FILE=/home/pflogger/pflog5min.$(date "+%Y%m%d%H%M")
kill -ALRM $(cat /var/run/pflogd.pid)
if [ $(ls -l /var/log/pflog | cut -d " " -f 8) -gt 24 ]; then
        mv /var/log/pflog $FILE
        chown pflogger $FILE
        kill -HUP $(cat /var/run/pflogd.pid)
fi
</pre></blockquote>


<p>
<i>/home/pflogger/pfl2sysl</i>

<blockquote><pre>
#!/bin/sh
# feed rotated pflog file(s) to syslog
for logfile in /home/pflogger/pflog5min* ; do
        tcpdump -n -e -ttt -r $logfile | logger -t pf -p local0.info
        rm $logfile
done
</pre></blockquote>

<p>
Edit the cron job for user <em>root</em>

<blockquote><pre>
# <b>crontab -u root -e</b>
</pre></blockquote>

<p>
and add the following two lines:

<blockquote><pre>
# rotate pf log file every 5 minutes
0-59/5 *       *       *       *       /bin/sh /etc/pflogrotate
</pre></blockquote>

<p>
Create a cron job for user <em>pflogger</em>

<blockquote><pre>
# <b>crontab -u pflogger -e</b>
</pre></blockquote>

<p>
and add the following two lines:

<blockquote><pre>
# feed rotated pflog file(s) to syslog
0-59/5 *       *       *       *       /bin/sh /home/pflogger/pfl2sysl
</pre></blockquote>

<p>
Add the following line to <i>/etc/syslog.conf</i>:

<blockquote><pre>
local0.info    /var/log/pflog.txt
</pre></blockquote>

<p>
If you want to log to a remote log server also add the line:

<blockquote><pre>
local0.info    @syslogger
</pre></blockquote>

<p>
and make sure host <i>syslogger</i> has been defined in the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hosts&amp;sektion=5&amp;manpath=OpenBSD+3.3">
/etc/hosts(5)</a> file.

<p>
All logged packets are sent to <i>/var/log/pflog.txt</i>.
If the second line is added too they are sent to the remote logging host
<i>syslogger</i> as well.

<p>
<i>/etc/pflogrotate</i> now processes and then deletes <i>/var/log/pflog</i>
so rotation of <i>pflog</i> by
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newsyslog&amp;sektion=8&amp;manpath=OpenBSD+3.3">
newsyslogd(8)</a> is no longer necessary and it should be
disabled. However <i>/var/log/pflog.txt</i> replaces <i>/var/log/pflog</i> and rotation of it
should be activated.
Change <i>/etc/newsyslog.conf</i> as follows:

<blockquote><pre>
#/var/log/pflog        600     3       250     *       ZB      /var/run/pflogd.pid
/var/log/pflog.txt     600     7       *       24
</pre></blockquote>

<p>
Pf will now log in ASCII to /var/log/pflog.txt. If so configured in
<em>/etc/syslog.conf</em> it will also log to a remote server.
The logging is not immediate but
it can take up to about 5-6 minutes (the cron job interval) before the logged
packets appear in the file.

<p>
<b>Multiple Protocols</b>
<p>
What if we need to allow connections to a service running 
over multiple protocols, such as bind, which uses TCP and UDP? 
Packet filter lets you lump options together into sets  
(more on this later): 

<blockquote><pre>
# Pass DNS traffic for BIND
pass in quick on fxp0 inet proto { tcp, udp } from any to any port 53
</pre></blockquote>

<p>
Notice the spaces on both sides of the '{ }' characters.  This is 
neater than the alternative you might otherwise have to use:

<blockquote><pre>
pass in quick on fxp0 inet proto tcp from any to any port 53
pass in quick on fxp0 inet proto udp from any to any port 53
</pre></blockquote>

<p>
<a name="normalization"></a>
<b> Packet Normalization</b>
<p> 
Packet Normalization means reassembling fragmented packets and clearing IP
options.
Some OSs and applications have trouble with abnormal or fragmented packets,
and it's in general good to have normalized packets for the filter rules to
look at and for the destination hosts to look at.
Thus, it is nearly always beneficial to normalize the
packets before they are passed on to their ultimate destination.
This is done with the <b>scrub</b> directive, used as here:

<blockquote><pre>
scrub in all
</pre></blockquote>

<p>
This does put a very minor additional load on the system, and requires a bit of
memory to cache the packet fragments. The advantages of packet normalization
almost always outweigh this cost.

<p>
<b>IP Options</b>
<p>
By default, PF blocks packets with IP options set.  This can make
the job more difficult for &quot;OS fingerprinting&quot; utilities
like nmap.  If you have an application that requires the passing of 
these packets, such as multicast or IGMP, you can use the 
<b>allow-opts</b>
directive:

<blockquote><pre>
pass in quick on fxp0 all allow-opts
</pre></blockquote>

<p>
<b>TCP Flags, established connections and keeping state</b>
<p>
Packet Filter can also filter packets based on TCP flags and 
maintain established connections and connection state. It is 
recommend that all users who wish to filter packets based on 
TCP flags understand what role each flag plays. For instance, 
if you wanted to deny all packets with the FIN, URG, and PSH 
flags set (like for instance an nmap OS fingerprinting attempt) 
you could use a rule like this:

<blockquote><pre>
block in quick on fxp0 inet proto tcp from any to any flags FUP/FUP
</pre></blockquote>

<p>
(Thanks to <a href="mailto:halogen@nol.net">Kyle Hargraves</a> for that tip)

<p>
Packet Filter's next cool trick is its ability to maintain state. 
Maintaining state has been described as &quot;not speaking until 
spoken to&quot;; in other words, once a connection is established, 
packets no longer have to traverse rulesets. This is a very 
powerful feature allowing much simpler and more secure rule 
writing.

<p>
For example, let's see how we can apply state to our previous 
example ruleset (confused yet?). To review, we are allowing 
management access from our Class C to port 22(ssh) and allowing 
all incoming web traffic on ports 80(http) and 443(https). We 
are blocking all other traffic. But, what if I want to
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh&amp;sektion=1">ssh(1)</a>
out of the webserver? What if I need to use
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lynx&amp;sektion=1">lynx(1)</a> to look up 
something in the FAQ? Well, I can't because I have blocked all 
incoming connections other than those on the specified ports. While 
this is the safest route, it can be quite inconvenient. By 
adding the <em>keep state</em> keywords to our &quot;pass 
out&quot; rule, we can automatically allow incoming 
packets in response to connections we initiate, such as 
when web browsing.  Remember, we do need to specify what 
protocol we are keeping state for.

<blockquote><pre>
block in  on fxp0 inet proto tcp all
pass  in  on fxp0 inet proto tcp from 1.1.1.0/24 to any port 22 keep state
pass  in  on fxp0 inet proto tcp from any to any port 80 keep state
pass  in  on fxp0 inet proto tcp from any to any port 443 keep state
pass  out on fxp0 inet proto tcp all keep state
</pre></blockquote>

<p>
This little change will dramatically increase the flexibility and
security of our ruleset: for instance, in the above ruleset, we are
allowing all tcp traffic into ports 80 &amp; 443. We can tighten this up
even more. In order for a tcp connection to be established, we only need
to allow the initial handshake to occur; once that occurs, we can block
traffic to that port and allow our &quot;keep state&quot; rule to manage
the connection. To allow the initial handshake to complete, we need only
allow packets with the SYN flag set and ACK flag not set. By passing only 
packets with SYN set, we can prevent many forms of portscanning such
as FIN scanning. flags S/SA means: out of flags S (SYN) and A (ACK), only
SYN may be set. Other flags aren't investigated.
The rules now look like this:

<blockquote><pre>
block in  on fxp0 inet proto tcp all
pass  in  on fxp0 inet proto tcp from 1.1.1.0/24 to any port 22 \
	flags S/SA keep state
pass  in  on fxp0 inet proto tcp from any to any port 80 \
	flags S/SA keep state
pass  in  on fxp0 inet proto tcp from any to any port 443 \
	flags S/SA keep state
block out on fxp0 inet proto tcp all
pass  out on fxp0 inet proto tcp all flags S/SA keep state
</pre></blockquote>

<p>
Let's start to tie things together by putting all of the rules we 
have so far into a ruleset. This ruleset will support IPv4, have 
a default deny policy, allow management connections from an 
internal network only (via ssh) and allow incoming traffic on 
ports 80(http) and 443(https). It will also protect against 
spoofed non-routeable ip addresses, and drop all packets that are 
too fragmented to inspect. A pretty comprehensive setup for a public 
webserver. Here's what <i>/etc/pf.conf</i> could look like:

<blockquote><pre>
# Clean up fragmented and abnormal packets
scrub in all

# don't allow anyone to spoof non-routeable addresses
block in quick on fxp0 inet from { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 } to any
block out quick on fxp0 inet from any to { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 }

# by default, block all incoming packets, except those explicitly
# allowed by further rules
block in on fxp0 all

# allow others to use http and https
pass in on fxp0 inet proto tcp from any to any port 80 \
	flags S/SA keep state
pass in on fxp0 inet proto tcp from any to any port 443 \
	flags S/SA keep state

# and let out-going traffic out and maintain state on established connections
# pass out all protocols, including TCP, UDP and ICMP, and create state,
# so that external DNS servers can reply to our own DNS requests (UDP).
block out on fxp0                 all
pass  out on fxp0 inet proto tcp  all flags S/SA keep state
pass  out on fxp0 inet proto udp  all            keep state
pass  out on fxp0 inet proto icmp all            keep state
</pre></blockquote>

<p>
While this may look good, there are some things Packet Filter 
will let you do to make your <i>pf.conf</i> file look neater and easier
to maintain.

<p>
<b>Sets</b>
<p>
Sets are useful "shortcuts" for writing simple and clear 
rules in PF.  For example, what if we need to allow 
connections to a service running
over multiple protocols, such as BIND, which uses TCP and UDP?

<blockquote><pre>
pass in quick on fxp0 inet proto { tcp, udp } from any to any port 53
</pre></blockquote>

<p>
Note the spaces on both sides of the '{ }' characters. 

<p>
Groups of related IPs can be clustered together into sets, which 
can be used anywhere a single IP could be used.  For example, 
looking at our anti-spoofing rules above:

<blockquote><pre>
# don't allow anyone to spoof non-routeable addresses
block in quick on fxp0 inet from { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 } to any
block out quick on fxp0 inet from any to { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 }
</pre></blockquote>

<p>
<b>Variable Expansion</b>
<p>
One problem with the above sample <i>pf.conf</i> file is that should
you need to change your NIC, or change an IP address, you would
need to change a number of lines.  This can be lessened by using
variable expansion:

<blockquote><pre>
NoRouteIPs="{ 127.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, 10.0.0.0/8 }"
ExtIF="fxp0"
block in quick on $ExtIF from $NoRouteIPs to any
block out quick on $ExtIF from any to $NoRouteIPs
</pre></blockquote>

<p>
<a name="sample_pf.conf"></a>
<b>Putting it all together</b>
<p>
Now, let's put it all together, and look at the elegance of the file:

<blockquote><pre>
# Define useful variables
ExtIF="fxp0"              # External Interface
IntNet="1.1.1.0/24"       # Our internal network
NoRouteIPs="{ 127.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, 10.0.0.0/8 }"
Services="{ www, https }"

# Clean up fragmented and abnormal packets
scrub in all

# don't allow anyone to spoof non-routeable addresses
block in  quick on $ExtIF from $NoRouteIPs to any
block out quick on $ExtIF from any to $NoRouteIPs

# by default, block all incoming packets, except those explicitly
# allowed by further rules
block in on $ExtIF all

# allow others to use http and https
pass  in on $ExtIF inet proto tcp from any to any port $Services \
	flags S/SA keep state

# and let out-going traffic out and maintain state on established connections
# pass out all protocols, including TCP, UDP and ICMP, and create state,
# so that external DNS servers can reply to our own DNS requests (UDP).
block out on $ExtIF                 all
pass  out on $ExtIF inet proto tcp  all flags S/SA keep state
pass  out on $ExtIF inet proto udp  all            keep state
pass  out on $ExtIF inet proto icmp all            keep state
</pre></blockquote>

<p>
If you experience problems, you may want to enable logging on 
individual rules to effectively troubleshoot. ie: 

<blockquote><pre>
pass in log quick on fxp0 proto tcp from 1.1.1.0/24 to any port 22
</pre></blockquote>

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&amp;sektion=8&amp;manpath=OpenBSD+3.3">pflogd(8)</a> will write the ip log entries to <i>/var/log/pflog</i>.
Remember that <i>/var/log/pflog</i> is a binary file, intended to be
read by <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcpdump&amp;sektion=8&amp;manpath=OpenBSD+3.3">tcpdump(8)</a>, NOT directly by humans.

<p>
When you modify the configuration file to log packets, don't 
forget to <b>pfctl -R /etc/pf.conf</b> for the changes to take effect! 

<a name="6.3"></a>
<a name="NAT"></a>
<h2>6.3 - NAT</h2>
<!-- XXXrelease -->

<p>
<h4>Note: For OpenBSD 3.2 and later, the NAT functions are incorporated
in the <i>/etc/pf.conf</i> file, not the separate <i>/etc/nat.conf</i>
file used in OpenBSD 3.0 and 3.1</h4>

<p>
<a name="nat1.0"></a>
<h3><u>6.3.1 NAT Introduction</u></h3>

<a name="nat1.1"></a>

<p>
Based on 
<a href="http://www.geektools.com/rfc/rfc1631.txt">RFC 1631</a>, 
NAT provides an easy way to map internal networks to a single 
routeable ("real") internet address. This is very useful if you 
don't have officially assigned addresses for every host on your 
internal network. When you set up private/internal networks, you 
can take advantage of reserved address blocks (assigned in 
<a href="http://www.geektools.com/rfc/rfc1918.txt">RFC 1918</a>), 
such as:

<p>
10.0.0.0/8 (10.0.0.0 - 10.255.255.255)<br>
172.16.0.0/12 (172.16.0.0 - 172.31.255.255)<br>
192.168.0.0/16 (192.168.0.0 - 192.168.255.255)

<p>
The user is assumed to have already set up
and configured an OpenBSD machine with two network cards (one
connected to the Internet and the other to the local network).

<p>
<a name="nat1.3"></a>
<b>Configuration</b>

<p>
For the purpose of example, we will use the system described
below. Your setup will almost certainly vary from this, so be 
very careful in typing anything you see here literally into
your system and expecting it to work as you desire.  

<blockquote>
<b>NICs: </b>
<pre>
Intel EtherExpress Pro/100 <b>fxp0</b>
Connected to the EXTERNAL LAN (or WAN)
<b>IP Address: </b>24.5.0.5
<b>Netmask: </b>255.255.255.0

Compaq Netelligent 10/100Mb <b>tl0</b>
Connected to the INTERNAL LAN
<b>IP Address: </b>192.168.1.1
<b>Netmask: </b>255.255.255.0
</pre>
</blockquote>

<blockquote>
<b>External, Internet-routeable IP (provided by ISP, in this example, a cable modem provider)<br></b>
<pre>
<b>IP Address: </b>24.5.0.5
<b>Netmask: </b>255.255.255.0
<b>Gateway: </b>24.5.0.1
</pre>
</blockquote>

<blockquote>
<b>Local Area Network</b><br>
In this example environment,
machines on the internal network use the IP addressing scheme 192.168.1.xxx
(where xxx is a unique number). There could be a variety of different
operating systems on the internal network, such as Windows 98,
Windows NT, OpenBSD and Linux, but the client OS is not an issue for NAT. 
For the examples, the client we will look at on the internal
network will be assumed to have an IP address of 192.168.1.40.
</blockquote>

<blockquote>
<b>Diagram of Configuration</b>
<pre>
+-----+              +---------+          +----------+
| Hub |--------- tl0 |   NAT   | fxp0 ----| Internet |
+-----+              +---------+          +----------+
| |
| +-- Client A
+---- More clients 

		      +--------------------------+
		      |          LEGEND          |
		      +--------------------------+
		      |  NIC fxp0 - 24.5.0.5     |
		      |  NIC tl0  - 192.168.1.1  |
		      | Client A  - 192.168.1.40 |
		      +--------------------------+

</pre>
</blockquote>

<p>
<a name="nat2.0"></a>
<h3><u>6.3.2 Network Address Translation</u></h3>

<p>
<a name="nat2.1"></a>
<b>Introduction to NAT</b>

<p>
Each node on the Internet requires a unique IP address.  At least
with IPv4, there is a very finite number of distinct IP addresses 
available, and as a result, they are not free.  Most "low-cost" ISPs
will limit a site to anywhere from 1 to 30 addresses, and while 
larger budget organizations may be able to afford a larger block, 
in most cases, there are relatively few benefits and considerable 
risks to having each computer individually addressable on the 
Internet.

<p>
Network Address Translation, or NAT, (also known as &quot;IP Masquerading&quot;
if you are coming from a Linux background) allows multiple computers
to be located &quot;behind&quot; one (or a small number of) IP address.  Each 
&quot;internal&quot; computer has a locally assigned, unregistered
IP address (per <a href="http://www.geektools.com/rfc/rfc1918.txt">RFC 1918</a>), 
and all utilize the same external IP address, simultaneously.  

<p>
The way NAT works is rather simple. When a client on the LAN
wants to connect to a machine on the Internet, it sends out a TCP
packet with a request to connect. Inside the TCP packet header is the
client's IP address (e.g. 192.168.1.40) and the requested host's IP
address (e.g. 123.45.67.89). The machine running NAT intercepts this
TCP packet and changes the client's IP address from 192.168.1.40 to
the IP address of the Internet-connected machine (e.g. 24.5.0.5). This
effectively tricks the host machine into thinking the actual connection
is from the NAT machine, not the actual client's machine. The host then
sends back responses to the NAT machine like it was the one connecting.
When the NAT machine receives the responses it quickly translates the
destination IP address back from itself to the client's machine and
sends the packet to the client. The client normally does not have any 
idea what happened and the apparent Internet connectivity is 
transparent to the user and user's applications.

<p>
The example below shows NAT a little more clearly:

<blockquote><pre>
Client ----------------- tl0 [ NAT ] fxp0 ---------- Internet Host
192.168.1.40 --- 192.168.1.1 [ NAT ] 24.5.0.5 --- 123.45.67.89

OUTGOING TCP Packet                     OUTGOING TCP Packet
From: 192.168.1.40  &gt;&gt;=== NAT ===&gt;&gt;     From: 24.5.0.5
To: 123.45.67.89                        To: 123.45.67.89

INCOMING TCP Packet                     INCOMING TCP Packet
From: 123.45.67.89 			From: 123.45.67.89
To:   192.168.1.40  &lt;&lt;=== NAT ===&lt;&lt;     To: 24.5.0.5
</pre></blockquote>

<p>
<a name="nat2.2"></a>
<b>Why use NAT?</b>

<p>
When presented with a cable modem in my new apartment I was also
presented with another minor problem. How to get Internet access for
my roommates, when the cable modem resides in my room? There were a
few options I could implement, ranging from obtaining extra IP
addresses, to setting up a proxy server, to setting up NAT.
(Don't let the home cable modem example fool you.  NAT is powerful enough
to masquerade a large network with hundreds or even thousands of computers!)

<p>
There are many reasons why I wanted to set up NAT. The number one
reason is to save money. There
are two roommates in my house; splitting the cost is certainly attractive.
Further, as each roommate has their own PC and I have three, we
had five computers to connect, but my ISP only allows for three IP 
addresses per household.  This means that there weren't enough IP 
addresses to allow every machine simultaneous direct Internet access.

<p>
By using NAT each machine will have a unique internal IP address
but share the one IP address given to me by my ISP. The cost goes down.

<p>
<a name="nat2.4"></a>
<b>Setup</b>

<p>
In order to enable NAT on your OpenBSD machine you will need to turn on
PF. This is easily accomplished by editing the files listed
below (make the changes to the file so it looks like the options below):

<p>
<b>/etc/rc.conf</b> (this file used to start services at boot time)

<blockquote><pre>
pf=YES<br>
</pre></blockquote>

<p>
<b>/etc/sysctl.conf</b>

<blockquote><pre>
net.inet.ip.forwarding=1
</pre></blockquote>

<p>
After these changes are made, the machine is now ready for the
configuration of NAT.

<p>
<a name="nat2.5"></a>
<b>Configuration</b>

<p>
The first step is to configure the PF configuration file
(<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+3.3">/etc/pf.conf</a></i>).
For the purposes of this document we will allow traffic to pass
through this firewall without any interference. The file
should look like this:

<blockquote><pre>
pass in all
pass out all
</pre></blockquote>

<p>
Again, for more information you can read <a href="#PF">FAQ 6, Packet Filter</a>

<p>
The NAT portion of the PF configuration file
(<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nat.conf&amp;sektion=5&amp;manpath=OpenBSD+3.3">/etc/pf.conf</a></i>)
has a very simple syntax.
For the configuration set forth above, the file should contain the
following entry:

<blockquote><pre>
nat on fxp0 from 192.168.1.0/24 to any -&gt; 24.5.0.5
</pre></blockquote>

<p>
Here is an explanation for the above lines.

<dl>
<dt>"nat"
<dd>This indicates the command you are giving is a NAT rule.
</dl>

<dl>
<dt>"fxp0"
<dd>This is the network interface that is connected to the Internet.
</dl>

<dl>
<dt>"192.168.1.0/24"
<dd>the IP address and netmask (the netmask is in
CIDR format). Combined they state "any IP address of value
192.168.1.1 through 192.168.1.254" should be mapped. 
</dl>

<dl>
<dt>"24.5.0.5"
<dd>This is the external IP address the internal IP addresses will be mapped to.
</dl>

<p>
<a name="nat2.6"></a>
<b>Running</b>

<p>
Once the configuration is
complete, there are two ways to enable NAT. The first (and best way if
possible) is to reboot your OpenBSD machine.
This is accomplished with the command "<i>reboot</i>". 

<p>
If you would like to configure NAT from the command line, use the following
commands:

<blockquote><pre>
# <b>pfctl -f /etc/pf.conf</b>
# <b>pfctl -e</b>
</pre></blockquote>

<p>
The first line is to load a set of NAT rules into PF (and flushing any
old rules); the second line enables PF.  Again, though, rebooting is
the best way to ensure that everything will startup from a reboot as 
you expect.

<p>
<b>Note:</b> in order to reload the NAT settings (in case you edit the file
but don't want to reboot) just execute the first command over again. The
settings will be flushed and reloaded.

<p>
<a name="nat3.0"></a>
<h3><u>6.3.3 Nat Knowledge Base</u></h3>

<p>
<a name="nat3.1"></a>
<b>Checking NAT Status</b>

<p>
To find out how NAT is doing or make sure the settings have taken
effect, you use the "-ss" option. This option will list all the
current sessions that NAT is running:

<blockquote><pre>
# pfctl -ss
TCP  192.168.1.40:2132 -&gt; 24.5.0.5:53136 -&gt; 65.42.33.245:22       TIME_WAIT:TIME_WAIT
TCP  192.168.1.40:2492 -&gt; 24.5.0.5:55011 -&gt; 65.42.33.245:22       ESTABLISHED:ESTABLISHED
UDP  192.168.1.40:2491 -&gt; 24.5.0.5:60527 -&gt; 24.2.68.33:53       2:1
</pre></blockquote>

<p>
Explanations (first line, others are similar):

<dl>
<dt>"192.168.1.40:2132"
<dd>This tells you the IP address of the
machine on the LAN that is using NAT (192.168.1.40). The port number used to make
the connection (2132) is displayed afterwards.
</dl>

<dl>
<dt>"24.5.0.5:53136"
<dd>This denotes that the connection is going
to the Internet via IP address 24.5.0.5 and using port 53136.
</dl>

<dl>
<dt>"65.42.33.245:22"
<dd>The IP address and the port being connected to.
</dl>

<dl>
<dt>"TIME_WAIT:TIME_WAIT"
<dd>This indicates what state PF believes the TCP connection to be in.
</dl>

<p>
<a name="nat3.2"></a>
<b>Issues with FTP and NAT</b>

<p>
There are a few limitations of NAT; the most commonly encountered is
with FTP. You can use FTP in two ways: passive and active. Of these,
passive FTP is generally considered more secure.

<p>
With active FTP, when a user connects to a remote FTP server and
requests information or a file, the FTP client sends the server a random
port number that the FTP server will make a connection to on the
client and transfer the info. This is a problem for users attempting
to gain access to FTP servers from within the LAN. When the FTP server
sends its information it sends it to the external NIC at a random port.
The NAT machine will receive this, but because it has no mappings for
the unknown packet and doesn't have any mappings for that port, it will
drop the packet and won't deliver it.

<p>
With passive mode FTP (the default with OpenBSD <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftp&amp;sektion=1">ftp(1)</a>
client), the client requests that the server picks up a random port
that it will listen on for the data connection. The server informs the
client of the port it has chosen, and the client connects to this port
to transfer the data. Unfortunately, this is not always possible or
desirable. ftp(1) uses this mode by default; to force active mode FTP,
use the -A flag to ftp, or set the passive mode to off by issuing
the command

<blockquote><pre>
passive off
</pre></blockquote>

<p>
at the ftp&gt; prompt.

<p>
Packet Filter provides another solution for this situation, redirecting 
FTP traffic through an FTP proxy server, a process which acts to "guide" your 
FTP traffic through the filters.  The FTP proxy used by OpenBSD and PF is 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftp-proxy&amp;sektion=8&amp;manpath=OpenBSD+3.3">ftp-proxy(8)</a>.
To activate it, put something like this in your <i>/etc/pf.conf</i> file:

<blockquote><pre>
rdr on tl0 proto tcp from any to any port 21 -&gt; 127.0.0.1 port 8021
</pre></blockquote>

<p>
Short explanation of this line is, "TCP port 21 traffic on the internal
interface is redirected to the proxy server running on this machine
which is listening at port 8021".

<p>
Hopefully, it is apparent the proxy server has to be started and running on 
the OpenBSD box; this is done by inserting the following line in
<i>/etc/inetd.conf</i>:

<blockquote><pre>
127.0.0.1:8021 stream tcp nowait root /usr/libexec/ftp-proxy ftp-proxy
</pre></blockquote>

<p>
and either rebooting the system or sending a 'HUP' signal to
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inetd&amp;sektion=8">inetd(8)</a>.
One way to send the 'HUP' signal is with the command:

<blockquote><pre>
kill -HUP `cat /var/run/inetd.pid`
</pre></blockquote>

<p>
You will note that ftp-proxy is listening on port 8021, the same port the above 
rdr statement was sending FTP traffic to.  The choice of port 8021 is arbitrary,
though 8021 is a good choice, as it is not defined for any other application.

<p>
<a name="nat3.3"></a>
<b>Redirecting Traffic</b>

<p>
For some applications, you may need to redirect incoming or outgoing 
traffic for a certain protocol and/or port to a particular machine behind
the filtering system. An example of this would be a computer residing inside 
the local network running a web server which was to be accessed by the outside world
(or of course, the already discussed ftp-proxy(8)). Incoming connections to 
your valid Internet IP will find that unless your NAT box is also running
a web server, no connection can be made. For this purpose we use the
NAT 'rdr' directive in the rules file to instruct where to redirect
a particular connection to.

<p>
For our example, lets say a web server resides on the LAN with IP address
of 192.168.1.80. The NAT rules file needs a new directive to handle this.
Add a line similar to the following one to your <i>/etc/pf.conf</i>:

<blockquote><pre>
rdr on fxp0 proto tcp from any to any port 80 -&gt; 192.168.1.80 port 80
</pre></blockquote>

<p>
The explanation for each part of this line:

<dl>
<dt>"rdr"
<dd>This is the command you are giving NAT. It is telling NAT 
that this entry is an entry to redirect a connection. 
</dl>

<dl>
<dt>"on fxp0"
<dd>This is the network interface that is connected to the Internet.
</dl>

<dl>
<dt>"from any to any"
<dd>This indicates which IP addresses to redirect (from any coming in 
on fxp0, as indicated above, to any destination IP) 
</dl>

<dl>
<dt>"port 80"
<dd>This is the incoming port (80) that should be redirected. The number
"80" didn't have to be used. You can use "port www" also to specify
a redirection of port 80. If you would like to use a name instead of
a number, the service name and corresponding port must exist in the
file <i>/etc/services</i>.
</dl>

<dl>
<dt>"192.168.1.80 port 80"
<dd>The IP address of the LAN machine which the packets are redirected to. 
Note that the destination port does NOT need to match the incoming port. 
For example, the following is valid, and even potentially useful:
<pre>
rdr on fxp0 proto tcp from any to any port 8080 -&gt; 192.168.1.35 port 80
</pre>
This line would redirect incoming traffic on port 8080 to a webserver
running on a machine in the internal network, at the "standard" port 80.
</dl>

<p>
When the addition is complete reload the NAT rules, and the redirection
will start immediately.

<p>
<b>Negation</b>
<p>
Sometimes, you need to make exceptions to a NAT or redirection rule.
Here's an example.  AOL Instant Messenger is noted for sneaking out 
firewalls through any available port.  You may find that the 
ftp-proxy is interfering with AIM when it chooses to go out to 
remote port 21.  In the event you consider this bad (many people 
spend considerable time trying to block AIM!), you might wish to 
exclude the IP addresses used by the AIM servers from the traffic
redirected by our above ftp-proxy line.  You can do this with the
following line:

<blockquote><pre>
rdr on tl0 proto tcp from any to ! 64.12.163.199 port 21 -&gt; 127.0.0.1 port 8021
</pre></blockquote>

<p>
Interpretation: Redirect traffic coming in on tl0 going to port 21 
but NOT to 64.12.163.199 (the AIM server users were having trouble
with) to localhost port 8021 (where
hopefully ftp-proxy is waiting).  Now, be advised that there are many
AIM servers; if this application interests you, you will probably
have to play with these IP addresses (64.12.0.0/16 might be more 
productive, though probably also interferes with some non-AOL sites).

<p>
<a name="nat3.4"></a>
<b>NAT versus Proxy</b>

<p>
The difference between NAT and an application-based proxy is that the proxy
software acts as a middle-man between the Internet and the machines connected
on the LAN. This is fine, however each application you want to run on
your machine and connect to the Internet through the proxy server MUST
be proxy-aware (be able to use a proxy server). Not all applications are
able to do this (especially games). Furthermore, there simply are not
proxy server applications for all of the Internet services out there.
NAT transparently maps
your internal network so that it may connect to the Internet.  The only
security advantage to using a proxy software over NAT is that the proxy
software may have been made security aware, and can filter based on content,
to keep your Windows machine from getting a macro virus, it can protect
against buffer overflows to your client software, and more.  To maintain
these filters is often a high-maintenance job.

<p>
<a name="nat3.5"></a>
<b>Redirection and reflection</b>

<p>
Often, redirection rules are used to forward incoming connections from
the Internet to a local server with a private address in the LAN, as in:

<pre>
rdr on $ext_if proto tcp from any to $ext_if port 80 -&gt; $server port 80
</pre>

<p>
But when the redirection rule is tested from a client on the LAN, it's
found to not work.
The reason is that redirection rules apply only to packets that pass
through the specified interface ($ext_if, the external interface, in
the example).
Connecting to the external address of the firewall from a host on the
LAN, however, does not mean the packets will actually pass through its
external interface.
The TCP/IP stack on the firewall compares the destination address of
incoming packets with its own addresses and aliases, and detects
connections to itself as soon as they have passed the internal interface.
Such packets do not physically pass through the external interface, and
the stack does not simulate such a passage in any way.
pf never sees these packets on the external interface, and the
redirection rule, specifying the external interface, does not apply.

<p>
Adding a second redirection rule for the internal interface does not
have the desired effect.
When the local client connects to the external address of the firewall,
the initial packet of the TCP handshake reaches the firewall through
the internal interface.
The redirection rule does apply and the destination address gets
replaced with that of the internal server.
The packet gets forwarded back through the internal interface and
reaches the internal server.
But the source address has not been translated, and still contains
the local client's address, so the server sends its replies directly
to the client.
The firewall never sees the reply and has no chance to properly reverse
the translation.
The client receives a reply from a source it never expected, and drops
it, the TCP handshake fails, and no connection can be established.

<p>
Still, it's often desirable for clients on the LAN to connect to the
same internal server as external clients, transparently.
There are several solutions for this problem:

<p>
<b>Split horizon DNS</b>
<p>
It's possible to configure DNS servers to answer queries from local
hosts differently than external queries, so that local clients will
receive the internal server's address during name resolution.
They will then connect directly to the local server, and the firewall
isn't involved at all.
This reduces local traffic, since packets don't have to be sent through
the firewall.

<p>
<b>Moving the server into a separate local network</b>
<p>
Adding an additional network interface to the firewall and moving the
local server from the client's network into a dedicated network (DMZ)
allows to redirect connections from local clients in the same way as
the redirection of external connections.
Use of separate networks has several advantages, including improving
security by isolating the server from the remaining local hosts.
Should the server (which in our case is reachable from the Internet)
ever become compromised, it can't access other local hosts directly,
as all connections have to pass through the firewall.

<p>
<b>TCP proxying</b>
<p>
A generic TCP proxy can be setup on the firewall, either listening on
the port to be forwarded or getting connections on the internal interface
redirected to the port it's listening on.
When a local client connects to the firewall, the proxy accepts the
connection, establishes a second connection to the internal server,
and forwards data between those two connections.

<p>
Simple proxies can be created using
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inetd&amp;sektion=8">inetd(8)</a>
and
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nc&amp;sektion=1">nc(1)</a>.
The following <i>/etc/inetd.conf</i> entry creates a listening socket
bound to the loopback address and port 5000.
Connections are forwarded to port 80 on server 192.168.1.10.

<pre>
127.0.0.1:5000 stream tcp wait nobody /usr/bin/nc nc -w 20 192.168.1.10 80
</pre>

<p>
The following redirection rule forwards port 80 on the internal interface
to the proxy:

<pre>
rdr on $int_if proto tcp from $int_net to $ext_if port 80 -&gt; 127.0.0.1 port 5000
</pre>

<p>
<b>RDR and NAT combination</b>
<p>
With an additional NAT rule on the internal interface, the lacking
source address translation described above can be achieved.

<pre>
rdr on $int_if proto tcp from $int_net to $ext_if port 80 -&gt; $server
no nat on $int_if proto tcp from $int_if to $int_net
nat on $int_if proto tcp from $int_net to $server port 80 -&gt; $int_if
</pre>

<p>
This will cause the initial packet from the client to be translated again
when it's forwarded back through the internal interface, replacing the
client's source address with the firewall's internal address.
The internal server will reply back to the firewall, which can reverse
both NAT and RDR translations when forwarding to the local client.
This construct is rather complex, as it creates two separate states
for each reflected connection.
Care must taken to prevent the NAT rule from applying to other traffic,
for instance connections originating from external hosts (through
other redirections) or the firewall itself.
Note that the rdr rule above will cause the TCP/IP stack to see packets
arriving on the internal interface with a destination address inside the
internal network.
To prevent the stack from issuing ICMP redirect messages (telling the
client that its destination is reachable directly, breaking the reflection),
disable redirects on the gateway, using

<pre>
# <strong>sysctl -w net.inet.ip.redirect=0</strong>
</pre>

In general, the previously mentioned solutions should be used instead.

<p>
<a name="nat4.0"></a>
<b>6.3.4 Links and Cross-References</b>

<p>
OpenBSD files:
<ul>
<li>/etc/pf.conf - PF/NAT rules file
<li>/etc/rc.conf - need to edit to start up NAT and PF at boot time
<li>/etc/sysctl.conf - need to edit to enable IP forwarding
</ul>

<p>
NAT Internet Links:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&amp;sektion=5&amp;manpath=OpenBSD+3.3">pf.conf man page</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pfctl&amp;sektion=8&amp;manpath=OpenBSD+3.3">pfctl man page</a>
<li><a href="http://www.geektools.com/rfc/rfc1631.txt">http://www.geektools.com/rfc/rfc1631.txt</a>
</ul>


<p> 
<a name= "DHCP"></a>
<a name= "6.4"></a> 
<h2>6.4 - DHCP</h2> 

<p>
<h3>6.4.1 DHCP Client</h3>

<p>
To use the DHCP client <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient&amp;sektion=8">dhclient(8)</a>
included with OpenBSD, edit /etc/hostname.xl0
(this is assuming your main ethernet interface is xl0.  Yours might be ep0 or fxp0 or something else!)
All you need to put in this hostname file is 'dhcp'

<pre>
# <strong>echo dhcp &gt;/etc/hostname.xl0</strong>
</pre>

<p>
This will cause OpenBSD to automatically start the DHCP client on boot.  OpenBSD will gather its IP address,
default gateway, and DNS servers from the DHCP server.  

<p>
If you want to start a dhcp client from the command line, make sure
/etc/dhclient.conf exists, then try:

<pre>
# <strong>dhclient fxp0</strong>
</pre>

<p>
Where fxp0 is the interface that you want to receive dhcp on.

<p>
No matter how you start the dhclient, you can edit
the /etc/dhclient.conf file to <b>not</b> update your DNS according to the dhcp
server's idea of DNS by first uncommenting the 'request' lines in it (they are
examples of the default settings, but you need to uncomment them to override
dhclient's defaults.)

<pre>
request subnet-mask, broadcast-address, time-offset, routers,
      domain-name, domain-name-servers, host-name, lpr-servers, ntp-servers;
</pre>

<p>
and then <b>remove</b> domain-name-servers.  Of course, you may want to remove
hostname, or other settings too.

<p>
<h3>6.4.2 DHCP Server</h3>

<p>
If you want to use OpenBSD as a DHCP server <A href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd&amp;sektion=8">dhcpd(8)</a>,
edit /etc/rc.conf.  Set it up so that dhcpd_flags="-q" instead of dhcpd_flags=NO.
Put the interfaces that you want dhcpd to <b>listen</b> on in /etc/dhcpd.interfaces.

<pre>
     # <b>echo xl1 xl2 xl3 &gt;/etc/dhcpd.interfaces</b>
</pre>

<p>
Then, edit /etc/dhcpd.conf.
The options are pretty self-explanatory.

<pre>
        option  domain-name "example.com";
        option  domain-name-servers 192.168.1.3, 192.168.1.5;

        subnet 192.168.1.0 netmask 255.255.255.0 {
                option routers 192.168.1.1;

                range 192.168.1.32 192.168.1.127;
        }
</pre>

<p>
This will tell your DHCP clients that the domain to append to DNS requests is example.com (so, if the user types in 'telnet joe' then it will
send them to joe.example.com).  It will point them to DNS servers
192.168.1.3 and 192.168.1.5.  For hosts that are on the same network as
an ethernet interface on the OpenBSD machine, which is in the 192.168.1.0/24 range, it will assign them an IP address between
192.168.1.32 and 192.168.1.127.  It will set their default gateway as 192.168.1.1.

<p>
If you want to start dhcpd(8) from the command line, after editing /etc/dhcpd.conf,
try:

<pre>
     # <b>dhcpd -q fxp0</b>
</pre>

<p>
Where <tt>fxp0</tt> is an interface that you want to start serving DHCP on.
The <tt>-q</tt> flag makes dhcpd(8) quiet; otherwise it is very noisy.

<p>
If you are serving DHCP to a Windows box, you may want
dhcpd(8) to give the client a 'WINS' server address.
To make this happen, just the following line to your /etc/dhcpd.conf:

<pre>
     option    netbios-name-servers    192.168.92.55;
</pre>

<p>
(where <tt>192.168.92.55</tt> is the IP of your Windows or Samba server.)
See <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcp-options&amp;sektion=5">dhcp-options(5)</a> for more options that your DHCP
clients may want.


<p>
<a name="PPP"></a>
<a name="6.5"></a>
<h2>6.5 - PPP </h2>

<p>
Point-to-Protocol is generally what is used to create a connection to
your ISP via your modem. OpenBSD has 2 ways of doing this.

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppd&amp;sektion=8">pppd(8)</a>
 - Which is the kernel ppp daemon.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8">ppp(8)</a>
 - Which is the userland ppp daemon. 
</ul>

<p>
The first one we will cover will be the userland PPP daemon. To start
off you will need some simple information about your ISP. Here is a list
of helpful information that you will need.

<ul>
<li>Your ISP's dialup number
<li>Your nameserver 
<li>Your username and password
<li>Your gateway
</ul>

<p>
Some of these you can do without, but would be helpful in setting up
your ppp. The userland PPP daemon uses the file 
<a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.conf.sample">/etc/ppp/ppp.conf</a>
as its configuration file. There are many helpful files in
<i>/etc/ppp</i> that can have different setups for many different
situations. You should take a browse though that directory.

<p>
Also, make sure, that if you're not using a GENERIC kernel, that you
have this line in your configuration file:

<blockquote><pre><strong>
pseudo-device   tun             2
</strong></pre></blockquote>

<p>
<h3>Initial Setup - for PPP(8)</h3>

<p>
Initial Setup for the userland PPP daemon consists of editing your
<i>/etc/ppp/ppp.conf</i> file. This file doesn't exist by default, but
there is a file <i>/etc/ppp/ppp.conf.sample</i> in which you can simply
edit to create your own <i>ppp.conf</i> file. Here I will start with the
simplist setup and probably most used setup.  Here is a quick
<i>ppp.conf</i> file that will simply connect to your ISP and set your
default routes and nameserver. With this file all the information you
need is your ISP's phone number and your username and password.

<blockquote>
<pre>
default:
set log Phase Chat LCP IPCP CCP tun command     
set device /dev/cua01                           
set speed 115200     
set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \"\" AT OK-AT-OK ATE1Q0 OK\\dATDT\\T TIMEOUT 40 CONNECT"
</pre>
</blockquote>

<p>
The section under the <tt>default:</tt> tag will get executed each time.
Here we setup all our critical information. Here with &quot;set
log&quot; we set our logging levels. This can be changed; refer to
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8">ppp(8)</a>
for more info on setting up logging levels. Our device gets set with
&quot;set device&quot;. This is the device that the modem is on. In this
example the modem is on com port 2. Therefore com port 1 would be
<i>/dev/cua00</i>. With &quot;set speed&quot; we set the speed of our
dialup connection and with &quot;set dial&quot; we set our dialup
parameters. With this we can change our timeout time, etc. This line
should stay pretty much as it is though.

<p>
Now we can move on and setup our information specific to our ISP. We do this by adding another tag under our
<b>default:</b> section. This tag can be called anything you want, easiest to just use the name of your ISP.
Here I will use <b>myisp:</b> as our tag referring to our ISP. Here is a simple setup incorporating all we need
to get ourselves connected.

<blockquote>
<pre>
myisp:
set phone 1234567   
set login "ABORT NO\\sCARRIER TIMEOUT 5 ogin:--ogin: ppp word: ppp"
set timeout 120   
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
add default HISADDR 
enable dns
</pre>
</blockquote>

<p>
Here we have setup essential info for that specific ISP. The first
option &quot;set phone&quot; sets your ISP's dialup number. The
&quot;set login&quot; sets our login options. Here we have the timeout
set to 5; this means that we will abort our login attempt after 5
seconds if no carrier. Otherwise it will wait for &quot;login:&quot; to
be sent and send in your username and password. In this example our
Username = ppp and Password = ppp. These values will need to be changed.
The line &quot;set timeout&quot; sets the idle timeout for the entire
connection duration to 120 seconds. The &quot;set ifaddr&quot; line is a
little tricky. Here is a more extensive explanation.

<blockquote><pre>
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
</pre></blockquote>

<p>
In the above line, we have it set in the format of &quot;<b>set ifaddr
[myaddr[/nn] [hisaddr[/nn] [netmask [triggeraddr]]]]</b>&quot;. So the
first IP specified is what we want as our IP. If you have a static IP
address, you set it here. In our example we use /0 which says that no
bits of this ip address need to match and the whole thing can be
replaced. The second IP specified is what we expect as their IP. If you
know this you can specify it. Again in our line we don't know what will
be assigned, so we let them tell us. The third option is our netmask,
here set to 255.255.255.0.  If triggeraddr is specified, it is used in
place of myaddr in the initial IPCP negotiation.  However, only an
address in the myaddr range will be accepted.  This is useful when
negotiating with some PPP implementations that will not assign an IP
number unless their peer requests ``0.0.0.0''.

<p>
The next option used &quot;add default HISADDR&quot; sets our default
route to their IP. This is 'sticky', meaning that if their IP should
change, our route will automatically be updated. With &quot;enable
dns&quot; we are telling our ISP to authenticate our nameserver
addresses. Do NOT do this if you are running a local DNS, as ppp will
simply circumvent its use by entering some nameserver lines in
<i>/etc/resolv.conf</i>.

<p>
<h3>Using PPP(8)</h3>

<p>
Now that we have our <i>ppp.conf</i> file setup we can start trying to
make a connection to our ISP. I will detail some commonly used arguments
with ppp.

<ul>
<li><tt>ppp -auto myisp</tt> - This will run ppp, configure your
interfaces and connect to your ISP and then go into the background.
<li><tt>ppp -ddial myisp</tt> - This is similar to -auto, but if your
connection is dropped it will try and reconnect.
</ul>

<p>
By using <i>/usr/sbin/ppp</i> with no options will put you into
interactive mode. From here you can interact directly with the modem, it
is great for debugging problems in your <i>ppp.conf</i> file.

<p>
<h3>ppp(8) extras</h3>

<p>
In some situations you might want commands executed as your connection
is made or dropped. There are two files you can create for just these
situations. <i>/etc/ppp/ppp.linkup</i> and <i>/etc/ppp/ppp.linkdown</i>.
Sample configurations can be viewed here:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkup.sample">ppp.linkup</a>
<li><a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkdown.sample">ppp.linkdown</a>
</ul>

<p>
Extended information can be found at
<a href="http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/userppp.html">FreeBSD 
Handbook entry on User PPP</a>. 


<p>
<a name="Tuning"></a>
<a name="6.6"></a>
<h2>6.6 - Tuning networking parameters</h2>
<!-- XXXrelease -->

<p>
<h3>6.6.1 - How can I tweak the kernel so that there are a higher number
of retries and longer timeouts for TCP sessions?</h3>

<p>
You would normally use this to allow for routing or connection problems.
Of course, for it to be most effective, both sides of the connection
need to use similar values.

<p>
To tweak this, use <tt>sysctl</tt> and increase the values of:

<pre>
net.inet.tcp.keepinittime
net.inet.tcp.keepidle
net.inet.tcp.keepintvl
</pre>

<p>
Using sysctl -a, you can see the current values of these (and many
other) parameters.  To change one, use <tt>sysctl -w</tt>, as in
<tt>sysctl -w net.inet.tcp.keepidle=28800</tt>.

<p>
<h3>6.6.2 - How can I turn on directed broadcasts?</h3>

<p>
Normally, you don't want to do this.  This allows someone to send
traffic to the broadcast address(es) of your connected network(s) if you
are using your OpenBSD box as a router.<P>
There are some instances, in closed networks, where this may be useful,
particularly when using older implementations of the NetBIOS protocol.
This is another sysctl.  <Tt>sysctl -w net.inet.ip.directed-broadcast=1</tt> 
turns this on.  Read about <a href="http://www.netscan.org">smurf attacks</a>
if you want to know why it is off by default.

<p>
<h3>6.6.3 - I don't want the kernel to dynamically allocate a certain port</h3>

<p>
There is a sysctl for this also.  From <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>:

<pre>
Set the list of reserved TCP ports that should not be allocated by the
kernel dynamically.  This can be used to keep daemons from stealing a
specific port that another program needs to function.  List elements may
be separated by commas and/or whitespace.

 #  <strong>sysctl -w  net.inet.tcp.baddynamic=749,750,751,760,761,871</strong>

It is also possible to add or remove ports from the current list.

 #  <strong>sysctl -w net.inet.tcp.baddynamic=+748</strong>
 #  <strong>sysctl -w net.inet.tcp.baddynamic=-871</strong>
</pre>


<p>
<a name="NFS"></a>
<a name="6.7"></a>
<h2>6.7 - Simple NFS usage</h2>

<p>
NFS, or Network File System, is used to share a filesystem over the
network. A few choice man pages to read before trying to setup a NFS
server are:

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nfsd&amp;sektion=8">nfsd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mountd&amp;sektion=8">mountd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&amp;sektion=5">exports(5)</a>
</ul>

<p>
This section will go through the steps for a simple setup of NFS. This
example details a server on a LAN, with clients accessing NFS on the
LAN. It does not talk about securing NFS. We presume you have already
setup packet filtering or other firewalling protection, to prevent
outside access.  If you are allowing outside access to your NFS server,
and you have any kind of sensitive data stored on it, we strongly
recommend that you employ <a href="faq13.html">IPsec</a>.  Otherwise,
people can potentially see your NFS traffic.  Someone could also pretend
to be the IP address which you are allowing into your NFS server.  There
are several attacks that can result.  When properly configured, IPsec
protects against these types of attacks.

<p>
Another important security note.  Don't just add a filesystem to
<i>/etc/exports</i> without some kind of list of allowed host(s).
Without a list of hosts which can mount a particular directory, anyone
on who can reach your host will be able to mount your NFS exports.

<p>
NFS depends upon
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=portmap&amp;sektion=8">portmap(8)</a>
to be running before it will operate.  Portmap(8) is now off by
default on OpenBSD 3.2 and later, so you must enable it in
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&amp;sektion=8">rc.conf(8)</a>
by changing the <tt>portmap</tt> line to read:

<blockquote><pre>
portmap=YES
</pre></blockquote>
and reboot to make it take effect. 

<p>
The setup consists of a server with the ip <b>10.0.0.1</b>. This server
will be serving NFS only to clients within that network. The first step
to setting up NFS is to setup your <i>/etc/exports</i> file. This file
lists which filesystems you wish to have accessible via NFS and defines
who is able to access them. There are many options that you can use in
your <i>/etc/exports</i> file, and it is best that you read the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&amp;sektion=5">exports(5)</a>
man page. For this example we have an <i>/etc/exports</i> that looks
like this:

<blockquote><pre>
#
# NFS exports Database
# See exports(5) for more information.  Be very careful, misconfiguration
# of this file can result in your filesystems being readable by the world.
/work -alldirs -ro -network 10.0.0 -mask 255.255.255.0
</pre></blockquote>

<p>
This means that the local filesystem <tt>/work</tt> will be made
available via NFS. <tt>-alldirs</tt> specifies that clients will be able
to mount at any point under the <tt>/work</tt> mount point. <tt>-ro</tt>
specifies that it will only be allowed to be mounted read-only. The last
two arguments specify that only clients within the 10.0.0.0 network
using a netmask of 255.255.255.0 will be authorized to mount this
filesystem. This is important for some servers that are accessible by
different networks.

<p>
Once your <i>/etc/exports</i> file is setup, you can go ahead and setup
your NFS server. You should first make sure that options NFSSERVER &amp;
NFSCLIENT are in your kernel configuration. (GENERIC kernel has these
options included.) Next, you should set <tt>nfs_server=YES</tt> in
<i>/etc/rc.conf</i>. This will bring up both nfsd(8) and mountd(8) when
you reboot. Now, you can go ahead and start the daemons yourself. These
daemons need to be started as root, and you need to make sure that
portmap(8) is running on your system. Here is an example of starting
nfsd(8) which serves on both TCP and UDP using 4 daemons.  You should
set an appropriate number of NFS server daemons to handle the maximum
number of concurrent client requests that you want to service.

<blockquote><pre>
# <strong>/sbin/nfsd -tun 4</strong>
</pre></blockquote>

<p>
Not only do you have to start the nfsd(8) server, but you need to start
mountd(8). This is the daemon that actually services the mount requests
on NFS. To start mountd(8), make sure an empty mountdtab file exists,
and run the daemon:

<blockquote><pre>
# <strong>echo -n &gt;/var/db/mountdtab</strong>
# <strong>/sbin/mountd</strong>
</pre></blockquote>

<p>
If you make changes to /etc/exports while NFS is already running, you
need to make mountd aware of this!  Just HUP it:

<blockquote><pre>
# <strong>kill -HUP `cat /var/run/mountd.pid`</strong>
</pre></blockquote>

<p>
<h3>Checking Stats on NFS</h3>

<p>
From here, you can check to make sure that all these daemons are up and
registered with RPC. To do this, use rpcinfo(8).

<blockquote><pre>
$ <strong>rpcinfo -p 10.0.0.1</strong>
   program vers proto   port
    100000    2   tcp    111  portmapper
    100000    2   udp    111  portmapper
    100005    1   udp    633  mountd
    100005    3   udp    633  mountd
    100005    1   tcp    916  mountd
    100005    3   tcp    916  mountd
    100003    2   udp   2049  nfs
    100003    3   udp   2049  nfs
    100003    2   tcp   2049  nfs
    100003    3   tcp   2049  nfs
</pre></blockquote>

<p>
During normal usage, there are a few other utilities that allow you to
see what is happening with NFS. One is
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=showmount&amp;sektion=8">showmount(8)</a>, 
which allows you to view what is currently mounted and who is mounting
it. There is also nfsstat(8) which shows much more verbose statistics.
To use showmount(8), try <tt>/usr/bin/showmount -a host</tt>. For
example:

<blockquote><pre>
$ <strong>/usr/bin/showmount -a 10.0.0.1</strong>
All mount points on 10.0.0.1:
10.0.0.37:/work
</pre></blockquote>

<p>
<h3>Mounting NFS Filesystems</h3>

<p>
NFS filesystems should be mounted via mount(8), or more specifically,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount_nfs&amp;sektion=8">mount_nfs(8)</a>.
To mount a filesystem <i>/work</i> on host 10.0.0.1 to local filesystem
<i>/mnt</i>, do this (note that you don't need to use an IP address;
mount will resolve host names):

<blockquote><pre>
# <strong>mount -t nfs 10.0.0.1:/work /mnt</strong>
</pre></blockquote>

<p>
To have your system mount upon boot,
add something like this to your <i>/etc/fstab</i>:

<blockquote><pre>
10.0.0.1:/work /mnt nfs rw 0 0
</pre></blockquote>

<p>
It is important that you use <tt>0 0</tt> at the end of this line so
that your computer does not try to fsck the NFS filesystem on boot!!!!
The other standard security options, such as noexec, nodev, and nosuid,
should also be used where applicable.  Such as:

<blockquote><pre>
10.0.0.1:/work /mnt nfs rw,nodev,nosuid 0 0
</pre></blockquote>

<p>
This way, no devices or setuid programs on the NFS server can subvert
security measures on the NFS client.  If you are not mounting programs
which you expect to run on the NFS client, add noexec to this list.


<p>
<a name="DNS"></a>
<a name="6.8"></a>
<h2>6.8 - Domain Name Service  - DNS, BIND, and named</h2>

<p>
<i>Note: The following section was written for OpenBSD 3.2 and before,
which included BIND4.  OpenBSD v3.3 now includes BIND9, which is more 
thorougly documented in print and on the Internet than the previous 
BIND 4 was.

<p>As with OpenBSD's BIND4,
BIND9 on OpenBSD is run in a chroot(2), and has a number of security
improvements over the standard BIND9:
<ul>
<li>arc4random() support (integrated in 9.3.0-snapshot)
<li>call tzset before chroot
<li>open /dev/null before chroot
<li>fall back to system default random device when running chroot
<li>add LCG (Linear Congruential Generator) implementation to libisc
<li>use LCG instead of LFSR for ID generation until LFSR is proven reliable
<li>IPv{4,6} query transport selection for dig(1)
<li>fixed sha1.c to work around gcc optimization bug (sparc64)
<li>chroot to <tt>/var/named</tt> by default
<li>setuid to user <tt>named</tt> by default
<li>write pid-file before chroot
</ul>
OpenBSD 3.3 users will wish to look at: 
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=named&amp;sektion=8">named(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/cvsweb/~checkout~/src/usr.sbin/bind/doc/arm/Bv9ARM.html"
>BIND 9 Administrator Reference Manual</a> (These pages are also
available in the <tt>/usr/share/doc/html/bind/</tt> directory on your
installed system)
</ul>
</blockquote> </i>

<h3>6.8.1 What is DNS?</h3>
Domain Name Service is a network facility allowing IP network domains to
provide name-to-IP address resolution and IP address-to-name resolution
in response to a query. Your OpenBSD installation is configured by
default as a DNS client but not as a DNS server. That is, your OpenBSD
installation can perform a DNS query against a domain name server for
the address of a machine, but it cannot answer such DNS queries itself
unless you specifically configure it to do so.

<p>
My OpenBSD machine is currently connected to the Internet via my ISP, so
I can use the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nslookup&amp;sektion=8">nslookup(8)</a>
utility to execute the DNS query:

<blockquote><pre>
$ <strong>nslookup www.openbsd.org</strong>
Server:  ns4.us.prserv.net
Address:  165.87.201.244

Non-authoritative answer:
Name:    www.openbsd.org
Address:  129.128.5.191
</pre></blockquote>

<p>
<b>165.87.201.244</b> is the name server which answered, because it is
the nameserver that my ISP told me to use with my account and whose
number is entered in
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&amp;sektion=5">/etc/resolv.conf</a>.
But the answer was not authoritative. For an authoritative answer, let's
find which is the authoritative DNS server for the <i>openbsd.org</i>
domain and ask it for the address of <i>www.openbsd.org</i>:

<blockquote><pre>
# Identify the name servers for openbsd.org
# with the help of my ISP's name server.
$ <strong>nslookup -type=NS openbsd.org</strong>
Server:  ns4.us.prserv.net
Address:  165.87.201.244

Non-authoritative answer:
openbsd.org     nameserver = cvs.openbsd.org
openbsd.org     nameserver = gandalf.sigmasoft.com
openbsd.org     nameserver = cs.colorado.edu
openbsd.org     nameserver = ns.appli.se
openbsd.org     nameserver = zeus.theos.com

Authoritative answers can be found from:
cvs.openbsd.org internet address = 199.185.137.3
gandalf.sigmasoft.com   internet address = 198.144.202.98
cs.colorado.edu internet address = 128.138.243.151
ns.appli.se     internet address = 194.198.196.230
zeus.theos.com  internet address = 199.185.137.1

# Use the info gained to query for an authoritative
# resolution: query the authoritative zeus.theos.com.
$ <strong>nslookup www.openbsd.org zeus.theos.com</strong>
Server:  zeus.theos.com
Address:  199.185.137.1

Name:    www.openbsd.org
Address:  129.128.5.191
</pre></blockquote>

<p>
<i>zeus.theos.com</i> is, one would suppose, running OpenBSD and is
properly configured to be a DNS server for the <i>openbsd.org</i>
domain.

<p>
<a name="DNS.1.1"></a>
<a name="6.8.1.1"></a>
<h3>6.8.1.1 Where can I learn all about DNS and its implementation under
OpenBSD?</h3>

<ul>
<li>See RFCs <a href="http://www.faqs.org/rfcs/rfc1033.html">1033</a>, 
<a href="http://www.faqs.org/rfcs/rfc1034.html">1034</a>, and 
<a href="http://www.faqs.org/rfcs/rfc1035.html">1035</a> for more
information on the Internet name-domain system.
<li>Read the O'Reilly Associates book <i><a href="../books.html#6">DNS
and BIND</a></i>.
<li>Read the <a href="http://www.openbsd.org/cgi-bin/man.cgi">OpenBSD Manual</a> especially the pages for
  <ul>
  <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&amp;sektion=1">dig(1)</a>
  <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nslookup&amp;sektion=8">nslookup(8)</a>
  <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gethostbyname&amp;sektion=3">gethostbyname(3)</a>
  <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=named&amp;sektion=8">named(8)</a>
  <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolver&amp;sektion=3">resolver(3)</a>
  <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolver&amp;sektion=5">resolver(5)</a>
  </ul>
</ul>

<p>
The
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&amp;sektion=1">dig(1)</a>
command is especially useful, because it can query a domain and return
information in much the same record format as required in BIND
configuration files. You can use
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&amp;sektion=1">dig(1)</a>
to examine name servers you know to be operating properly as a way of
comparing your setup to theirs.

<p>
<h3>6.8.2 Does my machine need to be a domain name server?</h3>

<p>
If you aren't sure that you need your machine to perform the role of DNS
server, don't configure it as one. The OpenBSD installation does not, by
default, activate your machine as a domain name server, though all
necessary files are installed. For most workstations, just the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hosts&amp;sektion=5">/etc/hosts</a>
file naming local machines' IP addresses and the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&amp;sektion=5">/etc/resolv.conf</a>
file for indicating which DNS servers serve you out on the intranet or
internet is sufficient.

<p>
On the other hand, you might need to set up a machine as a domain name
server:

<ul>
<li>If you have an IP LAN on which you do not wish to replicate "hosts"
files of local addresses machine by machine. In such a case, you may
configure your OpenBSD machine as a DNS server and serve queries from
the other machines on your LAN.
  <ul>
  <li><b>Note:</b> There is no practical restriction on the number of
  DNS servers on a LAN. Any or all machines on the LAN may offer DNS
  service if they are so configured. Whether any such server is
  considered authoritative from outside your LAN (or is even known from
  outside your LAN) is a configuration factor that typically is
  controlled at the next level up from your LAN in the domain hierarchy.
  </ul>
<li>If you have an IP LAN on which reside machines you will wish to be
findable via DNS query by machines on another IP LAN or WAN.
<li>If you experience difficulties resolving the local hostname to an IP
address, or resolving other local names to IP addresses even though you
have correct <i>/etc/hosts</i> and <i>/etc/resolv.conf</i> (E.g.,
Netscape on OpenBSD sometimes exhibits this behavior because it
implements its own resolver instead of just using
<i>gethostbyname(3)</i> to look up addresses.)
</ul>

<p>
One more consideration is speed of execution. Since name resolution is
an iterative process, in which the name server makes repeated queries to
other nameservers for addresses in remote domains, name resolution may
take slightly longer if you have a modem connection to the Internet and
are querying your own DNS server for remote addresses (which will then
iteratively query remote name servers via the modem) than if you are
querying your ISP's name server (which probably has a faster connection
to remote name servers).

<p>
<h3>6.8.3 What are the software components of the DNS server?</h3>

<ul>
<li>named <i>("name daemon")</i>
<li>Configuration files in the directory hierarchy under <i>/var/named/</i>
</ul>

<p>
<h4>6.8.3.1 What level of BIND is supported?</h4>
<!-- XXXchanges - changes with OpenBSD 3.3 -->

<p>
BIND is the name of the behavioral specification of a domain name
server. Domain name server components exist to collectively implement
BIND.

<p>
There are three distinct BIND specifications:

<ol>
<li>BIND 4
<li>BIND 8
<li>BIND 9
</ol>

<p>
As installed, OpenBSD <b>named</b> supports BIND 4.x.

<p>
<h4>6.8.3.2 What are some of the alternatives to providing DNS via the
default BIND 4.x implementation?</h4>
<!-- XXXexpires - goes away when 3.2 becomes unsupported -->

<ul>
<li>The BIND 9.x implementation in <i>/usr/ports/net/bind9</i>.(See
<a href="../ports.html">ports</a>)
</ul>

<p>
<h5>6.8.3.2.1 <u>Security</u> note</h5>

<p>
If you use these alternative implementations of domain name service, you
are providing a critical network service using software which may not
have been subject to quite the same level of scrutiny as the
<a href="http://www.openbsd.org/security.html">security-audited</a>
<b>named</b> name daemon in the base installation. This is a significant
consideration, since if a domain name server is compromised, resolvers
using that name server can be re-directed to impostor sites.

<p>
<h3>6.8.4 How much do I have to install?</h3>

<p>
If the default networking setup was installed properly at OpenBSD
installation time, everything is already installed. You just have to
configure the name daemon ("<tt>named</tt>").

<p>
<h3>6.8.5 How do I configure DNS?</h3>
<!-- XXXchanges - changes with OpenBSD 3.3 -->

<p>
You configure OpenBSD DNS by editing and/or creating files that control
the name daemon <tt>named</tt>. These files reside by default in the
directory <i>/var/named</i> and its subdirectories, especially the file
<i>/var/named/named.boot</i> which is the initialization file for
<b>named</b>. There are also a couple of other configuration steps to be
taken in <i>/etc</i>.

<p>
In this document, we will configure the name daemon on
<i>nemo.yewtopia.com</i> be the primary nameserver for the (very small!)
domain <i>yewtopia.com</i>. The address of <i>nemo.yewtopia.com</i> is
<i>192.168.1.9</i>. Two other machines are on that subnet,
<i>crater.yewtopia.com </i>at 192.168.1.1 and
<i>earhart.yewtopia.com</i> at 192.168.1.2.

<p>
<h4>6.8.5.1 Configuration in <i>/var/named</i></h4>
<!-- XXXchanges - changes with OpenBSD 3.3 -->

<p>
<h5>6.8.5.1.1 <i>/var/named/named.boot</i></h5>

<blockquote><pre>
; tell what subdir has the lookup database files
directory       /namedb

; type    domain   source host/file backup file
cache     .	   root.cache
primary   0.0.127.IN-ADDR.ARPA  localhost.rev

; example primary server config:
primary  yewtopia.com yewtopia
primary  1.168.192.IN-ADDR.ARPA yewtopia.rev
</pre></blockquote>

<p>
This tells the initialization process in what subdirectory and under
which filenames to find the configuration files for <i>yewtopia.com</i>.

<p>
<h5>6.8.5.1.2 <i>/var/named/namedb/localhost.rev</i></h5>

<blockquote><pre>
; Reverse lookup for localhost interface
@       IN      SOA     nemo.yewtopia.com.  your_id.nemo.yewtopia.com.  (
                                14      ; Serial
                                3600    ; Refresh
                                900     ; Retry
                                3600000 ; Expire
                                3600 )  ; Minimum
        IN      NS      nemo.yewtopia.com.
1       IN      PTR     localhost.yewtopia.com.
</pre></blockquote>

<p>
<h5>6.8.5.1.3 <i>/var/named/namedb/yewtopia</i></h5>

<blockquote><pre>
; yewtopia.com domain database
@      IN      SOA     nemo.yewtopia.com.  your_id.nemo.yewtopia.com.  (
                                14      ; Serial
                                3600    ; Refresh
                                900     ; Retry
                                3600000 ; Expire
                                3600 )  ; Minimum
                     IN      NS      nemo.yewtopia.com.

; Addresses
localhost.yewtopia.com.      IN A    127.0.0.1
crater.yewtopia.com.         IN A    192.168.1.1
earhart.yewtopia.com.        IN A    192.168.1.2
nemo.yewtopia.com.           IN A    192.168.1.9
</pre></blockquote>

<p>
<h5>6.8.5.1.4 <i>/var/named/namedb/yewtopia.rev</i></h5>

<blockquote><pre>
; yewtopia domain reverse lookup database
@      IN      SOA     nemo.yewtopia.com.  your_id.nemo.yewtopia.com.  (
                                14      ; Serial
                                3600    ; Refresh
                                900     ; Retry
                                3600000 ; Expire
                                3600 )  ; Minimum
1.168.192.in-addr.arpa. IN      NS      nemo.yewtopia.com.

; Addresses
1.1.168.192.in-addr.arpa. IN PTR crater.yewtopia.com.
2.1.168.192.in-addr.arpa. IN PTR earhart.yewtopia.com.
9.1.168.192.in-addr.arpa. IN PTR nemo.yewtopia.com.
</pre></blockquote>

<p>
<h4>6.8.5.2 Configuration in <i>/etc</i></h4>

<p>
<h5>6.8.5.2.1 <i>/etc/resolv.conf</i></h5>

<p>
Make sure <i>/etc/resolv.conf</i> now points to the domain of the local
machine (instead of, for example, your ISP's name server) so that name
resolution requests actually get sent to the <b>named</b> you have
configured!

<blockquote><pre>
domain yewtopia.com
lookup file bind
</pre></blockquote>

<p>
<h4>6.8.5.2.2 <i>/etc/hosts</i></h4>

<p>
If you previously had added the addresses of various machines to the
<i>/etc/hosts</i> file, you might consider shortening your
<i>/etc/hosts</i> file back to the default:

<blockquote><pre>
# Host addresses
127.0.0.1       localhost       localhost.localdomain
192.168.1.9     nemo            nemo.yewtopia.com
</pre></blockquote>

<p>
So that <b>named</b> isn't bypassed in favor of (possibly outdated)
addresses in the <i>/etc/hosts</i> file. <u>Make sure you have at least
the default <i>localhost</i> entry</u> or your network won't start
properly! Note also <i>nemo</i> must appear in its own hosts file or you
will see a (mostly harmless) error message at bootup when
<i>/etc/netstart</i> invokes 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=route&amp;sektion=8">route(8)</a>
in order to add <i>nemo</i> (whose name appears in <i>/etc/myname</i>).

<p>
<h4>6.8.5.3 Using <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&amp;sektion=1">dig(1)</a>
 to examine the results.</h4>

<blockquote><pre>
$ <strong>dig @nemo.yewtopia.com yewtopia.com any any</strong>

; &lt;&lt;&gt;&gt; DiG 2.2 &lt;&lt;&gt;&gt; @nemo.yewtopia yewtopia any any
; (1 server found)
;; res options: init recurs defnam dnsrch
;; got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 59904
;; flags: qr rd ra; Ques: 1, Ans: 2, Auth: 0, Addit: 1
;; QUESTIONS:
;;      yewtopia.com, type = ANY, class = ANY

;; ANSWERS:
yewtopia.com.   3600    SOA    nemo.yewtopia.com.  your_id.nemo.yewtopia.com. (
                        14      ; serial
                        3600    ; refresh (1 hour)
                        900     ; retry (15 mins)
                        3600000 ; expire (41 days 16 hours)
                        3600 )  ; minimum (1 hour)
yewtopia.com.   3600    NS      nemo.yewtopia.com.

;; ADDITIONAL RECORDS:
nemo.yewtopia.com.  3600    A       192.168.1.9

;; Total query time: 4 msec
;; FROM: nemo to SERVER: nemo.yewtopia.com  192.168.1.9
;; WHEN: Tue May  2 23:47:19 2000
;; MSG SIZE  sent: 25  rcvd: 102
</pre></blockquote>

<p>
<h3>6.8.6 How and when do I start and stop DNS?</h3>

<p>
<h4>6.8.6.1 Starting DNS</h4>

<p>
The name daemon <b>named</b> is launched during system startup from
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&amp;sektion=8">/etc/rc</a>
if the line installed by default in
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&amp;sektion=8">/etc/rc.conf</a>.

<blockquote><pre>
named_flags=NO          # for normal use: ""
</pre></blockquote>

<p>
is changed to

<blockquote><pre>
named_flags=""          # for normal use: ""
</pre></blockquote>

<p>
Also, examine these lines in /etc/rc.conf:

<blockquote><pre>
named_user=named                # Named should not run as root unless necessary
named_chroot=/var/named         # Where to chroot named if not empty
</pre></blockquote>

<p>
These defaults will be correct for nearly all setups.

<p>
To start <b>named</b> by hand, use the 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ndc&amp;sektion=8">ndc(8)</a>
command. For example:

<blockquote><pre>
# <strong>ndc start</strong>
          or
# <strong>ndc restart</strong>
</pre></blockquote>

<p>
<h4>6.8.6.2 Stopping DNS</h4>

<p>
The best way to stop the name daemon is to use the 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ndc&amp;sektion=8">ndc(8)</a>
command. For example:

<blockquote><pre>
# <strong>ndc stop</strong>
</pre></blockquote>

<p>
If this fails to work, find the process id of named and use the 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=kill&amp;sektion=1">kill(1)</a>
command to end that process. The PID for <b>named</b> while it is
running is found as the first line in the file
<i>/var/named/named.pid</i>:

<blockquote><pre>
# <strong>cat /var/named/named.pid</strong>
4608
named -t /var/named -u named
# <strong>kill -KILL 4608</strong>
</pre></blockquote>

<p>
<h4>6.8.6.3 Restarting DNS with an altered configuration</h4>

<p>
To cause a running instance of the name daemon to restart itself
reloading its configuration after you have made changes, send it a
"hangup" signal:

<blockquote><pre>
# <strong>kill -HUP 4608</strong> 
</pre></blockquote>

<p>
or by using the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ndc&amp;sektion=8">ndc(8)</a> 
command. For example:

<blockquote><pre>
# <strong>ndc reload</strong>
</pre></blockquote>

<p>
<h3>6.8.7 How do I block AXFR queries? </h3>

<p>
example:

<blockquote><pre>
garden:/home/jeremy$<strong>  host -l openssh.com</strong>
openssh.com.            NS      zeus.theos.com.
openssh.com.            NS      cvs.openbsd.org.
openssh.com.            NS      gandalf.sigmasoft.com.
openssh.com.            NS      cs.colorado.edu.
openssh.com.            NS      ns.appli.se.
openssh.com.            A       199.185.137.4
cvs.openssh.com.        A       199.185.137.4
localhost.openssh.com.  A       127.0.0.1
</pre></blockquote>

<p>
This information is useful for debugging DNS, but in some instances you
may not want this output publicly offered.  If you are using classless
in-addr(rfc2317) for reverse, host -l may report every domain that your
system hosts!  This can easily be remedied by the 'allow-transfer'
clause in your zone file.

<br><br>

If you're using Bind8 you need to specify the hosts you want to allow to
transfer zones in your individual zone file(s):

<blockquote><pre>
zone "foo.com" in {
        type master;
        file "directory/zonefile";
        allow-transfer {
          127.0.0.1;
          10.0.0.6;
          10.0.255.12;
        };
};
</pre></blockquote>

<p>
You can also block transfers for all domains by editing /var/named.conf
and add the 'allow-transfer' parameter to the 'options' section of the
configuration file:

<blockquote><pre>
   options {
        allow-transfer { 127.0.0.1; };
    };
</pre></blockquote>

<p>
The Bind8 method also works with Bind9.<br>
If you are using Bind 4 (default in OpenBSD) you can edit
/var/named/named.boot and use the 'xfrnets' option.

<blockquote><pre>
xfrnets 209.142.221.5 12.7.96.7
; type    domain                source host/file                backup file
cache     .                                                     root.cache
primary   0.0.127.IN-ADDR.ARPA  localhost.rev
</pre></blockquote>

<p>
Bind 4 allows transfers from entire classes so it is not as exact.
Typically, the only hosts that need to perform transfers are your DNS
slaves and hosts you may want to debug from (127.0.0.1 is usually a good
host to allow transfers from!) Blocking AXFR queries adds an extra level
of privacy, but can hinder useful DNS debugging.  (Thanks to
<a href="mailto:ntang@nachtwache.org">Nicholas Tang</a> for that tip.)

<p>
<h3>6.8.8 What didn't you tell me about setting up DNS?</h3>

<p>
There's a lot we didn't tell you, for example, how to set up DNS so that
queries for intranet domains that aren't visible from the root of the
domain hierarchy get relayed to servers within your enterprise. Read the
<a href="#DNS.1.1">documents we recommended</a> for more information on
DNS.


<p>
<a name="PPTP"></a>
<a name="6.9"></a>
<h2>6.9 - Setting up a PPTP connection in OpenBSD</h2>

<p>
<strong>NOTE:</strong> This does not apply to <strong>ALL</strong> ADSL
providers, but much information can be gleaned from the setup here. This
is known to work for <a href="http://www.inode.at">Inode</a>, an ADSL
provider in Austria.

<p>
To start off, you need to install pptp. The port is located at 
<i>/usr/ports/net/pptp</i>. Read <a href="faq8.html#Ports">FAQ 8, 
Ports</a> for more information on the OpenBSD ports tree.

<p>
Because of a conflict between the In-Kernel 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gre&amp;sektion=4">gre(4)</a>
support and pptp, you will need to re-compile your kernel, removing
support for gre(4).

<blockquote>Patch to remove GRE(4) support.
<pre>
Index: GENERIC
===================================================================
RCS file: /cvs/src/sys/conf/GENERIC,v
retrieving revision 1.86
diff -u -r1.86 GENERIC
--- GENERIC     14 Mar 2002 00:42:25 -0000      1.86
+++ GENERIC     17 May 2002 01:52:17 -0000
@@ -87,7 +87,7 @@
 pseudo-device  enc     1       # option IPSEC needs the encapsulation interface
 pseudo-device  bridge  2       # network bridging support
 pseudo-device  vlan    2       # IEEE 802.1Q VLAN
-pseudo-device  gre     1       # GRE encapsulation interface
+#pseudo-device gre     1       # GRE encapsulation interface
 #pseudo-device strip   1       # Starmode Radio IP interface

 pseudo-device  pty     64      # pseudo-terminals
</pre></blockquote>

<p>
To recompile your kernel, check out OpenBSD source via cvs (refer to <a
href="../anoncvs.html">AnonCVS</a> web page for more information), apply
the following patch, and rebuild your kernel as per <a
href="faq5.html#Building">FAQ 5, Building a kernel</a>.

<p>
After you have the <b>pptp</b> package installed and a new kernel, you
need to edit a few files to setup for your connection. This packages
uses the in-house OpenBSD
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8">ppp(8)</a>,
so if you are familiar with ppp(8), much of the setup is the same. Also,
refer to <a href="#PPP">FAQ 6, PPP</a>.

<ul>
<li>1 - /etc/ppp/options
<li>2 - /etc/ppp/pap-secrets
</ul>

<p>
For the <i>/etc/ppp/options</i> file, a setup like below will most likely
do all that you need:

<blockquote><pre>
# <strong>cat /etc/ppp/options</strong>
name "LOGINNAME"
noauth
noipdefault
defaultroute
debug
</pre></blockquote>

<p>
<tt>LOGINNAME</tt> should be replaced with your User-ID.

<p>
The <i>/etc/ppp/pap-secrets</i> a line like:

<blockquote><pre>
# <strong>cat /etc/ppp/pap-secrets</strong>
LOGINNAME 10.0.0.138 PASSWORD
</pre></blockquote>

<p>
Where LOGINNAME is your User-ID and PASSWORD is your password.
10.0.0.138 is the IP assigned to your MODEM in the case that you are
using ADSL, etc. Make sure this file stays readonly by root (mode 600).

<p>
<h3>6.9.1 - Assigning an address to your Network Interface</h3>

<p>
In the above example, our modem came with a preconfigured interface of
10.0.0.138. We now need to assign an address to OUR interface. It's best
to pick an IP close to the one given by your MODEM, or use the static IP
assigned to you. Read more about setting up interfaces in 
<a href="#Setup">FAQ 6, Setup</a>.

<p>
Once your interface is setup, you should be able to create a pptp
connection with the command:

<blockquote><pre>
# <strong>/usr/local/sbin/pptp 10.0.0.138 &amp;</strong>
</pre></blockquote>

<p>
Since this uses the in-house OpenBSD ppp(8), two processes are started.
You can kill pptp by killing both these processes:

<blockquote><pre>
# <strong>kill -9 [pid of pppd]</strong>
$ <strong>kill -9 [pid of pptp]</strong>
</pre></blockquote>

<p>
It is recommended to open <tt>/var/log/messages</tt> in a extra terminal
window, to recognize possible problems.

<blockquote>
<pre>
# <strong>tail -f /var/log/messages</strong>
</pre></blockquote>

<p>
We also suggest that you put the startup command in <i>/etc/rc.local</i>
so that you automatically connect on reboot.


<a name="Bridge"></a>
<h2>6.10 - Setting up a network bridge in OpenBSD</h2>

<p>
A <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4">bridge</a>
is a link between two or more separate networks.  Unlike a router, 
packets transfer through the bridge "invisibly" -- logically, the two
network segments appear to be one segment to nodes on either side of the
bridge.  The bridge will only forward packets that have to pass from one
segment to the other, so among other things, they provide an easy way to
reduce traffic in a complex network and yet allow any node to access any
other node when needed.

<p>
Note that because of this "invisible" nature, an interface in a  bridge
may or may not have an IP address of its own.  If it does, the interface
has effectively two modes of operation, one as part of a bridge, the
other as a normal, stand-alone NIC.  If neither interface has an IP
address, the bridge will pass network data, but will not be externally
maintainable (which can be a feature).

<p>
<h3>An example of a bridge application</h3>

<p>
One of my computer racks has a number of older systems, none of which have
a built-in 10BASE-TX NIC.  While they all have an AUI or AAUI connector,
my supply of transceivers is limited to coax.  One of the
machines on this rack is an OpenBSD-based terminal server which always on
and connected to the high-speed network.  Adding a second NIC with a 
coax port will allow me to use this machine as a bridge to the coax network.

<p>
This system has two NICs in it now, an Intel EtherExpress/100
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp&amp;sektion=4"><tt>fxp0</tt></a>)
and a 3c590-Combo card 
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&amp;sektion=4"><tt>ep0</tt></a>)
for the coax port.  <tt>fxp0</tt> is the link to the
rest of my network and will thus have an IP address, <tt>ep0</tt> is
going to be for bridging only and will have no IP address.
Machines attached to the coax segment will communicate as if they
were on the rest of my network.  So, how do we make this happen?

<p>
The file <tt>hostname.fxp0</tt> contains the configuration info for
the <tt>fxp0</tt> card.  This machine is set up using DHCP, so its file
looks like this:

<blockquote>
<pre>
$ <b>cat /etc/hostname.fxp0</b>
dhcp NONE NONE NONE NONE
</pre>
</blockquote>

<p>
No surprises here.

<p>
The <tt>ep0</tt> card is a bit different, as you might guess:

<blockquote>
<pre>
$ <b>cat /etc/hostname.ep0</b>
up media 10base2
</pre>
</blockquote>

<p>
Here, we are instructing the system to activate this interface using 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
and set it to 10BASE-2 (coax).  No IP address or similar information
needs to be specified for this interface.  The options the <tt>ep</tt>
card accepts are detailed in its
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&amp;sektion=4">man page</a>.

<p>
Now, we need to set up the bridge.  Bridges are initialized by the
existence of a file named something like 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridgename.if&amp;sektion=5"><tt>bridgename.bridge0</tt></a>. 
Here is an example for my situation here:

<blockquote>
<pre>
$ <b>cat /etc/bridgename.bridge0</b>
add fxp0
add ep0
up
</pre>
</blockquote>

<p>
This is saying set up a bridge consisting of the two NICs, fxp0 and ep0,
and activate it.  Does it matter which order the cards are listed?  No,
remember a bridge is very symmetrical -- packets flow in and out in both
directions.

<p>
That's it!  Reboot, and you now have a functioning bridge.

<p>
<h3>Filtering on a bridge</h3>
<!-- XXXchanges - changes with OpenBSD 3.3 -->

While there are certainly uses for a simple bridge like this, it is
likely you might want to DO something with the packets as they go
through your bridge.  As you might expect, <a href="#PF">Packet
Filter</a> can be used to restrict what traffic goes through your
bridge.

<p>
Keep in mind, by the nature of a bridge, the same data flows through
both interfaces, so you only need to filter on one interface.  Your
default "Pass all" statements would look something like this:

<blockquote>
<pre>
pass in  on ep0  all
pass out on ep0  all
pass in  on fxp0 all
pass out on fxp0 all
</pre>
</blockquote>

<p>
Now, let's say I wish to filter traffic hitting these old machines, I want 
only Web and SSH traffic to reach them.  In this case, we are going to let
all traffic in and out of the ep0 interface, but filter on the fxp0
interface, using keep state to handle the reply data:

<blockquote>
<pre>
# Pass all traffic through ep0
pass in quick on ep0 all
pass out quick on ep0 all

# Block fxp0 traffic
block in  on fxp0 all
block out on fxp0 all

pass in quick on fxp0 proto tcp from any to any port {22, 80} \
     flags S/SA keep state
</pre>
</blockquote>

<p>
Note that this rule set will prevent anything but incoming HTTP and SSH
traffic  from reaching either the bridge machine or any of the other
nodes "behind" it.  Other results could be had by filtering the other
interface.  

<p>
To monitor and control the bridge you have created, use the
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=brconfig&amp;sektion=8">brconfig(8)</a>
command, which can also be used to create a bridge after boot.

<p>
<h3>Tips on bridging</h3>

<ul>
<li>It is HIGHLY recommended that you filter on only one interface.
While it is possible to filter on both, you really need to understand
this very well to do it right.

<li>By using the <i>blocknonip</i> option of 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=brconfig&amp;sektion=8">brconfig(8)</a>
or in 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridgename.if&amp;sektion=5">bridgename.bridge0</a>,
you can prevent non-IP traffic (such as IPX or NETBEUI) from slipping
around your filters.  This may be important in some situations, but you
should be aware that bridges work for all kinds of traffic, not just IP.

<li>Bridging requires that the NICs be in a "Promiscuous mode" -- they
listen to ALL network traffic, not just that directed at the interface.
This will put a higher load on the processor and bus than one might
expect.  Some NICs don't work properly in this mode, the TI ThunderLAN
chip
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tl&amp;sektion=4">tl(4)</a>)
is an example of a chip that won't work as part of a bridge. 
</ul>


<p>
<font color="#0000e0">
<a href="index.html">[FAQ Index]</a>
<a href="faq5.html">[To Section 5 - Building the System from Source]</a>
<a href="faq7.html">[To Section 7 - Keyboard and Display Controls]</a>
</font>

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../images/back.gif" border="0" alt="[back]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>$OpenBSD: faq6.html,v 1.169 2003/05/01 01:47:41 nick Exp $</small>

</body>
</html>
