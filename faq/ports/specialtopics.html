<!doctype html>
<html lang=en id=faq>

<!-- If you make edits to any FAQ documents, please start each sentence
     on a new line, and try to keep the general formatting consistent
     with the rest of the pages -->

<title>OpenBSD Ports: Special Porting Topics</title>
<meta name= "description"   content= "OpenBSD Porting Guide">
<meta charset=utf-8>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="../../openbsd.css">
<link rel="canonical" href="https://www.openbsd.org/faq/ports/specialtopics.html">

<h2 id=OpenBSD>
<a href="../../index.html">
<i>Open</i><b>BSD</b></a>
Ports - Special Porting Topics
<small>
<a href="index.html">[Handbook Index]</a>
</small>
</h2>
<hr>
<p>

<ul>
  <li><a href="#SharedLibs">Shared Libraries</a>
  <li><a href="#Autoconf"  >GNU autoconf</a>
  <li><a href="#Config"    >Configuration Files</a>
  <li><a href="#Audio"     >Audio Applications</a>
  <li><a href="#Mandoc"    >Manual Pages</a>
  <li><a href="#RcScripts" >rc.d(8) Scripts</a>
</ul>

<hr>

<h2 id="SharedLibs">Shared Libraries</h2>

<h3>Understanding Shared Libraries Number Rules</h3>
Shared libraries are a bit tricky for a variety of reasons.
You must understand the library naming scheme:
<code>libfoo.so.major.minor</code>.

<p>
When you link a program, the linker ld embeds that information in the created
binary.
You can see it with <a href="https://man.openbsd.org/ldd">ldd(1)</a>.
Later, when you run that program, the dynamic linker
<a href="https://man.openbsd.org/ld.so">ld.so(1)</a> uses that information to
find the right dynamic library:

<ul><li>
A library with the same exact major number is required.

<li>
A library with an equal or higher minor number is required.
</ul>

So, this means that <b>all</b> libraries with the same major number and an
equal or higher minor number <b>must satisfy the binary API that the program
expects</b>.
If they do not, then your port is broken.
Specifically, it will break when users try to update their system.

<p>
The rules for shared libraries are quite simple.

<ul><li>
If functions were added to the library, you must bump the library minor
number: a program that needs those functions has no way to require it except
by asking explicitly for at least this version.

<li>
If the existing API changes, that is, if any function signature is altered,
or if valid calling sequences are no longer valid, if a type changes in an
incompatible way, the library major number <b>must be bumped</b>.

<li>
This includes removing old functions.
Any function removal should trigger a major number bump.

<li>A good hint is to compare the output of

<pre class="cmdbox">
$ <b>nm -g oldlib.so.X.Y | cut -c10- | grep -e^T</b>
</pre>

and

<pre class="cmdbox">
$ <b>nm -g newlib.so.X.Y | cut -c10- | grep -e^T</b>
</pre>

This won't show if functions arguments type changed, but at least you'll see
quickly if some functions were added and/or removed.
</ul>

<p>
Sometimes, it happens that a library is written as several files, and that
internal functions happen to be visible to communicate between those files.
Those function names traditionally begin with an underscore, and are not
part of the API proper.

<h3>Tweaking Ports Builds to Achieve the Right Names</h3>

Quite a few ports need tweaks to build shared libraries correctly anyways.
Remember that building shared libraries should be done with

<pre class="cmdbox">
$ <b>gcc -shared -fpic|-fPIC -o libfoo.so.4.5 obj1 obj2</b>
</pre>

Trying to rename the library after the fact to adjust the version number
does not work: ELF libraries use some extra magic to set the library
internal name, so you must link it with the correct version the first time.

<p>
On the other hand,
remember that you can override <code>Makefile</code> variables
from the command line, by using <code>MAKE_FLAGS</code> in the port's
<code>Makefile</code>.
In some cases, the program you're porting will have a simple variable which
you can override by setting the library version in MAKE_FLAGS, for example
<code>MAKE_FLAGS= SO_VERSION=${LIBfoo_VERSION}</code>.
In others, the port will need to be patched to make use of such a variable.

<p>
The ports infrastructure already handles these details in libtool-based
and CMake-based ports.
For libtool, by default the version from the base OS is used, but in some
cases this is insufficient and <code>USE_LIBTOOL=gnu</code> can be set.
CMake is handled by using the <code>cmake.port.mk</code> module:
<code>MODULES += devel/cmake</code>.
In these cases, most details are handled automatically:

<ul><li>
<code>SHARED_LIBS</code>
is examined and version numbers are automatically replaced.

<li>
Shared library building is logged in <code>${WRKBUILD}/shared_libs.log</code>,
which can be directly included in the port's <code>Makefile</code>.
</ul>

<h3>Avoid DT_SONAME hardcoding</h3>

Some ports use the <code>-soname</code> flag of
<a href="https://man.openbsd.org/ld">ld(1)</a> to override the library
specification in the DT_SONAME field.
Setting DT_SONAME is not a bug itself but is usually not desirable on
OpenBSD where <a href="https://man.openbsd.org/ld.so">ld.so(1)</a> is smart and
the ports tree takes care of library versioning.
Moreover, a wrong soname can result in unusable binaries that depend on this
library; either always or after some updates to the port containing the library.
To check if the DT_SONAME field is set, run the following command:

<pre class="cmdbox">
$ <b>objdump -x /path/to/libfoo.so.0.0 | fgrep SONAME</b>
  SONAME      libfoo.so.0.0
</pre>

As a general rule, <em>setting soname explicitly should be patched out</em>.
The only exception is a situation when the right soname is recorded
<em>and</em> it's hard to patch soname-related code out <em>and</em>
upstream won't accept such a patch.
In that case the soname should fully match the file name (see the example
above).

<h3>Try putting all user visible libraries into /usr/local/lib</h3>

As a rule, requesting the user to add directories to their
<a href="https://man.openbsd.org/ldconfig">ldconfig(8)</a> path is a
very bad idea: all shared libraries that are linked directly to programs
should appear in <code>/usr/local/lib</code>.
However, it is quite possible to use a symbolic link to the actual library.
You should understand the library lookup rules:

<ul><li>
At build time,
<a href="https://man.openbsd.org/ld">ld(1)</a> uses <code>-L</code>
flags to set up paths to look for libraries.
It stops looking as soon as it finds a library that matches its requirements.

<li>
At run time, <a href="https://man.openbsd.org/ld.so">ld.so(1)</a> uses the
information cached through
<a href="https://man.openbsd.org/ldconfig">ldconfig(8)</a> to find the required
library.
</ul>

So, let us assume you have two ports that provide two major versions of a
given library, say <code>qt.1.45</code> and <code>qt.2.31</code>.
Since both ports can be installed simultaneously, to make sure a given program
will link against <code>qt.1</code>, that library is provided as
<code>/usr/local/lib/qt/libqt.so.1.45</code>, and programs will be linked using

<pre class="cmdbox">
$ <b>ld -o program program.o -L/usr/local/lib/qt -lqt</b>
</pre>

Similarly, a program that links with <code>qt.2</code> will use the
<code>/usr/local/lib/qt2/libqt.so.2.31</code> file with

<pre class="cmdbox">
$ <b>ld -o program program.o -L/usr/local/lib/qt2 -lqt</b>
</pre>

To solve those libraries at run-time, a link called
<code>/usr/local/lib/libqt.so.1.45</code> and a link called
<code>/usr/local/lib/libqt.so.2.31</code> have been provided.
This is enough to satisfy <a href="https://man.openbsd.org/ld.so">ld.so(1)</a>.

<p>
It is an error to link a program using <code>qt1</code> with

<pre class="cmdbox">
$ <b>ld -o program program.o -L/usr/local/lib -lqt</b>
</pre>

This code assumes that <code>qt.2.31</code> is not installed, which is
a wrong assumption.

<p>
Such tricks are only necessary in the rare cases of very pervasive
libraries where a transition period between major versions must be
provided.
In general, it is enough to make sure the library appears in
<code>/usr/local/lib</code>.

<h3>Writing Library Dependencies Correctly</h3>

The new dependency code does need complete library dependencies.
You must use <code>make lib-depends-check</code> or
<code>make port-lib-depends-check</code> to verify a port does mention all
libraries it requires.
You just write them in <code>LIB_DEPENDS</code>/<code>WANTLIB</code> like this:

<pre class="cmdbox">
LIB_DEPENDS += x11/gtk+
WANTLIB += gtk&gt;=1.2 gdk&gt;=1.2
</pre>

It is not an error to specify static libraries on a <code>WANTLIB</code> line as
well.
<code>WANTLIB</code>s are fully evaluated at package build time: the resulting
package will have library dependency information embedded as lines for ld.so
that hold the actual major.minor number that was used for building, and
nothing for static libraries.

<p>
In fact, providing <code>LIB_DEPENDS</code> lines even for static libraries is a
good idea.
This will simplify port update if a given dependency goes from a static library
to a shared library.

<p>
<code>WANTLIB</code> lines must specify the same paths that are used for ld.
With the same example as above,
a standard <code>qt2</code> depends fragment would say
<code>WANTLIB += lib/qt2/qt.=2</code>.
This allows the dependency checking code to do the right thing when multiple
versions of the same library are encountered.

<h3>Updating Ports Correctly</h3>

So, when you update or add a port that involves shared libraries, a few details
must be done right.

<ul><li>
Make sure the shared libraries major.minor numbers are correct.

<li>
Verify all ports that depend on your port. Verify that they build correctly
with your changes.
Notify corresponding maintainers of the update, so that they can verify their
ports still run correctly.

<li>
You may have to adjust dependent ports' <code>WANTLIB</code> and
<code>LIB_DEPENDS</code>.
If you introduce new shared libraries, watch out for <code>BUILD_DEPENDS</code>
that need to be turned into <code>LIB_DEPENDS</code>.

<li>
Whenever you introduce a new port, you should verify that you are not creating
a library that conflicts with an existing library: libraries from two ports
with the same name are deadly, because their version numbering schemes have
no chance to match.
You should try to solve the situation with the software author (for instance,
a library that is called libnet is definitely badly named).
<li>
Check <a href="guide.html#PortsUpdate">the ports update guidelines</a> for a
more extensive discussion.
</ul>

<h2 id="Autoconf">GNU autoconf</h2>

Autoconf is a GNU tool that is supposed to help in writing portable programs.
It is often used together with automake (portable makefiles) and libtool
(portable shared libraries).

<p>
Those tools do not work all that well, and often create specific challenges
in porting software to OpenBSD.

<h3>Detecting the Use of autoconf in a Piece of Software</h3>

Quite a few software projects have configure scripts, and in most cases,
those scripts were generated by autoconf.
Such scripts have a line near the top that says:

<pre class="cmdbox">
# Generated automatically using autoconf version 2.13
</pre>

or something similar.
The generation procedure is covered in a following section.
Most often, autoconf ports come with the generated scripts, and with the
source scripts that generated these.
The next section covers the simple case where you simply want to run the
generated script, and not modify it.
Make sure you read the section about trojan horses as well.

<h3>Running an autoconf Configure Script</h3>

This script is normally run during the configure stage of ports building.
To invoke the configure script, one only has to set
<code>CONFIGURE_STYLE=gnu</code>
which will automatically invoke <code>${WRKSRC}/configure</code>.

<p>
If your configure script lies elsewhere,
just set <code>CONFIGURE_SCRIPT</code> to the right value.

<p>
Configure scripts often take a lot of arguments.
The default processing of the ports tree will only pass
<code>--prefix</code> and
<code>--sysconfdir</code> to these.
Very old configure scripts don't understand <code>--sysconfdir</code>; you
can set <code>CONFIGURE_STYLE=gnu old</code> in such cases.

<p>
Similarly, some ports are not aware of <code>DESTDIR</code>.
Those ports will often accept setting <code>prefix=${DESTDIR}/usr/local</code>
without any issue, which can be done with <code>CONFIGURE_STYLE=gnu dest</code>.

<p>
Ports using autoconf and automake
will have <code>Makefile</code>s with a specific
format that begins with a few standard locations:

<ul><li>
<code>bindir</code>: location for binaries
<li>
<code>sysconfdir</code>: location for configuration
<li>
<code>includedir</code>: location for include dirs
</ul>

If the configure script does not allow you to override these, you may
still be able to do it later on during the build or <code>fake</code> stage.
This does assume, of course, that the only reference to such a directory is with
in the generated <code>Makefile</code>.

<p>
For instance, a neat trick involves switching <code>sysconfdir</code> to
<code>${PREFIX}/share/example/pkgname</code> during the <code>fake</code> stage
to get default config files to package
(since packages don't normally store files under <code>/etc</code>).

<p>
Ports fully using autoconf and automake  may support building under a different
directory:
try setting <code>SEPARATE_BUILD=flavored</code> and see if that works.
This would allow you to wipe the build tree without wiping the source tree,
by giving you separate <code>${WRKSRC}</code> and <code>${WRKBUILD}</code>
locations.
In a few cases, separate builds may need to use gmake, where the rest of the
port is happy with bsd-make, in which case this is not worth it.

<p>
Automake will generate a few rules to rebuild all the generated scripts if
anything changes.
These often get in the way of OpenBSD specific patches.
For that reason,
as soon as <code>CONFIGURE_STYLE</code> corresponds to autoconf use,
<code>post-patch</code> will touch various files in a specific order,
so that no automake dependencies get triggered later.
The list of dependencies is given in
<a href="https://man.openbsd.org/tsort">tsort(1)</a> order
in a file mentioned in
<code>REORDER_DEPENDENCIES</code> (the default is
<code>${PORTSDIR}/infrastructure/mk/automake.dep</code>).

<h3>The Mechanics of Configure Checks</h3>

The configure script first runs a fixed script called <code>config.guess</code>,
that will determine which system configure is running on.
<code>config.guess</code> does not vary from port to port and is a fixed script,
so the OpenBSD ports tree replaces it with a fixed version that knows about some
specific OpenBSD architectures.
Since most software packages come with bundled <code>config.guess</code>,
and since some of them are quite old, this is a necessary step.
If a software package contains more than one <code>config.guess</code>,
you can overwrite them all by setting <code>MODGNU_CONFIG_GUESS_DIRS</code>
to the full list of directories to process.

<p>
The configure script generated by autoconf then simply checks all functionality
on the existing system, by looking for a compiler, and running simple test
programs through it.
Since some of these tests are quite lengthy, the ports tree primes configure
with a <code>CONFIG_SITE=config.site</code> file.
Configure will look at the contents of that file first before running the tests.
A few configure scripts may have bugs that will prevent them from running
correctly in the presence of <code>config.site</code>.
Setting <code>CONFIG_SITE</code> to empty will weed out these kind of problems.

<p>
Most configure will auto-detect quite a few conditions.
It is very important to look at configure's options, at configure's output,
and at the generated <code>config.log</code> file:
these will tell you what options were found, and what options were not found.
This will allow you to find out when configure did not find a package that was
installed.

<p>
This will also tell you which optional packages configure would find.
In the ports tree, those are called hidden dependencies.
This is a bad thing: a hidden dependency is some extra package configure will
pick up if it's installed.
Then it will proceed in building a mutant package.
In some cases, the build will fail because of OpenBSD peculiarities.
In some cases, the package creation will fail, as some files will have different
names.
In some cases, the resulting package will be incorrect, as it will fail to
record any dependency on the optional package.
So looking at configure's output is one of the most important duty of
ports' maintainers.
Watch out for cascading tests: detecting a given feature may lead a configure
script to try out and find some dependent feature, so you will not see the
second feature in the configure output unless the first feature is triggered.

<p>
In case some hidden dependencies are found, some action should be taken.
The most simple action is to install the optional package, and see what
configure will do.
If it detects the package, one can either disable the detection (by using
configure options, or environment variables, or patching the configure script),
or verify that the build goes well and add the dependency to the list of
dependent packages.
A better choice is to figure out a reasonable set of default dependencies, and
then add some flavors to cover other common features.

<h3>Re-generating Configure Scripts</h3>

Configure scripts are normally generated from a <code>configure.in</code> file
(recent versions of autoconf use a <code>configure.ac</code> file instead).
A standard library of definitions is often available in an
<code>aclocal.m4</code>.

<p>
In most cases, patching configure directly is a bad idea.
It is better to patch the <code>configure.in</code> file
and get the ports tree to call autoconf.
Good porters will endeavor to write <code>configure.in</code> changes
that they can feed to software authors.

<p>
Different versions of autoconf will produce distinct configure scripts.
<code>autoconf-2.13</code> is special:
it was used over a fairly long period,
and there has been mutant versions of <code>autoconf-2.13</code>
(actually, betas of a newer autoconf) in wide use.
Hence, using <code>autoconf-2.13</code> will often not produce the exact same
configure script.

<p>
Since having several autoconf versions around at the same time is useful,
the autoconf script actually available in the ports tree is part of a port
called metaauto.
Which autoconf script actually gets called is controlled through the
environment variable <code>AUTOCONF_VERSION</code>.
Calling autoconf happens if you set <code>CONFIGURE_STYLE=autoconf</code>,
together with setting <code>AUTOCONF_VERSION</code>.
In most cases, identify the version of autoconf that was used to generate
the distributed configure script (usually obvious when reading the script)
and use this same version yourself.

<p>
Autoconf relies on the standard unix preprocessor
<a href="https://man.openbsd.org/m4">m4(1)</a>.
Normally, autoconf relies on some features on the GNU version of m4, gm4.
Fortunately, OpenBSD's m4 has enough features to run autoconf as well, it
just needs to be invoked with <code>-g</code> to handle autoconf.
Very seldom, autoconf run with OpenBSD's m4 will produce bogus configure
scripts.
The OpenBSD developers will fix such an issue.

<h3>Trojan Horses</h3>

Configure scripts are big generated files.
They are an ideal hiding place for trojan horses, and this has indeed already
happened in the past.
This is the main reason for having most versions of autoconf in the tree:
a good porter is expected to check that a generated configure script matches
what the ports tree autoconf builds.

<h3>Interaction with Other Programs</h3>

Autoheader is another program related to autoconf that is normally run to
create a <code>config.h.in</code> file.
Setting <code>CONFIGURE_STYLE=autoconf</code> will also run autoheader.
A few ports don't use autoheader.
Setting <code>CONFIGURE_STYLE=autoconf no-autoheader</code> will fix that issue.

<p>
libtool has a few specific hooks in <code>configure.in</code>.
There is often a <code>libtool.m4</code> script that goes with it.
Getting libtool to do the right thing goes beyond the scope of this
documentation.

<h2 id="Config">Configuration Files</h2>

Packages should only install files under <code>${PREFIX}</code>, which is
<code>/usr/local</code> by default.
On the other hand, the OpenBSD policy is to install most configuration files
under <code>${SYSCONFDIR}</code>, which is <code>/etc</code> by default.

<p>
<i>Note that it is perfectly acceptable for a binary package to have both
<code>${PREFIX}</code> and <code>${SYSCONFDIR}</code> hardcoded:
<code>PREFIX</code> and
<code>SYSCONFDIR</code> are mostly user settings that influence the build of the
package.</i>

<h3><code>@sample</code> Explained</h3>

Packing-lists contain a specific <code>@sample</code> mechanism to deal with
configuration files:

<ul><li>
During fake installation, the port should install a sample configuration
file, for instance as <code>${PREFIX}/share/examples/PKGNAME/foo.rc</code>.

<li>
The packing-list should contain a <code>@sample ${SYSCONFDIR}/foo.rc</code>
right under the sample configuration file.

<li>
During installation, the default example configuration file will be copied
into the actual location where the configuration file should live.

<li>
During updates and deinstallation, an existing configuration file will be
compared with the default example file.
If they differ, the package tools will inform the user and let him perform
the update/removal himself.
If they are identical, the package tools know they can proceed and
update/remove the configuration files without any further precautions.
</ul>

<h3>More <code>@sample</code> Specificities</h3>

Contrary to other files in a packing-list, <code>@sample</code> entries can
have an absolute path name.

<p>
Some big packages will also need their own configuration directory,
<code>@sample ${SYSCONFDIR}/directory/</code> will deal with that.

<p>
Using <code>@sample directory/</code> to create port specific directories
that do not hold any configuration files is perfectly good style.
<code>@sample</code> correctly interprets correct <code>@mode</code>,
<code>@owner</code>, <code>@group</code> annotations.
This can be a bit cumbersome, because you will often need to switch back
and forth between a default mode and a configuration file specific mode.

<h3>Special Tricks</h3>

<code>make update-plist</code>
knows how to copy <code>@sample</code> annotations over,
but it does not know how to create them,
so they have to be written in the first place.

<p>
Note the distinction between configuration files and example configuration
files: the port must be configured to find its files under
<code>${SYSCONFDIR}</code>.
It is only the fake installation stage that must put stuff under
<code>${PREFIX}/share/examples</code>.
One simple way to handle that is to copy the files over in a
<code>post-install</code>.

<p>
A neat trick which often works is to look at a program's <code>Makefile</code>,
and override the configuration directory in the fake installation stage by using
specific <code>FAKE_FLAGS</code>, for instance:

<pre class="cmdbox">
FAKE_FLAGS=	DESTDIR=${WRKINST} \
		sysconfdir=${WRKINST}${TRUEPREFIX}/share/examples/PKGNAME
</pre>

You just need to watch out for programs that write the configuration directory
down in specific files during their install stage.

<h3>Examples</h3>

<ul><li>
The <code>security/integrit</code> port uses a configuration directory with a
few files.
Its packing-list looks like this:

<pre class="cmdbox">
@comment &#36;OpenBSD&#36;
@bin bin/i-ls
@info info/integrit.info
@man man/man1/i-ls.1
@man man/man1/i-viewdb.1
@man man/man1/integrit.1
@bin sbin/i-viewdb
@bin sbin/integrit
share/doc/integrit/
share/doc/integrit/README
share/doc/integrit/crontab
share/doc/integrit/install_db
share/doc/integrit/integrit_check
share/doc/integrit/viewreport
share/examples/integrit/
@sample ${SYSCONFDIR}/integrit/
share/examples/integrit/root.conf
@sample ${SYSCONFDIR}/integrit/root.conf
share/examples/integrit/src.conf
@sample ${SYSCONFDIR}/integrit/src.conf
share/examples/integrit/usr.conf
@sample ${SYSCONFDIR}/integrit/usr.conf
</pre>

<li>
The <code>mail/dovecot</code> port uses <code>@sample dir/</code> to create
private directories.

<pre class="cmdbox">
...
@extraunexec rm -rf /var/dovecot/*
@sample ${SYSCONFDIR}/dovecot/
@sample ${SYSCONFDIR}/dovecot/conf.d/
@mode 755
@sample /var/dovecot/
@mode 750
@group _dovenull
@sample /var/dovecot/login/
</pre>

<li>
The <code>sysutils/nut</code> port uses a specific owner for its configuration
files.

<pre class="cmdbox">
@comment &#36;OpenBSD&#36;
@conflict upsd-*
@newuser ${NUT_USER}:${NUT_ID}:daemon:UPS User:/var/empty:/sbin/nologin
...
share/examples/nut/
@sample ${SYSCONFDIR}/nut/
@owner ${NUT_USER}
share/examples/nut/ups.conf
@sample ${SYSCONFDIR}/nut/ups.conf
share/examples/nut/upsd.conf
@mode 600
@sample ${SYSCONFDIR}/nut/upsd.conf
@mode
share/examples/nut/upsd.users
@mode 600
@sample ${SYSCONFDIR}/nut/upsd.users
@mode
share/examples/nut/upsmon.conf
@mode 600
@sample ${SYSCONFDIR}/nut/upsmon.conf
@mode
share/examples/nut/upssched.conf
@sample ${SYSCONFDIR}/nut/upssched.conf
@mode 700
@sample /var/db/nut/
@mode
@owner
share/ups/
share/ups/cmdvartab
share/ups/driver.list
</pre>

</ul>

<h2 id="Audio">Audio Applications</h2>

This document currently deals with sampled sounds issues only.
Contributions dealing with synthesizers and waveform tables are welcome.

<p>
Audio applications tend to be hard to port, as this is a domain where
interfaces are not standardized at all, though approaches don't vary
much between operating systems.

<h3>libsndio</h3>

<p>
OpenBSD has its own audio layer provided by the sndio library, documented in
<a href="https://man.openbsd.org/sio_open">sio_open(3)</a>.
Until it's merged into this page, you can find further information about
programming for this API in the guide,
<a href="http://www.sndio.org/tips.html">hints on writing and porting audio
code</a>.
sndio allows user processes to access
<a href="https://man.openbsd.org/audio.4">audio(4)</a> hardware and the
<a href="https://man.openbsd.org/sndiod">sndiod(8)</a> audio server in
a uniform way.
It supports full-duplex operation, and when used with the
<a href="https://man.openbsd.org/sndiod">sndiod(8)</a> server it supports
resampling and format conversions on the fly.

<h3>Hardware Independence</h3>

<p>
<b>YOU SHOULDN'T ASSUME ANYTHING ABOUT THE AUDIO HARDWARE USED.</b>
<br>
Wrong code is code that only checks the <code>a_info.play.precision</code>
field against 8 or 16 bits, and assumes unsigned or signed samples based
on soundblaster behavior.
You should check the sample type explicitly, and code according to that.
Simple example:

<pre class="cmdbox">
AUDIO_INIT_INFO(&amp;a_info);
a_info.play.encoding = AUDIO_ENCODING_SLINEAR;
a_info.play.precision = 16;
a_info.play.sample_rate = 22050;
error = ioctl(audio, AUDIO_SETINFO, &amp;a_info);
if (error)
    /* deal with it */
error = ioctl(audio, AUDIO_GETINFO, &amp;a_info);
switch(a_info.play.encoding)
    {
case AUDIO_ENCODING_ULINEAR_LE:
case AUDIO_ENCODING_ULINEAR_BE:
    if (a_info.play.precision == 8)
        /* ... */
    else
        /* ... */
    break;
case ...

default:
    /* don't forget to deal with what you don't know !!! For instance, */
    fprintf(stderr,
        "Unsupported audio format (%d), ask ports@ about that\n",
            a_info.play.encoding);

    }
    /* now don't forget to check what sampling frequency you actually got */
</pre>

This is about the smallest code fragment that will deal with most issues.

<h3>16 bit Formats and Endianness</h3>

In normal usage, you just ask for an encoding type
(e.g., <code>AUDIO_ENCODING_SLINEAR</code>),
and you retrieve an encoding with endianness
(e.g., <code>AUDIO_ENCODING_SLINEAR_LE</code>).
Considering that a soundcard does not have to use the same endianness as your
platform, you should be prepared to deal with that.
The easiest way is probably to prepare a full audio buffer,
and to use <a href="https://man.openbsd.org/swab">swab(3)</a> if an endianness
change is required.
Dealing with external samples usually amounts to:

<ol>
<li>Parsing the sample format
<li>Getting the sample in
<li>Swapping endianness if it is not your native format
<li>Computing what you want to output into a buffer
<li>Swapping endianness if the sound card is not in your native format
<li>Playing the buffer
</ol>

Obviously, you may be able to remove steps 3 and 5 if you are simply playing
a sound sample which happens to be in your sound card native format.

<h3>Audio Quality</h3>

Hardware may have some weird limitations, such as being unable to get over
22050 Hz in stereo, but up to 44100 in mono.
In such cases, you should give the user a chance to state his preferences,
then try your best to give the best performance possible.
For instance, it is stupid to limit the frequency to 22050 Hz because you
are outputting stereo.
What if the user does not have a stereo sound system connected to his audio
card output?

<p>
It is also stupid to hardcode soundblaster-like limitations into your program.
You should be aware of these, but do try to get over the 22050&nbsp;Hz/stereo
barrier and check the results.

<h4>Sampling Frequency</h4>

You should definitely check the sampling frequency your card gives you back.
A 5% discrepancy already amounts to a half-tone, and some people have much
more accurate hearing than that, though most of us won't notice a thing.
Your application should be able to perform resampling on the fly, possibly
naively, or through devious applications of Shannon's resampling formula
if you can.

<h4>Dynamic Range</h4>

Samples don't always use the full range of values they could.
First, samples recorded with a low gain will not sound very loud on the
machine, forcing the user to turn the volume up.
Second, on machines with badly isolated audio, low sound output means
you mostly hear your machine heart-beat, and not the sound you expected.
Finally, dumb conversion from 16 bits to 8 bits may leave you with only
4 bits of usable audio, which makes for an awfully bad quality.

<p>
If possible, the best solution is probably to scan the whole stream you are
going to play ahead of time, and to scale it so that it fits the full dynamic
range.
If you can't afford that, but you can manage to get a bit of look-ahead on
what you're going to play, you can adjust the volume boost on the fly, you
just have to make sure that the boost factor stays at a low frequency compared
to the sound you want to play, and that you get absolutely
<i>no overflows</i> -- those will always sound much worse than the improvement
you're trying to achieve.
<br>
As sound volume perception is logarithmic, using arithmetic shifts is usually
enough.
If your data is signed, you should explicitly code the shift as a division,
as C <code>&gt;&gt;</code> operator is not portable on signed data.

<p>
If all else fails, you should at least try to provide the user with a volume
scaling option.

<h3>Audio Performance</h3>

Low-end applications usually don't have much to worry about.

<p>
Don't forget to run benches.
Theoretical optimizations are just that: theoretical.
Some hard figures should be collected to check what's a sizeable improvement
and what's not.

<p>
For high performance audio applications, such as mpegI-layer3, some points
should be taken into account:

<ul><li>
The audio interface does provide you with the natural hardware blocksize.
Using multiples of that for your output buffer is essential.
Keep in mind that <code>write</code>, as a system call,
incurs a high cost compared to internal audio processing.

<li>
Bandwidth is a very important factor when dealing with audio.
A useful way to optimize an audio player is to see it as a decompressor.
The longer you can keep with the compressed data, the better usually.
Very short loops that do very little processing are usually a bad idea.
It is generally much better to combine all processing into one loop.

<li>
Some formats do incur more overhead than others.
The <code>AUDIO_GETENC</code> <code>ioctl</code> should be used to retrieve all
formats that the audio device provides.
Be especially aware of the <code>AUDIO_ENCODINGFLAG_EMULATED</code> flag.
If your application is already able to output all kinds of weird formats,
and reasonably optimized for that, try to use a native format at all costs.
On the other hand, the emulation code present in the audio device can be
assumed to be reasonably optimal, so don't replace it with quickly hacked
up code.
</ul>

<p>
A model you may have to follow to get optimal results is to first compile
a small test program that enquires about the specific audio hardware available,
then proceed to configure your program so that it deals optimally with this
hardware.
You may reasonably expect people who want good audio performance to recompile
your port when they change hardware, provided it makes a difference.

<h3>Real Time or synchronized</h3>

Considering that OpenBSD is not real time, you may still wish to write audio
applications that are mostly real time, for instance games.
In such a case, you will have to lower the blocksize so that the sound effects
don't get out of sync with the current game.
The problem with this if that the audio device may get starved, which yields
horrible results.

<p>
In case you simply want audio to be synchronized with some graphics output,
but the behavior of your program is predictable, synchronization is easier
to achieve.
You just play your audio samples, and ask the audio device what you are
currently playing with <code>AUDIO_GETOOFFS</code>, then use that information
to post-synchronize graphics.
Provided you ask sufficiently often (say, every tenth of a second), and as
long as you have enough horse-power to run your application, you can get very
good synchronization that way.
You might have to tweak the figures by a constant offset, as there is some lag
between what the audio reports, what's currently playing, and the time it takes
for X Window to display something.

<h3>Contributing Code Back</h3>

In the case of audio applications, working with the original program's author
is very important.
If their code only works with soundblaster cards, for instance, there is a good
chance they will have to cope with other technology soon.

<p>
<b>If you don't send your comments to the author, your work will have been
useless</b>.

<p>
It may also be that the author has already noticed whatever problems
you are currently dealing with, and is addressing them in his current
development tree.
If the patches you are writing amount to more than a handful of lines,
cooperation is almost certainly a very good idea.

<h2 id="Mandoc">Manual Pages</h2>

This section provides guidelines on how to deal with groff versus
<a href="https://man.openbsd.org/mandoc">mandoc(1)</a> issues in ports,
and what to do with non-English manual pages.

<h3>Should I check anything?</h3>

When creating a new port or updating an existing port, please
check whether the port can use mandoc to format its manuals.
Both the automatic and the manual checks described below are required.
This may make the manuals more useable for the port's users, and it will
reduce the port's build time.

<p>
If a new port or an existing port not marked with <code>USE_GROFF</code>
does not work with mandoc, please report that to schwarze@, who
will probably fix mandoc.

<h3>Which tools do I need?</h3>

No tools are required except the
<a href="https://man.openbsd.org/mandoc.1">mandoc(1)</a>
utility included in the base system.
In the very unusual case that you suspect recent changes to mandoc are
important for the port, you can easily update mandoc, even without
updating the rest of the system:

<pre class="cmdbox">
$ <b>cd /usr/src/usr.bin/mandoc/</b>
$ <b>cvs -q up -Pd</b>
$ <b>make cleandir</b>
$ <b>make obj</b>
$ <b>make</b>
$ <b>doas make install</b>
</pre>

Optionally, you may also get a copy of the
<a href="https://mandoc.bsd.lv/cgi-bin/cvsweb/gmdiff">gmdiff</a>
utility script that helps to compare groff and mandoc output.
The gmdiff script is not strictly required, doing the necessary checks by hand
is perfectly acceptable.

<h3>How do I report the results?</h3>

The following paragraphs ask for sending in reports to the mandoc maintainers
in some particular situations.
Before sending such reports, please always tick off the following checklist:

<ol><li>
Attach the <a href="https://man.openbsd.org/mdoc.7">mdoc(7)</a> or
<a href="https://man.openbsd.org/man.7">man(7)</a> source file in question
to the mail.
This may either be a file contained in the distribution tarball or a file
generated during the build process.
In case several files exhibit the problems, choose one that shows all problems.
In case different files exhibit different problems you wish to report, attach
as many files as necessary.
The point is to save the mandoc maintainers the work of downloading
distribution tarballs, searching them for source files, sometimes even
installing software before being able to start a build, while you have that
information readily at hand, anyway.

<li>
Briefly describe all the problems you want to report, and where they can be
seen in which file.
We have spent time wondering what exactly the reporter's point was more than
once in the past.

<li>
In case your report is related to errors or warnings printed by the mandoc
utility, copy the output of <code>mandoc -Tlint</code>
(or <code>mandoc -Tlint -Werror</code> when warnings are irrelevant)
into the body of your mail.
Usually, this is easy to reproduce, but it did happen that it was not, causing
unnecessary confusion.

<li>
In case the version of the port you are talking about is not yet committed,
please attach what is needed to build the uncommitted port: A diff against
-current when it is an update, or a tarball of the port directory when it is
a completely new port.
Very often, the source files will be sufficient to identify the problem;
however, in those cases where they are not, mailing back and forth or searching
mailing list archives just to get the needed additional information is a waste
of time.

<li>
Send mail to schwarze@.
Unless you are the maintainer of the port, Cc: him or her.
Unless you are an OpenBSD developer, in case you regularly work with a
developer who is committing your ports and who you know is interested in
this port, Cc:ing him or her may be useful as well.
</ol>

<h3>How do I do automatic checking?</h3>

To do the automatic part of the check, please run the following command over
all <a href="https://man.openbsd.org/mdoc.7">mdoc(7)</a> and
<a href="https://man.openbsd.org/man.7">man(7)</a> manual source files contained
in the port:

<pre class="cmdbox">
$ <b>mandoc -Tlint -Werror *</b>
</pre>

If you get any <code>UNSUPPORTED</code> messages, the respective
places of the manual page require careful scrutiny.
It is likely that the page will be misformatted with mandoc and the
port requires <code>USE_GROFF</code>.
If you are sure that all misformattings related to the unsupported
features are minor and don't hinder the reader, you may remove
<code>USE_GROFF</code>; but in case of doubt, leave <code>USE_GROFF</code>
in place when there are <code>UNSUPPORTED</code> messages.

<p>
If there are any <code>ERROR</code> messages, they should also be briefly
looked at.
In the unusual case that they are related to misformatting with
mandoc that doesn't happen with groff, that should be reported; the
mandoc maintainer might choose to let mandoc issue <code>UNSUPPORTED</code>
messages in additional cases or to fix the formatting.

<p>
If manual pages look good with groff, never patch them to get rid of mandoc
errors.
That would merely be a make-work project not helping anyone: It will neither
help to improve upstream manuals nor mandoc.

<h3>How do I do manual checking?</h3>

If there are no errors or the errors are not related to serious
misformatting with mandoc, proceed to the manual part of the check.
Look at the manuals as formatted by mandoc.
Do they look fine?
If yes, you do not need <code>USE_GROFF</code>, and there is no need to report
anything.

<p>
If there are no errors, but mandoc output has serious issues, that is,
relevant information is missing or part of the output is garbled,
please always report your findings, even if you happen to know it's due to
a known issue with mandoc.
We do want to know which issues cause serious problems in practice, such that
we can address the most pressing issues first.

<p>
If mandoc output has serious issues and groff output looks bad as well, then
the manuals are probably just broken upstream.
In that case, you have the usual options when porting broken software:
Abandon the port, ignore the problem, report upstream, and/or patch the bugs
away.
In case you need help with the latter, talk to schwarze@.

<p>
If there are no errors, but mandoc output has minor issues that don't really
hinder the user when reading the manual, you are welcome to report these
issues as well.
In that case, you are even more welcome to first check the mandoc
<a href="https://mandoc.bsd.lv/cgi-bin/cvsweb/TODO">TODO</a>
list, to avoid having the same minor issues reported again and again -
but in case of doubt, it is always better to report dupes than to let
problems go unnoticed.

<p>
If there are only very few errors, in particular if you get the
impression that mandoc output is just fine all the same, you don't
usually need <code>USE_GROFF=Yes</code>.
In case of doubt, ask for advice.
Such questions often help to improve mandoc error reporting, in
particular to identify and remove bogus mandoc errors messages.

<p>
To speed up the manual checks, in particular if you are often doing mandoc
checks on OpenBSD ports, and to reduce the risk of overlooking problems,
consider using the 
<a href="https://mandoc.bsd.lv/cgi-bin/cvsweb/gmdiff">gmdiff</a>
utility script.
It takes the file names of an arbitrary number of manual source files as
arguments, runs both groff and mandoc on all the files in turn, and compares
the output of both programs.
However, bear in mind that you are still doing manual checks with the ultimate
goal to judge the quality of mandoc output: all the above points still apply
even when you are using the gmdiff script to help your work.
Also note that gmdiff will usually find minor formatting differences between
both programs, in particular with respect to whitespace.
If mandoc output looks good, even if it's slightly different from groff output,
<code>USE_GROFF</code> is not needed.

<p>
For ease of use, it's possible to call gmdiff from a custom target in mk.conf:

<pre class="cmdbox">
gmdiff:
	@make fake; cd ${WRKINST}${TRUEPREFIX}; find man -type f -path 'man/man*' -print0 | xargs -0r gmdiff | less
</pre>

<h3>What about warnings?</h3>

You might wonder about mandoc warnings, as opposed to mandoc errors.
In a nutshell, the distinction is that errors may seriously impact the
usefulness of the output, while warnings might at the worst cause minor
formatting glitches, if at all.
If a mandoc warning appears to be related to seriously garbled output,
that's probably a bug in mandoc and should always be reported.

<p>
That said, it is obvious that warnings are irrelevant for the decision
whether to use or not to use mandoc for a given port.
They are for manual authors, to help improve manual quality, not for porters.

<h3>How can I help upstream?</h3>

In case you are one of the port's upstream developers, or know they care
about good quality of their manuals and gladly accept patches, it may make
sense to use <code>mandoc -Tlint</code> to identify potential formatting issues
and to produce patches to be submitted upstream.
Usually, there is no need to put such patches into the ports tree.

<p>
As with any kind of linting, before changing your
<a href="https://man.openbsd.org/mdoc.7">mdoc(7)</a> or
<a href="https://man.openbsd.org/man.7">man(7)</a> source code or sending out
patches, first make sure you are chasing real problems in the manuals.
The mandoc utility is not perfect.
It may produce bogus warnings.
We are trying to fix that, but there will always be room for improvement.
In case of doubt, report the issue and ask for advice.

<h3>Non-English Manual Pages</h3>

The following are rules of thumb, not laws set in stone.
If you find that you port has special needs, you can set them
aside; the goal is to make the port useful for users.
Consider telling schwarze@ about it if you do, maybe we can learn
something from your port.

<ol>
<li>If upstream provides non-English manual pages, install them if
that is possible without jumping through hoops, and unless there
are specific reasons not to.
"They are outdated" is not a good reason to exclude them.

<li>Never install any encoding except UTF-8.
If upstream provides UTF-8, great.
Otherwise, set <code>BUILD_DEPENDS = converters/libiconv</code>
and use iconv(1) in the <code>post-build</code> target.

<li>If mandoc copes, which you can check in exactly the same
way as with English manuals, simply install the UTF-8 source
code to <code>man/language/manN/*.N</code> and do not <code>USE_GROFF</code>.

<li>If mandoc does not cope, the proper order of
operations is iconv(1) -t UTF-8, then preconv(1), then nroff(1),
never some other way round.

<li>If possible, install to <code>man/language/manN</code>,
without any "_" or "@" characters.
Never include the encoding in the path name, and make sure
the <code>/language/</code> part never contains "." (a dot).

<li>As an exception, use <code>zh_CN</code> and <code>zh_TW</code> rather
than just <code>zh</code>.
Also, keep <code>pt</code> and <code>pt_BR</code> as they are upstream,
and install both if available. 
</ol>

<p>If the above is followed, people can do the following with no
changes to any part of the default configuration:

<pre class="cmdbox">
$ <b>doas pkg_add mc</b>
$ <b>export LC_CTYPE=en_US.UTF-8</b>
$ <b>alias ruman="man -m /usr/local/man/ru"</b>
$ <b>ruman mc</b>
</pre>

<h2 id="RcScripts">rc.d(8) Scripts</h2>

This section is intended to provide some information on writing and installing
<a href="https://man.openbsd.org/rc.d">rc.d(8)</a> scripts.

<p>
Ports that install a daemon benefit greatly from having
<a href="https://man.openbsd.org/rc.d">rc.d(8)</a> scripts.
It allows the user to easily check if the daemon is running, as well as
providing an easy and consistent way to start and stop it.

<h3>Writing rc.d(8) Scripts</h3>

Writing an <a href="https://man.openbsd.org/rc.d">rc.d(8)</a> script is
straightforward and simple due to the clean and simple design of the
<a href="https://man.openbsd.org/rc.subr">rc.subr(8)</a> system.
Though there are several things to take into account.

<ol><li>
The script has to be placed into <code>${PKGDIR}</code> with a <code>.rc</code>
extension, like <code>mpd.rc</code>.
This will allow the package tools to pick it up.
<!-- and it to the PLIST. -->

<li>
Be sure to test all the functions of the script, especially the <i>reload</i>
function.

<li>Use <code>${TRUEPREFIX}</code> when writing the path to the daemon.
</ol>

<h3>Example Script</h3>

Below is an example of a typical script.

<pre class="cmdbox">
#!/bin/ksh
#
# $OpenBSD: specialtopics.html,v 1.84 2019/05/28 01:53:12 bentley Exp $

daemon="${TRUEPREFIX}/sbin/munin-node"

. /etc/rc.d/rc.subr

pexp="/usr/bin/perl -wT ${daemon}${daemon_flags:+ ${daemon_flags}}"

rc_pre() {
        install -d -o _munin /var/run/munin
}

rc_cmd $1
</pre>

A <a href="https://cvsweb.openbsd.org/ports/infrastructure/templates/rc.template?rev=HEAD">
template script</a> can also be found in the templates directory of your
ports tree.
