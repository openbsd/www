<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>14 - Disk Setup</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2003 by OpenBSD.">
<meta http-equiv="Content-Type" content="text/html; charset=iso-2022-jp">
<style type="text/css">
  <!--
  pre { margin-left: 20px; }
  -->
</style>
</head>

<body bgcolor= "#ffffff" text= "#000000">

<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif">
<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ の目次]</a>
<a href= "faq13.html">[13 章 - IPsec]</a>
</font>

<h1><font color="#e00000">14 - ディスクの設定</font></h1><hr>

<h3>目次</h3>
<ul>
<li><a href="#disklabel"  >14.1 - OpenBSD の Disklabelを使う</a>
<li><a href="#fdisk"      >14.2 - OpenBSD の fdiskを使う</a>
<li><a href="#NewDisk"    >14.3 - OpenBSD でディスクを追加する</a>
<li><a href="#SwapFile"   >14.4 - ファイルへのスワップ</a>
<li><a href="#SoftUpdates">14.5 - Soft updates</a>
<li><a href="#D0P3"       >14.6 - OpenBSD/i386 をインストールして起動すると
    "Using partition 3 id 0" で止まるのですが</a>
<li><a href="#LargeDrive" >14.7 - OpenBSD での大容量ドライブは
    どうなってるの ?</a>
<li><a href="#InstBoot"   >14.8 - Bootblock のインストール - i386 のみ</a>
<li><a href="#Backup"     >14.9 - トラブルに備えよう: テープへの
    バックアップと復元</a>
<li><a href="#MountImage" >14.10 - OpenBSD でディスクイメージをマウント</a>
<li><a href="#pciideErr"  >14.11 - 助けて!  PCIIDE でエラーになってしまう !</a>
<li><a href="#IDEDMA"     >14.12 - IDE ディスクに対しての DMA アクセスの強制</a>
<li><a href="#RAID"       >14.13 - OpenBSD の RAID オプション</a>
</ul>
<hr>

<a name= "disklabel"></a>
<a name="14.1"></a>
<h2>OpenBSD の Disklabel を使う</h2>
<h3>目次</h3>

<ul>
<li><a href="#disklabel.1">disklabel とは ?</a></li>
<li><a href="#disklabel.2">OpenBSD インストール時の disklabel</a></li>
<li><a href="#disklabel.3">よくある disklabel の使い方</a></li>
</ul>


<a name="disklabel.1"></a>
<h3>disklabel とは ?</h3>
  
<p>
まず、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
にあるマニュアルをお読みください。

<p>
Disklabel は、ディスクとカーネル内のディスクドライバの間に、
効率よいインターフェースを提供するために作成されたものです。
ラベルには、ドライブのジオメトリとか、ファイルシステム情報とか、
ディスク関係の情報が含まれています。そしてこれをブートストラップ・プログラムが
使用して、ドライブをロードしたり、ドライブ上のどこにファイルシステムが
あるのかを調べたりします。ラベルはまた、ファイルシステムといっしょに
使用されて、効率よい環境が作られます。disklabel についてのより
詳しいことは
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=5">disklabel(5)</a>
を参照してください。

<p>
さらなるメリットとして、disklabel を使うことでディスクパーティションの
アーキテクチャ的な制約を乗り越えられるのです。たとえば i386 では
プライマリパーティション (つまり Windows NT や DOS など他の OS に見える
パーティション) は 4 つまでしか持てません。
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
では、この「プライマリパーティション」をひとつ使用するだけで、OpenBSD パーティション
を全部 (たとえば 'swap', '/', '/usr', '/var') をそこに納められます。
それでも他の OS で使えるパーティションが 3 つも残っているのです !

<a name="disklabel.2"></a>
<h3>OpenBSD インストール時の disklabel</h3>

<p>
OpenBSD インストールでの大きな山場のひとつが、ラベルを最初に作成する
ところでしょう。これは (i386 ユーザなら) <a href="#fdisk">fdisk(1)</a>
の直後に出てきます。インストール中に、disklabel を使って、
マウントポイントごとに別々のラベルを作成します。
インストール中に、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
の中からマウントポイントを指定することもできますが、これはどうしても
必要というわけではありません。というのは、後ほどプロンプトで、
これでいいかどうかの確認を求められますからです。しかし、
これは実行しておいた方がインストールが少しはスムーズになることでしょう。

<p>
インストール中なら、まだラベルはぜんぜんないはずですので、
どうしても作成する必要があります。最初に作成するラベルはラベル
'a' です。このラベルは絶対に / をマウントするところにすべきです。
作成しておいた方が良い、お勧めパーティションとそのサイズについては、
<a href="../faq4.html#SpaceNeeded">FAQ 4, 必要なスペース</a>
を参照してください。サーバの場合、少なくともここに書いてあるラベルは
別々にしておくのが望ましいでしょう。デスクトップのユーザなら、
/ のマウントポイントだけを作成しておけば十分でしょう。最初に
root パーティション ('a' ラベル) を作るとき、スワップラベル用に
多少の空きを残しておくのをお忘れなく。これまでに基本は
説明しましたから、以下にインストール中に disklabel を使う例を挙げてみましょう。
最初の例では、このマシン上には OpenBSD しか
なく、フルインストールをするものとします。

<pre>

If this disk is shared with other operating systems, those operating systems
should have a BIOS partition entry that spans the space they occupy completely.
For safety, also make sure all OpenBSD file systems are within the offset and
size specified in the 'A6' BIOS partition table.  (By default, the disklabel
editor will try to enforce this).  If you are unsure of how to use multiple
partitions properly (ie. separating /,  /usr, /tmp, /var, /usr/local, and other
things) just split the space into a root and swap partition for now.

# using MBR partition 3: type A6 off 63 (0x3f) size 4991553 (0x4c2a41) 

Treating sectors 63-16386300 as the OpenBSD portion of the disk.
You can use the 'b' command to change this.

Initial label editor (enter '?' for help at any prompt)
&gt; <b>d a</b>
&gt; <b>a a</b>
offset: [63] <b>&lt;Enter&gt;</b>
size: [16386237] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <b>&lt;Enter&gt;</b>
mount point: [none] <b>/</b>
fragment size: [1024] <b>&lt;Enter&gt;</b>
block size: [8192] <b>&lt;Enter&gt;</b>
cpg: [16] <b>&lt;Enter&gt;</b>
&gt; <b>a b</b>
offset: [131103] <b>&lt;Enter&gt;</b>
size: [16255197] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [swap] <b>&lt;Enter&gt;</b>
</pre>

<p>
これで、64MB の root パーティションが / にマウントされて、64MB の
スワップパーティションが作られました。オフセットがセクター 63 から
始まるのに注目してください。しかし、これで良いのです。
サイズの話という点で、disklabel はセクター単位で表示を行いますが、
入力は特にセクターで入力しなくても構いません。上記の例でもそうですが、
<i>64MB なら 64M</i> とか、<i>2GBなら 2G</i> とすれば良いのです。
すると Disklabel はそれをいちばん近いシリンダに丸めてくれます。
また上記の例では、disklabel は「b」がスワップであると自動的に
想定していることにも注目してください。これは正しい想定で、GENERIC
カーネルはラベル「b」にスワップを探しにいくよう設定されているのです。
ですから、このガイドラインに従って、スワップは 'b' にしておきましょう。

<p>
次の例では、もうふたつラベルを作成しています。これはつまり、完全な
インストールではないということです。これらのサイズは、OpenBSD を
完全にインストールするには不十分だからです。繰り返しになるだけですので、
パーティションをすべて作成する作業を見せるのは省略します。

<pre>
&gt; <b>a d</b>
offset: [262143] <b>&lt;Enter&gt;</b>
size: [16124157] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <b>&lt;Enter&gt;</b>
mount point: [none] <b>/tmp</b>
fragment size: [1024] <b>&lt;Enter&gt;</b>
block size: [8192] <b>&lt;Enter&gt;</b>
cpg: [16] <b>&lt;Enter&gt;</b>
&gt; <b>a e</b>
offset: [393183] <b>&lt;Enter&gt;</b>
size: [15993117] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <b>&lt;Enter&gt;</b>
mount point: [none] <b>/var</b>
fragment size: [1024] <b>&lt;Enter&gt;</b>
block size: [8192] <b>&lt;Enter&gt;</b>
cpg: [16] <b>&lt;Enter&gt;</b>
</pre>

<p>
上記の例では、ふたつほど気付く点があります。まず、オフセットが
自動的に計算され、次のところでデフォルトになって待っているということです。
このようなインストールをするなら、オフセットをあれこれと変更する
必要はまったくありません。別の違いとしては、ラベル 'c' はスキップ
されています。これには理由があり、ラベル 'c' はディスク全体を
表わすラベルだからなのです。ですから、ラベル 'c' だけは絶対に
変更してはいけません。

<p>
ラベルが全部できたら、後はそれをディスクに書き込んでインストールを
先に進めましょう。全部書いて disklabel を終了するには
(そしてインストールを続けるには)、次のようにします。


<pre>
&gt; <b>w</b>
&gt; <b>q</b>
</pre>>

<p>
<b>*注*</b> - 巨大なドライブをお持ちの方に。もしあなたの bios が
そのサイズのドライブをサポートできなければ、OpenBSD でもサポート
は無理です。そうでなければ、OpenBSD は問題なくディスクを扱えるはずです。
もし bios がサポートしていないドライブに直面したら、Maxtor EZ-Drive
のようなオーバーレイ製品を試してみると良いでしょう。


<a name="disklabel.3"></a>
<h3>よくある disklabel(8) の使い方</h3>

<p>
いったんシステムのインストールが終わったら、もうあまり disklabel を
使うこともないでしょう。しかし、ディスクを追加、削除、再構成するときなど、
disklabel を使う場合が出てきます。まず最初にやるべきことは、現状の
disklabel を見ることです。これには以下のようにします。

<pre>
# <b>disklabel wd0</b> &gt;----- Or whatever disk device you'd like to view

# using MBR partition 3: type A6 off 64 (0x40) size 16777152 (0xffffc0)
# /dev/rwd0c:
type: ESDI
disk:
label: TOSHIBA MK2720FC
flags:
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 2633
total sectors: 2654064
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # milliseconds
track-to-track seek: 0  # milliseconds
drivedata: 0 

16 partitions:
#        size   offset    fstype   [fsize bsize   cpg]
  a:  2071440    65583    4.2BSD     1024  8192    16   # (Cyl.   65*- 2120)
  b:    65520       63      swap                        # (Cyl.    0*- 65)
  c:  2654064        0    unused        0     0         # (Cyl.    0 - 2632)
  j:   512001  2137023    4.2BSD     1024  8192    16   # (Cyl. 2120*- 2627*)
</pre>

<p>
上記のコマンドは、単に既存の disklabel を許すためのものであり、
間違って変更してしまったりしないよう保証してくれるものです
(これは私たちは、ときどき必要なことでしょう)。しかし、もし変更を
加えたいなら、disklabel で -E オプションを使用しなければなりません。

<pre>
# <b>disklabel -E wd0</b>
</pre>

<p>
これでプロンプトが出てきますが、これは OpenBSD のインストール時に
目にするものと同じものです。このプロンプトで何より大切なコマンドは
'?' でしょう。これは disklabel で使用可能なオプションの
一覧を表示してくれるものです。
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
man ページ全部を見るには、 'M' コマンドを使います。
このプロンプトから、パーティションの追加、削除、
変更すべてを行うことができます。より詳しくは 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
man ページを参照してください。

<a name= "fdisk"></a>
<a name="14.2"></a>
<h2>14.2 - OpenBSD の fdisk を使う</h2>

まず、必ず fdisk の man ページを参照してください。
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>

<p>
Fdisk は、パーティションのメンテナンスを助けてくれるソフトです。この
プログラムはインストール時に使われて、OpenBSD のパーティションを設定します (この
パーティションの中に複数のラベルが設定されて、それぞれがファイルシステムやスワップ等になります)。
ドライブのスペースを区切って、ひとつをアクティブにできます。このプログラムは
通常、シングルユーザモード (つまり boot -s) で使われます。Fdisk はまた、
各種ハードディスクの MBR も設定します。

<p>
インストールするには、ほとんどの場合は OpenBSD パーティションが <b>ひとつ</b>あれば良いでしょう。
それをさらに区切って、スワップやファイルシステムを作成するには disklabel を使います。

<p>
fdisk でパーティションテーブルを見るだけでしたら、次のように

<pre># <b>fdisk fd0</b><br>
</pre>

<p>
と入力すると、次のように出力されます。

<pre>
         Disk: fd0       geometry: 80/2/18 [2880 sectors]
         Offset: 0       Signatures: 0xAA55,0x0
                  Starting        Ending
          #: id  cyl  hd sec -  cyl  hd sec [     start -       size]
        ----------------------------------------------------------------------
         *0: A6    0   0   1 -   79   1  18 [         0 -       2880] OpenBSD
          1: 00    0   0   0 -    0   0   0 [         0 -          0] unused
          2: A7    0   0   2 -   79   1  18 [         1 -       2879] NEXTSTEP
          3: 00    0   0   0 -    0   0   0 [         0 -          0] unused
</pre>

<p>
この例では、フロッピードライブの fdisk 出力を見ています。OpenBSD パーティション (A6) と
そのサイズも見られます。* がついているので、起動パーティションが
OpenBSD パーティションだとわかります。

<p>
前の例では、情報を見ただけですが、では、パーティションテーブルを編集したい場合は
どのようにすれば良いのでしょう ?　そのときには <b>-e</b> フラグを使います。
これによって、コマンドラインプロンプトが出力されて、fdisk が操作可能になります。

<pre>
# <b>fdisk -e wd0</b>
Enter 'help' for information
fdisk: 1&gt; <b>help</b>
        help            Command help list
        manual          Show entire OpenBSD man page for fdisk
        reinit          Re-initialize loaded MBR (to defaults)
        setpid          Set the identifier of a given table entry
        disk            Edit current drive stats
        edit            Edit given table entry
        flag            Flag given table entry as bootable
        update          Update machine code in loaded MBR
        select          Select extended partition table entry MBR
        print           Print loaded MBR partition table
        write           Write loaded MBR to disk
        exit            Exit edit of current MBR, without saving changes
        quit            Quit edit of current MBR, saving current changes
        abort           Abort program without saving current changes
fdisk: 1&gt; 
</pre>

<p> 
fdisk に入っていろいろ試すのは、まったく危険はありません。ただし、
変更を保存するかどうか聞かれた場合には、絶対に <b>N</b> と答え、
<b>write</b> コマンドは使わないようにしてください。

<p><b>-e</b> フラグで使用可能なコマンドの一覧を
以下に挙げておきます。

<ul>
<li><b>help</b>    対話型編集モードで fdisk のわかる
コマンド一覧を表示します。
<li><b>reinit</b>  現在選択中のメモリに入っている
ブートブロックのコピーを初期化します。
<li><b>disk</b>    fdisk がプローブした現在のドライブジオメトリを
表示します。必要なら編集も可能です。
<li><b>setpid</b>  パーティションテーブルの指定エントリの
パーティション ID を変更します。このコマンドは、既存のパーティションを
OpenBSD に再割り当てしたりする場合には特に便利です。
<li><b>edit</b>    現在のブートブロックのメモリ内コピーの、
指定テーブルエントリを編集。BIOS ジオメトリモードで編集することも、
セクターオフセットやサイズで編集することも可能です。
<li><b>flag</b>    パーティションテーブルの指定エントリを起動可能に設定します。
ただし、起動可能に設定できるエントリはひとつだけです。
もし、拡張パーティションから起動したい場合には、その拡張パーティションの
エントリを起動可能にする必要があります。
<li><b>update</b>  現在のブートブロックのメモリ内コピーの
機械コードを更新します。
<li><b>select</b>  現在のブートブロックにある、拡張パーティションテーブルエントリで
示されたブートブロックを、メモリに読み込みます。
<li><b>print</b>   現在選択中のメモリ内のブートブロックのコピーと
その MBR テーブルをターミナルに表示します。
<li><b>write</b>   現在メモリ内にあるブートブロックのコピーをディスクに出力します。
本当に実行してよいかどうか、操作確認が出力されます。
<li><b>exit</b>    現在の fdisk のレベルを終了し、
前に選んだメモリ内のブートブロックのコピーに戻るか、
それがなければプログラムを終了します。
<li><b>quit</b>    現在の fdisk のレベルを終了し、
前に選んだメモリ内のブートブロックのコピーに戻るか、
それがなければプログラムを終了します。exit と異なるのは、
変更したブロックはディスクに出力される点です。
<li><b>abort</b>   現在の変更を保存しないでプログラムを終了します。
</ul>

<a name= "NewDisk"></a>
<a name="14.3"></a>
<h2>14.3 - OpenBSD でディスクを追加する</h2>

<p>
そう、ディスクさえ<b>きちんと</b>インストールされれば、あとは
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;&amp;sektion=8&amp;arch=i386">fdisk(8)</a>
(<i>i386 のみ</i>) と
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
を使用して OpenBSD 用にディスクを設定するだけなのです。

<p>
i386 の人たちは、fdisk から始めてください。他のアーキテクチャの人は、ここをスキップすることができます。
以下の例では、3 個目の SCSI ドライブをシステムに追加しています。
<pre>
# <b>fdisk -i sd2</b>
</pre>
これはディスクの「ほんものの」パーティションを初期化して、
OpenBSD 専用に変える作業です。
続いてここに disklabel を作成します。これは少し面倒かも知れません。
<pre>
# <b>disklabel -e sd2</b>

<i>(画面が消えて、$EDITOR で指定のエディタが起動します)</i>
type: SCSI
<i>うだうだ……</i>
sectors/track: 63
total sectors: 6185088
<i>うだうだ……</i>
16 partitions:
#        size   offset    fstype   [fsize bsize   cpg]
  c:  6185088        0    unused        0     0         # (Cyl.    0 - 6135)
  d:  1405080       63    4.2BSD     1024  8192    16   # (Cyl.    0*- 1393*)
  e:  4779945  1405143    4.2BSD     1024  8192    16   # (Cyl. 1393*- 6135)
</pre>

まず、'c' パーティションは無視します。必ず存在していて、disklabel のような
プログラムが機能するために必要なものですから !  ふつうの操作用なら、fsize は必ず
1024 で、bsize は必ず 8192、cpg は必ず 16 です。Fstype は 4.2BSD です。Total sectors
は、ディスクの総容量となります。たとえば、これが 3 GB のディスクとします。
ディスクメーカの言い方では、3 GB は 3000 MB です。そこで 6185088/3000 の割り算をします
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bc&amp;sektion=1">bc(1))</a>
を使います。答は 2061 です。そこで a, d, e, f, g, ... のパーティションサイズを
計算するには、それぞれ X MB の容量が必要ならば、単に X*2061 のかけ算をすれば
良いのです。最初の新しいパーティションのオフセットは、さっき disklabel
の出力に出てきた「sectors/track」と同じになります。ここでは 63 です。
その後の各パーティションのオフセットは、各パーティションサイズと、
そのパーティションのオフセットを組み合わせたものになります
(ただし 'c' パーティションだけは、現在の式にあてはまるところもないし、
無視しましょう)。

<p>
あるいは、ディスク上にパーティションがひとつだけしか必要ない場合もあります。たとえば、
ディスク全体を Web 保存に使うとか、ホームディレクトリにしたいとかなどです。
この場合には、ディスクの総容量から、トラックあたりのセクター数をひくことで求められます。
6185088-63 = 6185025 ですから、あなたのパーティションは次のようになります。

<pre>
    d:  6185025       63    4.2BSD     1024  8192    16 
</pre>

<b>これが必要以上に面倒だと思うのでしたら、単に disklabel -E を使うことで、
インストール時と同じパーティション切りモードに入れます !</b>
そこで、96 メガバイト必要なら "96M" と指定すれば良いのです (ディスクが巨大なら、
96GB で 96 ギガバイトということです !) 残念なことに、
-E モードは本当のディスクジオメトリではなく、BIOS ディスクジオメトリを使用していて、
この両者が必ずしも一致しないということでしょう。この制約を回避するには、
'geometry disk'の略で 'g d' とタイプします (その他のオプションとしては、'geometry bios' なら 'g b' で、
'g u' とすれば geometry user、つまり disklabel が変更前に
どのような内容になっていたかを表示します)。

<p>
以上、非常に多くの内容でした。しかし、まだ話は終ってはいないのです。
最後に、そのディスク上にファイルシステムを作成しなくてはならないのです。これには、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&amp;sektion=8">newfs(8)</a> を使用します。

<pre>
# <b>newfs sd2a </b>
</pre>

<p>
wd1a のところは、OpenBSD のディスク番号方式で、あなたのディスクの番号に該当するものに置き換えます
(OpenBSD のディスク名称を見たい場合は、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&amp;sektion=8">newfs(8)</a>
の出力を見ます)。

<p>
さて、この作成されたばかりのパーティションをどこにマウントするのかを考えます。たとえば /u にマウントしたいとします。
その場合、まず、/u ディレクトリを作成します。それからそれをマウントするのです。

<pre>
# <b>mount /dev/sd2a /u</b>
</pre>

<p>
最後にそれを
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a> に追加します。

<pre>/dev/sd2a /u ffs rw 1 1</pre>

<p>
では、/usr/local などの既存のディレクトリを移動させたい場合にはどのようにすれば良いのでしょう。
このような場合には、新しいドライブを /mnt にマウントして、<tt>cpio -pdum</tt> を使って /usr/local を
/mnt ディレクトリにコピーします。そして、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a>
ファイルを編集して、/usr/local パーティションが新しい /dev/sd2a
(さきほど新規にフォーマットしたパーティション) になるように変更します。たとえば、

<pre>
<b>/dev/sd2a /usr/local ffs rw 1 1</b>
</pre>

<p>
<strong>boot -s</strong> で、シングルユーザモードで再起動します。既存の /usr/local を /usr/local-backup
に移動します (あるいは、ツキが上向いてる気分ならバッサリ削除しても良いでしょう)。そして、
空のディレクトリ /usr/local を作成してください。そしてシステムを再起動すると、ファイルが
/usr/local に元どおりになっているのがわかります !


<a name= "SwapFile"></a>
<a name="14.4"></a>
<h2>14.4 - ファイルへのスワップ</h2>

<p>
(注: もし、
&quot;virtual memory exhausted&quot; エラーが多数出力されているため、スワップをしようとしているのでしたら、
まずはプロセスごとのリミットを上げてみましょう。csh でしたら
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=unlimit&amp;sektion=1&amp;format=html">unlimit(1)</a>
ですし、sh でしたら
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ulimit&amp;sektion=1&amp;format=html">ulimit(1)</a> です。)

<p>
ファイルへのスワップは、カスタムのカーネルは必要ありませんが、
ビルドし直しても構いません。
この FAQ では、どちらの方法でもスワップスペースを追加する方法を示します。

<h3>ファイルへのスワップ</h3>

<p>
追加のスワップ領域を設定するのに、最も簡単かつ迅速な方法は、ファイルへのスワップを追加することです。
この方法は、Soft Updates が有効になっているファイルシステム上では使用できません
(これはデフォルトでは有効になってはいません)。最初に、まず、今どのくらいのスワップ領域があって、
どれくらいスワップを使用しているのかを調べます。これには
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=swapctl&amp;sektion=8">swapctl(8)</a>
ユーティリティを、次のように使用します。

<pre>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
</pre>

<p>
これは、今、スワップに使用されているデバイスとその現在の統計を示しています。
上記の例では &quot;swap_device&quot; というデバイスがひとつしかありません。
これはディスク上の事前に定義されたスワップ領域です
(disklabel を見るときにはパーティション b として表示されます)。
上記の例でもわかりますが、このデバイスは現状ではあまり使用されてはいません。
しかし、この文章では仮に、
さらに 32MB が必要だということにしましょう。

<p>
ファイルをスワップデバイスとして設定する第一歩は、
そのファイルを作成することです。これは 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&amp;sektion=1">dd(1)</a>
ユーティリティで作成するのが最も良いでしょう。
以下は、大きさ 32MB の <i>/var/swap</i> ファイルを作成しています。

<pre>
$ <b>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</b>
32768+0 records in
32768+0 records out
33554432 bytes transferred in 20 secs (1677721 bytes/sec)
</pre>

<p>
これができたら、そのデバイスへのスワップを有効にします。以下のコマンドを使用して、
このデバイスへのスワップを有効にします。

<pre>
$ <b>sudo chmod 600 /var/swap</b>
$ <b>sudo swapctl -a /var/swap</b>
</pre>

<p>
ここで、作成されたものがスワップデバイスの一覧に追加されたかどうかを
チェックしましょう。

<pre>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
/var/swap        65536        0    65536     0%    0
Total           131056        8   131048     0%
</pre>

<p>
これでファイルが設定されてスワップが行われているので、
<i>/etc/fstab</i> ファイルに記入して、次の起動時にも
このファイルが使用されるようにします。
この一行がないと、スワップデバイスとして設定されません。

<pre>
$ <b>cat /etc/fstab</b>
/dev/wd0a / ffs rw 1 1
/var/swap /var/swap swap sw 0 0
</pre>

<h3>vnode デバイス経由でスワップ</h3>

<p>
これはスワップ領域を追加するさらに恒久的な解決方法です。ファイルを恒久的にスワップするには、
まず vnd0c をスワップにしたカーネルを作成します。カーネルが wd0a を root ファイルシステムに
しているなら、これまでのスワップは wd0b ですから、カーネル設定ファイルで以下のような行を
使用します (疑問があれば、新しいカーネルのコンパイルを参照してください)。 

<pre>
config          bsd     root on wd0a swap on wd0b and vnd0c dumps on wd0b
</pre>

<p>
これが終れば、スワップに使用するファイルを
作成しなければなりません。
これは、上記の例と同じコマンドを使えば良いでしょう。

<pre>
$ <b>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</b>
32768+0 records in
32768+0 records out
33554432 bytes transferred in 20 secs (1677721 bytes/sec)
</pre>

<p>
さて、ファイルができたましたので、そのファイルを
<i>/etc/fstab</i> に追加します。このデバイスが起動時に
スワップデバイスになるための一行は、以下のようになります。

<pre>
$ <b>cat /etc/fstab</b>
/dev/wd0a / ffs rw 1 1
/dev/vnd0c none swap sw 0 0 
</pre>

<p>
この時点でコンピュータを再起動させて、カーネルの変更が反映されるようにします。
これを実行したら、デバイスをスワップとして設定することになります。これには
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&amp;sektion=8">vnconfig(8)</a>
を使用します。

<pre>
$ <b>sudo vnconfig -c -v vnd0 /var/swap</b>
vnd0: 33554432 bytes on /var/swap
</pre>

<p>
そして、最後になりますが、そのデバイスでスワップを有効にします。これは、上記の例とまったく
同じように swapctl(8) を使用しましょう。最後に、それがスワップの一覧にきちんと追加されたかどうかを
確認してください。

<pre>
$ <b>sudo swapctl -a /dev/vnd0c</b>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
/dev/vnd0c       65536        0    65536     0%    0
Total           131056        8   131048     0%
</pre>



<a name= "SoftUpdates"></a>
<a name="14.5"></a>
<h2>14.5 - Soft Update</h2>


<p>
過去数年にわたって、Kirk McKusick は "Soft Update" なるものの
開発を進めてきました。これは Greg Ganger と Yale Patt が
提案したアイディアに基づくもので、バッファキャッシュ操作を
部分的に整理することで、FFS コードからディレクトリのエントリを同期書き込みしなければならない
という要件が除去可能になる、という考え方です。これによって、ディスクへの書き込み性能が
大幅に向上します。

<p>
Soft Update は今も開発中ですから、
コンピュータがきちんと shutdown せずに突然落ちたときには、やはり
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)</a>
が必要なのですが、これは将来的には改善される見込みです。

<p>
Soft Update についてのより詳しいことは、
<a href="http://www.ece.cmu.edu/~ganger/papers/CSE-TR-254-95/">Ganger and Patt</a> や
<a href="http://www.mckusick.com/softdep/index.html">McKusick</a>
の論文を参照してください。

<p>
Soft Update を使用するには、

<p>
<b>option FFS_SOFTUPDATES</b>
<p>
をつけたカーネルをコンパイルしなければなりませんが、これは既に GENERIC には入っています。

<p>
Soft Update を有効にするにはマウント時のオプションで行う必要があります。
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>
ユーティリティでパーティションをマウントする際、このパーティションでは
Soft Update を有効にしたいということを指定することができます。
以下は、Soft Update を使用してマウントしようとしているひとつの
パーティション <i>sd0a</i> を持つ、サンプルの
<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">/etc/fstab(5)</a></i> 
エントリです。

<pre>
/dev/sd0a / ffs rw,softdep 1 1
</pre>

<p>
sparc ユーザへの注意: sun4 や sun4c のマシンでは Soft Update を有効にしてはいけません。
これらのアーキテクチャでは、ごく限られた量のカーネルメモリしかサポートしませんので、
Soft Update を使用することができないのです。
しかし、sun4m マシンなら大丈夫です。


<a name= "D0P3"></a>
<a name="14.6"></a>
<h2>14.6 -  OpenBSD/i386 をインストールして起動すると "Using Drive: 0 Partition: 3"
  で止まるのですが  - i386 のみ</h2>

<p>
これ自体は実はエラーメッセージではなく、MBR に入ってるブートローダが、
どのドライブのどのパーティションから起動しようとしているかということです。
問題なのは、起動がここで止まってしまうということでしょう。

<p>
このようなことが起こる場合のよくある理由がふたつあります。BIOS と
OpenBSD の MBR の非互換性、つまり、ドライブのジオメトリの問題です。
ドライブのジオメトリの問題は、インストールの途中で原因不明で起きること
も報告されていますが、たとえば、ドライブをコンピュータから別のコンピュータ
へ移したり、BIOS をアップデートしたり、BIOS の設定を変更したりしたときに
起きるものです。

<p>
<b>注:</b> OpenBSD 3.1 以降では、BIOS の互換性の問題は、すべてのコンピュータ
システムで仮想的に解決されているはずです。しかしながら、ドライブジオメトリの
問題はまだ存在し得ますので、このメッセージが表示された後で、システムがハング
アップする危険性はまだ残っています。

<p>
BIOS の非互換性の問題を解決するには、ブートローダをシステムに合った
ものにしなければなりません。幸い、ブートローダは
簡単に手に入るものです。

<h3>BootEasy ブートローダをインストールするには</h3>
<p>
まず、システムを起動しなければなりません。ハードディスクから直接起動できない
場合には、ブートフロッピーか CD-ROM で起動する必要があります。
'boot&gt;' プロンプトが出力されたら、ハードディスクからの起動に
切り換えます。

<pre>
reading boot.......
probing pc0 com0 com1 pci mem [639k 79m a20=on]
disk hd0 fd0
&gt;&gt; OpenBSD BOOT 1.28
boot&gt; <b>boot hd0a:/bsd</b>
</pre>
<p>
このコマンドで、最初のドライブの 'a' パーティションにある /bsd
からの起動に切り換わって、システムが起動するようになります。

<p>
<!-- XXXversion -->
システムが起動できたら、BootEasy ブートローダをインストールする必要が
あります。ファイルは CD-ROM か ftp サイトの 
<tt>3.3/tools/booteasy/Boot.bin</tt> ディレクトリ
にありますので、以下のような
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386&amp;format=html">fdisk(8)</a>
コマンドでインストールできます。

<pre>
<!-- XXXversion -->
# <b>fdisk -i -f /mnt/3.3/tools/booteasy/Boot.bin wd0</b>
</pre>
<p>
<!-- XXXversion -->
3.3 の CD を /mnt にマウントしていて、IDE ドライブを使っている場合には、
Boot.bin の場所やどのようなハードディスクを使用しているのか (SCSI
ドライブなら 'sd0' というように) によって、適当に変える必要があります。
<b>注意: ディスクが丸ごと OpenBSD のパーティションではない場合に、
これを実行してはいけません !</b>  MBR をこのように初期化してしまいますと、
OpenBSD のパーティションをディスク全体に広げて他のパーティションを
全部消去してしまうことになりますので、大変なことになります。

<p>
BootEasy には他にも機能がありますので、ブートローダに問題がなくても
使用してみたくなるかも知れません。起動時にブートパーティション
を選択することができます -- これは、どのパーティションから起動するのかを
聞いてきて、何も選ばなければアクティブパーティションから起動します。
ひとつのディスクに複数の OS を入れている場合には、これは非常に便利なものです。
BootEasy をこのようにインストールするには、MS-DOS から CD-ROM か
FTP サーバーの BootEasy のディレクトリにある BOOTINST.EXE を実行してください。

<h3>MS-DOS ブートローダをインストールするには</h3>
<p>
FDISK.EXE の入った Windows 9x か v6 の起動ディスクから起動します。
システムが起動して MS-DOS のプロンプトが出力されたら、次のようにタイプします。

<pre>
A:\&gt;<b>fdisk /mbr</b>
</pre>
<p>
メッセージは何も出力されずに少しだけディスクにアクセスあってからコマンド
プロンプトに戻ってきます。"Bad command or file name" と出た場合には、
FDISK.EXE がディスクにないということです。うまくいけば、
"Using ..." というメッセージを出力していた部分が置き換えられますので、
メッセージは出なくなります。BIOS 互換性の問題があった場合、
これで問題がなくなったはずですから、再起動すれば、OpenBSD のインスールは
うまくいくでしょう。

<p>
FreeDOS でもうまくいくという報告もあります。


<h3>OS-BS ブートローダ</h3>
<p>
別のブートローダの OS-BS は OpenBSD の CD-ROM に入っていますし、
FTP サイトの 2.9/tools/osbs135.exe にもあります。OS-BS の web ページは、
<a href="http://www.prz.tu-berlin.de/~wolf/os-bs.html">
    http://www.prz.tu-berlin.de/~wolf/os-bs.html</a>
です。

<h3>LILO</h3>
<p>
Linux の LILO も使用できます。詳細は以下のところにあります。
<a href="ftp://ftp.openbsd.org/pub/OpenBSD/3.3/i386/INSTALL.linux">INSTALL.linux</a>


<h3>問題を避けるには</h3>
<p>
ほとんどのマシンは BIOS の互換性の問題はありませんが、もし、
この問題があるとわかっているマシンの設定をするのでしたら
問題を避けるのはとても簡単です。普通にインストールしているときに
OpenBSD のローダがシステムにインストールされるのは 'Use entire disk for OpenBSD'
という質問に 'Y' と答えたときだけです。'N' と答えて OpenBSD のパーティションを
手動で作成すれば、fdisk で 'reinit' か' 'update' をしない限りは、
ブートローダが置き換えられることはありません。もちろん、これは何らかの
ブートローダが入っている場合の話です。-- そうでなければ (新品や空のディスクの場合や、
他のプラットフォームから持ってきたドライブのような場合)
システムが起動する前に入れておかなければなりません。


<h3>ドライブのジオメトリの問題を解決するには</h3>
<p>
理想的には、ドライブのジオメトリを直さずに同じジオメトリの
ままにして問題を避けたいと思うでしょうが、それでは避けられない
場合もあります。例えば LBA をサポートしていない古い
コンピュータからどうしても LBA を使う新しいマシンへ
大容量のドライブを移すような場合です。

<p>
上記にあるように、ブートディスクか CD-ROM で起動します。
root でログインして、以下のコマンドを実行してください。

<pre>
# cp /usr/mdec/boot /boot
# /usr/mdec/installboot -v /boot /usr/mdec/biosboot wd0
</pre>
<p>
再起動すれば、うまくいくはずです。

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=installboot&amp;sektion=8&amp;arch=i386">installboot(8)</a>
は
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8&amp;arch=i386">biosboot(8)</a>
をロードするパーティションブートローダ
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">boot(8)</a>
をインストールして設定します。
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">boot(8)</a>
はカーネルを RAM へロードするモジュールです。
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8&amp;arch=i386">biosboot(8)</a> は、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">boot(8)</a>
の物理的な場所 (システムの BIOS による) を指し示すテーブルを持っています。BIOS が感知する
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">boot(8)</a>
の場所を変更するような何かを行った場合には、上にあるように
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=installboot&amp;sektion=8&amp;arch=i386">installboot(8)</a>
を再度実行して
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">boot(8)</a>
を指しているテーブルを再初期化しなければなりません。

<p>
詳しくは <a href="#InstBoot">Install Boot</a> を参照してください。

<a name= "LargeDrive"></a>
<a name="14.7"></a>
<h2>14.7 - OpenBSD での大容量ドライブに関する問題は ?</h2>

<p>
<!-- XXXexpires - この文節は 3.1 がサポートされなくなった時点で書き直しが必要です。 -->
OpenBSD は現在や近い将来入手できるどのようなハードディスクよりも
はるかに大きなサイズのファイルシステムをサポートしていますが、
いくつかのインターフェースでは OpenBSD の理論的な最大値よりも小さな限界があります。
IDE ドライブでは、限界は 128GB で、これは現在一般的な ATA インターフェースの
限界となっています。128GB (1G=2^30 で、1,000,000,000 ではありませんので、
ドライブ製造業者はしばしば 137GB と呼称しています) より大きな容量を持つ次世代の
ATA ドライブは、OpenBSD 3.1 およびそれ以前のバージョンでは
サポートされていないことに注意してください。

<p>
不幸にも、OS がメモリにロードされるまでは OS のすべての能力は使用できませんので、
起動のプロセスそれ自体に限界があります。
起動プロセスはシステムのブート ROM を使用します (また、だからこそそれに制限されるのです)。
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8&amp;arch=i386">biosboot(8)</a>
や
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">boot(8)</a>)
といった OpenBSD/i386 のブートローダも
それ自身の内部的な古い BIOS の限界から来る 8GB の限界が存在しています。

<p>
このような理由で、/bsd ファイル (カーネル) 全体がブート ROM で使用できる
領域内か、ディスクの先頭の 8GB 以内のどちらか小さい方に置かれなて
いなければなりません。これは、いくつかのさらに古い i386 システムでは
root パーティションは、完全に先頭の 504MB 以内になければなりませんが、
ほとんどの新しいコンピュータでは root パーティションは先頭の 8GB 以内の
どこかにあれば良い、という意味です。

<p>
古い 486 に 40GB のドライブを入れてひとつの巨大なパーティションとして
OpenBSD をロードすることもできることに注意しましょう。うまく上記の
規則を破ることができたと思うかも知れません。しかしながら、その規則は
もっとも嫌な具合につきまとってくるかも知れません。

<ul>
  <li>40GB の / パーティションにインストールすると、これはうまく動きます。
      なぜなら OS と (/bsd を含む) すべてのファイルは先頭の 504MB 以内にあるからです。
  <li>システムを使い込んでいくに従って、504MB 以上のファイルが存在するようになります。
  <li>アップグレードの際に自分のカーネルを作成するなどして、新しい
      /bsd を古いものに上書きコピーします。
  <li>再起動します。
  <li>"bad magic" というようなメッセージが出ることになります。
</ul>
<p>
これはどうしてでしょう ?  なぜなら新しい /bsd ファイルを「上書き」コピーしたとき、
古いものを上書きしたのではなく、BIOS がサポートする
504MB の範囲の外にあるであろう新しい領域に再配置されてしまったからなのです。
ブートローダは /bsd ファイルをロードできなくなって、
システムはハングしてしまうのです。

<p>
OpenBSD が起動するようにするには、/bsd がブート ROM がサポートしている
範囲内になければいけません。安全に実行するための規則は単純です。

<p>
<b>root パーティション全体はコンピュータの BIOS (もしくはブート ROM) で使用可能な
領域内か、ディスクの先頭の 8GB 以内のどちらか小さい方に置かれていなければなりません。</b>
現時点では、これに対処するための他の方法はありません。私たちを信じて、このルールを
<i>必ず守ってください</i>。


<p>
これは、単一の巨大なパーティションを使用するより、<a href="../faq4.html#SpaceNeeded">
ハードディスクのパーティションを分割する</a>ことに対するもうひとつの良い理由となっています。


<a name= "InstBoot"></a>
<a name="14.8"></a>
<h2>14.8 - Bootblock のインストール - i386 のみ</h2>

<p>
古いバージョンの MS-DOS は、1024 シリンダ以下のディスクジオメトリにしか対応
していません。最近のディスクはほとんどすべて 1024 シリンダ以上
ありますので、ほとんどの SCSI BIOS チップ (SCSI コントローラボード上にある) と
IDE BIOS (その他 PC BIOS の一部) は、真のディスクジオメトリを MS-DOS が扱える
ようなものに「翻訳」するオプション (ときにはこれがデフォルト) があります。
しかし、BIOS チップの「翻訳」のしかたは必ずしも一致するわけではありません。
もし、BIOS を変えて (マザーボードを交換したとか、SCSI コントローラを交換したとか)、
そして新しい方が使用している「翻訳」ディスクジオメトリが異なっていたら、
第二段階ブートローダが読み込めない (つまりカーネルも読み込めない) ことになります。
(なぜかというと、第一段階ブートローダは /boot の入ったブロック一覧を
持っていますが、これが以前の「翻訳」ジオメトリで記述されているからなのです)。
IDE ディスクを使用していて BIOS 設定を変更した場合にも、翻訳を (うっかり)
変更してしまう場合があります (ほとんどの IDE BIOS は翻訳の仕方を 3 通り持っています)。
ブートブロックを直して普通にブートできるようにするためには、
ドライブに起動フロッピーを入れて (あるいはブート可能な CDROM を使用して)、
boot プロンプトで「b hd0a:/bsd」とタイプして、最初のハードディスク
(フロッピーではなく) から起動してください。これで普通にマシンが起動するはずです。
そうしたら、第一段階ブートローダを更新して、
新しいジオメトリが見えるようにしてください
(そしてそれに応じたブートブロックに書き換えてください)。 <br>
ここでの例では、あなたの起動ディスクが sd0 だと想定しています
(もし IDE なら wd0 等々..)。

<pre>
# <b>cd /usr/mdec; ./installboot /boot biosboot sd0</b>
</pre>

<p>
もし、installboot が BIOS のジオメトリが読めなくてエラーメッセージを出力するようなら、
boot&gt; プロンプトで &quot;machine diskinfo&quot; コマンド (または短く
&quot;ma di&quot;) コマンドを入力して、必要な情報を表示させてください。
&quot;heads&quot; と &quot;secs&quot; の値をそれぞれ installboot の -h
と -s フラグ付きで入力しましょう。このような形で変更した installboot コマンドは
次のようになります。

<pre>
#<b> cd /usr/mdec; ./installboot -h &lt;heads&gt; -s &lt;secs&gt; /boot biosboot sd0</b>
</pre>

<p>
もし、ブートブロックのバージョン更新が必要なら、
それは自分でコンパイルするしかありませんが、その方法は簡単です。

<pre>
# <b>cd /sys/arch/i386/stand/</b>
# <b>make &amp;&amp; make install </b>
# <b>cd /usr/mdec; cp ./boot /boot</b>
# <b>./installboot /boot biosboot sd0</b> (ディスクのデバイスは自分のにあわせて変更してください)
</pre>

<a name= "Backup"></a>
<a name="14.9"></a>
<h2>14.9 - トラブルにそなえよう: テープへのバックアップと復元</h2>

<h3>はじめに</h3>

<p>
たとえば、もし業務用サーバを走らせようとしているのでしたら、
固定ディスクのどれかがクラッシュした場合のために、
何らかのバックアップは取っておくようにしてください。

<p>
ここにある情報は、OpenBSD 附属の通常の
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>/<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>
ユーティリティの使い方を説明しています。
複数のサーバを一本のテープドライブでバックアップするために、
より高度な「Amanda」というソフトもあります。普通の環境では
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>/<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">restore(8)</a>
で十分でしょうが、複数のマシンを一台のテープにバックアップしたい場合には、
Amanda を検討してみてください。

<p>
この文書のデバイス例は、SCSI ディスクとテープを使うような構成のシステムを想定しています。
業務用環境では、不良ブロックの処理の方法から、IDE よりも SCSI が推奨されています。
しかし、IDE や別種のテープドライブを使用している人に
この情報が役に立たないわけではありません。
デバイス名を読み換えることで話は同じになります。
たとえば、SCSI の sd0a は IDE のシステムなら wd0a になります。

<h3>テープにバックアップ</h3>

<p>
テープへのバックアップは、ファイルシステムがどこにマウントされているかという知識が必須になります。
ファイルシステムがどうマウントされているのかについては、シェルプロンプトから
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>
コマンドを使用します。これによって、たとえば、以下のような出力が得られるはずです。

<pre>
# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0h on /usr type ffs (local)
</pre>

<p>
この例では、root (/) ファイルシステムは物理的には sd0a 上にあります。
これは SCSI 固定ディスク 0 のパーティション a です。
/usr ファイルシステムは sd0h 上で、これは SCSI 固定ディスク 0 のパーティション h になります。

<p>
以下は、さらに高度なマウントテーブルの例です。

<pre>
# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0d on /var type ffs (local)
/dev/sd0e on /home type ffs (local)
/dev/sd0h on /usr type ffs (local)
</pre>

<p>
この、さらに高度な例では、root (/) ファイルシステムは物理的には sd0a 上にあります。
/var ファイルシステムは sd0d、/home ファイルシステムは sd0e で、
/usr は sd0h にあります。

<p>
マシンのバックアップには、それぞれの固定ディスクパーティション名を
dump に指定する必要があります。さきほどの簡単な方のマウントテーブルを
バックアップするコマンドは次のようになります。

<pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h</b>
# <b>mt -f /dev/rst0 rewind  </b>
</pre>

<p>
さらに複雑な方のマウントテーブルの例なら
次のようになります。

<pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h</b>
# <b>mt -f /dev/rst0 rewind</b>
</pre>

<p>
それぞれのコマンドラインのスイッチが何を意味するのかについては、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)</a>
man ページを見るのが最も良いでしょう。
上記の例で使用したパラメータの概要を以下に説明します。

<ul>
<li><b>0</b> - レベル 0 でダンプします。つまり全ファイルをダンプします。
<li><b>a</b> - 自動的にテープメディアの長さを決めようとします。
<li><b>u</b> - /etc/dumpdates を更新して、最後にバックアップをした日時を記録します。
<li><b>f</b> - どのテープデバイスを使うかを指定します (ここでは /dev/nrst0)。
</ul>

<p>
そして最後に、バックアップするパーティションが記述されています (/dev/rsd0a, etc)。

<p>
最後に
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mt&amp;sektion=1">mt(1)</a>
コマンドを使用して、ドライブを巻き戻しています。
他のオプション (たとえば eject) については、mt の man ページを参照してください。

<p>
テープデバイス名がよくわからない場合には、dmesg を使用して調べます。
たとえば、dmesg を使った例は次のようになります。

<pre>
st0 at scsibus0 targ 5 lun 0: &lt;ARCHIVE, Python 28388-XXX, 5.28&gt;
</pre>

<p>
バックアップをする場合に、デバイス名が dmesg に出てくる「st0」ではなく
「nrst0」になっているのにお気付きでしょうか ?
st0 に nrst0 としてアクセスした場合は、
同じ物理デバイスにアクセスしていることには違いないのですが、
ジョブの終了後に巻き戻さないことと、デバイスを raw mode でアクセスすることが異なります。
複数のファイルシステムを一本のテープにバックアップするには、
必ず巻き戻さないデバイスを使用してください。
もし巻き戻すデバイス (rst0) を使用した場合には、
バックアップごとにテープが巻き戻されて、前のファイルシステムが上書きされてしまいます。
各種テープドライブについてのより詳しい説明は dump の man ページを参照してください。

<p>
以下は、"backup" を
簡単なスクリプトにした例です。

<pre>
echo "  Starting Full Backup..."
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h
echo
echo -n "  Rewinding Drive, Please wait..."
mt -f /dev/rst0 rewind
echo "Done."
echo
</pre>

<p>
もし、毎晩定期的にバックアップしたい場合には、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=cron&amp;sektion=8">cron(8)</a>
を使用して自動的にバックアップ用スクリプトを起動させます。

<p>
あと、それぞれのファイルシステムがどのくらいのサイズになるかを (紙切れに)
書いておくと役立ちます。それぞれのパーティションがどのくらいの容量を使用しているかを調べるには
df -h を使用します。これを行っておくと、ドライブが壊れてパーティションテーブルを
新しいドライブに再現するときに便利です。

<p>
データをリストアすることで、ファイルの断片化解消にもなります。
ファイル全部を確実にバックアップするには、まず再起動してシングルユーザモードで起動することです。
ファイルシステムは、バックアップするときにマウントしていなくても構いません。
シングルユーザモードで起動したら、root (/) r/w をマウントするのは忘れないようにしてください。
そうしないと、ダンプの日付を書き出そうとするときに dump は失敗します。
シングルユーザモードで起動するには、boot&gt; プロンプトで bsd -s を入力してください。

<h3>dump テープの中身を見る</h3>


<p>
初めてファイルシステムをバックアップしたら、
テープをちょっとテストしてみて、
そこのデータが思い通りのところにあるか確認するようにしてください。

<p>
以下に dump テープ上のファイルの
カタログを見る例を示します。

<pre>
# <b>/sbin/restore -tvs 1 -f /dev/rst0</b>
</pre>

<p>
これで、dump テープの最初のパーティション上にある
ファイルのリストが一覧表示されます。上記の例について
さらに述べるなら、1 というのは root (/) ファイルシステムのことです。

<p>
2番目のテープパーティションに何があるのかを見て、
その出力をファイルに書き込むには次の例のようにしてください。

<pre>
# <b>/sbin/restore -tvs 2 -f /dev/rst0 > /home/me/list.txt</b>
</pre>

<p>
さきほどの単純な方のようなマウントテーブルを持っている場合には 2 は /usr で、
もし高度な方のマウントテーブルならば 2 は /var などの
他のファイルシステムになります。また、シーケンス番号は、
ファイルシステムがテープに書き出された順番と一致します。


<h3>テープからの復元</h3>

<p>
以下に挙げた例題シナリオは、固定ディスクが完全に壊れた場合に便利です。
テープからファイルをひとつだけを復元したい場合には、
restore の man ページを参照して、
対話型モードの指示をよく読んでください。

<p>
もし、きちんと準備をしてあれば、ディスクを交換してテープからデータを復元するのは
とても手早くできます。標準の OpenBSD インストール/起動フロッピーは、
すでに必要な復元ユーティリティも附属していますし、
パーティションを切って新しいドライブを起動可能にするためのバイナリも入っています。
ほとんどの場合、このフロッピーと最新の dump テープがあれば、
それだけでシステムを立て直せます。

<p>
壊れたディスクドライブを物理的に交換したら、
データの復元の基本的なステップは以下の通りです。

<ul>
<li>
<p>
まず、OpenBSD インストール/起動フロッピーから起動し、メニュー選択で
Shell を選択します。そして、最新のバックアップテープを、
書き込み禁止にした上でテープドライブに入れてください。
<br>
<li>
<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>r
コマンドを使用して、新品のドライブにプライマリ
OpenBSD パーティションを作成します。
以下に例を示します。

<pre>
# <b>fdisk -e sd0</b>
</pre>

<p>
詳しくは <a href="#fdisk">fdisk FAQ</a> を参照してください。

<li>
<p>
disklabel コマンドを使用して、今、fdisk で作成したプライマリ
OpenBSD パーティションの中に、OpenBSD パーティションを作成します。
その例を以下に示します。

<pre>
# <b>disklabel -E sd0</b>
</pre>

<p>
(スワップを忘れないようにしてください。詳しくは <a href="#disklabel">disklabel FAQ</a>
を参照してください。)

<li>
<p>
newfs コマンドで、上記ステップで作成したパーティションに新しいファイルシステムを作成します。
以下にその例を示します。

<pre>
# <b>newfs /dev/rsd0a</b>
# <b>newfs /dev/rsd0h</b>
</pre>

<li>
<p>
新品の root (/) ファイルシステムを /mnt にマウントします。以下に例を示します。

<pre>
# <b>mount /dev/sd0a /mnt</b>
</pre>

<li>
<p>
マウントされた root ファイルシステムに移動して、復元プロセスを開始します。
以下に例を示します。

<pre>
# <b>cd /mnt</b>
# <b>restore -rs 1 -f /dev/rst0</b>
</pre>

<li>
<p>
この新しいディスクを起動可能にする場合には、以下のコマンドでドライブに新しい MBR を書き込みます。
以下に例を示します。

<pre>
# <b>fdisk -i sd0</b>
</pre>

<li>
<p>
ドライブに新品の MBR を書くと同時に、起動できるようにブートブロックをインストールしなければなりません。
以下に簡単な例を示します。

<pre>
# <b>cp /usr/mdec/boot /mnt/boot</b>
# <b>/usr/mdec/installboot -v /mnt/boot /usr/mdec/biosboot sd0</b>
</pre>

<li>
<p>
ハードディスクの新しい root ファイルシステムはこれで用意できましたので、
そこから起動して他のファイルシステムのリストアを続けることができます。
OS はまだ完全ではありませんので、必ずシングルユーザモードで
起動するようにしてください。シェルのプロンプトで、
以下のコマンドを使用してアンマウントしてシステムを停止します。

<pre>
# <b>umount /mnt</b>
# <b>halt</b>
</pre>

<li>
<p>
インストール/起動フロッピーをドライブから抜いて、システムを再起動します。
OpenBSD boot&gt; プロンプトで次のコマンドを入力します。

<pre>
boot&gt; <b>bsd -s</b>
</pre>

<p>
bsd -s で、カーネルをシングルユーザモードで起動します。
これには root (/) ファイルシステムだけが必要となります。

<li>
<p>
以上のステップをきちんと実行して、途中で何らかのトラブルがなければ、
プロンプトが出力され、シェルのパスを入力するかリターンを押すことが求められます。
リターンを押した場合は、sh が使用可能になります。次に、root を読み出し専用ではなく
r/w モードでマウントし直すため、以下のコマンドを実行します。

<pre>
# <b>mount -u -w /</b>
</pre>

<li>
<p>
r/w モードで再マウントしましたら、残りのファイルシステムの再現を続けてください。
以下にその例を示します。

<pre>
(単純なマウントテーブル)
# <b>mount /dev/sd0h /usr; cd /usr; restore -rs 2 -f /dev/rst0</b>

(さらに高度なマウントテーブル)
# <b>mount /dev/sd0d /var; cd /var; restore -rs 2 -f /dev/rst0</b>
# <b>mount /dev/sd0e /home; cd /home; restore -rs 3 -f /dev/rst0</b>
# <b>mount /dev/sd0h /usr; cd /usr; restore -rs 4 -f /dev/rst0</b>
</pre>

<p>
ダンプセットから復元されるオブジェクト名をその都度見たい場合には、
単に rsf とするのではなく "<b>restore rvsf</b>" を使用します。

<li>
<p>
最後に、他のファイルシステムを全部ディスクに回復し終えましたら、
マルチユーザモードに移行します。すべてが意図した通りに進んでいたら、
システムは最新のバックアップ時と同じ状態に戻っていて、
また使用可能になっているはずです。
</ul>

<a name= "MountImage"></a>
<a name=14.l0></a>
<h2>14.10 - OpenBSD でディスクイメージをマウントする</h2>

<p>
ディスクイメージ (ISO イメージ、dd で作ったディスクイメージなど)
を OpenBSD でマウントするには、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnd&amp;sektion=4">vnd(4)</a>
デバイスを設定する必要があります。たとえば、ISO イメージが
<i>/tmp/ISO.image</i> にあるとしたら、
マウントするには以下のようにしてください。

<table border=0 width="650">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<pre>
# <b>vnconfig svnd0 /tmp/ISO.image</b>
# <b>mount -t cd9660 /dev/svnd0c /mnt</b>
</pre>
                </td>
        </tr>
</table>

<p>
ポイントとしては、このイメージは CD イメージですので、マウントする場合にはその種類を
<i>cd9660</i> で指定するということです。これはどのような種類のイメージでもそうなのですが、
たとえばディスクイメージをマウントするのでしたら ffs を使用しなければなりません。

<p>
イメージのアンマウントには以下のコマンドを使用します。

<table border=0 width="650">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<pre>
# <b>umount /mnt</b>
# <b>vnconfig -u svnd0</b>
</pre>
                </td>
        </tr>
</table>

<p>
詳しくは
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&amp;sektion=8">vnconfig(8)</a>
man page を参照のこと。


<a name= "pciideErr"></a>
<a name=14.11></a>
<h2>14.11 - 助けて!  PCIIDE でエラーになってしまう !</h2>

<p>
PCI IDE DMA は多くのハードウェアの組み合わせにおいて信頼性が低いものです。
ですので、最近までは、IDE ドライブとの DMA 転送のサポートを謳っている、
ほとんどの「主流」のオペレーティングシステムでも、デフォルトでは
この機能を有効にしていない状態で出荷されていました。

<p>
OpenBSD は積極的で、設定できる最上位の DMA モードを使おうとします。
このようにすることで、ある設定ではバグのあるマザーボードのチップセットや
バグのあるドライブ、ケーブル上のノイズなどの理由によって
データ転送の悪化を引き起こすかも知れません。幸運にも、Ultra-DMA モードは
悪化を検出する CRC によってデータ転送を保護してくれます。Ultra-DMA CRC
が失敗した場合には、OpenBSD はエラーメッセージを出力して、もう一度転送を試みます。

<pre>
wd2a:  aborted command, interface CRC error reading fsbn 64 of 64-79 (wd2 bn 127; cn 0 tn 2 sn 1), retrying
</pre>

<p>
何度か失敗すると、OpenBSD はもっと遅い (そして願わくばもっと信頼できる)
Ultra-DMA モードへと下げます。Ultra-DMA モード 0 まで行ってしまったら、
ドライブは PIO モードへと下げます。

<p>
もし OpenBSD がうまくモードを下げられなかったり、
途中でマシンが固まったりするようでしたら、
<a href="../../ja/report.html">バグの報告</a>を行ってください。

<a name= "IDEDMA"></a>
<h2>14.12 - IDE ディスクに対しての DMA アクセスの強制</h2>

<p>
PCI IDE のコードは、チップセットが何であるのかわからないことがあります。
そのような場合には、次のようなメッセージが出力されます。

<blockquote>
<pre>
pciide0: DMA, (unused)
</pre>
</blockquote>

このメッセージが出力された場合には、カーネルコンフィグレーションファイルの pciide の
エントリに 'flags 0x0001' を使用することで、強制的に DMA モードで使用することができます。
これは次のような行になります。

<blockquote>
<pre>
pciide* at pci ? dev ? function ? flags 0x0001
</pre>
</blockquote>

この設定を行われると、pciide コードは、チップセットが実際にはどのようにして
DMA 転送を行うのかを知っているかどうかに関わらず、DMA モードを使おうとします。
もし、これが動いてシステムが fsck を行って起動すれば、だいたいうまく動いている
と見ても良いでしょう。もし、これが動かなければ、つまり、起動後にハングアップ
したりパニックするようなら、(そのチップセットのサポートがまだ追加されていない
ため)、DMA モードを使用することができないということです。もし、その PCI-IDE
チップセットのドキュメントを見つけたら、その PCI-IDE コントローラチップセットを
完全にサポートできるようにするための良い機会だと考えてください。それは製造業者の
Web サイト上にあるかも知れませんし、電話で聞いてみても良いでしょう。また、もし、
その PCI-IDE コントローラがマザーボードの一部なら、どの製造業者のものかを調べ、
その製造業者のリソースを追いかけましょう。

<p>
次のようなメッセージが表示されることで、DMA サポートが有効化されたことが
わかるということに注意してください。

<blockquote>
<pre>
cd0(pciide0:1:0): using PIO mode 3, DMA mode 1
</pre>
</blockquote>

これは、(ATAPI CD-ROM として見えている) pciide0 の channel 1、drive 0 が
DMA 転送を使用していることを意味します。


<a name= "RAID"></a>
<h2>14.13 - OpenBSD の RAID オプション</h2>
RAID (Redundant Array of Inexpensive Disks) は、一台のディスクだけのときより、
より良い性能や、容量、そして冗長性を得るために、複数台のディスクを使うための
仕組みです。
RAID の特質についての詳細な議論は、この文章の範囲外ですが、ふたつの重要な点だけは
ここで明確にしておきましょう。

<ul>
<li>RAID はバックアップについては何もしない。
<li>RAID 自身はダウンタイムを短縮してくれるわけではない。
</ul>

もし、これがあなたにとって新しい情報だったりしたら、これはあなたにとって、
RAID の冒険のための良い出発点ではありません。

<h3>ソフトウェアオプション</h3>
OpenBSD は、ソフトウェア RAID である RAIDframe を含んでいます。
これについてのドキュメントは以下の場所にあります。

<ul>
<li><a href="faq11.html#raid">FAQ 11, RAID</a>
<li><a href="http://www.pdl.cmu.edu/RAIDframe/">RAIDframe ホームページ</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;sektion=8">raidctl(8)
     man ページ</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">raid(4)
     man ページ</a>
</ul>

<p>
<!-- XXXexpires - この文節は 3.1 がサポートされなくなった時点で書き直しが必要です。 -->
OpenBSD 3.1 では、RAIDframe の "Autoconfiguration" オプションを使用して、
直接 root パーティションをミラーリングすることが可能になりました。
OpenBSD の以前のリリースでは、この方法で root パーティションを
ミラーリングすることはできませんでした。

<h3>ハードウェアオプション</h3>
<p>
多くの OpenBSD の <a href="../../ja/plat.html">プラットフォーム</a> は、
いろんな種類のハードウェア RAID 製品をサポートしています。
これはプラットフォームによって変わりますので、ハードウェアサポート
ページ (<a href="../../ja/plat.html">ここ</a> にリストがあります) を見てください。

<p>
もうひとつ、複数のドライブを一台の IDE や SCSI のドライブとして見せて、
これを標準の IDE や SCSI アダプタに接続して使うタイプの多くの製品が、
多くのプラットフォームで利用可能です。
これらのデバイスは、SCSI や IDE をサポートしている
どのようなハードウェアプラットフォームでも仮想的に動作できます。

<p>
これらの製品のいくつかの製造業者は次のとおり。
<ul>
<li><a href="http://www.arcoide.com/">Arco</a>
<li><a href="http://www.maxtronic.com/">Maxtronic</a>
<li><a href="http://www.infortrend.com/">Infortrend</a>
</ul>
(注: これらは OpenBSD のユーザが使えることをレポートしてくれた
製品というだけですので、その使用を推奨しているわけではありませんし、
徹底したリストというわけでもありません。)


<h3>Non-Options</h3>
<p>
<a href="../../ja/mail.html">メーリングリスト</a>上で、ときどき繰り返される質問として、
「Promise や HighPoint の IDE RAID コントローラはサポートしているのか ?」というのがあります。
しかし、その答は "No" です。これらのカードやチップはほんとうのハードウェア RAID コントローラ
ではなく、むしろ、これは、BIOS の助けを借りてブートするソフトウェア RAID だからななのです。
既に OpenBSD は、ハードウェアに依存しない方法でソフトウェア RAID をサポートしているのですから、
OpenBSD の開発者の間では、これらのカードの特別なサポートを実装しようという気には
ならないのです。

<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ の目次]</a>
<a href= "faq13.html">[13 章 - IPsec]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt="[back]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
Originally [OpenBSD: faq14.html,v 1.83 ]
<br>
$Translation: faq14.html,v 1.27 2003/05/10 01:03:42 toshi Exp $
<br>
$OpenBSD: faq14.html,v 1.27 2003/05/10 13:21:29 jufi Exp $
</small>

</body>
</html>
