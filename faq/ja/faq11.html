
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>11 - Performance Tuning</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-2022-JP">
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2003 by OpenBSD.">
</head>

<body bgcolor= "#ffffff" text= "#000000">

<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif">
<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ の目次]</a>
<a href= "faq10.html">[10 章 - システム管理]</a>
<a href= "faq12.html">[12 章 - 上級ユーザのために]</a>
</font>

<h1><font color="#e00000">11 - パフォーマンスチューニング</font></h1>
<hr>

<p>
<h3>目次</h3>
<ul>
<li><a href="#Network">11.1 - ネットワーキング</a>
<li><a href="#Disk"   >11.2 - ディスク I/O</a>
<!-- li><a href="#kmem"   >11.3 - kmem のチューニング</a></li -->
<li><a href="#HW"     >11.4 - ハードウェアの選定</a>
<li><a href="#Async"  >11.5 - なぜ私たちは非同期マウントを使用しないのしょう ?</a>
<li><a href="#XF86"   >11.6 - XFree86 におけるモニタ解像度の
チューニング</a>
</ul>

<hr>

<p>
もし、あなたがビジーなサーバやゲートウェイ、ファイアウォールを運用しているのなら、最適な性能を
得るために、いくつかのパラメータを調整したいと思ったり、あるいはその必要性に迫られるかも知れません。
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=options&amp;sektion=4">options(4)</a> 
man ページでは、カーネルオプションについて説明しています。これらのオプションは、カスタムカーネルを
コンパイルする前のカーネルコンフィグレーションファイルに存在するもので、これらのいくつかについては、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=config&amp;sektion=8">config(8)</a>
でも設定可能なものです。
より詳しくは、<a href="../faq5.html">FAQ 5</a> を参照してください。


<p>
<a name= "Network"></a>
<a name= "11.1"></a>
<h2>11.1 - ネットワーキング</h2>
<!-- XXXchanges - changes with OpenBSD 3.3 -->

<p>
ビジーなサーバ、ゲートウェイあるいはファイアウォール用に変更する必要があるかも知れないパラメータは
NMBCLUSTERS でしょう。これは、カーネルの mbuf クラスタのマップを制御するためのものです。
もし、"mb_map full" のようなメッセージが、あなたのコンピュータ上に表示された場合には、
このパラメータの値を増加させる必要があります。
もし、ネットワークインターフェイス上のトラフィックが明確な理由もなしに停止してしまうような場合には、
やはり、この NMBCLUSTERS の値を増加させる必要があるというサインかも知れません。
100Mbps の Ethernet インターフェイスを持つ i386 ポートの場合 (いかに多くをマシンが持っていようとも)、
このパラメータのリーズナブルな値は 8192 です。

<blockquote><strong>
option NMBCLUSTERS=8192
</strong></blockquote>

<p>
各種プラットフォームにおける NMBCLUSTERS のデフォルト値のレンジは 256 から 2048 です。
これは、カーネルコンフィグレーションファイルのオプション行で上書きされない限りは、
プラットフォーム依存のヘッダファイルに設定されている値です。

<p>
NMBCLUSTERS も
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=config&amp;sektion=8">config(8)</a>
を使用して設定可能であり、単にこのオプションを変更するためだけに
カーネルを再構築してリブートする必要がなくなりました。

<blockquote><pre>
# <b>config -e -o bsd.new /bsd</b>
OpenBSD 3.3 (GENERIC) #44: Sat Mar 29 13:22:05 MST 2003
    deraadt@i386.openbsd.org:/usr/src/sys/arch/i386/compile/GENERIC
Enter 'help' for information
ukc> <b>nmbclust</b>
nmbclusters = 2048
ukc> <b>nmbclust 8192</b>
nmbclusters = 8192
ukc> <b>quit</b>
Saving modified kernel.
</pre></blockquote>

これによって、カレントディレクトリに新しいカーネル <tt>bsd.new</tt>
が生成され、<i>さらに</i>、現在稼働中のカーネルの NMBCLUSTERS パラメータが
更新されます。これが成功した後、リブートの前に <tt>bsd.new</tt> を
<tt>/bsd</tt> にコピーしておくことをお忘れなく。


<p>
<a name= "Disk"></a>
<a name= "11.2"></a>
<h2>11.2 - ディスク I/O</h2>

<p>
ディスク I/O の速度は、コンピュータ全体の速度に与える影響が非常に大きい要素です。
(会話的にログインするユーザから、ファイルサーバや web サーバとして使用するユーザまで、
あらゆる種類のユーザを) ホスティングするマルチユーザ環境のコンピュータにおいて、
これはますます重要なものとなってきています。
データストレージは、特にパーティションの容量オーバーやディスク故障等、常に注意を
払う必要のあるものです。OpenBSD には、ディスクアクセス速度や耐故障性を向上させる
いくつかのオプションが用意されています。

<p>
目次
<ul>
<li><a href="#ccd">CCD</a> - Concatenated Disk Driver
<li><a href="#raid">RAID</a>
<li><a href="#buf">ファイルシステムバッファ</a>
<li><a href="#softu">Soft Updates</a>
<li><a href="#maxvnodes">namei() キャッシュのサイズ</a>
</ul>

<p>
<a name="ccd"></a>
<h3>11.2.1 - CCD</h3>

<blockquote>
最初のオプションは、<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccd&amp;sektion=4">ccd(4)</a> (Concatenated Disk Driver) を使用することでしょう。
これは、いくつかのパーティションをひとつの仮想ディスクに (そして同様にして、いくつかの
ディスクをひとつのディスクであるかのように) まとめることができるものです。
このコンセプトは、多くの商用 Unix に見られる LVM (論理ボリューム管理) と同様のものです。

<p>
GENERIC カーネルの場合、CCD は (<tt>/usr/src/sys/conf/GENERIC</tt> で)
既に有効化されています。もし、カーネルをカスタマイズしている場合には、
この設定をカーネルコンフィグレーションに戻す必要があるかも知れません。
いずれの場合も、カーネルコンフィグレーションに以下のような行が必要です。

<pre>
     <strong>pseudo-device   ccd     4       # concatenated disk devices</strong>
</pre>

<p>
上記の例では、4 個までの CCD デバイス (仮想ディスク) を設定可能となります。ここであなたは、
実際のディスク上のどのパーティションを CCD のために使用するのか決定しなければなりません。
disklabel を使用して、これらのパーティションに 'ccd' という型を設定してください。
ある種のアーキテクチャでは、disklabel でこのようなパーティションタイプを設定できないかも
知れません。このような場合、これらは 'ffs' としておいてください。

<p>
もし、ストライピングによって性能を向上させるために CCD を使用するのでしたら、同じモデルの
ディスクを使用して同じ disklabel の設定で使用しない限りは、最適の性能を得ることはできない
ということに注意してください。

<p>
たとえば、以下のように /etc/ccd.conf を編集してください (CCD を構成する上でのより詳しい情報は
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccdconfig&amp;sektion=8">ccdconfig(8)</a>
を参照してください)。

<blockquote><pre>
# Configuration file for concatenated disk devices
#
# ccd   ileave  flags   component devices
ccd0   16      none    /dev/sd2e /dev/sd3e
</pre></blockquote>

<p>
変更結果を反映させるために、次のコマンドを実行してください。

<blockquote><pre>
# ccdconfig -C
</pre></blockquote>

<p>
/etc/ccd.conf が存在していれば、CCD はブート時に自動的に
構成されます。
これで、/dev/sd2e と /dev/sd3e が結合された新しいディスク ccd0 ができあがります。
disklabel を使用して、お望みのとおりのパーティションを作成してください。
繰り返しますが、データ等を置くための実際のパーティションとして、
'c' パーティションを使用してはいけません。
また、使用可能なパーティションが、ディスクの先頭から少なくとも 1 シリンダ分は
離れていることを確認しておいてください。
</blockquote>

<p>
<a name="raid"></a>
<h3>11.2.2 - RAID</h3>

<blockquote>
もうひとつのソリューションである
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">raid(4)</a> は、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;sektion=8">raidctl(8)</a>
を使用して RAID デバイスを制御します。
OpenBSD の RAID は、CMU の <a href="http://www.pdl.cmu.edu/RAIDframe/">RAIDframe</a> ソフトウェアの
Greg Oster の手による <a href="http://www.cs.usask.ca/staff/oster/raid.html">NetBSD への移植版</a>
をベースにしたものです。OpenBSD では、0、1、4 および 5 の RAID レベルをサポートしています。<p>
CCD と同様、RAID もまた、カーネルのサポートが必要となります。
また、CCD とは異なり、RAID のサポートは GENERIC カーネルには含まれていませんので、カスタムカーネルを
構築する必要があります (RAID サポートは i386 カーネルの場合で 500K 以上のサイズの増加となります)。

<blockquote><pre>
<strong>pseudo-device   raid   4       # RAIDframe disk device</strong>
</pre></blockquote>

<p>
いくつかのオペレーティングシステムにおける RAID の設定は、控え目に見ても
混乱するものですし、また苦痛でもあります。しかし、RAIDframe はそうではありません。
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">raid(4)</a> と
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;sektion=8">raidctl(8)</a>
についての詳細な情報については、これらの man ページをお読みください。非常に多くのオプションや
可能なコンフィグレーションがありますが、これについての詳細な記述はこのドキュメントの範囲外です。
</blockquote>

<p>
<a name="buf"></a>
<h3>11.2.3 - ファイルシステムバッファ</h3>

<blockquote>
メモリに余裕のあるファイルサーバなら、BUFCACHEPERCENT を増加させることができます。
これは、ファイルシステムバッファとして使用すべき RAM のパーセンテージを指定するものです。
このオプションは、OpenBSD の一部である Unified Buffer Cache が完成した後、
変更されるかも知れません。それまでは、BUFCACHEPERCENT を増加させるためには、
カーネルコンフィグレーションファイルに以下のような行を加えます。
</blockquote>

<blockquote>
<strong>option	BUFCACHEPERCENT=30</strong><BR>
</blockquote>

<blockquote>
もちろん、これは最低で 5 パーセント (デフォルト) から最高で 50 パーセント
(あるいはそれ以上) くらいまで設定することができます。
</blockquote>

<blockquote>
BUFCACHEPERCENT も<a href="#Network">上記</a>のように
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=config&amp;sektion=8">config(8)</a>
を使用して設定可能であり、単にこのオプションを変更するためだけに
カーネルを再構築する必要がなくなりました。</blockquote>

<p>
<a name="softu"></a>
<h3>11.2.4 - Soft updates</h3>

<blockquote>
あなたのシステムをスピードアップすることができる、もうひとつの道具として soft update があります。
伝統的な BSD のファイルシステムにおける最も遅い動作のひとつに、メタデータの更新作業を
挙げることができます (これは、運転中に、あなたがファイルやディレクトリを生成したり
消去したりした際に、発生する作業です)。
soft update は、それぞれの単一のメタデータの更新を毎回ハードディスクに書き込む代わりに、
RAM 上のメタデータの更新を試みます。
その副作用として、ディスク上のメタデータは常に完全に保たれますが、
常に最新に保たれるわけではありません。ですので、システムクラッシュの後、ブート時に
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)</a>
が必要ではなく、単にバックグラウンド版の fsck を (soft update 流に) RAM 上のメタデータの
変更のために実行するだけで良くなります。
この機能は、fsck の実行を待つ必要がないので、サーバの起動が非常に高速になるということを
意味するのです (OpenBSD には、まだこの機能は実装されていません)。soft update に関する
より詳しいことは、<a href="faq14.html#SoftUpdates">Softupdates FAQ</a> エントリを参照してください。
</blockquote>

<p>
<a name="maxvnodes"></a>
<h3>11.2.5 - namei() キャッシュのサイズ</h3>

<dl>
<dd>
注: 以前は、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=options&amp;sektion=4">options(4)</a>
の man ページで、<tt>NVNODE=integer</tt> カーネルオプションの設定が推奨されていましたが、 
もはやこれは推奨されなくなり、今では、その代わりに
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
コマンドを使用すべきでしょう。
<p>
名前から inode への変換 (いわゆる namei())
キャッシュは、パス名から
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inode&amp;sektion=5">inode(5)</a>
への変換の速度を制御します。デフォルトでは、このキャッシュは <tt>NPROC * (80 + NPROC / 8)</tt>
というエントリを持っており、<tt>NPROC</tt> は <tt>20 + 16 * MAXUSERS</tt> になっています。
<tt>maxusers</tt> カーネルコンフィグレーションパラメータに関する記述を参照するためには、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=config&amp;sektion=8">config(8)</a>
を参照してください。
キャッシュの値を導出するためのリーズナブルな方法は、namei() の喪失が大きな値になってきた場合に、
("<tt>kern.maxvnodes</tt>" というパラメータを読む)
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
を使用して計算された、システムの現在の値を調べるための
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=systat&amp;sektion=1">systat(1)</a>,
のようなツールによって注意が出されるべきであり、この値を namei() キャッシュのヒットレートが
改善されるか、システムが namei() キャッシュの増加の恩恵を実質的に受けていないと判断されるまで
増加させることです。
この値が決定されたら、
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5">sysctl.conf(5)</a>.
に設定することで、システムの起動時に設定することができます。
</dd>
</dl>


<p>
<!-- a name= "kmem"></a>
<a name= "11.3"></a>
<h2>11.3 - Tuning kmem</h2>
This was moved to the <a href="../faq11-2.5.html#11.2">OpenBSD 2.5 information section</a>.
<br>
<p -->
<a name= "HW"></a>
<a name= "11.4"></a>
<h2>11.4 - ハードウェアの選定</h2>
<!-- XXXchanges - check every OpenBSD release -->

<p>
<i>(注: この章は、i386 あるいは PC のアーキテクチャ関連に重点的に焦点を当てたものです。
言い換えるなら、他のアーキテクチャはあなたにあまり多くの選択肢を与えてはくれません !)</i>

<p>
アプリケーションの性能は、あなたの使用する OS と、
それが提供する機能に大きく依存します。これこそ、
あなたが OpenBSD を使用する理由のひとつであるのかも知れませんね。
また、アプリケーションの性能は、あなたの使用するハードウェアにも大きく依存します。
多くの人々にとって、Intel Pentium IV や AMD Athlon プロセッサが
搭載された新品の PC の価格/性能比は、Sun UltraSparc 60 のそれと
比べて、非常に良いものでしょう。
もちろん、OpenBSD の価格が問題になることはないでしょう。

<p>
もし、あなたが新しい PC を購入する場合、ひとつひとつの構成部品を買い集めるか、あるいは
すべて一式で買うかのどちらかだと思いますが、いずれにせよ、信頼性の高いものを買おうとしているのだ
ということを最初に確認しておきたいのではないでしょうか。しかし、PC の世界では、
これは簡単なことではありません。<b>不良品だったり、信頼性の低いものだったり、あるいは
相性問題のある部品だったりすると、OpenBSD の性能が出なかったり、しばしばクラッシュしたり
することになり兼ねません。</b> 私たちにできる最良のアドバイスは、よく注意すること、
そしてブランド品、あるいは、あなたが信頼する専門家が評価した部品を買うことでしょう。
たまに、PC の価格をケチってしまって、品質を落としてしまうことがあります。

<p>
ここには、あなたのハードウェアに最大の性能をもたらすための
助けになる、確かなことが書かれています。

<ul>
<li><b>複数のディスクを使用しましょう。</b>
一台の大容量ディスクを購入する代わりに、複数の小容量ディスクを買いましょう。これには、より多くの
費用がかかりますが、複数のディスクによって負荷が分散されることで、ディスク上のデータにアクセスするのに
必要な時間全体を減少させてくれることでしょう。また、さらに多くのディスクを使用した RAID によって、
より高い信頼性とより高速なデータアクセスが可能になります。
<p>
<li><b>より高性能なディスク I/O 速度が必要なら、SCSI ディスクを使用しましょう。</b>
IDE ディスクのスピンドルモータの回転数は、通常 5400rpm から 7200rpm です。
最良の IDE ディスクを使用しても、一台のディスクから 1 秒間に 15MB 〜 20MB
以上のスループットを引き出すことは難しいかも知れません。
最高性能の SCSI ディスク (より高価な 10000rpm 〜 15000rpm のディスク) なら、
これより高い性能を亨受可能です。
逆に言えば、中くらいの性能または低性能の SCSI ディスクを使用しているのでしたら、
それはお金の無駄遣いであり、IDE デスクでも、より良いというわけではないものの、
同等の効果が得られることでしょう。
<p>もし、サーバを構築するのでしたら、そして、複数台のドライブが必要なのでしたら、SCSI の利用を考えたいと
思うのではないでしょうか。IDE はひとつのコントローラに接続可能なディスク数が 2 台までという制限がありますので、
これらの 2 台のディスクへの同時アクセスは、これらのディスクの I/O 性能に対する、負のインパクトになると考えられます。
これが Wide SCSI でしたら、ひとつのコントローラに対して 15 台まで接続可能であり、IDE より良好な
同時アクセスに対するサポートがあります。SCSI の価格は高価ですが、その柔軟性と性能によって、
利用環境次第ではこれらの費用を最適化することもできるでしょう。
<p>
<li><b>DRAM ではなく SDRAM を使用しましょう。</b>
この選択肢は、主に PC に対して適用されるものです。他のほとんどのアーキテクチャでは、どのような RAM
を使用するかという選択肢をあなたに与えてくれることはないでしょう。いくつかの PC についても同様です。
DRAM (SIMM) に比べて、SDRAM ならより良い性能を得ることができるでしょう。
もし、あなたのシステムが RDRAM、DDR や他のいくつかの新しいタイプの RAM をサポートしているのでしたら、
さらに高速なマシン性能を得られることになります。
<p>
<li><b>ECC かパリティ付きの RAM を使用しましょう。</b>
パリティは、RAM の中のデータが汚染されてしまったかどうかを検出するための機能を
付加してくれます。また、ECC はこの機能性をさらに拡張して、汚染されて変化してしまった
いくつかのビットを、稼働しながら修正しようと試みます。
この選択肢も、主に PC に対して適用されるものです。他のほとんどのアーキテクチャでは、最初から
パリティ付きや ECC の機能が RAM に要求されるだけです。いくつかの PC ではないコンピュータでは、
ノンパリティの RAM ではブートしてくれないこともあります。
もし、ECC やパリティ付きの RAM を使用しないのでしたら、データの汚染や他の異常自体に
遭遇してしまうかも知れません。「安ものの PC 用 RAM」を製造するいくつかの製造業者の場合、
各種 ECC を製造してはいないでしょう。このようなところの製品は避けましょう。
PC の製造業者は、しばしば、「サーバ」や「ワークステーション」などに分かれた、
いくつかの製品ラインの販売を行っています。サーバ製品では、そのアーキテクチャに ECC RAM
を組み込んでいることでしょう。また、Unix ワークステーションの製造業者では、彼らのすべての
製品ラインに対して、パリティ付き (そして、現在では ECC) の RAM を何年も前から使用しています。
<p>
<li><b>ISA デバイスは避けましょう。</b>
ISA デバイスは、一般的に構成が難しく、時代遅れのものであることから、多くの人々がこれらを避けていますが、
まだまだ数多く存在しているものです。もし、ディスクデバイスやネットワークデバイスのコントローラ用に
(それどころか、その両方で) ISA バスを使用しているのでしたら、ISA バス自身がボトルネックになっている
ということを覚えておいてください。もし、スピードが必要なら、PCI を検討してください。
もちろん、今でもいくつもの ISA バスカードが立派に稼働可能であることも事実です。
不幸にも、これらの多くはサウンドカードであったりシリアルポートカードであったりします。
<p>
<li><b>安ものの PCI ネットワークアダプタは避けましょう。</b>
OpenBSD は非常に多くの安ものの PCI ネットワークアダプタもサポートしています。
これらのアダプタは家庭用システム用には十分に使用可能なものであり、低い、穏かなスループットの
ビジネスや研究用環境でも使用可能でしょう。
しかし、高いスループットやサーバに対する負荷が小さいことを必要としているのでしたら、高品質の
PCI ネットワークアダプタを購入する方が良いでしょう。不幸にも、(3com XL シリーズのような)
いくつかの高級ブランドもののアダプタが、安もののアダプタより非常に良いというわけではない
こともあります。
有名な 10/100Mbps アダプタとしては、Intel EtherExpress PRO/100 が挙げられます。
</ul>


<p>
<a name= "Async"></a>
<a name= "11.5"></a>
<h2>11.5 - なぜ私たちは非同期マウントを使用しないのでしょう ?</h2>

<p>
質問: 「私が使用中の、(その実行中に数百のものを触る必要のある) あるパッケージを
使い易いものにするために、私は簡単に "mount -u -o async /" を実行しました。

どうして非同期マウントは難色を示され、また (他の Unix ライクな OS がそうであるように)
デフォルトで有効になっていないのでしょうか ?  これは非常に簡便であり、それが故に、
ある種のアプリケーションの性能を改善してくれる、より安全な方法ではないのでしょうか ?」

<p>
回答: 「非同期マウントは同期マウントより実に高速ではありますが、安全性という点では劣ります。
電源が落ちたりハードウェアが故障したりした場合に、いったい何が起きるでしょう ?
こうしたスピードのための模索は、システムの信頼性や安定性を犠牲にするものであってはいけません。
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)</a>
の man ページを調べてみてください。」

<pre>
	     async   All I/O to the file system should be done asynchronously.
		     This is a dangerous flag to set since it does not guaran-
		     tee to keep a consistent file system structure on the
		     disk.  You should not use this flag unless you are pre-
		     pared to recreate the file system should your system
		     crash.  The most common use of this flag is to speed up
		     restore(8) where it can give a factor of two speed in-
		     crease.
</pre>

<p>
言い換えれば、クラッシュしても、一から再生成できるような一時データを処理しようと
しているのでしたら、非同期マウントを使用した別のパーティションを用意することで、
処理速度を向上させることが可能になる、ということです。繰り返しますが、これは、何か
問題が発生して、パーティション内の全データを損失しても気にしない場合に<i>のみ</i>、
実行するようにしてください。このような理由から、
<a href= "http://www.openbsd.org/cgi-bin/man.cgi?query=mfs&amp;sektion=8">mfs(8)</a>
パーティションはリブートすることで必ず初期化され、再生成されることになるので、
非同期でマウントされます。


<p>
<a name= "XF86"></a>
<a name= "11.6"></a>
<h2>11.6 - XFree86 におけるモニタ解像度のチューニング</h2>

<p>
多くのマルチシンクモニタが受け付けてくれる解像度で動くよう、X サーバを設定することは
可能です。しかし、もし、標準的な xf86config や XF86Setup ユーティリティを使用して
その設定を試みても、たぶん考え得る最良の結果を得ることはできないでしょう。
さらに手間のかかる作業のひとつとして、使用中のモニタで単純に好みの解像度を得る
というのがあり、
そして、
人間の目にはほとんどチラつきの見えない垂直同期のレートである、
少なくとも 72 〜 75Hz くらいの値に設定するというのがあります。
また逆に、垂直同期レートが非常に低くなるように設定しようと試みる場合、どのようにするのでしょう ?
フリッカーなしでビデオにキャプチャーできるからといって、これを 50Hz に設定することもできるのですが、
このように設定する方法は、標準的な XFree86 のツールやドキュメントの中では
明らかにされていません。

<p>
最後に、高価ではない VGA モニタ上で、多くの人が通常使用する解像度
(800x600、1024x768、1152x900、1280x1024)
において、非常に美しい、心地良い画像を実現するために、85Hz 以上の垂直同期レートを使用することが
(少なくとも新しい目のモニタなら) 可能です。
XFree86 の X サーバには、使用したいビデオモードの詳細を記述するためのメカニズムが用意されており、
それが ModeLine です。ModeLine には 4 個のセクションがあり、これにはドットクロック用のひとつの数字、
水平同期用の 4 個の数字、垂直同期用の 4 個の数字、および
(インターレースやダブルスキャンなどのような)
モードの他の特性を指定するためのフラグのリストのオプションのセクションがあります
(ModeLine の詳細については、XF86Config(5) のマニュアルページを参照してください)。

<p>
ModeLine の生成は魔法のようなものですが、幸いなことに、この作業を代行してくれる、
いくつかのスクリプトがあります。そのひとつに、
<a href="http://www-sop.inria.fr/cgi-bin/koala/nph-colas-modelines">Colas XFree86 ModeLine Generator</a>
があります。他にも、SourceForge がホストの
<a href="http://xtiming.sourceforge.net/">The XFree86 Modeline Generator</a>
や、<a href="http://freshmeat.net/search/?q=modeline">Freshmeat</a> にも
他のいくつかのものがあります。
これらの ModeLine 生成スクリプトを使用する前に、使用するモニタの垂直同期と
水平同期の限界値を把握しておく必要があります。これは、しばしば、マニュアルや
製造業者の web サイトに記述があります。これらのどちらも見つけられなければ、
単にモニタのメーカーやモデルを web で検索してみましょう。親切にも、
このような情報をリストにしておいてくれる人々が見つかるかも知れません。

<p>
たとえば、Dell の D1226H モニタを持っているとしましょう。このモニタの水平同期の範囲が
30 〜 95kHz で垂直同期の範囲が 50 〜 160Hz であるということを見つけるために、苦労して
Dell の web サイトを検索したとします。ここで ModeLine 生成のためのページを訪れて、
この情報を入力しましょう。次に、使用したい最小の垂直同期のレートを
入力します。72Hz 以上のどのようなレートでも、一般的には目に見えるチラつきは
わずかなものになります。より高いものなら、さらにクリアでより鮮明な
スクリーンイメージになります。

<p>
これらのすべての断片的な情報でも、先ほど入力した最小の垂直同期のレート以上で、
モニタがサポート可能な 4 × 3 の解像度のそれぞれに対して、スクリプトは
ModeLine を生成してくれるでしょう。もし、上記の Dell のモニタのスペックと
最小の垂直同期レートとして 75Hz を入力したとすると、スクリプトはたとえば
次のような ModeLine を出力するでしょう。

<pre>
ModeLine "320x240" 20.07 320 336 416 448 240 242 254 280 #160Hz
ModeLine "328x246" 20.86 328 344 424 456 246 248 260 286 #160Hz
...
ModeLine "816x612" 107.39 816 856 1056 1136 612 614 626 652 #145Hz
ModeLine "824x618" 108.39 824 864 1064 1144 618 620 632 658 #144Hz
ModeLine "832x624" 109.38 832 872 1072 1152 624 626 638 664 #143Hz
...
ModeLine "840x630" 109.58 840 880 1080 1160 630 632 644 670 #141Hz
ModeLine "848x636" 110.54 848 888 1088 1168 636 638 650 676 #140Hz
...
ModeLine "1048x786" 136.02 1048 1096 1336 1432 786 788 800 826 #115Hz
ModeLine "1056x792" 136.58 1056 1104 1344 1440 792 794 806 832 #114Hz
ModeLine "1064x798" 137.11 1064 1112 1352 1448 798 800 812 838 #113Hz
...
ModeLine "1432x1074" 184.07 1432 1496 1816 1944 1074 1076 1088 1114 #85Hz
ModeLine "1576x1182" 199.86 1576 1648 2008 2152 1182 1184 1196 1222 #76Hz
ModeLine "1584x1188" 198.93 1584 1656 2016 2160 1188 1190 1202 1228 #75Hz
</pre>

<p>
今、このモニタが 1600x1200 @ 75Hz を要求していて、しかし、スクリプトは
75Hz 以内であるとしています。ですから、本当に正確に 1600x1200 が必要なら、
最小の垂直同期レートを段階的に下げてみてください (ここでは、70Hz まで
下げてみました)。

<pre>
ModeLine "1592x1194" 197.97 1592 1664 2024 2168 1194 1196 1208 1234 #74Hz
ModeLine "1600x1200" 199.67 1600 1672 2032 2176 1200 1202 1214 1240 #74Hz
ModeLine "1608x1206" 198.65 1608 1680 2040 2184 1206 1208 1220 1246 #73Hz
ModeLine "1616x1212" 197.59 1616 1688 2048 2192 1212 1214 1226 1252 #72Hz
ModeLine "1624x1218" 199.26 1624 1696 2056 2200 1218 1220 1232 1258 #72Hz
ModeLine "1632x1224" 198.15 1632 1704 2064 2208 1224 1226 1238 1264 #71Hz
ModeLine "1640x1230" 199.81 1640 1712 2072 2216 1230 1232 1244 1270 #71Hz
ModeLine "1648x1236" 198.64 1648 1720 2080 2224 1236 1238 1250 1276 #70Hz
</pre>

<p>
ここで、ドットクロック (帯域幅) が 200MHz に限定されているものとして、モニタが
1600x1200 @ 74Hz の解像度で表示しているのを見ることができるでしょう。
帯域幅は、モニタに定義されている限界に従って設定してください。

<p>
いったん ModeLines が入手できれば、それを /etc/X11/XF86Config ファイルに入れます。
この新しい ModeLines が使用できなかった場合に備えて、古い ModeLines を再利用できるように、
これをコメントアウトしてください。
次に、どの解像度を使用したいのかを選択してください。まず、X をアクセラレーテッドモード
(これはほとんどのビデオカードで利用可能です) で実行するのかどうかを考えて、XF86Config
のどの <tt>"Screen"</tt> セクションを変更するのかを決定します。
あるいは、すべての <tt>"Screen"</tt> セクションを変更します。

<pre>
Section "Screen"
   Driver          "Accel"
   Device          "Primary Card"
   Monitor         "Primary Monitor"
   DefaultColorDepth 32
   SubSection "Display"
      Depth        32
      Modes        "1280x1024" "1024x768"
   EndSubSection
</pre>

<p>
"Modes" キーワードの後に記述された最初の解像度は、X の起動時に使用される
解像度です。CTRL-ALT-(キーパッドの) '-' か CTRL-ALT-(キーパッドの) '+'
を押下することで、ここにリストアップされた解像度を切り替えることができます。
上記のセクションに従って、X は (DefaultColorDepth ディレクティブに従って
8 ビットモードで起動することなく) 32 ビットカラーモードでの起動を試みます。
また、最初に使用を試みる解像度は ("Modes" ラインの順序に従って) 1280x1024
となります。この "1280x1024" は、単に ModeLine の値のためのラベルでしかない
ということに注意してください。

<p>
ModeLine 生成スクリプトは、より古いモニタやより小さなモニタ用に、
そのタイミングを緩和し、特定の解像度用の ModeLines を用意する機能も
持っているいることに注意してください。ハードウェアのタイプに依存しますが、
デフォルトのオプションでの使用が非常に簡単というわけにはいかないかも知れません。
もし、絵の背が高過ぎたり、幅が広過ぎたり、小さ過ぎたり、
あるいは水平方向か垂直方向にシフトしている場合に、モニタの制御機能が
その見た目を修正するのに十分ではないのでしたら、そのモニタのタイミングがより良く適合するよう 
ModeLine を調整するため、xvidtune(1) を使用してみるのも良いでしょう。

<p>
ほとんどの最近のモニタでは、帯域幅に固定的な限界がありませんので、しばしば、
そのスペックのどこにも記載されていない場合があります。帯域幅をより増加させていった場合に
何が起きるかというと、スクリーンの画像がより毛羽立ってきます。
ですので、テストのために、グラフィックカードの帯域幅 (これは "ドットクロック" とも呼ばれるものです)
内に収めたいと思うかも知れませんし (これによってモニタがダメージを受けることはありません)、
帯域幅を徐々に下げていくことで、美しく、鮮明な画像を得ることができるでしょう。

<p>
もし、これが必要以上に複雑に感じるのでしたら、これはそういうものだからなのです。
XFree86 4.0 はいくつかの組み込みモードを持ち、DDC および DDC2 を通して、
"プラグアンドプレイ" のモニタからその能力を読み出す機能があるので、
この問題は解決され、この手順が非常に簡単なものになりました。

<p>
<a href="http://koala.ilog.fr/ftp/pub/Klone/">http://koala.ilog.fr/ftp/pub/Klone/</a>
から Colas XFree86 ModeLine Generator スクリプトをダウンロードすることもできます。
Klone インタープリタを取り込んで、これをコンパイルする必要があります。また、これは
<tt>lang/klone</tt> として ports にも用意されています。
このスクリプトは、Klone の配布物の中の scripts ディレクトリの中にあります
(ports の場合なら、これらを /usr/local/lib/klone/scripts にインストールします)。

<p>
これにはふたつのバージョンのスクリプトが含まれます。最初のものは、上記の
web ページのものと同じもので、CGI バージョンです。また、ふたつ目のものは、
既存の完全な XF86Config ファイルを取るもので、その作成の際に xf86config/XF86Setup
に入力したモニタのスペックを読み取り (ここで、本当にモニタのスペックを入力したのか、
一般的なものを選択したのかを思い出してください)、
これに従って既存の ModeLines を修正するものです。

<p>
<font color= "#0000e0">
<a href= "index.html">[FAQ の目次]</a>
<a href= "faq10.html">[10 章 - システム管理]</a>
<a href= "faq12.html">[12 章 - 上級ユーザのために]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt="[back]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
Originally [OpenBSD: faq11.html,v 1.41 ]
<br>
$Translation: faq11.html,v 1.7 2003/06/17 23:04:53 toshi Exp $
<br>
$OpenBSD: faq11.html,v 1.7 2003/06/21 10:00:37 jufi Exp $
</small>
</body>
</html>
