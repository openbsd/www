<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>14 - Configuration des disques</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2005 by OpenBSD.">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<style type="text/css">
  <!--
  pre { margin-left: 20px; }
  -->
</style>
</head>

<body bgcolor= "#ffffff" text= "#000000">

<a href="../../fr/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">
</a>
<p>
<font color= "#0000e0">
<a href= "index.html">[Index de la FAQ]</a>
<a href= "faq13.html">[Section 13 - Multimédia]</a>
</font>

<h1><font color="#e00000">14 - Configuration des disques</font></h1><hr>
<!-- UNCOMMENT ONLY WHEN THE FILE IS OUT OF SYNC

<hr>
<p>
<b><font color="#e00000">Remarque Importante :</font></b> Le contenu de
   ce fichier est obsolète. Consultez la version anglaise 
   <a href="../faq6.html">ici</a> pour des informations à jour.

<p>
Si vous souhaitez contribuez à l'effort de traduction, prière de consulter
<a href="../../fr/translation.html">la page de traduction</a>.

-->

<h3>Table des matières</h3>
<ul>
<li><a href="#disklabel"  >14.1 - Utilisation de disklabel(8) sous OpenBSD</a>
<li><a href="#fdisk"      >14.2 - Utilisation de fdisk(8) sous OpenBSD</a>
<li><a href="#NewDisk"    >14.3 - Ajout de nouveaux disques sous OpenBSD</a>
<li><a href="#SwapFile"   >14.4 - Comment créer un espace de pagination dans un
fichier</a>
<li><a href="#SoftUpdates">14.5 - Soft Updates</a>
<li><a href="#Boot386"    >14.6 - Comment se déroule le processus de démarrage
d'OpenBSD/i386 ?</a>
<li><a href="#LargeDrive" >14.7 - Quels sont les problèmes liés aux disques de
grande capacité sous OpenBSD ?</a>
<li><a href="#InstBoot"   >14.8 - Installation des blocs de démarrage
("Bootblocks") - spécifique i386</a>
<li><a href="#Backup"     >14.9 - Se préparer au désastre : faire une sauvegarde
vers une bande et effectuer une restauration</a>
<li><a href="#MountImage" >14.10 - Montage des images disque sous OpenBSD</a>
<li><a href="#pciideErr"  >14.11 - A l'aide ! J'ai des erreurs avec IDE DMA !
</a>
<li><a href="#RAID"       >14.13 - Options RAID avec OpenBSD</a>
<li><a href="#NegSpace"   >14.14 - Pourquoi <tt>df(1)</tt> me dit que j'ai plus
de 100% d'espace disque utilisé ?</a>
<li><a href="#OhBugger"   >14.15 - Récupération de partitions après une
suppression du disklabel</a>
<li><a href="#foreignfs"  >14.16 - Est-il possible d'accéder aux données
présentes sur des systèmes de fichiers autres que FFS ?</a>
<li><a href="#flashmem"   >14.17 - Est-il possible d'utiliser un
périphérique de masse ('flash memory device') sous OpenBSD ?</a>

</ul>
<hr>

<a name="disklabel"></a>
<h2>14.1 - Utilisation de disklabel(8) sous OpenBSD</h2>
<h3>Table des matières</h3>

<ul>
<li><a href="#disklabel.1">Qu'est-ce que disklabel(8) ?</a>
<li><a href="#disklabel.2">disklabel(8) à l'installation d'OpenBSD</a>
<li><a href="#disklabel.3">Utilisations courantes de disklabel(8)</a>
</ul>

   
<a name="disklabel.1"></a>
<h3>Qu'est-ce que disklabel(8) ?</h3>
  
<p>
Pour commencer, lisez le manuel de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>.

<p>
Les "Disklabels" sont créés afin d'interfacer efficacement un disque
avec les pilotes inclus dans le noyau. Les "labels" (partitions)
contiennent plusieurs informations à propos de vos disques, comme la
géométrie du lecteur et le type de système de fichiers. Ceux-ci sont
utilisés par le programme d'amorçage pour démarrer le disque et
connaître les systèmes de fichiers présents sur celui-ci. Ces partitions
sont également utilisées en conjonction avec le système de fichiers afin
de créer un environnement optimisé. Vous pouvez accéder à de plus amples
informations sur disklabel en lisant le manuel
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=5">disklabel(5)</a>.

<p>
De plus, l'utilisation de disklabel permet de passer outre les
limitations de partitionnement liées aux types d'achitectures. Par
exemple, sur i386, vous ne pouvez avoir que 4 partitions primaires. (Les
partitions que les autres systèmes d'exploitation, comme Windows NT ou
DOS, peuvent voir.) Avec
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">
disklabel(8)</a>, vous utilisez une de ces partitions 'primaires' pour
stocker *toutes* vos partitions OpenBSD (ex. 'swap', '/', '/usr' et
'/var'). Et il vous reste encore 3 partitions disponibles pour d'autres
systèmes d'exploitation !

<a name="disklabel.2"></a>
<h3>disklabel(8) à l'installation d'OpenBSD</h3>

<p>
Une partie importante de l'installation d'OpenBSD est la création
initiale des labels. Celle-ci intervient (pour les utilisateurs de i386)
juste après avoir utilisé <a href="#fdisk">fdisk(1)</a>. A
l'installation, vous utilisez disklabel afin de créer les différentes
partitions qui contiendront vos points de montage. Vous pouvez définir
ces points de montage à l'installation lorsque vous êtes sous
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a> bien que ce ne soit pas nécessaire puisque vous serez
amené à confirmer ces choix plus tard. Mais cela permettra d'accélérer
votre installation.

<p>
Puisque vous en êtes à l'installation, vous n'aurez aucun label existant
et devrez les créer. Le premier label à créer est le label 'a'. Celui-ci
DEVRA correspondre au point de montage /. Vous pouvez connaître quels
labels il est recommandé de créer en lisant la
<a href="faq4.html#SpaceNeeded">FAQ 4, De combien d'espace ai-je besoin pour une installation OpenBSD ?</a>. Pour les
serveurs, il est recommandé de créer des labels séparés. Pour une
utilisation bureautique, créer un point de montage / sera probablement
suffisant. A la création initiale de votre partition racine (label 'a'),
gardez à l'esprit que vous aurez besoin d'un CERTAIN espace libre pour
votre partition d'échange (label 'SWAP'). Maintenant que les bases ont
été abordées, voici un exemple d'utilisation de disklabel à
l'installation. Dans cet exemple, on assumera qu'OpenBSD est le seul
système présent dans l'ordinateur et qu'une installation complète sera
réalisée.

<pre>

If this disk is shared with other operating systems, those operating systems
should have a BIOS partition entry that spans the space they occupy completely.
For safety, also make sure all OpenBSD file systems are within the offset and
size specified in the 'A6' BIOS partition table.  (By default, the disklabel
editor will try to enforce this).  If you are unsure of how to use multiple
partitions properly (ie. separating /,  /usr, /tmp, /var, /usr/local, and other
things) just split the space into a root and swap partition for now.

# using MBR partition 3: type A6 off 63 (0x3f) size 4991553 (0x4c2a41) 

Treating sectors 63-16386300 as the OpenBSD portion of the disk.
You can use the 'b' command to change this.

Initial label editor (enter '?' for help at any prompt)
&gt; <b>d a</b>
&gt; <b>a a</b>
offset: [63] <b>&lt;Enter&gt;</b>
size: [16386237] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <b>&lt;Enter&gt;</b>
mount point: [none] <b>/</b>
fragment size: [1024] <b>&lt;Enter&gt;</b>
block size: [8192] <b>&lt;Enter&gt;</b>
cpg: [16] <b>&lt;Enter&gt;</b>
&gt; <b>a b</b>
offset: [131103] <b>&lt;Enter&gt;</b>
size: [16255197] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [swap] <b>&lt;Enter&gt;</b>
</pre>

<p>
A ce niveau, nous avons créé une partition racine de 64M montée sur / et
une partition d'échange de 64M. Notez que l'offset (calage du disque)
débute au secteur 63 ; c'est ce qu'il faut. En ce qui concerne la
taille, disklabel vous la présentera sous forme de secteurs, cependant,
vous n'avez pas besoin de rentrer la taille dans ce même format. Comme
dans l'exemple précédent, vous pouvez entrer une taille sous la forme
<i>64 Megabytes = 64M</i> et <i>2 Gigabytes = 2G</i>. Disklabel en fera
l'approximation au secteur le plus proche. Dans cet exemple, vous
noterez également que disklabel assume que le label 'b' correspond à une
partition d'échange (SWAP). Cette assomption est correcte puisque, par
défaut, le noyau GENERIC est configuré pour rechercher une partition
d'échange sur le label 'b' ; vous devriez suivre cette recommandation et
utiliser 'b' pour votre partition swap.

<p>
L'exemple suivant vous montrera la création de deux labels
supplémentaires. Cela signifie qu'il ne s'agit pas d'une installation
complète puisque la taille de ces labels ne sera pas suffisante pour
contenir la totalité d'OpenBSD. Montrer la création de toutes les
partitions serait répétitif.

<pre>
&gt; <b>a d</b>
offset: [262143] <b>&lt;Enter&gt;</b>
size: [16124157] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <b>&lt;Enter&gt;</b>
mount point: [none] <b>/tmp</b>
fragment size: [1024] <b>&lt;Enter&gt;</b>
block size: [8192] <b>&lt;Enter&gt;</b>
cpg: [16] <b>&lt;Enter&gt;</b>
&gt; <b>a e</b>
offset: [393183] <b>&lt;Enter&gt;</b>
size: [15993117] <b>64M</b>
Rounding to nearest cylinder: 131040
FS type: [4.2BSD] <b>&lt;Enter&gt;</b>
mount point: [none] <b>/var</b>
fragment size: [1024] <b>&lt;Enter&gt;</b>
block size: [8192] <b>&lt;Enter&gt;</b>
cpg: [16] <b>&lt;Enter&gt;</b>
</pre>

<p>
Deux choses sont à noter dans l'exemple précédent. La première est que
l'offset est automatiquement défini pour vous en se basant sur le
prochain disponible (dans l'ordre). Dans une telle installation, vous
n'aurez pas à vous soucier de changer les offsets. La deuxième chose que
vous noterez est que le label 'c' a été évité. La raison en est que ce
label représente la totalité du disque. C'est pourquoi vous ne devriez
jamais toucher au label 'c' de quelque sorte que ce soit.

<p>
Une fois vos labels créés, tout ce qu'il reste à faire est de les
inscrire sur le disque et poursuivre l'installation. Pour sauvegarder le
tout et quitter disklabel (et ainsi continuer l'installation), tapez :


<pre>
&gt; <b>w</b>
&gt; <b>q</b>
</pre>

<p>

<a name="disklabel.3"></a>
<h3>Utilisations courantes disklabel(8)</h3>

<p>
Une fois votre système installé, vous ne devriez pas avoir à utiliser
disklabel trop souvent. Mais parfois, vous aurez besoin de l'utiliser
afin d'ajouter, de supprimer ou de supprimer des disques. Une des
premières choses que vous aurez besoin de faire sera de voir le
disklabel actuel. Pour ce faire, tapez simplement :

<pre>
# <b>disklabel wd0</b> &gt;----- Or whatever disk device you'd like to view

# using MBR partition 3: type A6 off 64 (0x40) size 16777152 (0xffffc0)
# /dev/rwd0c:
type: ESDI
disk:
label: TOSHIBA MK2720FC
flags:
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 2633
total sectors: 2654064
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # milliseconds
track-to-track seek: 0  # milliseconds
drivedata: 0 

16 partitions:
#        size   offset    fstype   [fsize bsize   cpg]
  a:  2071440    65583    4.2BSD     1024  8192    16   # (Cyl.   65*- 2120)
  b:    65520       63      swap                        # (Cyl.    0*- 65)
  c:  2654064        0    unused        0     0         # (Cyl.    0 - 2632)
  j:   512001  2137023    4.2BSD     1024  8192    16   # (Cyl. 2120*- 2627*)
</pre>

<p>
Cette commande permet simplement de voir le disklabel existant afin de
nous empêcher d'effectuer des manipulations hasardeuses (un conseil dont
nous avons tous besoin de temps en temps). Pour avoir la possibilité
d'effectuer des changements avec disklabel, il faut utiliser l'otion -E
comme suit :

<pre>
# <b>disklabel -E wd0</b>
</pre>

<p>
Vous retrouverez alors une invite de commandes similaire à celle
rencontrée à l'installation d'OpenBSD. A priori, la commande la plus
importante à connaître est '?'. Celle-ci vous donnera la liste des
options utilisables sous disklalbel. Vous pouvez aussi voir le manuel
complet de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>
en tapant la commande 'M'. C'est à partir de cette invite de commandes
que vous ajouterez, supprimerez et modifierez vos labels. Si vous
souhaitez d'avantage d'information, lisez le manuel
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a>.

<a name="fdisk"></a>
<h2>14.2 - Utilisation de fdisk(8) sous OpenBSD</h2>

Avant de commencer, soyez sûr d'avoir lu le manuel de <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a>.

<p>
Fdisk est un programme d'aide à la maintenance de vos partitions. Ce
programme est utilisé à l'installation afin de mettre en place vos
partitions OpenBSD (cette partition peut contenir <u>plusieurs</u>
labels, chacun avec un système de fichiers, partition d'échange (swap),
etc). Il permet de diviser l'espace de vos disques et d'activer une
partition. Ce programme pourra éventuellement être utilisé en mode
"Single User" (boot -s). Fdisk permet également d'inscrire le MBR
("Master boot record") sur vos différents disques.

<p>
Pour les besoins de l'installation, vous ne nécessiterez, la plupart du
temps, que d'<b>UNE</b> partition OpenBSD dans laquelle vous ajouterez
le swap et les systèmes de fichiers à l'aide de disklabel.

<p>
Pour simplement voir votre table de partition avec fdisk, utilisez :

<pre># <b>fdisk sd0</b><br>
</pre>

<p>
Ce qui vous donnera une sortie similaire à celle-ci :

<pre>
Disk: sd0       geometry: 553/255/63 [8883945 Sectors]
Offset: 0       Signature: 0xAA55
         Starting       Ending       LBA Info:
 #: id    C   H  S -    C   H  S [       start:      size   ]
------------------------------------------------------------------------
*0: A6    3   0  1 -  552 254 63 [       48195:     8835750 ] OpenBSD     
 1: 12    0   1  1 -    2 254 63 [          63:       48132 ] Compaq Diag.
 2: 00    0   0  0 -    0   0  0 [           0:           0 ] unused      
 3: 00    0   0  0 -    0   0  0 [           0:           0 ] unused      
</pre>

<p>
Dans cet exemple, nous voyons la sortie de fdisk concernant le premier
lecteur SCSI. Nous pouvons voir les partitions OpenBSD (A6). Le *
indique que la partition OpenBSD est amorçable.

<p>
Dans l'exemple précédent, nous avons simplement accédé à une
information. Qu'en est-il si nous souhaitons éditer notre table de
partition ? Et bien, pour ce faire, nous devons utiliser l'option <b>-
e</b>. Ceci fera apparaître une invite de commandes pour intéragir avec
fdisk.

<pre>
# <b>fdisk -e wd0</b>
Enter 'help' for information
fdisk: 1&gt; <b>help</b>
        help            Command help list
        manual          Show entire OpenBSD man page for fdisk
        reinit          Re-initialize loaded MBR (to defaults)
        setpid          Set the identifier of a given table entry
        disk            Edit current drive stats
        edit            Edit given table entry
        flag            Flag given table entry as bootable
        update          Update machine code in loaded MBR
        select          Select extended partition table entry MBR
        print           Print loaded MBR partition table
        write           Write loaded MBR to disk
        exit            Exit edit of current MBR, without saving changes
        quit            Quit edit of current MBR, saving current changes
        abort           Abort program without saving current changes
fdisk: 1&gt; 
</pre>

<p> 
Il est parfaitement sans danger d'explorer les diverses commande sous
fdisk, à condition de répondre <b>N</b> à la sauvegarde des changements
et de ne *PAS* utiliser la commande <b>write</b>.

<p>
Voici un aperçu des commandes disponibles lorsque vous utilisez l'option
<b>-e</b>.

<ul>
<li><b>help</b> Affiche la liste des commandes utilisables par fdisk en
    mode d'édition intéractif.
<li><b>reinit</b> Initialise la copie en mémoire du bloc de démarrage
    actuellement sélectionné.
<li><b>disk</b> Affiche la géométrie actuelle du disque détectée par
    fdisk. Vous pouvez l'éditer selon vos désirs.
<li><b>setpid</b> Change l'identifiant de partition de l'entrée
    sélectionnée de la table de partition.
<li><b>edit</b> Edite l'entrée sélectionnée de la table dans la copie
    mémoire du bloc de démarrage actuel. Vous pouvez entrer les valeurs
    en géométrie BIOS ou en secteurs, offsets et tailles.
<li><b>flag</b> Rend amorçable la partition sélectionnée. Seule une
    entrée peut être marquée comme amorçable. Si vous souhaitez démarrer
    à partir d'une partition étendue, vous devez la marquer comme
    amorçable.
<li><b>update</b> Met à jour le code machine dans la copie mémoire du
    bloc de démarrage actuellement sélectionné.
<li><b>select</b> Sélectionne et charge en mémoire le bloc de démarrage
    désigné par la table de partition étendue dans le bloc de démarrage
    actuel.
<li><b>print</b> Affiche la copie en mémoire actuelle du bloc de
    démarrage et de son MBR sur le terminal.
<li><b>write</b> Ecrit la copie en mémoire actuelle du bloc de démarrage
    sur le disque. Vous serez amené à confirmer cette action.
<li><b>exit</b> Quitte le niveau actuel de fdisk, revenant à la copie
    précédente du bloc de démarrage ou sortant du programme si une telle
    copie n'existe pas.
<li><b>quit</b> Quitte le niveau actuel de fdisk, revenant à la copie
    précédente du bloc de démarrage ou sortant du programme si une telle
    copie n'existe pas. A l'inverse d'"exit", le bloc de démarrage
    modifié est inscrit sur le disque.
<li><b>abort</b> Quitte le programme sans sauvegarder les changements.
</ul>

<a name="NewDisk"></a>
<h2>14.3 - Ajout de nouveaux disques sous OpenBSD</h2>

<p>
Une fois votre disque <b>CORRECTEMENT</b> installé, vous devez utiliser <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">fdisk(8)</a> (<i>i386 seulement</i>) et <a
href= "http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">disklabel(8)</a> afin de le configurer pour OpenBSD.

<p>
Pour les utilisateurs i386, commencez avec fdisk. Les autres
architectures peuvent ignorer cette étape. Dans l'exemple suivant, nous
ajouterons un troisième disque SCSI au système.

<pre>
# <b>fdisk -i sd2</b>
</pre>

Cette commande va initialiser la "véritable" table de partition du
disque pour un usage exclusif par OpenBSD. Ensuite, vous devez créer un
disklabel. Ceci risque de sembler confus.

<pre>
# <b>disklabel -e sd2</b>

<i>(screen goes blank, your $EDITOR comes up)</i>
type: SCSI
<i>...bla...</i>
sectors/track: 63
total sectors: 6185088
<i>...bla...</i>
16 partitions:
#        size   offset    fstype   [fsize bsize   cpg]
  c:  6185088        0    unused        0     0         # (Cyl.    0 - 6135)
  d:  1405080       63    4.2BSD     1024  8192    16   # (Cyl.    0*- 1393*)
  e:  4779945  1405143    4.2BSD     1024  8192    16   # (Cyl. 1393*- 6135)
</pre>

Tout d'abord, ignorez la partition 'c', celle-ci est toujours présente
et est nécessaire au fonctionnement de programmes comme disklabel ! Le
type de système de fichiers ("fstype") pour OpenBSD est 4.2BSD. Le
nombre total de secteurs ("total sectors") représente la taille du
disque. Admettons qu'il s'agit d'un disque de 3 gigabytes. 3 gigabytes
en terme de constructeur de disques représente 3000 megabytes. Divisons
6185088 par 3000 (on utilise
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bc&amp;sektion=1">bc(1)</a>).
Vous obtenez 2061. Ainsi, pour décider des tailles des partitions a, d,
e, f, g, ... multipliez simplement X par 2061 afin d'avoir X megabytes
d'expace sur cette partition. L'offset de votre première partition doit
être égal à "sectors/track" comme rapporté par disklabel. Pour nous,
cette valeur est égale à 63. L'offset de chaque partition suivante
résultera de la combinaison de la taille et de l'offset de chacune
d'elle (sauf la partition 'c' qui n'intervient pas dans cette équation).

<p>
Ou, si vous souhaitez simplement une partition couvrant tout le disque,
afin d'offrir un espace de stockage web, un répertoire d'utilisateurs
("home") ou autre chose, ôtez simplement la valeur "sectors/track" à la
taille totale du disque. 6185088-63 = 6185025. Votre partition est :

<pre>
    d:  6185025       63    4.2BSD     1024  8192    16 
</pre>

<b>Si tout ceci vous semble inutilement complexe, vous pouvez simplement
utiliser disklabel -E pour entrer dans le même mode de partitionnement
dont vous disposiez à l'installation !</b> Dans celui- ci, vous pouvez
utiliser "96M" pour spécifier "96 megabytes" (ou, si vous possédez un
disque suffisamment gros, 96G pour 96 gigabytes). En revanche, le mode
-E utilise la géométrie BIOS du disque, pas sa véritable géométrie, et
souvent ces deux valeurs sont différentes. Pour passer outre cette
limitation, tapez 'g d' pour "geometry disk" (géométrie disque). Les
autres options sont 'g b' for "geometry bios" (géométrie bios) et 'g u'
pour "geometry user" (géométrie utilisateur) ou simplement, ce que le
label affichait avant que disklabel n'effectue des changements.

<p>
Voilà qui était dense. Mais tout n'est pas terminé. Vous devez à présent
créer un système de fichiers sur ce disque en utilisant
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&amp;sektion=8">newfs(8)</a>.

<pre>
# <b>newfs sd2a </b>
</pre>

<p>
Ou autre, selon le nom donné à votre disque par le système de nommage
d'OpenBSD (regardez la sortie de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">
dmesg(8)</a> pour voir comment OpenBSD a nommé votre disque).

<p>
Maintenant, il vous faut décider où vous souhaitez monter cette
partition nouvellement créée. Disons que vous vouliez la monter sur /u.
Tout d'abord, créez le répertoire /u. Puis montez-le.

<pre>
# <b>mount /dev/sd2a /u</b>
</pre>

<p>
Enfin, ajoutez-le a <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">
/etc/fstab(5)</a>.

<pre>/dev/sd2a /u ffs rw 1 1</pre>

<p>
Et si vous souhaitiez migrer un répertoire existant comme /usr/local ?
Vous devriez monter le nouveau disque sur /mnt et utiliser <tt>cpio -
pdum</tt> pour copier /usr/local vers le répertoire /mnt. Editez le
fichier
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">
/etc/fstab(5)</a>
afin de préciser que votre partition /usr/local est maintenant /dev/sda2
(votre nouvelle partition formatée). Exemple :

<pre>
<b>/dev/sd2a /usr/local ffs rw 1 1</b>
</pre>

<p>
Redémarrez en mode single user avec <b>boot -s</b>, déplacez le
répertoire /usr/local vers /usr/local-backup (ou si vous vous sentez en
veine, supprimez-le) et créez un répertoire /usr/local vide. Enfin,
redémarrez le système et voilà, les fichiers sont présents !


<a name="SwapFile"></a>
<h2>14.4 - Comment créer un espace de pagination dans un fichier</h2>

<p>
(Note : si vous souhaitez ajouter un espace de pagination dans un
fichier parce que vous recevez des erreurs du type &quot;virtual memory
exhausted&quot;, vous devriez d'abord essayer d'augmenter la limite des
processus avec
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=unlimit&amp;sektion=1">
unlimit(1)</a> pour csh ou
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ulimit&amp;sektion=1">
ulimit(1)</a> pour sh)

<p>
Il n'est pas nécessaire de recompiler le noyau pour utiliser un fichier
comme espace de pagination, même si cela peut être effectué à des fins
de personnalisation, cette faq vous montrera les deux façons de faire.

<h3>Paginer dans un fichier.</h3>

<p>
L'utilisation d'un fichier d'échange est le moyen le plus simple et le
plus rapide pour augmenter l'espace de pagination (swap) disponible. Ce
fichier ne doit pas résider sur un système de fichiers dont l'option
"SoftUpdates" est activée (cette option est désactivée par défaut). Pour
commencer, vous pouvez voir la taille totale et utilisée de votre swap
actuel en utilisant l'utilitaire
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=swapctl&amp;sektion=8">
swapctl(8)</a>. Pour ce faire, lancez la commande :

<pre>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
</pre>

<p>
Cela vous affiche les différents dispositifs utilisés pour la pagination
ainsi que leurs statistiques actuelles. Dans l'exemple précédent, il n'y
a qu'un seul dispositif nommé &quot;swap_device&quot;. Il s'agit de
l'espace disque prédéfini utilisé pour paginer (partition b visible sous
disklabel). Comme vous pouvez le constater dans l'exemple précédent, cet
espace n'est pas beaucoup utilisé pour le moment. Mais pour les besoins
de ce document, nous imaginerons que 32M supplémentaires sont
nécessaires.

<p>
La première chose à faire pour configurer un fichier en tant que
dispositif de pagination est de créer ce fichier. Le mieux est
d'utiliser la commande <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dd&amp;sektion=1">dd(1)</a>.
Voici un exemple montrant la création d'un fichier /var/swap de 32M.

<pre>
$ <b>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</b>
32768+0 records in
32768+0 records out
33554432 bytes transferred in 20 secs (1677721 bytes/sec)
</pre>

<p>
Une fois que cela est fait, nous pouvons activer la pagination vers ce
fichier. Pour ce faire, utilisez la commande suivante :

<pre>
$ <b>sudo chmod 600 /var/swap</b>
$ <b>sudo swapctl -a /var/swap</b>
</pre>

<p>
A présent, vérifions que ce fichier a bien été ajouté à la liste des
dispositifs de pagination disponibles.

<pre>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
/var/swap        65536        0    65536     0%    0
Total           131056        8   131048     0%
</pre>

<p>
Maintenant que le fichier de pagination est activé, vous devez ajouter
une ligne à votre fichier <i>/etc/fstab</i> afin que les changements
soient pris en compte au prochain redémarrage. Si cette ligne n'est pas
ajoutée, ce dispositif ne sera plus activé au prochain reboot.

<pre>
$ <b>cat /etc/fstab</b>
/dev/wd0a / ffs rw 1 1
/var/swap /var/swap swap sw 0 0
</pre>

<h3>Paginer via un périphérique vnode</h3>

<p>
Il s'agit d'une solution plus définitive pour ajouter de l'espace de
pagination. Afin de paginer vers un fichier de façon permanente,
commencez par créer un noyau avec vnd0c comme swap. Si votre système de
fichiers racine est wd0a, alors wd0b est votre ancien swap ; utilisez la
ligne suivante dans le fichier de configuration du noyau (référez-vous à
la section de compilation d'un nouveau noyau en cas de doute) :

<pre>
config          bsd     root on wd0a swap on wd0b and vnd0c dumps on wd0b
</pre>

<p>
Après cela, le fichier qui sera utilisé pour paginer devra être créé.
Pour ce faire, utilisez la même commande que pour l'exemple précédent.

<pre>
$ <b>sudo dd if=/dev/zero of=/var/swap bs=1k count=32768</b>
32768+0 records in
32768+0 records out
33554432 bytes transferred in 20 secs (1677721 bytes/sec)
</pre>

<p>
A présent que votre fichier est en place, vous devez l'ajouter dans
votre fichier <i>/etc/fstab</i>. Voici une ligne d'exemple pour démarrer
la machine avec ce dispositif de pagination activé.

<pre>
$ <b>cat /etc/fstab</b>
/dev/wd0a / ffs rw 1 1
/dev/vnd0c none swap sw 0 0 
</pre>

<p>
Votre ordinateur doit maintenant être redémarré afin que les changements
effectués sur le noyau soient pris en compte. Une fois que cela est
fait, il est temps de configurer le dispositif pour paginer. On
utilisera la commande <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&amp;sektion=8">
vnconfig(8)</a>.

<pre>
$ <b>sudo vnconfig -c -v vnd0 /var/swap</b>
vnd0: 33554432 bytes on /var/swap
</pre>

<p>
La dernière étape consiste à activer la pagination vers ce dispositif.
Cela s'effectue de la même façon que dans les exemples précédents, en
utilisant using swapctl(8). Puis nous vérifierons qu'il a bien été
ajouté à la liste des dispositifs de pagination disponibles.

<pre>
$ <b>sudo swapctl -a /dev/vnd0c</b>
$ <b>swapctl -l</b>
Device      512-blocks     Used    Avail Capacity  Priority
swap_device      65520        8    65512     0%    0
/dev/vnd0c       65536        0    65536     0%    0
Total           131056        8   131048     0%
</pre>



<a name="SoftUpdates"></a>
<h2>14.5 - Soft Updates</h2>


<p>
Les "Soft Updates" sont basés sur une idée de <a
href="http://www.ece.cmu.edu/~ganger/papers/CSE-TR-254-95/">Greg Ganger et Yale
Patt</a> et ont été développés pour FreeBSD par <a
href="http://www.mckusick.com/softdep/">Kirk McKusick</a>.
Les Soft Updates imposent une réorganisation partielle des opérations
sur le tampon permettant la suppression du code FFS, des écritures
synchrones des entrées. Une augmentation des performances est ainsi
réalisée lors des écritures sur disque.

<p>
La possibilité d'effectuer un fsck(8) en arrière plan avec Soft Updates
n'a pas encore été implémentée sous OpenBSD, donc l'utilisation de <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)
</a> est toujours nécessaire lors d'un arrêt brutal. Les futures
versions pourraient inclure cette fonctionnalité.

<p>
Pour utiliser les Soft Updates, votre noyau doit avoir

<p>
<b>option FFS_SOFTUPDATES</b>
<p>
compilé, ce qui est le cas du noyau GENERIC.

<p>
L'activation des Soft Updates est effectuée par une option de montage. Lors du
montage d'une partition avec l'utilitaire <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)
</a>, vous pouvez activer les Soft Updates sur celle-ci. Voici l'exemple
d'une entrée dans le fichier <i><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=fstab&amp;sektion=5">
/etc/fstab(5)</a></i> permettant de monter la partition <i>sd0a</i> avec
les Soft Updates activés.

<pre>
/dev/sd0a / ffs rw,softdep 1 1
</pre>

<p>
Note aux utilisateur sparc : n'activez pas Soft Updates sur les machines
de type sun4 ou sun4c. Ces architectures ne supportent qu'un montant
très faible de mémoire noyau et ne peuvent utiliser cette
fonctionnalité. En revanche, les machines de type sun4m ne posent pas de
problème.

<a name="Boot386"></a>
<h2>14.6 - Comment se déroule le processus de démarrage d'OpenBSD/i386 ?</h2>
Le processus de démarrage d'un système OpenBSD/i386 est loin d'être
simple et une bonne compréhension de celui-ci peut être utile afin de
diagnostiquer un problème lorsque les choses ne fonctionnent pas. Ce
processus comporte quatre étapes clefs :
<ol>
<li><b><i>Master Boot Record (MBR) :</i></b> Le "Master Boot Record"
    (enregistrement de démarrage principal) est le premier seceur (512
    bytes) du disque. Il contient la table de partition primaire et un
    petit programme permettant de charger le "Partition Boot Record"
    (PBR - enregistrement de démarrage des partitions). Notez que dans
    certains environnements, le terme "MBR" se réfère uniquement à la
    portion de code comprise dans le premier bloc du disque et non pas
    au bloc entier (incluant la table de partition). Il est primordial
    de comprendre le sens d'"initialiser le MBR" ; la terminologie sous
    OpenBSD sous-entend la ré-écriture complète du secteur MBR et pas
    seulement son code, comme cela peut être le cas avec certains
    systèmes. Vous n'en aurez l'utilité que très rarement. Pour ce
    faire, utilisez l'option "-u" de la commande fdisk(8) ("<tt>fdisk -u
    wd0</tt>").

<p>
Bien qu'un MBR soit inclu avec OpenBSD, vous n'êtes pas obligé de
l'utiliser puisque virtuellement, n'importe quel MBR est capable de le
faire démarrer. Le MBR se manipule avec l'aide du programme fdisk(8) qui
est utilisé pour éditer la table de partition mais également pour
installer le code MBR sur le disque.

<p>
Le MBR d'OpenBSD s'annonce avec le message suivant :

<pre>
    Using drive 0, partition 3.
</pre>

montrant le disque ainsi que la partition d'où il s'apprête à charger le
PBR. On peut également voir un point (".") en fin de ligne, ce qui
signifie que la machine est capable d'utiliser la conversion LBA
("Logical Block Adressing") au démarrage. Si la machine avait été
incapable d'une telle conversion, le point aurait été remplacé par un
point-virgule (";"), indiquant une conversion CHS 
("Cylinder-Head-Sector") :

<pre>
    Using Drive 0, Partition 3;
</pre>
Notez que le point ou le point-virgule en fin de ligne peut servir
d'indicateur du "nouveau" MBR OpenBSD introduit à partir de la version
3.5.

<li><b><i>Partition Boot Record (PBR) :</i></b> Le "Partition Boot
    Record" (enregistrement de démarrage de partition), aussi appelé PBR
    ou
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8&amp;arch=i386">biosboot(8)</a>
    (d'après le nom du fichier contenant le code) représente le premier
    secteur physique de la partition OpenBSD du disque. Le PBR est le
    "first-stage boot loader" (chargeur de démarrage de niveau un)
    d'OpenBSD. Il est exécuté par le code MBR et se charge de lancer le
    "second- stage boot loader" (chargeur de démarrage de niveau deux),
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">boot(8)</a>.
    Comme le MBR, le PBR est constitué d'une toute petite quantité de
    code et de données d'une taille totale de 512 bytes. Ce n'est pas
    suffisant pour avoir une application reconnaissant un système de
    fichiers, donc, plutôt que de demander au PBR de localiser
    <tt>/boot</tt> sur le disque, sa localisation accessible par le BIOS
    est codée physiquement dans le PBR lors de l'installation.

<p>
Le PBR est installé par <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=installboot&amp;sektion=8&amp;arch=i386">installboot</a>, décrit dans
<a href="faq14.html#InstBoot">plus en détails dans la
suite de ce document</a>. Le PBR s'annonce avec le message suivant :

<pre>
    Loading...
</pre>

affichant un point pour chaque bloc qu'il essaye de charger. Comme
précédemment, le PBR montre s'il utilise une conversion LBA ou CHS pour
s'exécuter. Dans le cas de CHS, il affichera un message suivi d'un point-
virgule :

<pre>
    Loading;... 
</pre>

L'ancien biosboot(8) (avant la version 3.5) affichait le message
"<tt>reading boot...</tt>".


<li><b><i>Second Stage Boot Loader, <tt>/boot</tt> :</i></b>
    <tt>/boot</tt> est chargé par le PBR et se charge d'accéder au
    système de fichiers OpenBSD par le BIOS de la machine afin de
    localiser et de lancer le noyau. boot(8) permet également de passer
    plusieurs options et informations au noyau.

<p>
boot(8) est un programme intéractif. Après son exécution, il tente de
localiser et lire <tt>/etc/boot.conf</tt> si celui-ci existe (ce qui
n'est pas le cas dans une installation par défaut) puis lance les
commandes qui y sont indiquées. A moins que le fichier
<tt>/etc/boot.conf</tt> ne l'en empêche, boot(8) offre à l'utilisateur
une invite de commandes similaire à celle-ci :

<pre>
     probing: pc0 com0 com1 apm mem[636k 190M a20=on]
     disk: fd0 hd0+
     >> OpenBSD/i386 BOOT 2.06
     boot>
</pre>

Par défaut, l'utilisateur a cinq secondes pour entrer une commande avant
le démarrage du noyau, <tt>bsd</tt>, à partir de la partition racine du
premier disque dur, ce qui représente le comportement par défaut. Le "second-
stage boot loader" détecte (et examine) votre matériel grâce au BIOS
(puisque le noyau OpenBSD n'est pas encore chargé). Précédemment on peut
voir qu'il a détecté :
<ul>
<li><b>pc0</b> - Clavier et affichage vidéo d'un système i386 standard.
<li><b>com0, com1</b> - Deux ports série.
<li><b>apm</b> - BIOS compatible APM ("Advanced Power Management" - gestion de
courant évoluée).
<li><b>636k 190M</b> - Le montant de mémoire conventionnelle (sous 1M) et
étendue (au-dessus d'1M) trouvée.
<li><b>fd0 hd0+</b> - Les disques accessibles par le BIOS, dans ce cas, un
lecteur de disquettes et un disque dur.
</ul>

Le signe '+' après "hd0" signifie que le BIOS a indiqué à <tt>/boot</tt> que ce
disque peut être accessible par LBA. Lors d'une première installation, vous
verrez souvent un '*' après un disque dur ; ceci signifie que ce disque ne
possède pas de label OpenBSD valide.


<li><b><i>Noyau : <tt>/bsd</tt></i>:</b> il s'agit de la finalité du processus
de démarrage, avoir le noyau OpenBSD chargé en mémoire RAM et fonctionnant
correctement. Une fois le noyau exécuté, OpenBSD peut accéder directement au
matériel sans passer par le BIOS.

</ol>

Ainsi, le tout début du processus de démarrage pourrait ressembler à ceci :
<blockquote><pre>
Using drive 0, partition 3.                      <b><i>&lt;- MBR</i></b>
Loading....                                      <b><i>&lt;- PBR</i></b>
probing: pc0 com0 com1 apm mem[636k 190M a20=on] <b><i>&lt;- /boot</i></b>
disk: fd0 hd0+
>> OpenBSD/i386 BOOT 2.06
boot>
booting hd0a:/bsd 4464500+838332 [58+204240+181750]=0x56cfd0
entry point at 0x100120

[ using 386464 bytes of bsd ELF symbol table ]
Copyright (c) 1982, 1986, 1989, 1991, 1993       <b><i>&lt;- Noyau</i></b>
        The Regents of the University of California.  All rights reserved.
Copyright (c) 1995-2003 OpenBSD.  All rights reserved.  http://www.OpenBSD.org

OpenBSD 3.7 (GENERIC) #50: Sun Mar 20 00:01:57 MST 2005
   ...
</pre></blockquote>


<h3>Ce qui peut mal se passer</h3>
<ul>
<li><b>Bad/invalid/incompatible MBR :</b> habituellement, un disque déja utilisé
possède un code MBR, mais s'il est neuf ou déplacé à partir d'une plateforme
différente ET que vous ne répondez pas "Yes" à la question "Use entire disk"
lors de l'<a href="faq4.html#Disks">installation</a>, vous pourriez vous
retrouver avec un disque sans MBR valide, le rendant ainsi non-bootable même si
sa table de partition est correcte.

<p>
Vous pouvez installer le MBR OpenBSD sur votre disque dur à l'aide du programme
fdisk. Démarrez à l'aide du medium d'installation; choisissez "Shell" pour vous
retrouver en ligne de commandes :

<pre>
    # <b>fdisk -u wd0</b>
</pre>

Vous pouvez également installer un MBR particulier avec fdisk :
<pre>
    # <b>fdisk -u -f /usr/mdec/mbr wd0 </b>
</pre> 

ce qui installera le fichier <tt>/usr/mdec/mbr</tt> en tant que MBR de votre
système. Dans une installation standard d'OpenBSD, ce fichier représente le MBR
par défaut codé dans fdisk, mais n'importe quel autre MBR pourrait ici être
spécifié.

<li><b>Invalid <tt>/boot</tt> location installed in PBR :</b>
lorsqu'installboot(8) installe le PBR, il inscrit l'offset et le numéro du bloc
de l'inode de <tt>/boot</tt> dans le celui-ci. Ainsi, supprimer puis remplacer
<tt>/boot</tt> sans relancer <a href="faq14.html#InstBoot">installboot(8)</a>
empêchera votre système de redémarrer puisque le PBR chargera ce qui se trouve
à l'ancien inode spécifié, ce qui ne sera certainement plus le "second-stage
boot loader" désiré !

Puisque que <tt>/boot</tt> est accédé au travers d'appels BIOS, les anciennes
versions de PBR étaient dépendantes de la conversion BIOS des disques. Si vous
avez altéré la géométrie (à savoir, pris un disque d'un ordinateur utilisant la
conversion CHS pour le mettre dans une machine utilisant LBA, ou simplement
changé l'option de conversion dans votre BIOS), il <i>apparaitra au niveau du
BIOS</i> comme étant déplacé vers une autre location (un bloc numérique
différent doit être accédé afin de récupérer les mêmes informations du disque)
et vous devrez donc relancer installboot(8) avant que le système ne puisse être
redémarré. Le nouveau PBR (OpenBSD 3.5 et plus) est beaucoup plus tolérant dans
les changements de conversion.
</ul>

Le PBR étant très petit, son éventail de messages d'erreur est limité et
quelque peu complexe. La plupart des messages ressemblent à :

<ul>
<li><b>ERR R</b> - Le BIOS a retourné une erreur en tentant de lire un bloc à
partir du disque. Habituellement, ceci est assez explicite : votre disque
n'était pas lisible.
<li><b>ERR M</b> - Un nombre <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=magic&amp;sektion=5">magic(5)
</a> invalide a été lu dans l'entête du "second-stage bootloader". Ceci signifie
généralement que ce qui a été lu n'était PAS <tt>/boot</tt>, à savoir
qu'installboot(8) n'a pas été correctement exécuté, que le fichier /boot a été
altéré ou encore que vous avez exédé la capacité de votre BIOS à lire les
<a href="#LargeDrive">disques de grande capacité</a>.

</ul>
Les autres messages d'erreur sont expliqués en détail dans le manuel de <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=biosboot&amp;sektion=8">
biosboot(8)</a>.


Pour plus d'informations sur le processus de démarrage pour i386, référez-vous
à :
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot_i386&amp;sektion=8&amp;arch=i386">boot_i386(8)</a>
<li><a href="http://www.ata-atapi.com/hiw.htm">http://www.ata-atapi.com/hiw.htm
</a> - Documents "How it Works" (comment cela fonctionne) de Hale Landis.
</ul>

<a name="LargeDrive"></a>
<h2>14.7 - Quels sont les problèmes liés aux disques de grande capacité sous
OpenBSD ?</h2>

<p>
OpenBSD supporte les systèmes de fichiers jusqu'à 2<sup>31</sup>-1, soit
2,147,483,647 secteurs, et puisque chaque secteur équivaut à 512 bytes,
cela correspond à un peu moins de 1T.

<p>
Bien entendu, les capacités du système de fichiers et celles d'un
matériel défini sont deux choses bien différentes. Un nouveau disque dur
IDE de 250G ne fonctionnera pas sur des interfaces trop anciennes (d'une
capacité standard de 137G maximum), certains adaptateurs SCSI très
anciens peuvent avoir des problèmes avec des lecteurs modernes et des
BIOS un peu trop vieux peuvent se figer lorsqu'ils tombent sur un disque
dur de trop grande capacité. De fait, vous devez respecter les
possibilités de votre matériel.

<h3>Taille des partitions et limitations au niveau de la localisation</h3>
Malheureusement, les fonctionnalités du système d'exploitation ne sont
accessibles qu'une fois celui-ci chargé en mémoire. Le processus de
démarrage devra se contenter de la ROM de lancement du système (bien
plus limitée).
 
<p>
Pour cette raison, le fichier /bsd (le noyau) doit se trouver dans
l'espace disque adressable par la ROM. Cela signifie que sur certains
systèmes i386, la partition racine doit se situer dans les premiers
504M, mais les ordinateurs plus récents peuvent avoir des limites de
l'ordre de 2G, 8G, 32G, 128G ou plus. Il est important de noter que de
nombreux ordinateurs récents supportant un adressage au delà de 128G
sont en fait limités par le BIOS et ne peuvent démarrer que sur les 128
premiers G. Vous pouvez utiliser ces systèmes avec de gros disques durs,
mais la partition racine devra être placée dans les premiers 128G.
 
<p>
Notez qu'il est toujours possible d'installer un disque dur de 40G sur un vieux
486 et d'y placer OpenBSD sur une seule et énorme partition ; vous pourriez
penser avoir réussi à violer la règle précédente. Cependant, un beau jour,
celle-ci risque de revenir vous hanter de manière peu plaisante :

<ul>
  <li>Vous installez tout sur une partition / de 40G. Cela fonctionne car le
système de base et ses fichiers (/bsd inclu) se situent dans les premiers 504M.
  <li>Vous utilisez le système et finissez par avoir pus de 504M de données
dessus.
  <li>Vous mettez à jour, compilez un nouveau noyau, au autre, et vous copiez
votre nouveau /bsd sur l'ancien.
  <li>Vous redémarrez.
  <li>C'est alors que vous recevez un message tel que "ERR M" ou rencontrez des
problèmes lors du démarrage.
</ul>
<p>
Pourquoi ? Simplement parce que vous avez "écrasé" l'ancien /bsd par le nouveau,
ce fichier n'a pas été écrit au-dessus de l'autre, mais a été relocalisé vers un
autre endroit sur le disque, probablement au-delà des 504 premiers M supportés
par le bios. Le chargeur de démarrage se voit alors dans l'impossibilité
d'atteindre /bsd et le système se fige.

<p>
Afin de permettre le lancement d'OpenBSD, les chargeurs de démarrage
(biosboot(8) et <tt>/boot</tt> dans le cas d'un i386) ainsi que le noyau
(<tt>/bsd</tt>) doivent se situer à l'intérieur de l'espace d'adressage supporté
par la ROM de boot et par leurs propres capacités. Afin de ne jamais rencontrer
de problèmes, la règle est simple :

<p>
<b>la partition racine dans son ensemble doit se situer dans l'espace
d'adressage supporté par le BIOS (ou la ROM de démarrage).</b>

<p>
Certains utilisateurs n'utilisant pas d'i386 peuvent penser qu'ils sont
immunisés contre ce problème, cependant, de nombreuses plateformes possèdent une
certaine limite fixée par la ROM de démarrage concernant la taille du disque.
Trouver cette limite peut être compliquée.

<p>
Et c'est une autre raison pour <a href="faq4.html#SpaceNeeded">partitionner
votre disque dur</a>, plutôt que d'utiliser une seule grosse partition.

<h3>fsck(8) : impératifs de durée et de mémoire</h3>
Les autres points à prendre en considération avec les gros systèmes de fichiers
sont le temps et la mémoire nécessaires à l'utilisation de <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=fsck&amp;sektion=8">fsck(8)
</a> après un crash ou à une coupure de courant. On ne peut pas créer un
système de fichiers de 120G sur un disque et espérer utiliser fsck(1) avec
succès après un crash. Une règle simple à appliquer est de considérer que le
système doit posséder au moins 1M de mémoire libre pour chaque 1G d'espace
disque afin d'utiliser fsck sans problème. Le temps nécessaire à l'utilisation
de fsck peut devenir un problème au fur et à mesure que le système de fichiers
grossit.


<a name="InstBoot"></a>
<h2>14.8 - Installation des blocs de démarrage ("Bootblocks") - spécifique
i386</h2>

<p>
Les anciennes versions de MS-DOS n'étaient capables d'intéragir qu'avec les
disques dont la géométrie était de 1024 cylindres ou moins. Puisque de nos jours
tous les disques ont plus de 1024 cylindres, la plupart des BIOS SCSI (qui sont
présents sur les cartes contrôleur SCSI) et IDE (qui sont inclus avec le reste
du BIOS du PC) possèdent une option qui "traduit" la véritable géométrie du
disque en une géométrie compatible 'MS-DOS'. Cependant, tous les BIOS ne
"traduisent" pas cette géométrie de la même manière. Si vous changez votre BIOS
(en installant une nouvelle carte mère ou un nouveau contrôleur SCSI) et que le
nouveau utilise une "traduction" de géométrie différente, vous ne pourrez pas
lancer le chargeur de démarrage de niveau 2 ("second-stage boot loader") et donc
le noyau. Cela est du au fait que le chargeur de démarrage de niveau 1
("first-stage boot loader") contient la liste des blocs conprenant /boot
formatée selon l'ancienne géométrie "traduite". Si vous utilisez des disques
IDE et effectuez des changements dans la configuration de votre BIOS, vous
pouvez (sans le savoir) changer aussi la traduction de la géométrie (la plupart
des BIOS proposent 3 types de traductions différentes).Pour réparer votre bloc
de démarrage afin que vous puissiez booter normalement, insérez une disquette
dans votre lecteur (ou utilisez un CD-ROM bootable) et à l'invite de commandes,
tapez "b hd0a:/bsd" afin de le forcer à démarrer sur le premier disque (et non
sur la disquette). Votre machine devrait se lancer normalement. Vous devez à
présent mettre à jour le chargeur de premier niveau pour qu'il voit la nouvelle
géométrie (et récrive le bloc de démarrage en conséquence). <br>Notre exemple
assume que votre disque de démarrage est sd0 (mais pour de l'IDE, ce pourrait
être wd0, etc) :

<pre>
# <b>cd /usr/mdec; ./installboot /boot biosboot sd0</b>
</pre>

<p>
Si une nouvelle version des blocs de démarrage est nécessaire, vous devrez la
compiler vous même. Pour ce faire, tapez simplement :

<pre>
# <b>cd /sys/arch/i386/stand/</b>
# <b>make &amp;&amp; make install </b>
# <b>cd /usr/mdec; cp ./boot /boot</b>
# <b>./installboot /boot biosboot sd0</b> (ou quelque soit le périphérique
désignant votre disque dur)
</pre>

<a name="Backup"></a>
<h2>14.9 - Se préparer au désastre : faire une sauvegarde vers une bande et
effectuer une restauration</h2>

<h3>Introduction :</h3>

<p>
Si vous envisagez d'administrer ce que l'on pourrait appeler un serveur de
production, il est préférable d'avoir une sauvegarde au cas où l'un de vos
disques durs tomberait en panne.

<p>
Cette documentation vous assistera dans l'utilisation des utilitaires standards
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">
dump(8)</a>/<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">
restore(8)</a> fournis avec OpenBSD. Un autre utilitaire de sauvegarde plus
avancé nommé "Amanda" est également disponible via les <a
href="faq8.html#Ports">ports</a> afin de sauvegarder plusieurs serveurs vers un
unique lecteur de bandes. Dans la plupart des environnements, <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)
</a>/<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=restore&amp;sektion=8">
restore(8)</a> suffit. Cependant, si vous avez besoin de sauvegarder plusieurs
machines vers une seule bande, il peut être utile de se documenter sur Amanda
dans le futur.

<p>
Les périphériques utilisés en exemple dans ce document se réfèrent à une
configuration utilisant des disques et lecteurs de bandes SCSI. En environnement
de production, les disques SCSI sont recommandés en place des disques IDE pour
la façon dont ils gèrent les blocs défectueux. Ceci ne signifie pas pour autant
que ce document est sans intérêt pour les possesseurs de disques IDE ou d'autres
types de lecteurs de bandes, les noms de vos périphériques changeront
légèrement. Par exemple, sd0a deviendra wd0a dans un système à base d'IDE.

<h3>Sauvegarder vers une bande :</h3>

<p>
Sauvegarder sur bande demande de savoir exactement où vos systèmes de fichiers
sont montés. Vous pouvez le déterminer en utilisant la commande <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">mount(8)
</a> dans un terminal. Vous devriez obtenir une sortie similaire à celle-ci :

<pre>
# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0h on /usr type ffs (local)
</pre>

<p>
Dans cet exemple, le système de fichiers racine (/) réside physiquement sur
sd0a, ce qui désigne la partition a du disque SCSI fixe 0. Le système de
fichiers /usr réside sur sd0h, ma partition h du disque SCSI fixe 0.

<p>
Un autre exemple de ce qu'une table de montage plus avancée pourrait être :

<pre>
# <b>mount</b>
/dev/sd0a on / type ffs (local)
/dev/sd0d on /var type ffs (local)
/dev/sd0e on /home type ffs (local)
/dev/sd0h on /usr type ffs (local)
</pre>

<p>
Dans cet exemple plus compliqué, le système de fichiers racine (/) réside
physiquement sur sd0a ; /var sur sd0d; /home sur sd0e et enfin /usr sur sd0h.

<p>
Afin de sauvegarder votre machine, vous aurez besoin de renseigner dump avec le
nom exact de chaque partition fixe. Voici un exemple des commandes nécessaires
pour sauvegarder la table de montage simple vue plus haut :

<pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h</b>
# <b>mt -f /dev/rst0 rewind  </b>
</pre>

<p>
Pour la table de montage plus avancée, vous utiliserez des commandes similaires
à :

<pre>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e</b>
# <b>/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h  </b>
# <b>mt -f /dev/rst0 rewind  </b>
</pre>

<p>
Vous pouvez vous référer à la page de manuel de <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dump&amp;sektion=8">dump(8)
</a> afin de connaître les fonctionnalités de chaque option. Voici une brève
description des paramètres utilisés :

<ul>
<li><b>0</b> - Effectue un dump de niveau 0, sauvegarde tout.
<li><b>a</b> - Tente de détecter automatiquement la taille de la bande.
<li><b>u</b> - Met à jour le fichier /etc/dumpdates afin de savoir quand la
dernière sauvegarde a été effectuée.
<li><b>f</b> - Lecteur de bande à utiliser (ici, /dev/nrst0).
</ul>

<p>
Et finalement, la partition à sauvegarder (/dev/rsd0a, etc).

<p>
La commande <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=mt&amp;sektion=1">mt(1)</a>
est utilisée à la fin pour rembobiner la bande. Référez-vous au manuel de mt
afin de connaître les options disponibles (comme eject).

<p>
Si vous n'êtes pas sûr du nom de périphérique du lecteur, utilisez dmegs pour le
localiser. Un lecteur de bande peut, par exemple, apparaître ainsi dans dmesg :

<pre>
st0 at scsibus0 targ 5 lun 0: &lt;ARCHIVE, Python 28388-XXX, 5.28&gt;
</pre>

<p>
Vous avez peut-être noté que, lors d'une sauvegarde, le lecteur est accédé par
son nom de périphérique "<tt>nrst0</tt>" au lieu de "<tt>st0</tt>" qui apparait
dans dmesg. Lorsque vous accédez <tt>st0</tt> à la place de <tt>nrst0</tt>, vous
accédez au même lecteur bande mais en mode "raw" et en lui indiquant de ne pas
rembobiner la bande à la fin du travail. Pour sauvegarder plusieurs systèmes de
fichiers sur une même bande, soyez certains d'utiliser le périphérique de
non-rembobinage ; dans le cas contraire (si vous utilisez <tt>rst0</tt>), la
sauvegarde du système de fichiers précédent sera écrasée à la prochaine écriture
sur la bande. Vous pouvez trouver une description plus conséquente de plusieurs
lecteurs de bande dans la page de manuel de dump.

<p>
Si vous souhaitez écrire un petit script appelé "backup", il pourrait ressembler
à celui-ci :

<pre>
echo "  Starting Full Backup..."
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0a
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0d
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0e
/sbin/dump -0au -f /dev/nrst0 /dev/rsd0h
echo
echo -n "  Rewinding Drive, Please wait..."
mt -f /dev/rst0 rewind
echo "Done."
echo
</pre>

<p>
Si des sauvegardes nocturnes planifiées sont nécessaires, <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=cron&amp;sektion=8">cron(8)
</a> pourra être utilisé pour lancer votre utilitaire de sauvegarde
automatiquement.

<p>
Il serait également utile de préciser (sur un bout de papier) la taille que
devrait avoir chaque système de fichiers. Vous pouvez utiliser "<tt>df -h</tt>"
afin de connaître l'espace actuellement utilisé par chaque partition. En effet,
ceci pourra vous aider lorsque votre disque dur tombera en panne et que vous
devrez recréer la table de partition sur le nouveau disque.

<p>
Restaurer vos données aidera aussi à réduire la fragmentation. Afin d'être sûr
de récupérer tous les fichiers, le meilleur moyen de sauvegarder est de
redémarrer votre système en mode "single user". Les systèmes de fichiers n'ont
pas besoin d'être montés pour être sauvegardés. N'oubliez pas de monter la
racine (/) en mode r/w (lecture/écriture) après avoir redémarré en mode "single
user" ou dump retournera une erreur lorsqu'il essayera d'écrire les "dumpdates".
Au démarrage, entrez "<tt>bsd -s</tt>" à l'invite de commandes boot&gt; pour
lancer le système en mode "single user".

<h3>Voir le contenu d'une sauvegarde sur bande :</h3>


<p>
Après avoir sauvegardé votre système de fichiers pour la première fois, il est
bon de vérifier rapidement votre bande afin d'être certain que que les données
sont bien présentes.

<p>
Vous pouvez utiliser l'exemple suivant afin de voir le catalogue de fichiers
présents sur une bande :

<pre>
# <b>/sbin/restore -tvs 1 -f /dev/rst0</b>
</pre>

<p>
Cette commande affichera la liste des fichiers présents sur la première
partition de la bande. Si l'on se réfère à l'exemple précédent, 1 serait votre
système de fichiers racine (/).

<p>
Pour afficher se qui est présent sur la deuxième partition vers un fichier, vous
utiliserez une commande similaire à :

<pre>
# <b>/sbin/restore -tvs 2 -f /dev/rst0 > /home/me/list.txt</b>
</pre>

<p>
Pour une table de partition assez simple, 2 serait /usr ; si la vôtre est plus
compliquée, 2 pourrait être /var/ ou un autre système de fichiers. L'ordre des
séquences est similaire à celui utilisé pour sauvegarder les systèmes de
fichiers sur la bande.


<h3>Restaurer à partir d'une bande :</h3>

<p>
Le scénario de l'exemple suivant pourrait être utile si votre disque tombait
complètement en panne. Dans le cas ou vous ne souhaiteriez récupérer qu'un seul
fichier à partir de la bande, référez-vous à la page de manuel de la commande
restore et soyez attentifs aux instructions concernant le mode intéractif.

<p>
Si vous avez bien tout préparé, remplacer un disque et restaurer vos données à
partir d'une bande peut être une procédure très rapide. La disquette standard
install/boot sous OpenBSD contient déja l'utilitaire restore ainsi que les
exécutables nécessaires au partitionnement de votre nouveau disque et permettant
de le rendre bootable. Dans la plupart des cas, cette disquette et votre bande
de sauvegarde la plus récente sont tout ce dont vous avez besoin pour remettre
votre machine en production.

<p>
Après avoir remplacé le disque en panne, suivez les étapes suivantes afin de
restaurer vos données :

<ul>
<li>
<p>
Démarrez à partir de la disquette install/boot d'OpenBSD. Au menu, choisissez
Shell. Insérez la bande de votre sauvegarde la plus récente bande, en lecture
seule, dans votre lecteur.
<br>
<li>
<p>
En vous aidant de la commande <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">
fdisk(8)</a>, créez une partition primaire OpenBSD sur le nouveau disque. Par
exemple :

<pre>
# <b>fdisk -e sd0</b>
</pre>

<p>
Référez-vous à l'<a href="#fdisk">Utilisation de fdisk(8) sous OpenBSD</a> pour
de plus amples informations.

<li>
<p>
Avec la commande disklabel, recréez votre table de partition OpenBSD à
l'intérieur de la partition primaire que vous venez de créer avec fdisk. Par
exemple :

<pre>
# <b>disklabel -E sd0</b>
</pre>

<p>
(N'oubliez pas la partition d'échange, swap, référez-vous à <a
href="#disklabel">Utilisation de disklabel</a> pour plus d'informations)

<li>
<p>
Utilisez la commande newfs pour créer un système de fichier vièrge sur chaque
partition que vous venez de créer. Par exemple :

<pre>
# <b>newfs /dev/rsd0a</b>
# <b>newfs /dev/rsd0h</b>
</pre>

<li>
<p>
Monter votre nouvelle partition racine (/) sur /mnt. Par exemple :

<pre>
# <b>mount /dev/sd0a /mnt</b>
</pre>

<li>
<p>
Allez dans le nouveau répertoire racine et démarrez la procédure de
restauration. Par exemple :

<pre>
# <b>cd /mnt</b>
# <b>restore -rs 1 -f /dev/rst0</b>
</pre>

<li>
<p>
Vous aurez besoin de rendre ce disque bootable, inspirez-vous la commande
suivante pour y inscrire un nouveau MBR. Par exemple :

<pre>
# <b>fdisk -i sd0</b>
</pre>

<li>
<p>
En plus d'inscrire un nouveau MBR, vous aurez besoin d'installer les blocs de
démarrage afin de pouvoir lancer la machine. Voici un bref exemple :

<pre>
# <b>cp /usr/mdec/boot /mnt/boot</b>
# <b>/usr/mdec/installboot -v /mnt/boot /usr/mdec/biosboot sd0</b>
</pre>

<li>
<p>
Votre nouveau système de fichiers racine devrait être suffisamment prêt pour
que vous puissiez démarrer dessus et continuer de restaurer le reste de vos
systèmes de fichiers. Puisque votre système d'exploitation n'est pas encore
complet, soyez sûrs de redémarrer en mode single-user. A l'invite de commandes,
effectuez la procédure suivante afin de démonter et redémarrer le système :

<pre>
# <b>umount /mnt</b>
# <b>halt</b>
</pre>

<li>
<p>
Retirez la disquette install/boot du lecteur et redémarrez votre machine. A
l'invite de commandes de boot d'OpenBSD, lancez les commandes suivantes :

<pre>
boot&gt; <b>bsd -s</b>
</pre>

<p>
La commande "bsd -s" ordonnera au noyau de démarrer en mode single-user qui ne
nécessite que le système de fichiers racine (/).

<li>
<p>
En admettant que vous ayez effectué correctement les étapes précédentes et que
tout se soit bien passé, vous devriez vous retrouver à une invite de commandes
vous demandant le chemin d'accès à un shell ou d'appuyer sur entrée. Appuyez sur
entrée pour utiliser sh. Ensuite, vous devrez remonter la racine en mode r/w
plutôt qu'en lecture seule. Lancez la commande suivante :

<pre>
# <b>mount -u -w /</b>
</pre>

<li>
<p>
Une fois la racine en mode r/w, vous pourrez continuer à restaurer vos autres
systèmes de fichiers. Par exemple :

<pre>
(table de montage simple)
# <b>mount /dev/sd0h /usr; cd /usr; restore -rs 2 -f /dev/rst0</b>

(table de montage avancée)
# <b>mount /dev/sd0d /var; cd /var; restore -rs 2 -f /dev/rst0</b>
# <b>mount /dev/sd0e /home; cd /home; restore -rs 3 -f /dev/rst0</b>
# <b>mount /dev/sd0h /usr; cd /usr; restore -rs 4 -f /dev/rst0</b>
</pre>

<p>
A la place, vous pourriez utiliser "<b>restore rvsf</b>" ou juste rsf pour voir
le nom des fichiers extraits de la sauvegarde.

<li>
<p>
Pour terminer, après avoir restauré tous vos systèmes de fichiers sur le disque,
redémarrez en mode multi-utilisateurs. Si tout s'est déroulé comme prévu, votre
système devrait se retrouver dans l'état dans lequel il se trouvait à la date
de votre sauvegarde la plus récente et être totalement fonctionnel.
</ul>

<a name="MountImage"></a>
<h2>14.10 - Montage des images disque sous OpenBSD</h2>

<p>
Pour monter une image disque (images ISO, images disques créées avec dd, etc)
sous OpenBSD, vous devez configurer un périphérique <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnd&amp;sektion=4">vnd(4)
</a>. Par exemple, si vous avez une image ISO localisée dans <i>/tmp/ISO.image
</i>, voici les étapes nécessaires pour la monter :

<table border=0 width="650">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<pre>
# <b>vnconfig svnd0 /tmp/ISO.image</b>
# <b>mount -t cd9660 /dev/svnd0c /mnt</b>
</pre>
                </td>
        </tr>
</table>

<p>
Remarquez que, puisque cette image est une image CD, vous devez spécifier le
type <i>cd9660</i> lors du montage. Ceci est vrai peut importe le type, par
exemple, vous devez utiliser <i>ext2fs</i> lors du montage d'images
dique Linux.

<p>
Pour démonter une image, utilisez les commandes suivantes.

<table border=0 width="650">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<pre>
# <b>umount /mnt</b>
# <b>vnconfig -u svnd0</b>
</pre>
                </td>
        </tr>
</table>

<p>
Pour plus d'information, référez-vous à la page de manuel de <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=vnconfig&amp;sektion=8">
vnconfig(8)</a>.


<a name="pciideErr"></a>
<h2>14.11 - A l'aide ! J'ai des erreurs avec IDE DMA !</h2>

<p>
Les transferts IDE DMA supportés par <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pciide&amp;sektion=4">
pciide(4)</a> ne sont pas fiables avec plusieurs combinaisons de matériel.
Jusqu'à récemment, la plupart des "principaux" systèmes d'exploitation
prétendant supporter les transferts DMA sur périphériques IDE n'activaient pas
cette fonctionnalité par défaut à cause de certains matériels peu fiables. A
présent, beaucoup de ces machines sont utilisées sous OpenBSD.

<p>
OpenBSD est agressif et tente d'utiliser le mode DMA le plus haut qu'il puisse
configurer. Ceci pourrait engendrer une corruption dans le transfert des données
sur certaines configurations à cause de certaines puces ("chipsets") de cartes
mères, de disques de mauvaise qualité et/ou de la friture sur les câbles.
Heureusement, les modes Ultra-DMA protègent les transferts de données avec CRC
afin de détecter une éventuelle corruption. Si le CRC de l'Ultra-DMA échoue,
OpenBSD affichera un message d'erreur et recommencera l'opération de transfert.

<pre>
wd2a:  aborted command, interface CRC error reading fsbn 64 of 64-79
(wd2 bn 127; cn 0 tn 2 sn 1), retrying
</pre>

<p>
Après plusieurs échecs, OpenBSD fera descendre le mode Ultra-DMA (à priori plus
fiable). Lorsqu'un mode Ultra-DMA atteint 0, le mode PIO prendra le relais.

<p>
Les erreurs UDMA sont souvent causées par des câbles endommagés ou de mauvaise
qualité. C'est pourquoi les câbles devraient être les premiers suspectés si vous
avez de nombreuses erreurs de DMA ou des performances dégradées. De plus, il
n'est pas conseillé de placer un lecteur de CD-ROM sur la même nappe qu'un
disque dur.

<p>
Si le remplacement des câbles ne résout pas le problème et qu'OpenBSD n'arrive
pas à faire descendre le niveau UDMA, que votre machine se fige ou que vous
obtenez trop de messages d'erreur sur la console et dans les logs, vous pouvez
forcer le système à utiliser un mode DMA ou UDMA inférieur par défaut. Ceci peut
être effectuté avec <a href="faq5.html#BootConfig">UKC</a> ou <a
href="faq5.html#config">config(8)</a> afin de changer les options du
périphérique <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=wd&amp;sektion=4">wd(4)</a>.


<a name="RAID"></a>
<h2>14.13 - Options RAID avec OpenBSD</h2>
Un ensemble redondant de disques durs indépendants (RAID - "Redundant Array of
Inexpensive Disks") vous offre la possibilité d'utiliser plusieurs disques afin
d'améliorer les performances, la capacité et/ou la redondance qu'un disque seul
ne serait pas capable d'apporter. Bien qu'une description des avantages ou des
risques apportés par une configuration RAID ne soit pas le propos de cet
article, il est important de noter les points suivants :

<ul>
<li>Un RAID ne constitue pas un système de sauvegarde.
<li>Seul, un RAID n'éliminera pas le délais d'indisponibilité.
</ul>

Si ces informations sont nouvelles pour vous, ce document n'est pas un bon point
de départ pour débuter avec un RAID.

<h3>Options logicielles</h3>
OpenBSD inclu RAIDframe, une solution logicielle de RAID. La documentation est
disponible ici :

<ul>
<li><a href="faq11.html#raid">FAQ 11, RAID</a>
<li><a href="http://www.pdl.cmu.edu/RAIDframe/">Page d'accueil de RAIDframe</a>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=raidctl&amp;sektion=8">manuel
de raidctl(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=raid&amp;sektion=4">
manuel de raid(4)</a>
</ul>

<p>
La partition racine peut être directement configurée en miroir par OpenBSD en
utilisant l'option "Autoconfiguration" de RAIDframe.

<p>
A partir d'OpenBSD 3.7-stable, le pilote <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccd&amp;sektion=4">
ccd(4)</a> inclu également une fonction de "mirroring". Il n'est pas
recommandé d'utiliser 3.7-release pour ceci, un bug ayant été corrigé
dans 3.7-stable. Ce système est inclu dans le noyau GENERIC et est
présent dans le noyau bsd.rd, ce qui facilite son utilisation même s'il
possède certaines limitations dans la reconstruction de l'array.
Référez-vous aux manuels :
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccd&amp;sektion=4">
ccd(4)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ccdconfig&amp;sektion=8">
ccdconfig(8)</a>
</ul>

<h3>Options matérielles</h3>
<p>
De nombreuses <a href="../../fr/plat.html">plateformes</a> OpenBSD supportent
plusieurs contrôleurs RAID matériels. Ceux-ci varient selon les plateformes,
référez-vous à la page des plateformes supportées (listées <a
href="../../fr/plat.html">ici</a>).

<p>
Une autre option accessible à plusieurs plateformes est l'un des
nombreux produits qui font apparaître plusieurs disques comme un seul
disque IDE ou SCSI et sont ensuite branchés sur un contrôleur IDE ou
SCSI standard. Ces périphériques peuvent virtuellement fonctionner sur
n'importe quelle platerforme supportant IDE ou SCSI.

<p>
Quelques manufactureurs de ce type de produits :
<ul>
<li><a href="http://www.arcoide.com/">Arco</a>
<li><a href="http://www.accusys.com.tw/">Accusys</a>
<li><a href="http://www.maxtronic.com/">Maxtronic</a>
<li><a href="http://www.infortrend.com/">Infortrend</a>
</ul>
(Note : ce sont des produits que certains utilisateurs d'OpenBSD
utilisent ; il ne s'agit en aucun cas d'une liste exhaustive ni de
matériels certifiés).


<h3>Options non valides</h3>
<p>
Une question récurrente sur les <a href="../../fr/mail.html">listes de
diffusion</a> consiste à savoir si "les contrôleurs RAID IDE ou SATA peu
coûteux (tels que les contrôleurs HighPoint, Promise ou Adaptec HostRAID) sont
supportés ?". La réponse est "Non". Ces cartes et puces ne sont pas de
véritables contrôleurs RAID matériels mais plutôt des RAID logiciels assistés
par un BIOS. Puisqu'OpenBSD supporte déja le RAID logiciel indépendamment du
type de matériel, il n'y a pas de volonté parmi les développeurs OpenBSD
d'implémenter un support spécifique à ces cartes.

<p>
Presque tous ces contrôlleurs "RAID" SATA ou IDE embarqués sont de type
logiciel et fonctionneront sans problème comme contrôlleur SATA ou IDE
en utilisant le pilote IDE standard
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pciide&amp;sektion=4">pciide(4)</a>),
mais ne fonctionneront pas comme RAID matériel sous OpenBSD.

<a name="NegSpace"></a>
<h2>14.14 - Pourquoi <tt>df(1)</tt> me dit que j'ai plus de 100% d'espace disque
utilisé ?</h2>
Certaines personnes sont parfois surprises de voir qu'elles ont un
espace disque disponible <i>negatif</i> ou que plus de 100% de l'espace
d'une partition est utilisé, comme on peut le voir avec <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=df&amp;sektion=1">df(1)</a>.

<p>
Lorsqu'une partition est créée avec <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=newfs&amp;sektion=8">newfs(8)
</a>, un certain montant d'espace disque inaccessible aux utilisateurs
est réservé. Cela permet d'avoir une marge d'erreur en cas de
remplissage accidentel du disque et de garder la fragmentation au
minimum. Par défaut, l'espace réservé correspond à 5% de la capacité du
disque ce qui signifie que si root a imprudemment rempli le disque, vous
pouvez vous retrouver avec 105% de capacité disponible utilisée.

<p>
Si une valeur de 5% ne vous semble pas appropriée, vous pouvez la
changer avec la commande
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tunefs&amp;sektion=8">
tunefs(8)</a>.

<a name="OhBugger"></a>
<h2>14.15 - Récupération de partitions après une suppression du
disklabel</h2>

<p>
Si vous avez une table de partitions endommagée, vous disposez de
plusieurs moyens afin d'essayer de la récupérer.

<p>
Premièrement, paniquez.
Vous le faites relativement souvent, et ceci devrait donc bien se
passer.
Cependant, ne faites rien de stupide.
Paniquez à l'écart de votre machine.
Ensuite, relaxez vous, et voyez si les étapes suivantes ne pourraient
pas vous aider.

<p>
Depuis OpenBSD 3.6, une copie de votre disklabel est sauvegardée pour
chaque disque dans <tt>/var/backups</tt> via la maintenance système
journalière.
A condition d'avoir encore votre partition var, vous pouvez simplement
lire la sortie, et la réintégrer dans disklabel.

<p>
Dans le cas ou vous ne pouvez plus voir cette partition, il y a deux
options. Corriger une assez grande partie du disque afin de la voir, ou
fixer une partie suffisament grande du disque afin de pouvoir récupérer
vos données.

Selon ce qui s'est passé, l'une ou l'autre de ces deux solutions serait
préférable (avec des disques mourrants vous voudrez en premier les
données, avec des doigts mouillés vous ne pourrez avoir que le label).

<p>

Le premier bon outil dont vous avez besoin est
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=scan_ffs">scan_ffs(8)</a>
(remarquez l'underscore, il ne s'appelle pas "scanffs").
scan_ffs(8) regardera au travers du disque, et essaiera de trouver les
partitions, en vous avertissant des informations qu'il trouve sur
celles-ci).
Vous pouvez utiliser ces informations pour recréer le disklabel. Si vous
voulez uniquement restaurer <tt>/var</tt>, vous pouvez recréer la
partition pour <tt>/var</tt>, et ensuite récupérer le label et ajouter
le reste.

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel;sektion=8">disklabel(8)</a>
mettra à jour à la fois la compréhension du disklabel par le noyau, et
essaiera également d'écrire le label sur le disque. Ainsi, même si la
partie du disque qui contient le disklabel est illisible, vous serez en
mesure de la monter avec
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount;sektion=8">mount(8)</a>
jusqu'au prochain redémarrage.


<a name="foreignfs"></a>
<h2>14.16 - Est-il possible d'accéder aux données présentes sur des
systèmes de fichiers autres que FFS ?</h2>
<!-- This article written by Steven Mestdagh,
steven.mestdagh@esat.kuleuven.be, and released under the BSD license -->

Oui. Les systèmes de fichiers supportés sont : ext2 (Linux), ISO9660
(CD-ROM, DVD), FAT (MS-DOS et Windows), NFS, NTFS (Windows), AmigaDOS.
Certains n'ont qu'un support limité, comme par exemple l'accès en
lecture uniquement.

<p>
Nous allons donner un aperçu sur la façon d'utiliser un de ces systèmes
de fichiers sous OpenBSD. Afin d'utiliser un système de fichiers,
celui-ci doit être monté. Pour plus de détails sur les options de
montage, référez-vous au manuel de <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount&amp;sektion=8">
mount(8)</a> ainsi qu'à celui correspondant au système de fichiers que
vous souhaitez monter. Par exemple, mount_msdos, mount_ext2fs, ...

<p>
Tout d'abord, vous devez connaître le périphérique sur lequel votre
système de fichiers est présent. Cela peut être tout simplement votre
disque dur, <tt>wd0</tt> ou <tt>sd0</tt>, mais ça n'est pas toujours
évident. Tous les périphériques reconnus et configurés par votre système
apparaissent dans la sortie de la commande <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=1">
dmesg(1)</a> : un nom de périphérique, suivi par une ligne descriptive.
Ainsi, mon premier CD-ROM est reconnu de la façon suivante :

<blockquote><pre>
cd0 at scsibus0 targ 0 lun 0: &lt;COMPAQ, DVD-ROM LTD163, GQH3&gt; SCSI0 5/cdrom removable
</pre></blockquote>

<p>
A présent, il est temps de déterminer quelles partitions sont présentes
sur le périphérique et sur quelle partition le système de fichiers qui
nous intéresse est présent. Nous examinerons le périphérique en
utilisant <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">
disklabel(8)</a>. Le 'disklabel' comporte une liste de partitions, 16 au
maximum. La partition c désigne toujours le périphérique dans son
ensemble. Les partitions a-b et d-p sont utilisées par OpenBSD. Les
partitions i-p peuvent être allouées automatiquement aux systèmes de
fichiers d'autres systèmes d'exploitation. Dans notre cas, j'analyserai
le 'disklabel' de mon disque dur qui contient un certain nombre de
systèmes de fichiers.

<blockquote><pre>
# <b>disklabel wd0</b>

# using MBR partition 2: type A6 off 20338290 (0x1365672) size 29318625 (0x1bf5de1)
# /dev/rwd0c:
type: ESDI
disk: ESDI/IDE disk
label: ST340016A
flags:
bytes/sector: 512
sectors/track: 63
tracks/cylinder: 16
sectors/cylinder: 1008
cylinders: 16383
total sectors: 78165360
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # microseconds
track-to-track seek: 0  # microseconds
drivedata: 0

16 partitions:
#             size        offset  fstype [fsize bsize  cpg]
  a:        408366      20338290  4.2BSD   2048 16384   16 # Cyl 20176*- 20581 
  b:       1638000      20746656    swap                   # Cyl 20582 - 22206 
  c:      78165360             0  unused      0     0      # Cyl     0 - 77544 
  d:       4194288      22384656  4.2BSD   2048 16384   16 # Cyl 22207 - 26367 
  e:        409248      26578944  4.2BSD   2048 16384   16 # Cyl 26368 - 26773 
  f:      10486224      26988192  4.2BSD   2048 16384   16 # Cyl 26774 - 37176 
  g:      12182499      37474416  4.2BSD   2048 16384   16 # Cyl 37177 - 49262*
  i:         64197            63 unknown                   # Cyl     0*-    63*
  j:      20274030         64260 unknown                   # Cyl    63*- 20176*
  k:       1975932      49656978   MSDOS                   # Cyl 49262*- 51223*
  l:       3919797      51632973 unknown                   # Cyl 51223*- 55111*
  m:       2939832      55552833  ext2fs                   # Cyl 55111*- 58028*
  n:       5879727      58492728  ext2fs                   # Cyl 58028*- 63861*
  o:      13783707      64372518  ext2fs                   # Cyl 63861*- 77535*

</pre></blockquote>

<p>
Comme on peut le constater, les partitions OpenBSD sont affichées en
premier. Puis l'on peut voir un certain nombre de partitions ext2, une
partition MSDOS ainsi que plusieurs partitions inconnues ('unknown').
Sous i386 ou amd64, vous pouvez généralement en savoir plus sur
celles-ci en utilisant l'utilitaire <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=fdisk&amp;sektion=8&amp;arch=i386">
fdisk(8)</a>. Pour le lecteur curieux, la parition i est une partition
de maintenance créée par le revendeur, la partition j est une partition
NTFS et et la parition l est une partition d'échange Linux
('Linux swap').

<p>
Après avoir déterminée la partition que vous souhaitez utiliser, vous
pouvez enfin monter le système de fichiers qu'elle contient. La plupart
des systèmes de fichiers sont supportés par de noyau GENERIC :
référez-vous à son fichier de configuration situé dans le répertoire
<tt>/usr/src/sys/arch/&lt;<i>arch</i>&gt;/conf</tt>. Cependant, certains
dont le support est expérimental (comme NTFS) ne sont pas inclus dans le
noyau GENERIC. Si vous souhaitez utiliser un de ces systèmes de
fichiers, vous devrez <a href="faq5.html#Options">recompiler votre noyau
</a>.

<p>
Une fois les informations nécessaires entre vos mains, il est temps de
monter le système de fichiers. Imaginons que le répertoire
<tt>/mnt/otherfs</tt> existe, nous l'utiliserons pour monter le système
de fichiers souhaité. Dans l'exemple suivant, nous monterons un système
de fichiers ext2 dans la partition m :

<blockquote><pre>
# <b>mount -t ext2fs /dev/wd0m /mnt/otherfs</b>
</pre></blockquote>

<p>
Si vous souhaitez utiliser ce système de fichiers régulièrement, vous
gagnerez du temps en insérant la ligne suivante dans votre fichier
<tt>/etc/fstab</tt> :

<blockquote><pre>
/dev/wd0m /mnt/otherfs ext2fs rw,noauto,nodev,nosuid 0 0
</pre></blockquote>

Notez les valeurs 0 dans les cinquièmes et sixièmes champs. Cela indique
que nous ne souhaitons pas que le système de fichiers soit sauvegardé
(avec dump) ni vérifié avec fsck. Généralement, il est préférable de
laisser le système d'exploitation associé à ces systèmes de fichiers
s'occuper de ces choses.


<a name="flashmem"></a>
<h2>14.17 - Est-il possible d'utiliser un périphérique de masse ('flash
memory device') sous OpenBSD ?</h2>
<!-- This article written by Steven Mestdagh,
steven.mestdagh@esat.kuleuven.be, and released under the BSD license -->

Théoriquement, un périphérique mémoire devrait être reconnu dès sont
insertion dans la machine. Peut après l'avoir branché, un certain nombre
de messages du noyau devrait apparaître sur la console. Ainsi, lorsque
je branche mon périphérique USB, voici ce qui apparait sur la console :

<blockquote><pre>
umass0 at uhub1 port 1 configuration 1 interface 0
umass0: LEXR PLUG DRIVE LEXR PLUG DRIVE, rev 1.10/0.01, addr 2
umass0: using SCSI over Bulk-Only
scsibus2 at umass0: 2 targets
sd0 at scsibus2 targ 1 lun 0: &lt;LEXAR, DIGITAL FILM, /W1.&gt; SCSI2 0/direct removable
sd0: 123MB, 123 cyl, 64 head, 32 sec, 512 bytes/sec, 251904 sec total
</pre></blockquote>

Ces lignes indiquent que le pilote <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=umass&amp;sektion=4">
umass(4)</a> (périphérique de masse USB -'USB mass storage') à été
rattaché au périphérique mémoire et qu'il utilise le système SCSI. Les
deux dernières lignes sont les plus importantes : elles indiquent sur
quel fichier de périphérique le matériel a été rattaché ainsi que le
montant total d'espace de stockage. Si vous avez manqué ces lignes, vous
pouvez vous y référez plus tard à l'aide de la commande <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=1">
dmesg(1)</a>. La géométrie CHS est fictive puisque le périphérique USB
est traité comme un disque SCSI classique.

<p>
Nous allons voir deux scénarios possibles.

<h3>Le périphérique est nouveau/vide et vous souhaitez l'utiliser
exclusivement avec OpenBSD.</h3>

Vous allez devoir initialiser un 'disklabel' sur le périphérique et
créer au minimum une partition. Pour plus de détails, lisez
<a href="#disklabel">Utilisation de disklabel(8) sous OpenBSD</a> ainsi
que sa <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=disklabel&amp;sektion=8">
page de manuel</a>.

<p>
Dans cet exemple, je ne vais créer qu'une seule partition <i>a</i> dans
laquelle je placerai un système de fichiers FFS :

<blockquote><pre>
# <b>newfs sd0a</b>
Warning: inode blocks/cyl group (125) >= data blocks (62) in last
    cylinder group. This implies 1984 sector(s) cannot be allocated.
/dev/rsd0a:     249856 sectors in 122 cylinders of 64 tracks, 32 sectors
        122.0MB in 1 cyl groups (122 c/g, 122.00MB/g, 15488 i/g)
super-block backups (for fsck -b #) at:
 32,
</pre></blockquote>

Montons le système de fichiers créé dans la partition <i>a</i> sur
<tt>/mnt/flashmem</tt>. Si le point de montage n'existe pas, créez-le.

<blockquote><pre>
# <b>mkdir /mnt/flashmem</b>
# <b>mount /dev/sd0a /mnt/flashmem</b>
</pre></blockquote>

<h3>Vous avez reçu le périphérique de quelqu'un avec qui vous souhaitez
échanger des données.</h3>

<p>
Il y a une grande chance que la personne en question n'utilise pas
OpenBSD, ce qui signifie qu'un système de fichiers étranger doit être
présent sur le périphérique. Nous allons donc devoir découvrir quelles
partitions sont présentes, comme décrit dans la section précédente :
<a href="#foreignfs">Est-il possible d'accéder aux données présentes sur
des systèmes de fichiers autres que FFS ?</a>.

<blockquote><pre>
# <b>disklabel sd0</b>

# /dev/rsd0c:
type: SCSI
disk: SCSI disk
label: DIGITAL FILM    
flags:
bytes/sector: 512
sectors/track: 32
tracks/cylinder: 64
sectors/cylinder: 2048
cylinders: 123
total sectors: 251904
rpm: 3600
interleave: 1
trackskew: 0
cylinderskew: 0
headswitch: 0           # microseconds
track-to-track seek: 0  # microseconds
drivedata: 0 

16 partitions:
#             size        offset  fstype [fsize bsize  cpg]
  c:        251904             0  unused      0     0      # Cyl     0 -   122 
  i:        250592            32   MSDOS                   # Cyl     0*-   122*
</pre></blockquote>

Le 'disklabel' nous apprend qu'il n'y a qu'une seule partition <i>i</i>,
contenant un système de fichiers FAT créé sur une machine Windows.
Comme d'habitude, la partition <i>c</i> représente l'ensemble du disque.

<p>
A présent, nous allons monter le système de fichiers présent dans la
partition <i>i</i> vers <tt>/mnt/flashmem</tt>.

<blockquote><pre>
# <b>mount -t msdos /dev/sd0i /mnt/flashmem</b>
</pre></blockquote>

Vous pouvez désormais l'utiliser comme n'importe quel autre disque.

<p>
<b>ATTENTION :</b>
Vous devriez toujours <b>démonter</b> le système de fichiers <b>avant de
débrancher</b> le périphérique de masse. Si vous ne le faites, le
système de fichiers pourrait être laissé dans un état inconsistant
pouvant emmener de la corruption dans vos données.

<p>
Après avoir débranché le périphérique de votre machine, vous verrez à
nouveau des messages du noyau sur la console :

<blockquote><pre>
umass0: at uhub1 port 1 (addr 2) disconnected
sd0 detached
scsibus2 detached
umass0 detached
</pre></blockquote>

<p>
<font color= "#0000e0">
<a href= "index.html">[Index de la FAQ]</a>
<a href= "faq13.html">[Section 13 - Multimédia]</a>
</font>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt="[back]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: faq14.html,v 1.131 ]<br>
$Translation: faq14.html,v 1.26 2005/06/15 16:21:01 ajacoutot Exp $<br>
-->
$OpenBSD: faq14.html,v 1.17 2005/06/16 13:01:09 saad Exp $
</small>

</body>
</html>
