<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>6 - Le réseau</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2008 by OpenBSD.">
</head>

<body bgcolor="#ffffff" text="#000000">
<!-- passes validator.w3.org, please keep it this way -->

<a href="../../fr/index.html">
<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif" border="0">
</a>
<p>
<font color="#0000e0">
<a href="index.html">[Index de la FAQ]</a>
<a href="faq5.html">[Section 5 - Construire le Système à partir des Sources]</a>
<a href="faq7.html">[Section 7 - Contrôles du clavier et de l'affichage]</a></font>

<h1><font color="#e00000">6 - Le réseau</font></h1>
<!-- UNCOMMENT ONLY WHEN THE FILE IS OUT OF SYNC

<hr>
<p>
<b><font color="#e00000">Remarque Importante :</font></b> Le contenu de
   ce fichier est obsolète. Consultez la version anglaise 
   <a href="../faq6.html">ici</a> pour des informations à jour.

<p>
Si vous souhaitez contribuez à l'effort de traduction,
prière de consulter
<a href="../../fr/translation.html">la page de traduction</a>.

-->
<hr>

<p>
<h3>Table des matières</h3>
<ul>
<li><a href= "#Intro">6.1 - Avant d'aller plus loin</a>
<li><a href= "#Setup">6.2 - Configuration du réseau</a>
<ul>
<li><a href="#Setup.if">6.2.1 - Identifier et configurer vos interfaces réseau</a>
<li><a href="#Setup.gateway">6.2.2 - Passerelle par défaut</a>
<li><a href="#Setup.resolver">6.2.3 - Résolution DNS</a>
<li><a href="#Setup.myname">6.2.4 - Nom d'hôte</a>
<li><a href="#Setup.activate">6.2.5 - Activer les changements</a>
<li><a href="#Setup.chkroute">6.2.6 - Vérifier les routes</a>
<li><a href="#Setup.forward">6.2.7 - Mettre en place une passerelle OpenBSD</a>
<li><a href="#Setup.aliases">6.2.8 - Configurer les alias sur une interface</a>
</ul>
<li><a href= "#PF">6.3 - Comment filtrer et utiliser un pare-feu sous
OpenBSD ?</a>
<li><a href= "#DHCP">6.4 - Protocole d'attribution dynamique des
adresses (DHCP)</a>
<ul>
<li><a href="#DHCPclient">6.4.1 - Client DHCP</a>
<li><a href="#DHCPserver">6.4.2 - Server DHCP</a>
</ul>
<li><a href= "#PPP">6.5 - Protocole Point à Point (PPP)</a>
<li><a href= "#Tuning">6.6 - Optimisation des paramètres
réseau</a>
<li><a href= "#NFS">6.7 - Utilisation de NFS</a>
<li><a href= "#Bridge">6.9 - Mise en place d'un pont ("bridge") avec OpenBSD</a>
<li><a href= "#PXE">6.10 - Comment démarrer en utilisant PXE ?</a>
<li><a href= "#CARP">6.11 - Protocole de redondance d'adresse commune (CARP)</a>
<li><a href="#OpenNTPD">6.12 - Utiliser OpenNTPD</a>
<li><a href="#Wireless">6.13 - Quels sont les types de cartes Sans Fil
supportées par OpenBSD ?</a>
<li><a href="#Multipath">6.14 - Comment puis-je mettre en oeuvre un
routage multi-chemin à coût égal ?</a>
</ul>

<hr>

<p>
<a name="Intro"></a>
<h2>6.1 - Avant d'aller plus loin</h2>

<p>
Afin de mieux comprendre ce document, vous devriez lire et assimiler
au moins partiellement la section <a href="faq5.html">Construire le Système
à partir des Sources</a> de la FAQ ainsi que le manuel
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a> et
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&amp;sektion=1">netstat(1)</a>.

<p>
Si vous êtes administrateur de réseau et que vous mettez en place
des protocoles de routage, si vous utilisez OpenBSD en tant que routeur, ou si
vous souhaitez en savoir plus sur les réseaux IP, vous devriez lire "<a
href="http://www.3com.com/other/pdfs/infra/corpinfo/en_US/501302.pdf">
Understanding IP Addressing</a>" (Comprendre l'adressage IP). Il s'agit d'un
excellent document. Vous pouvez vous appuyer sur celui-ci afin de vous aider
à travailler sur les réseaux IP, surtout si vous en avez un ou
plusieurs sous votre responsabilité.

<p>
Si vous travaillez sur des applications telles que des serveurs web, des
serveurs ftp et des serveurs de messagerie, vous pourriez
bénéficier de la <a
href="http://www.rfc-editor.org/rfc.html">lecture des RFCs</a>. A priori, vous
ne pourrez pas toutes les lire. Choisissez les sujets qui vous
intéressent ou les technologies que vous utilisez sur votre
réseau. Lisez-les et voyez comment ces technologies fonctionnent. Les
RFCs standardisent beaucoup (plusieurs milliers) de protocoles Internet et la
façon dont ils sont censés fonctionner.

<p>
<a name="Setup"></a>
<h2>6.2 - Configuration du réseau</h2>

Normalement, OpenBSD est configuré initialement durant la procédure
d'<a href="faq4.html">installation</a>. Cependant il est intéressant de
comprendre ce qui se passe pendant cette procédure et la façon dont
cela fonctionne.
Toute la configuration réseau est effectuée en utilisant de simples
fichiers texte sous le répertoire <i>/etc</i>.

<p>
<a name="Setup.if"></a>
<h3>6.2.1 - Identifier et configurer vos interfaces réseau</h3>

<p>
Sous OpenBSD, les interfaces sont nommées en fonction du type de la carte
réseau, et non en fonction du type de la connexion. Vous pouvez voir
l'initialisation de votre carte pendant la procédure de démarrage, ou après
celle-ci en utilisant la commande <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)
</a>. Vous avez aussi la possibilité de voir votre carte réseau
grâce à l'utilisation de la commande <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a>. Voici par exemple la sortie de la commande dmesg pour
une carte Intel Fast Ethernet qui utilise le nom de périphérique fxp.

<blockquote><pre>
fxp0 at pci0 dev 10 function 0 "Intel 82557" rev 0x0c: irq 5, address 00:02:b3:2b:10:f7
inphy0 at fxp0 phy 1: i82555 10/100 media interface, rev. 4
</pre></blockquote>

<p>
Si vous ne connaissez pas le nom du périphérique associé à votre carte,
regardez dans la liste des <a href="../../fr/plat.html">plates-formes
actuellement supportées</a> par votre architecture. Vous pourrez y
trouver le nom des cartes les plus courantes et leur équivalent sous
OpenBSD. Ajoutez au nom alphabétique du périphérique (par exemple fxp)
le numéro assigné par le noyau et vous aurez le nom de votre interface
(par exemple fxp0).

Le chiffre est attribué selon plusieurs critères dépendant du type de
carte et d'autres détails du système.
Certaines cartes se voient assigner un chiffre selon l'ordre dans lequel
elles ont été détectées au démarrage et d'autres selon la configuration
des ressources matérielles ou de l'adresse MAC.

<p>
Vous pouvez connaître quelles interfaces réseaux ont été identifiées à
l'aide de l'utilitaire <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a>. La commande suivante montrera toutes les interfaces
réseau d'un système. Cet exemple montre qu'il n'y a qu'une seule
interface Ethernet physique :
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp&amp;sektion=4">fxp(4)</a> .

<blockquote><pre>
$ <b>ifconfig</b>
lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 33224
        inet 127.0.0.1 netmask 0xff000000
        inet6 ::1 prefixlen 128
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x5
lo1: flags=8008&lt;LOOPBACK,MULTICAST&gt; mtu 33224
fxp0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        address: 00:04:ac:dd:39:6a
        media: Ethernet autoselect (100baseTX full-duplex)
        status: active
        inet 10.0.0.38 netmask 0xffffff00 broadcast 10.0.0.255
        inet6 fe80::204:acff:fedd:396a%fxp0 prefixlen 64 scopeid 0x1
pflog0: flags=0&lt;&gt; mtu 33224
pfsync0: flags=0&lt;&gt; mtu 2020
sl0: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt; mtu 296
sl1: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt; mtu 296
ppp0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500
ppp1: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500
tun0: flags=10&lt;POINTOPOINT&gt; mtu 3000
tun1: flags=10&lt;POINTOPOINT&gt; mtu 3000
enc0: flags=0&lt;&gt; mtu 1536
bridge0: flags=0&lt;&gt; mtu 1500
bridge1: flags=0&lt;&gt; mtu 1500
vlan0: flags=0&lt;&gt; mtu 1500
        address: 00:00:00:00:00:00
vlan1: flags=0&lt;&gt; mtu 1500
        address: 00:00:00:00:00:00
gre0: flags=9010&lt;POINTOPOINT,LINK0,MULTICAST&gt; mtu 1450
carp0: flags=0&lt;&gt; mtu 1500
carp1: flags=0&lt;&gt; mtu 1500
gif0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif1: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif2: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif3: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
</pre></blockquote>

<p>
Comme vous pouvez le voir, <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a> nous fourni ici beaucoup plus d'informations que nécessaire.
Mais nous pouvons tout de même voir notre interface. Dans l'exemple
précédent, la carte est déjà configurée. Ceci est évident de part la
présence d'une configuration réseau IP pour fxp0, à savoir &quot;inet
10.0.0.38 netmask 0xffffff00 broadcast 10.0.0.255&quot;. Les indicateurs
<b>UP</b> et <b>RUNNING</b> sont également présents.

<p>
Finalement, vous noterez que d'autres interfaces sont activées par
défaut. Il s'agit d'interfaces virtuelles servant différentes fonctions.
Les manuels suivants les décrivent :

<ul>
<!-- XXXrelease -->
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=lo&amp;sektion=4">lo</a>
 - Interface "Loopback"
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflog&amp;sektion=4">pflog</a>
 - Interface d'enregistrement du filtre de paquet (PF)
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=sl&amp;sektion=4">sl</a>
 - Interface SLIP (protocole Internet sur ligne série)
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=4">ppp</a>
 - Protocole point à point
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=tun&amp;sektion=4">tun</a>
 - Interface de tunnel
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=enc&amp;sektion=4">enc</a>
 - Interface d'encapsulation
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4">bridge
</a>
 - Interface de pont Ethernet
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=vlan&amp;sektion=4">vlan</a>
 - Interface d'encapsulation IEEE 802.1Q
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=gre&amp;sektion=4">gre</a>
 - Interface d'encapsulation GRE/MobileIP
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=gif&amp;sektion=4">gif</a>
 - Interface générique de tunnel IPv4/IPv6
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=carp&amp;sektion=4">carp</a>
 - Interface du protocole de redondance d'adresse (CARP)
</ul>

<p>
L'interface est configurée au démarrage en utilisant les fichiers <a 
href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5">/etc/hostname.<i>if</i>(5)</a>
où <i>if</i> est remplacé par le nom complet de votre interface, c'est à
dire dans notre exemple: <i>/etc/hostname.fxp0</i>.

<p>
Le format de ce fichier est simple :

<blockquote><pre>
address_family address netmask broadcast [autres options]
</pre></blockquote>

Beaucoup plus d'informations sur la syntaxe de ce fichier sont
disponibles dans le manuel <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5">
hostname.if(5)</a>.
Vous devrez le lire si vous avez besoin de configurations moins
triviales.

<p>
Un fichier de configuration typique pour une interface IPv4 ressemblera
à :

<blockquote><pre>
$ <b>cat /etc/hostname.fxp0</b>
inet 10.0.0.38 255.255.255.0 NONE
</pre></blockquote>

<p>
Dans ce cas, nous avons défini une adresse IPv4 (inet), avec une adresse
IP de 10.0.0.38, un masque de sous-réseau de 255.255.255.0 et pas
d'adresse de broadcast spécifique (qui sera mise par défaut à 10.0.0.255
dans notre cas).

<p>
Vous pouvez également spécifier le type de media d'une connexion
Ethernet pour, par exemple, forcer le mode 100baseTX full-duplex.

<blockquote><pre>
inet 10.0.0.38 255.255.255.0 NONE media 100baseTX mediaopt full-duplex
</pre></blockquote>

<p>
(Bien entendu, vous ne devriez jamais forcer le mode full duplex à moins
que les deux extrémités de la connexion ne soient configurées ainsi ! Si
ce n'est pour des besoins spécifiques, la configuration du type de media
n'est pas nécessaire.
Un cas plus réaliste serait de forcer le mode 10base-T ou half duplex
lorsque cela est rendu nécessaire par votre infrastructure.)

<p>
Vous pouvez aussi vouloir utiliser des indicateurs spécifiques à une
certaine interface. Le format du fichier hostname ne change que très
peu.

<blockquote><pre>
$ <b>cat /etc/hostname.vlan0</b>
inet 172.21.0.31 255.255.255.0 NONE vlan 2 vlandev fxp1
</pre></blockquote>

<a name="Setup.gateway"></a>
<h3>6.2.2 - Passerelle par défaut</h3>
Mettez l'adresse IP de votre passerelle par défaut dans le fichier <i>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mygate&amp;sektion=5">/etc/mygate</a></i>.
Cela permettra à votre route par défaut d'être configurée au démarrage.
Le fichier n'est constitué que d'une seule ligne comportant l'adresse IP
de la passerelle pour cette machine :

<blockquote><pre>
10.0.0.1
</pre></blockquote>

Il est possible d'utiliser un nom symbolique ici mais soyez prudents :
vous ne pouvez jamais être certain que le résolveur soit configuré ni
même accessible AVANT que la passerelle par défaut n'est été elle-même
configurée.
En d'autres termes, il est souhaitable que cela soit une adresse IP ou
un objet défini dans le fichier <i>/etc/hosts</i>.

<a name="Setup.resolver"></a>
<h3>6.2.3 - Résolution DNS</h3>
La résolution de noms DNS est configurée par le fichier <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&amp;sektion=5"><i>/etc/resolv.conf</i></a>.
Voici un exemple de fichier <i>/etc/resolv.conf</i> :

<blockquote><pre>
search example.com
nameserver 125.2.3.4
nameserver 125.2.3.5
lookup file bind
</pre></blockquote>

Dans notre cas, le domaine par défaut sera <tt>example.com</tt>, il y
a deux serveurs DNS, <tt>125.2.3.4</tt> et <tt>125.2.3.5</tt>, spécifiés
et le fichier <i>/etc/hosts</i> sera consulté avant que les DNS ne le
soient.

<p>
Comme sous la plupart des Unix (ainsi que de nombreux systèmes
non-Unix), il existe un fichier <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=hosts&amp;sektion=5"><i>/etc/hosts</i></a>
permettant de définir des systèmes qui ne sont pas (ou, si utilisés avec
la directive de priorité "lookup", ne sont pas désirés) dans le système
DNS formel.

<p>
Si vous utilisez DHCP, lisez <a href="#DHCP">6.4 - DHCP</a> en faisant
attention à la partie sur <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf.tail&amp;sektion=5">resolv.conf.tail(5)</a>.

<a name="Setup.myname"></a>
<h3>6.2.4 - Nom d'hôte</h3>
Chaque machine sous Unix possède un nom.
Sous OpenBSD, ce nom est défini comme FQDN ("Fully Qualified Domain
Name" - Nom d'Hôte Pleinement Qualifié") dans le fichier <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=myname&amp;sektion=5"><i>/etc/myname</i></a>.
Si cette machine se nomme "puffy" et que son domaine est "example.com",
le fichier contiendra la ligne :

<blockquote><pre>
puffy.example.com
</pre></blockquote>

<a name="Setup.activate"></a>
<h3>6.2.5 - Activer les changements</h3>
A présent, vous pouvez soit redémarrer, soit lancer le script
<b>/etc/netstart</b>. Vous pouvez l'exécuter simplement en
tapant (en tant que root) :

<blockquote><pre>
# <b>sh /etc/netstart</b>
writing to routing socket: File exists
add net 127: gateway 127.0.0.1: File exists
writing to routing socket: File exists
add net 224.0.0.0: gateway 127.0.0.1: File exists
</pre></blockquote>

<p>
Notez que plusieurs erreurs sont apparues. En exécutant ce script, vous
reconfigurez certaines choses qui le sont déjà. De fait, certaines
routes sont déjà présentes dans la table de routage du noyau. A présent,
votre système devrait être en état de fonctionner. Une nouvelle fois,
vous pouvez vérifier que votre interface a été correctement configurée
avec <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a>.

<p>
Bien que vous puissiez complètement reconfigurer le réseau sous OpenBSD
sans redémarrer, un reboot est FORTEMENT conseillé après tout changement
significatif dans la configuration.
La raison en est que l'environnement de démarrage est légèrement
différent de celui d'un système en production.
Ainsi, si vous avez défini un nom symbolique à résoudre par DNS dans un
de vos fichiers de configuration, vous vous apercevrez probablement que
cela fonctionnait après une reconfiguration mais que lors du démarrage,
votre résolveur pourrait ne pas être disponible et la configuration
échouer.

<a name="Setup.chkroute"></a>
<h3>6.2.6 - Vérification des routes</h3>
Vous pouvez vérifier vos routes via <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&amp;sektion=1">
netstat(1)</a> ou <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=route&amp;sektion=8">route(8)
</a>. Si vous avez des problèmes de routage, vous pouvez utiliser
l'option -n de la commande route(8) qui affichera l'adresse IP plutôt
que d'effectuer une requête DNS et d'afficher le nom d'hôte. Voici un
exemple qui vous permettra de voir vos tables de routage en utilisant
ces deux programmes.

<blockquote><pre>
$ <b>netstat -rn</b>
Routing tables

Internet:
Destination        Gateway            Flags     Refs     Use    Mtu  Interface
default            10.0.0.1           UGS         0       86      -  fxp0
127/8              127.0.0.1          UGRS        0        0      -  lo0
127.0.0.1          127.0.0.1          UH          0        0      -  lo0
10.0.0/24          link#1             UC          0        0      -  fxp0
10.0.0.1           aa:0:4:0:81:d      UHL         1        0      -  fxp0
10.0.0.38          127.0.0.1          UGHS        0        0      -  lo0
224/4              127.0.0.1          URS         0        0      -  lo0

Encap:
Source             Port  Destination        Port  Proto SA(Address/SPI/Proto)

$ <b>route show</b>
Routing tables

Internet:
Destination      Gateway            Flags
default          10.0.0.1           UG
127.0.0.0        LOCALHOST          UG
localhost        LOCALHOST          UH
10.0.0.0         link#1             U
10.0.0.1         aa:0:4:0:81:d      UH
10.0.0.38        LOCALHOST          UGH
BASE-ADDRESS.MCA LOCALHOST          U
</pre></blockquote>

<p>
<a name="Setup.forward"></a>
<h3>6.2.7 - Mettre en place une passerelle OpenBSD</h3>

<p>
Voici les informations nécessaires à la mise en place d'une passerelle
OpenBSD (appelé aussi routeur). Si vous devez installer OpenBSD pour en
faire un routeur Internet, nous vous suggérons de lire les instructions
sur la mise en place du filtre de paquets (plus loin) afin de bloquer le
trafic non-autorisé. Avec le peu de disponibilité d'adresses <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4">IPv4</a> de
la part des fournisseurs d'accès à Internet ainsi que des registres
Internet régionaux, vous pourriez vouloir vous renseigner sur la
translation d'adresses (NAT) afin d'économiser votre adressage IP.

<p>
Le noyau GENERIC est déjà configuré pour permettre le routage IP,
mais celui-ci doit être explicitement activé. Vous pouvez l'activer
avec l'utilitaire <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">
sysctl(8)</a>. Afin d'autoriser le routage de façon permanente,
éditez le fichier <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5">
/etc/sysctl.conf</a> et ajoutez-y la ligne suivante.

<blockquote><pre>
net.inet.ip.forwarding=1
</pre></blockquote>

<p>
Pour prendre en compte ce changement sans redémarrer, vous utiliserez
directement l'utilitaire
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8"> sysctl(8)</a>.
Souvenez-vous que ce changement ne sera pas sauvegardé au redémarrage et
que vous devrez être root pour utiliser cette commande.

<blockquote><pre>
# <b>sysctl net.inet.ip.forwarding=1</b>
net.inet.ip.forwarding: 0 -&gt; 1
</pre></blockquote>

<p>
A présent, modifiez les routes sur les hôtes aux deux extrémités. Il
existe beaucoup d'autres usages d'OpenBSD en tant que routeur avec
l'aide de programmes comme <a href="http://www.openbgpd.org/">OpenBGPD</a>
(qui fait partie du projet OpenBSD), <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=routed&amp;sektion=8">
routed(8)</a>, <a href="http://www.mrtd.net">mrtd</a>, <a
href="http://www.zebra.org">zebra </a> et <a
href="http://www.quagga.net">quagga</a>. Sous OpenBSD, zebra et mrtd
sont disponibles en tant que ports. OpenBGPD et routed sont inclus dans
le système de base. OpenBSD supporte différentes interfaces T1, HSSI,
ATM, FDDI, Ethernet et série (PPP/SLIP).

<p>
<a name="Setup.aliases"></a>
<h3>6.2.8 - Configurer les alias sur une interface</h3>

<p>
OpenBSD possède un mécanisme simple pour la mise en place d'alias
IP sur une interface. Pour ce faire, il suffit d'éditer le fichier <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5">
<i>/etc/hostname.&lt;if&gt;</i></a>. Ce fichier est lu au boot par le
script <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstart&amp;sektion=8">
/etc/netstart(8)</a> faisant partie de la séquence de démarrage <a
href="faq10.html#rc">rc</a>. Admettons par exemple qu'un utilisateur utilise
l'interface <b>dc0</b> et se trouve sur le réseau 192.168.0.0. Autres
informations importantes :

<ul>
<li>l'adresse IP pour dc0 est 192.168.0.2
<li>le masque de sous-réseau est 255.255.255.0
</ul>

<p>
Notes sur les alias. Sous OpenBSD, vous utilisez le nom de l'interface
uniquement. Il n'y a pas de différence entre le premier et le second
alias. A la différence d'autres systèmes d'exploitation, OpenBSD ne s'y
réfère pas en tant que dc0:0, dc0:1. Si vous vous référez à une adresse
IP d'alias avec ifconfig ou si vous ajoutez un alias, soyez sûr
d'utiliser la commande "<tt>ifconfig int alias</tt>" au lieu de
"<tt>ifconfig int</tt>". Vous pouvez supprimer les alias en utilisant
"<tt>ifconfig int delete</tt>".

<p>
En admettant que vous utilisiez plusieurs adresses avec alias sur le
même sous-réseau IP, le masque correspondant à chaque alias devient
255.255.255.255. Il n'est pas nécessaire d'utiliser le masque
correspondant à l'adresse IP primaire de l'interface. Dans cet exemple,
<i>/etc/hostname.dc0</i>, deux alias sont configurés pour le
périphérique dc0, qui lui-même possède l'adresse 192.168.0.2 avec un
masque de 255.255.255.0.

<blockquote><pre>
# <b>cat /etc/hostname.dc0</b>
inet 192.168.0.2 255.255.255.0 NONE media 100baseTX
inet alias 192.168.0.3 255.255.255.255
inet alias 192.168.0.4 255.255.255.255
</pre></blockquote>

<p>
Après avoir édité ce fichier, il suffit de redémarrer pour que les
changements prennent effet. Mais vous pouvez aussi créer les alias à la
main en utilisant l'utilitaire <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a>. Pour créer le premier alias, lancez la commande
suivante :

<blockquote><pre>
# <b>ifconfig dc0 inet alias 192.168.0.3 netmask 255.255.255.255</b>
</pre></blockquote>

(mais encore une fois, un redémarrage est conseillé afin d'être certain
que vous ayez rentré la configuration que vous pensiez !)

<p>
Pour voir les alias, utilisez la commande suivante :

<blockquote><pre>
$ <b>ifconfig -A</b>
dc0: flags=8863&lt;UP,BROADCAST,NOTRAILERS,RUNNING,SIMPLEX,MULTICAST&gt;
        media: Ethernet manual
        inet 192.168.0.2  netmask 0xffffff00 broadcast 192.168.0.255
        inet 192.168.0.3 netmask 0xffffffff broadcast 192.168.0.3
</pre></blockquote>


<p>
<a name="PF"></a>
<h2>6.3 - Comment filtrer et utiliser un pare-feu sous OpenBSD ?</h2>
Sous OpenBSD, le filtrage du trafic IP ainsi que la translation
d'adresses (NAT) est pris en charge par "Packet Filter" (filtre de
paquet ; auquel nous nous référerons à présent sous le nom de PF) . PF
est aussi capable de normaliser et de traiter le trafic IP, d'offrir
une gestion de la bande passante et une prioritarisation des paquets
ainsi que d'être utilisé dans la création de puissants et flexibles
pare-feu. Tout ceci est décrit dans le <a href="../pf/fr/index.html"><b>Guide
de l'Utilisateur PF</b></a>.


<p> 
<a name= "DHCP"></a>
<h2>6.4 - DHCP</h2> 

Le protocole d'attribution dynamique des adresses (DHCP) permet de
configurer les interfaces réseau automatiquement. OpenBSD peut être
serveur DHCP (afin de configurer les autres machines), client DHCP (afin
de recevoir sa configuration à partir d'une autre machine) et, dans
certains cas, les deux.

<p>
<a name="DHCPclient"></a>
<h3>6.4.1 Client DHCP</h3>

<p>
Pour utiliser le client DHCP <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient&amp;sektion=8">
dhclient(8)</a> inclus avec OpenBSD, éditez le fichier
<tt>/etc/hostname.xl0</tt> (sous-entendu que l'interface Ethernet soit
xl0. La vôtre pouvant être aussi bien ep0 que fxp0 ou encore autre chose).
Tout ce que vous avez besoin d'écrire dans ce fichier est
'<tt>dhcp</tt>' :

<blockquote><pre>
# <b>echo dhcp &gt; /etc/hostname.xl0</b>
</pre></blockquote>

<p>
Ceci aura pour effet de démarrer automatiquement le client DHCP au
démarrage. OpenBSD se verra attribuer son adresse IP, sa passerelle par
défaut et ses serveurs de noms (DNS) à partir du serveur DHCP.

<p>
Si vous souhaitez démarrer le client DHCP à partir de la ligne de
commande, vérifiez bien que <tt>/etc/dhclient.conf</tt> existe, puis
lancez la commande :

<blockquote><pre>
# <b>dhclient fxp0</b>
</pre></blockquote>

<p>
Où <tt>fxp0</tt> représente l'interface que vous voulez configurer
par DHCP.

<p>
Peu importe la façon dont vous démarrez le client DHCP, vous pouvez
éditer <tt>/etc/dhclient.conf</tt> afin de ne <b>pas</b> mettre à
jour vos DNS à l'aide du serveur dhcp en décommentant les lignes
'request' (il y a des exemples de configurations, mais vous devez les
décommenter afin de changer le comportement par défaut de
dhclient.)

<blockquote><pre>
request subnet-mask, broadcast-address, time-offset, routers,
      domain-name, domain-name-servers, host-name, lpr-servers, ntp-servers;
</pre></blockquote>

<p>
et supprimez <tt>domain-name-servers</tt>. Bien sûr, vous pouvez
également supprimer <tt>hostname</tt> ainsi que d'autres options.

<p>
En changeant les options dans le fichier <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient.conf&amp;sektion=5">
dhclient.conf(5)</a>, vous indiquez au client DHCP la façon de créer votre
fichier  <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&amp;sektion=5">
resolv.conf(5)</a>.
Le client DHCP écrase toutes les données déjà présentes dans resolv.conf(5)
en utilisant les informations envoyées par le serveur DHCP. De fait, tous les
changements que vous aurez apportés manuellement seront perdus.

<p>
Il existe deux mécanismes pour empêcher cela :
<ul>
<li>
<tt><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient.conf&amp;sektion=5#OPTION+MODIFIERS">OPTION MODIFIERS</a>
</tt> (<b>default</b>, <b>supersede</b>, <b>prepend</b>, et <b>append</b>)
vous permet de modifier n'importe quelles options du fichier dhclient.conf(5).

<li>
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf.tail&amp;sektion=5"><tt>resolv.conf.tail(5)</tt></a>
vous permet d'ajouter ce que vous souhaitez au fichier resolv.conf(5)
créé par dhclient(8).
</ul>

<p>
Imaginions que vous souhaitiez utiliser le client DHCP mais que vous
vouliez ajouter <tt>lookup file bind</tt> au fichier resolv.conf(5) créé
par dhclient(8).
Il n'existe pas de telle option dans le fichier <tt>dhclient.conf</tt> et
vous devrez donc utiliser <tt>resolv.conf.tail</tt> pour préserver ce
changement.

<blockquote><pre>
# <b>echo "lookup file bind" &gt /etc/resolv.conf.tail</b>
</pre></blockquote>

A présent, votre fichier resolv.conf(5) devrait inclure "lookup file bind"
à la fin.

<blockquote><pre>
nameserver 192.168.1.1
nameserver 192.168.1.2
lookup file bind
</pre></blockquote>

<p>
<a name="DHCPserver"></a>
<h3>6.4.2 Serveur DHCP</h3>

<p>
Pour utiliser OpenBSD en tant que serveur DHCP <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd&amp;sektion=8">dhcpd(8)
</a>, éditez le fichier <tt>/etc/rc.conf.local</tt> afin qu'il contienne la
ligne <tt>dhcpd_flags=""</tt>. Placez le nom des interfaces sur lesquelles vous
souhaitez que le serveur <b>écoute</b>, dans le fichier <tt>/etc/dhcpd.interfaces</tt>.

<pre>
     # <b>echo xl1 xl2 xl3 &gt;/etc/dhcpd.interfaces</b>
</pre>

<p>
Ensuite, éditez <tt>/etc/dhcpd.conf</tt>. Les options sont plutôt
explicites.

<pre>
        option  domain-name "example.com";
        option  domain-name-servers 192.168.1.3, 192.168.1.5;

        subnet 192.168.1.0 netmask 255.255.255.0 {
                option routers 192.168.1.1;

                range 192.168.1.32 192.168.1.127;
        }
</pre>

<p>
Ceci indique à vos clients DHCP que le domaine à ajouter aux
requêtes DNS est example.com (ainsi, si un utilisateur lance la commande
'telnet joe', il sera renvoyé vers joe.example.com). Les clients auront
comme serveurs DNS 192.168.1.3 et 192.168.1.5. Pour les hôtes
présents sur le sous-réseau correspondant à l'interface du
serveur OpenBSD, à savoir dans la plage 192.168.1.0/24, ils se verront
attribuer une adresse IP entre 192.168.1.32 et 192.168.1.127. Leur passerelle
par défaut sera 192.168.1.1.

<p>
Si vous souhaitez démarrer dhcpd(8) à partir de la ligne de
commandes, une fois <tt>/etc/dhcpd.conf</tt> configuré, tapez :

<pre>
     # <b>touch /var/db/dhcpd.leases</b>
     # <b>dhcpd fxp0</b>
</pre>

<p>
La ligne invoquant <tt>touch</tt> est nécessaire afin de créer un
fichier <tt>dhcpd.leases</tt> vide avant que dhcpd(8) ne démarre.
Les <a href="faq10.html#rc">scripts de démarrage</a> d'OpenBSD se
chargeront de créer ce fichier au boot, mais si vous lancez dhcpd(8)
manuellement, vous devez au préalable créer ce fichier.
<tt>fxp0</tt> représente l'interface sur laquelle vous voulez
répondre aux requêtes DHCP.

<p>
Si vous prévoyez de servir DHCP à des machines Windows, pour
pourriez souhaiter donner à ces clients une adresse de serveur 'WINS'.
Pour ce faire, ajoutez simplement la ligne suivante dans votre fichier
<tt>/etc/dhcpd.conf</tt> :

<pre>
     option    netbios-name-servers    192.168.92.55;
</pre>

<p>
(où <tt>192.168.92.55</tt> est l'adresse IP de votre serveur Windows ou
Samba.) Reportez vous au manuel
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcp-options&amp;sektion=5">
dhcp-options(5)</a> si vos clients DHCP ont besoin de plus d'options.


<p>
<a name="PPP"></a>
<h2>6.5 - PPP </h2>

<p>
Le protocole point à point est généralement utilisé
afin de créer une connexion modem vers votre FAI (fournisseur
d'accès à Internet). Sous OpenBSD, deux solutions existent.

<ul>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppd&amp;sektion=8">
pppd(8)</a>
 - implémentation noyau du service ppp.
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8">ppp(8)</a>
 - implémentation ppp en espace utilisateur ("userland"). 
</ul>

<p>
Chacune des implémentations (ppp et pppd) offrent des fonctionnalités similaires
de différentes façons. pppd utilise le pilote <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=4">ppp(4)</a>
inclus dans le noyau alors que ppp utilise <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=tun&amp;sektion=4">tun(4)</a>
dans l'espace utilisateur. Ce document ne couvrira que l'implémentation en
espace utilisateur du service PPP car il est plus simple à utiliser et
diagnostiquer. Pour commencer, vous aurez besoin de certaines informations
concernant votre FAI. En voici une liste non-exhaustive.

<ul>
<li>Le numéro de téléphone de votre FAI
<li>Votre serveur de noms
<li>Votre nom d'utilisateur et votre mot de passe
<li>Votre passerelle
</ul>

<p>
Certaines de ces options ne sont pas obligatoires mais vous aideront
à la mise en place de ppp. Le fichier de configuration du service
PPP est <a
href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.conf.sample">
/etc/ppp/ppp.conf</a>. Selon votre situation, les nombreux fichiers
présents dans <i>/etc/ppp</i> peuvent vous aider à la mise en
place de votre configuration. Vous devriez jeter un oeil à ce
répertoire.

<p>

<h3>Configuration initiale - pour PPP(8)</h3>

<p>
La configuration initiale de PPP nécessite l'édition du fichier
<i>/etc/ppp/ppp.conf</i>. Ce fichier n'existe pas par défaut, mais vous
pouvez vous inspirer du fichier <i>/etc/ppp/ppp.conf.sample</i> afin de
créer votre propre <i>ppp.conf</i>. Je commencerai par une configuration
simple et généralement très employée. Voici
rapidement un petit fichier <i>ppp.conf</i> définissant quelques valeurs
par défaut :

<blockquote><pre>
default:
set log Phase Chat LCP IPCP CCP tun command     
set device /dev/cua01                           
set speed 115200     
set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \"\" AT OK-AT-OK ATE1Q0 OK \\dATDT\\T TIMEOUT 40 CONNECT"
</pre></blockquote>

<p>
La section définie par le marqueur <tt>default:</tt> sera
exécutée à chaque fois. Cette section recense des
informations importantes. &quot;set log&quot; défini le niveau de
verbosité des logs. Il peut être changé :
référez-vous au manuel de <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8">ppp(8)</a>
pour plus d'informations concernant les niveaux d'enregistrement des
différents événements. Le périphérique utilisé est indiqué par &quot;set
device&quot;. Il s'agit du port sur lequel est présent notre modem. Dans
cet exemple, le modem est branché sur le port com 2. Ainsi, le port com
1 sera indiqué par <i>/dev/cua00</i>. La vitesse de la connexion est
précisée par &quot;set speed&quot; et &quot;set dial&quot; renseigne nos
paramètres de numérotation. Avec ceci, nous pouvons changer l'expiration
("timeout") de la connexion, etc. Ceci étant, cette ligne ne devrait pas
tellement varier.

<p>
Nous pouvons maintenant continuer et configurer les informations
spécifiques à notre FAI. Pour ce faire, nous allons rajouter une autre
section en dessous de <tt>default:</tt>. Le marqueur définissant cette
nouvelle section pourra être ce que vous désirez - le plus simple étant
d'utiliser le nom de votre FAI. Ici, nous utiliserons <tt>myisp:</tt> pour
indiquer le commencement de la section correspondant à notre FAI. Voici
une configuration simple contenant le nécessaire afin de nous connecter
:

<blockquote><pre>
myisp:
set phone 1234567   
set login "ABORT NO\\sCARRIER TIMEOUT 5 ogin:--ogin: ppp word: ppp"
set timeout 120   
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
add default HISADDR 
enable dns
</pre></blockquote>

<p>
Ici nous avons fourni les éléments essentiels concernant ce FAI. La
première option, &quot;set phone&quot;, donne le numéro de téléphone du
FAI. Nos options d'ouverture de session sont renseignées par &quot;set
login&quot;. Notre "timeout" est égal à 5 ; ce qui signifie que notre
tentative de connexion expirera après 5 secondes si aucune porteuse
n'est trouvée. Dans le cas contraire, &quot;login:&quot; sera envoyé
avec notre nom d'utilisateur et notre mot de passe.

<p>
Dans cet exemple, notre nom d'utilisateur est : ppp ; notre mot de passe
est : ppp. Ces valeurs doivent être changées. La ligne &quot;set
timeout&quot; permet de couper la connexion après 120 secondes de
non-utilisation. L'option &quot;set ifaddr&quot; est un peu plus compliquée.
En voici une explication plus complète.

<blockquote><pre>
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
</pre></blockquote>

<p>
La ligne précédente se définit avec le format suivant : &quot;<b>set
ifaddr [myaddr[/nn] [hisaddr[/nn] [netmask [triggeraddr]]]]</b>&quot;.
La première IP désigne l'adresse IP que nous souhaitons nous voir
attribuer. Si vous avez une adresse IP statique, vous devez l'indiquer
ici. Dans notre exemple, nous utilisons la notation /0 qui dit qu'aucun
"bit" de cette adresse ne doit forcément correspondre et que celle-ci
peut être changée. La deuxième adresse IP est celle du FAI. La troisième
option est notre masque de sous-réseau, ici défini à 255.255.255.0. Si
triggeraddr est renseigné, il remplacera myaddr comme adresse IP
utilisée pour la négociation IPCP initiale. Cependant, seule une adresse
incluse dans la gamme d'adressage correspondant à myaddr sera acceptée.
Ceci peut être utile dans la négociation avec certaines implémentations
PPP qui n'attribuent pas d'adresse IP à moins que l'initiateur de la
connexion ne demande explicitement l'adresse &quot;0.0.0.0&quot;.

<p>
L'option suivante &quot;add default HISADDR&quot; attribue comme route
par défaut l'adresse IP de votre FAI. Cette entrée permet d'ajuster
automatiquement notre route par défaut en cas de changement d'adresse IP
de celui-ci. &quot;enable dns&quot; est utilisé afin de récupérer la
liste des serveurs DNS du FAI. N'utilisez PAS cette option si vous avez
votre propre serveur DNS local car ppp empêchera les requêtes vers celui-ci
en remplaçant les lignes "nameserver" de votre fichier
<i>/etc/resolv.conf</i>.

<p>
A la place des méthodes traditionnelles de connexion, certains FAI
utilisent à présent l'authentification CHAP ou PAP. Si c'est le cas, notre
configuration sera un peu différente:

<blockquote><pre>
myisp:
set phone 1234567   
set authname ppp
set authkey ppp
set login
set timeout 120   
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
add default HISADDR 
enable dns
</pre></blockquote>

<p>
Dans l'exemple précédent, nous spécifions notre nom d'utilisateur (ppp)
et notre mot de passe à l'aide des options authname et authkey,
respectivement. Il n'est pas nécessaire de spécifier le type
d'authentification CHAP ou PAP utilisé, car il sera négocié
automatiquement. "set login" signifie simplement de tenter de se
connecter en utilisant le nom d'utilisateur et le mot de passe précisés
précédemment.

<p>
<h3>Utiliser PPP(8)</h3>

<p>
Maintenant que <i>ppp.conf</i> est configuré, nous pouvons essayer
d'initier une connexion vers notre FAI. Je détaillerais certaines des
options les plus utilisées :

<ul>
<li><tt>ppp -auto myisp</tt> - Cette commande lancera ppp, configurera vos
interfaces, vous connectera à votre FAI et se placera en
arrière-plan.
<li><tt>ppp -ddial myisp</tt> - Cette commande est similaire à -auto mais
si votre connexion est rompue, ppp essayera de se reconnecter automatiquement.
</ul>

<p>
Si les commandes précédentes ne fonctionnent pas, lancez
<i>/usr/sbin/ppp</i> sans option, ce qui vous placera en mode
interactif. Les options peuvent être spécifiées une par une afin de
diagnostiquer les erreurs et autres problèmes. En utilisant la
configuration précédente, ppp enregistrera les événements dans
/var/log/ppp.log. Ce fichier de log ainsi que la page de manuel
contiennent des informations utiles.

<p>
<h3>Autres options de ppp(8)</h3>

<p>
Dans certaines situations, vous pourriez avoir besoin de lancer
certaines commandes au lancement ou à la coupure de votre connexion. Si
vous vous trouvez dans cette situation, il existe deux fichiers que vous
pouvez créer : <i>/etc/ppp/ppp.linkup</i> et
<i>/etc/ppp/ppp.linkdown</i>. Des exemples de configurations sont
disponibles ici :

<ul>
<li><a
href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkup.sample">
ppp.linkup</a>
<li><a
href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkdown.sample">
ppp.linkdown</a>
</ul>

<p>
<h3>variations sur ppp(8)</h3>

<p>
De  nos jours, beaucoup de FAI offrent des services xDSL plus rapides que les
méthodes traditionnelles de connexion. Ceux-ci incluent des variantes de type
ADSL et SDSL. Bien qu'aucun appel à distance n'est lieu, la connexion reste
basée sur le protocole point-à-point. En voici des exemples:

<ul>
<li>PPPoE
<li>PPPoA
<li>PPTP
</ul>

<p>
<h3>PPPoE/PPPoA</h3>

<p>
Le protocole d'encapsulation de PPP dans Ethernet (PPPoE - "Point to Point
Protocol over Ethernet") permet d'envoyer des paquets PPP à l'intérieur de
trames Ethernet. Le protocole d'encapsulation de PPP dans ATM (PPPoA - "Point
to Point Protocol over ATM") est généralement utilisé dans les réseaux ATM tels
qu'au Royaume-Uni ou en Belgique.

<p>
En résumé cela signifie que vous pouvez établir une connexion vers votre FAI à
l'aide d'une carte Ethernet standard et d'un modem DSL-Ethernet (à l'inverse des
modems USB).

<p>
Si vous possédez un modem compatible PPPoE/PPPoA, il est possible de le
configurer afin qu'il initie lui-même la connexion. Dans le cas contraire, si le
modem est capable de fonctionner en mode &quot;bridge&quot;, il est possible d'activer ce
mode afin que celui-ci fasse "transiter" les paquets vers une machine exécutant
un logiciel PPPoE (voir plus loin).

<p>
Sous OpenBSD, l'interface logicielle PPPoE/PPPoA principale est <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppoe&amp;sektion=8">pppoe(8)
</a>, qui est l'implémentation en espace utilisateur (de la même manière que <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8">ppp(8)
</a>, précédemment décrit). Une implémentation noyau de PPPoE, <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppoe&amp;sektion=4">pppoe(4)
</a>, a été ajoutée dans OpenBSD.

<p>
<h3>PPTP</h3>

<p>
Le "Point to Point Tunneling Protocol" (PPTP) est un protocole propriétaire
Microsoft. Un client pptp s'interfaçant avec <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppd&amp;sektion=8">pppd(8)
</a> est disponible et est capable de se connecter à un réseau privé virtuel
PPTP (VPN) utilisé par certains fournisseurs d'accès câble ou xDSL. Le logiciel
pptp quant à lui doit être installé en utilisant les <a href="faq15.html#PkgMgmt">
paquets</a> ou les <a href="faq15.html#Ports">ports</a>. De plus amples
instructions sur la façon de mettre en place et d'utiliser pptp sont disponibles
dans la page de manuel installée avec le paquet pptp.

<p>
<a name="Tuning"></a>
<h2>6.6 - Optimisation des paramètres réseau</h2>
<!-- XXXrelease -->

<p>
<h3>6.6.1 - Comment configurer le noyau pour avoir un plus grand nombre d'essais
et augmenter le délai d'expiration des sessions TCP ?</h3>

<p>
Généralement, vous utiliserez ceci en cas de problèmes de routage ou de
connexion. Bien sûr, pour que cette configuration soit la plus
efficace, les deux extrémités de la connexion doivent utiliser des
valeurs similaires.

<p>
Pour optimiser ceci, utilisez <tt>sysctl</tt> et augmentez les valeurs
de :

<pre>
net.inet.tcp.keepinittime
net.inet.tcp.keepidle
net.inet.tcp.keepintvl
</pre>

<p>
Avec sysctl -a, vous pouvez voir les valeurs courantes de ces paramètres
(ainsi que beaucoup d'autres). Pour en changer un, tapez par exemple
<tt>sysctl net.inet.tcp.keepidle=28800</tt>.

<p>
<h3>6.6.2 - Comment activer les émissions ("broadcasts") dirigées
?</h3>

<p>
Normalement, vous ne devriez pas utiliser ceci. Cette option permet à
quelqu'un de diriger le trafic vers la ou les adresses "broadcast" des
réseaux sur lesquels vous êtes connecté si vous utilisez OpenBSD en tant
que routeur.

<p>
Dans certaines situations, sur des réseaux fermés, cette option peut-
être utile, surtout lors de l'utilisation de vieilles implémentations du
protocole NetBIOS. Il s'agit d'un autre paramètre sysctl. <tt>sysctl net.inet.ip.directed-
broadcast=1</tt> active cette option. Lisez la section sur les <a
href="http://www.netscan.org">"attaques de type smurf"</a> si vous voulez savoir
pourquoi cette option est désactivée par défaut.

<p>
<h3>6.6.3 - Je ne veux pas que le noyau alloue dynamiquement un port
donné</h3>

<p>
Il existe également un paramètre sysctl pour cela. D'après <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">
sysctl(8)</a> :

<pre>
Définie la liste des ports TCP ne devant pas être alloués dynamiquement
par le noyau. Ceci peut être utile afin d'éviter l'appropriation d'un
port spécifique dont un autre programme a besoin pour fonctionner. Les
éléments listés peuvent être séparés par une virgule et/ou un espace.

 #  <b>sysctl net.inet.tcp.baddynamic=749,750,751,760,761,871</b>

Il est aussi possible d'ajouter ou de retirer des ports de la liste courante.

 #  <b>sysctl net.inet.tcp.baddynamic=+748</b>
 #  <b>sysctl net.inet.tcp.baddynamic=-871</b>
</pre>

<p>
<h3>6.6.4 - Comment augmenter les performances sur les liens à grande
vitesse et à fort trafic ?</h3>

Si vous avez des soucis de performances sur des liens WAN à grande
vitesse lorsque vous transférez beaucoup de données, vous devriez
pouvoir optimiser ces performances en éditant les valeurs sysctls
suivantes :
<blockquote><pre>
net.inet.tcp.recvspace
net.inet.tcp.sendspace
</pre></blockquote>

Essayez une valeur comme 65536 au lieu de 16384. Notez que très peu de
personnes verront un gain réel. N'ajustez ces valeurs que si vous
obtenez des performances en deçà de vos attentes.

<p>
<a name="NFS"></a>
<h2>6.7 - Utilisation simple de NFS</h2>

<p>
NFS ("Network File System") est utilisé afin de partager un système de
fichiers à travers un réseau. Voici un certain nombre de manuels à lire
avant la mise en place d'un serveur NFS :

<ul>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=nfsd&amp;sektion=8">nfsd(8)
</a>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=mountd&amp;sektion=8">
mountd(8)</a>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&amp;sektion=5">
exports(5)</a>
</ul>

<p>
Cette section détaillera les étapes nécessaires à la mise en oeuvre
d'une configuration NFS simple. Cet exemple détaille un serveur et ses
clients NFS sur un LAN. Il ne s'agit pas d'étudier la sécurisation de
NFS. Nous assumerons que le filtre de paquets (PF) ou qu'un autre type
de pare-feu est configuré afin d'interdire les accès extérieurs. Si vous
autorisez l'accès à votre serveur NFS depuis l'extérieur et que vous
hébergez des données sensibles, nous vous conseillons fortement
d'utiliser IPsec. Autrement certaines personnes pourraient voir ce qui
transite dans votre trafic NFS. Quelqu'un pourrait également usurper
l'adresse IP que vous autorisez à se connecter à votre serveur NFS.
Plusieurs types d'attaques peuvent en découler. Mais lorsqu'IPsec est
correctement configuré, il offre une protection contre ces attaques.


<h3>Mise en place d'un serveur NFS</h3>


<p>
Les services suivants doivent être activés et mis en route sur 
serveur :

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=portmap&amp;sektion=8">portmap(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mountd&amp;sektion=8">mountd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nfsd&amp;sektion=8">nfsd(8)</a>
</ul>

<p>
Ces services sont désactivés par défaut sous OpenBSD.
Afin de les activer, veuillez ajouter les lignes suivantes au fichier
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf.local&amp;sektion=8">rc.conf.local(8)</a> :

<blockquote><pre>
portmap=YES
nfs_server=YES
</pre></blockquote>

<p>
L'étape suivante consiste à configurer la liste des systèmes de fichiers
qui doivent être mis à disposition des clients.

<p>
Dans cet exemple, nous disposons d'un serveur dont l'adresse IP est
10.0.0.1.
Ce serveur est destiné à fournir le service FS uniquement aux clients de
son propre sous-réseau. Tout ceci est configurable dans le fichier
/etc/exports.
Ce fichier liste les systèmes de fichiers destinés à être mis à
disposition via NFS et définit les droits d'accès associés.
Plusieurs options sont disponibles. Il convient de lire la page du
manuel
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&amp;sektion=5">exports(5)</a>.
Pour notre serveur, nous utiliserons le fichier exports suivant :

<blockquote><pre>
#
# NFS exports Database
# See exports(5) for more information.  Be very careful, misconfiguration
# of this file can result in your filesystems being readable by the world.
/work -alldirs -ro -network=10.0.0 -mask=255.255.255.0
</pre></blockquote>

<p>
Ceci signifie que le système de fichiers local <tt>/work</tt> sera
accessible par NFS.
L'option <tt>-alldirs</tt> spécifie que les clients seront capables
de monter n'importe quel répertoire situé sous <tt>/work</tt> ainsi que
<tt>/work</tt> lui-même.
Par exemple, s'il existait un répertoire appelé <tt>/work/monday</tt>,
les clients pourraient monter <tt>/work</tt> (et avoir ainsi accès à
tous les fichiers/répertoires situés sous ce répertoire) ou ils
pourraient tout simplement monter <tt>/work/monday</tt> et avoir ainsi
juste accès aux fichiers/répertoires qu'il contient.
L'option <tt>-ro</tt> spécifie que les clients sont autorisés à faire
de la lecture uniquement.
Les deux derniers arguments spécifient que seuls les
clients présents dans le réseau 10.0.0.0 et utilisant un masque de
255.255.255.0 seront autorisés à monter ce système de fichiers.
Ceci est important pour certains serveurs accessibles dans différents
réseaux.

<p>
Une autre remarque sécurité importante : ne vous contentez pas d'ajouter
tout simplement un système de fichiers à /etc/exports sans l'associer à
une liste d'hôte(s) autorisé(s).
Sans cela, n'importe qui pourrait monter vos répertoires exportés par
NFS.

<p>
Vous pouvez maintenant démarrer les services du serveur.
Vous pouvez soit redémarrer (après activation telle qu'indiquée plus
haut) soit exécuter ces services manuellement.

<blockquote><pre>
# <b>/usr/sbin/portmap</b>
# <b>echo -n &gt;/var/db/mountdtab</b>
# <b>/sbin/mountd</b>
# <b>/sbin/nfsd -tun 4</b>
</pre></blockquote>

<p>
Les arguments passés à nfsd autorisent les connexions TCP (-t) et UDP
(-u) et autorisent aussi 4 instances (-n) de nfsd en exécution.
Vous devriez paramétrer un nombre approprié d'instances de serveur NFS
pour gérer le maximum de connexions simultanées que vous souhaitez être
en mesure de traiter.

<p>
Vous êtes maintenant prêt à monter les systèmes de fichiers exportés
depuis le(s) client(s).

<p>
Rappel : Si vous effectuez des changements au niveau de /etc/exports
alors que NFS est en cours d'éxecution, vous avez juste besoin d'en
informer mountd !
Il suffit d'envoyer un signal HUP à ce service et les modifications
seront effectives.
<blockquote><pre>
# <b>kill -HUP `cat /var/run/mountd.pid`</b>
</pre></blockquote>
<h3>Montage de Systèmes de Fichiers NFS</h3>

<p>
Les systèmes de fichiers NFS peuvent être montés à partir d'un client
sans avoir besoin d'activer aucun service.
Ils peuvent être montés de la même manière que n'importe quel autre
système de fichiers.

<p>
Les systèmes de fichiers NFS devraient être montés via mount(8), ou plus
précisément,
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount_nfs&amp;sektion=8">mount_nfs(8)</a>.
Pour monter un système de fichiers <tt>/work</tt> partagé par l'hôte
10.0.0.1 au niveau du système de fichiers local <tt>/mnt</tt>, effectuez
l'opération suivante (veuillez noter que vous n'avez pas besoin
d'utiliser obligatoirement une adresse IP. mountd peut utiliser le DNS)
:
<blockquote><pre>
# <b>mount -t nfs 10.0.0.1:/work /mnt</b>
</pre></blockquote>

<p>
Pour monter le système de fichiers au démarrage, ajoutez la ligne
suivante à /etc/fstab :
<blockquote><pre>
10.0.0.1:/work /mnt nfs rw 0 0
</pre></blockquote>

<p>
Il est important d'utiliser <tt>0 0</tt> à la fin de cette ligne pour
éviter que le système essaie de faire un fsck des systèmes de fichiers
NFS au démarrage. Les autres options de sécurité standard telles que
<tt>noexec</tt>, <tt>nodev</tt>, et <tt>nosuid</tt>, devraient aussi
être utilisées si applicable.
Par exemple :
<blockquote><pre>
10.0.0.1:/work /mnt nfs rw,nodev,nosuid 0 0
</pre></blockquote>

<p>
De cette manière, aucun périphérique ou programme setuid sur le serveur
NFS ne pourra mettre en défaut les mesures de sécurité prises sur le
client NFS.
Si vous ne comptez pas utiliser de programmes mis à disposition par le
serveur NFS, ajoutez noexec à la liste.

<p>
Lorsqu'on accède à un montage NFS avec l'identité de l'utilisateur root,
le serveur réalisera une correspondance automatique de cet accès root
vers l'utilisateur et le groupe "nobody".
C'est une information importante à connaître lorsqu'on prend en compte
les permissions sur les fichiers.
Par exemple, prenez un fichier avec les permissions suivantes :

<blockquote><pre>
-rw-------    1 root     wheel           0 Dec 31 03:00 _daily.B20143
</pre></blockquote>

<p>
Si le fichier était sur un partage NFS et l'utilisateur root essaye
d'accéder à ce fichier depuis le client NFS, l'accès sera interdit.
Ceci est du au fait que le serveur utilise les identifiants de
l'utilisateur "nobody" lorsque root essaie d'accéder au fichier.
Etant donné que l'utilisateur nobody n'a pas de permissions d'accès au
fichier, l'accès est interdit.

<p>
L'utilisateur et le groupe auxquels root est "traduit" sont
configurables à l'aide du fichier
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&amp;sektion=5"
>exports(5)</a>
sur le serveur NFS.

<h3>Statistiques NFS</h3>

<p>
Pour s'assurer que NFS fonctionne correctement il faut vérifier que tous
ces services sont lancés et enregistrés avec RPC. Pour ce faire,
utilisez rpcinfo(8).

<blockquote><pre>
$ <b>rpcinfo -p 10.0.0.1</b>
   program vers proto   port
    100000    2   tcp    111  portmapper
    100000    2   udp    111  portmapper
    100005    1   udp    633  mountd
    100005    3   udp    633  mountd
    100005    1   tcp    916  mountd
    100005    3   tcp    916  mountd
    100003    2   udp   2049  nfs
    100003    3   udp   2049  nfs
    100003    2   tcp   2049  nfs
    100003    3   tcp   2049  nfs
</pre></blockquote>

<p>
Dans le cadre d'une utilisation normale, d'autres utilitaires peuvent vous
permettre de voir ce qui se passe au niveau NFS. Un de ces utilitaires est <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=showmount&amp;sektion=8">
showmount(8)</a>, qui permet de voir ce qui est monté et par qui. Il
existe aussi
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=nfsstat&amp;sektion=1"
>nfsstat(1)</a>
qui affiche beaucoup plus de statistiques.
Pour utiliser showmount(8), essayez la commande <tt>/usr/bin/showmount
-a hôte</tt>. Par exemple :

<blockquote><pre>
$ <b>/usr/bin/showmount -a 10.0.0.1</b>
All mount points on 10.0.0.1:
10.0.0.37:/work
</pre></blockquote>

<p>
Cette sortie montre que le client  10.0.0.37 a monté le système de
fichiers exporté <tt>/work</tt> mis à disposition par le serveur
10.0.0.1.


<a name="Bridge"></a>
<h2>6.9 - Mise en place d'un pont ("bridge") avec OpenBSD</h2>

<p>
Un pont ("<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4">bridge</a>")
est un lien entre deux (ou plusieurs) réseaux séparés. A
l'inverse d'un routeur, les paquets sont transférés à travers le pont de
manière "invisible" -- au niveau logique, les deux segments de réseau
semblent n'en faire qu'un de chaque côté du pont. Le pont ne transfèrera
que les paquets passant d'un segment à l'autre, ce qui entre autres,
permet de réduire le trafic sur un réseau complexe tout en permettant à
n'importe quel noeud d'accéder à un autre en cas de besoin.

<p>
Notez qu'à cause de sa nature "invisible", une interface faisant partie
d'un pont peut, ou non, posséder une adresse IP. Si c'est le cas,
l'interface aura deux modes d'opération, l'un faisant parti du pont et
l'autre se comportant comme une interface normale. Si aucune interface
ne possède d'adresse IP, le pont fera transiter le trafic mais ne sera
pas administrable par le réseau (ce qui peut être une fonctionnalité
voulue).

<p>
<h3>Exemple d'application d'un pont</h3>

<p>
Un de mes racks possède un certain nombre d'anciens systèmes, lesquels
ne sont pas équipés de carte réseau 10BASE-TX. Bien qu'ils possèdent des
ports AUI ou AAUI, ma réserve de transmetteurs est limitée à des câbles
coaxiaux. Une des machines de cette rangée est un serveur d'accès
terminal sous OpenBSD, toujours allumée et connectée au réseau à haut
débit. L'ajout d'une seconde carte équipée d'un port coaxial permettra
d'utiliser cette machine comme un pont vers le réseau coaxial.

<p>
Ce système a, pour le moment, deux cartes réseau, une Intel
EtherExpress/100 (<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp&amp;sektion=4"><tt>fxp0</tt></a>)
et une carte 3c590-Combo
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&amp;sektion=4"><tt>ep0</tt></a>)
pour le port coaxial. <tt>fxp0</tt> fait le lien avec le
reste du réseau et possède donc une adresse IP, <tt>ep0</tt>, ne faisant
quant à elle que du "bridging", n'en possède pas. Les machines
connectées sur le segment coaxial communiqueront comme les autres
présentes sur le reste du réseau. A présent, voyons comment arriver à ce
résultat.

<p>
Le fichier <tt>hostname.fxp0</tt> contient les informations concernant
la carte <tt>fxp0</tt>. Cette machine est configurée pour DHCP, donc le
fichier ressemble à celui-ci :

<blockquote><pre>
$ <b>cat /etc/hostname.fxp0</b>
dhcp NONE NONE NONE
</pre></blockquote>

<p>
Ici, aucune surprise.

<p>
Comme vous pouvez le deviner, la configuration de la carte <tt>ep0</tt>
est un peu différente :

<blockquote><pre>
$ <b>cat /etc/hostname.ep0</b>
up media 10base2
</pre></blockquote>

<p>
Ici, nous demandons au système d'activer cette interface en utilisant <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a> et de la configurer pour du 10BASE-2 (coaxial). Aucune adresse
ou information similaire n'est nécessaire pour cette interface. Les
options possibles pour la carte <tt>ep</tt> sont disponibles en détail
dans le <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&amp;sektion=4">manuel</a>.

<p>
A présent, il nous faut paramétrer le pont. Un pont est initialisé par
l'existence d'un fichier du type
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridgename.if&amp;sektion=5">
<tt>bridgename.bridge0</tt></a>. Dans ma situation, voici un exemple
possible :

<blockquote><pre>
$ <b>cat /etc/bridgename.bridge0</b>
add fxp0
add ep0
up
</pre></blockquote>

<p>
Cela indique de mettre en place un pont constitué de deux interfaces,
fxp0 et ep0 et de l'activer. Est-ce que l'ordre dans lequel les cartes
sont énoncées est important ? Non, souvenez-vous qu'un pont est très
symétrique -- les paquets entrent et sortent dans les deux directions.

<p>
C'est tout ! Redémarrez et vous aurez un pont fonctionnel.

<p>
<h3>Le filtrage sur un pont ("filtering bridge")</h3>

Bien qu'il existe certainement des usages pour de simples ponts du genre
évoqué, il est probable que vous souhaitiez FAIRE quelque chose avec les
paquets qui le traversent. Comme vous pouvez vous en douter, <a
href="#PF">Packet Filter</a> peut être utilisé pour restreindre le
trafic traversant votre pont (pont filtrant).

<p>
Gardez à l'esprit que de part la nature d'un pont, les mêmes données
traversent les deux interfaces, ce qui signifie que vous n'avez besoin
de filtrer que sur l'une d'entre elles. Vos déclarations par défaut "Pass
all" ressembleront à l'exemple suivant :

<blockquote><pre>
pass in  on ep0  all
pass out on ep0  all
pass in  on fxp0 all
pass out on fxp0 all
</pre></blockquote>

<p>
Maintenant, admettons que je souhaite filtrer le trafic dirigé vers les
vieux systèmes évoqués précédemment, ne permettant qu'aux protocoles Web
et SSH de les atteindre. Dans ce cas, nous allons autoriser tout le
trafic entrant et sortant sur l'interface <tt>ep0</tt>, mais nous filtrerons sur
l'interface <tt>fxp0</tt> en utilisant <tt>keep state</tt>
pour prendre en charge les données retournées :

<blockquote><pre>
# Autoriser le trafic entrant et sortant sur ep0
pass in quick on ep0 all
pass out quick on ep0 all

# Bloquer tout le trafic sur fxp0
block in  on fxp0 all
block out on fxp0 all

pass in quick on fxp0 proto tcp from any to any port {22, 80} \
     flags S/SA keep state
</pre></blockquote>

<p>
Notez que cette règle bloquera tout, à l'exception des requêtes
entrantes HTTP et SSH, vers la machine qui fait le pont ainsi qu'en
direction des autres noeuds "derrière" elle. Il est possible d'obtenir
d'autres résultats en filtrant sur l'autre interface.

<p>
Pour surveiller et contrôler le pont que vous venez de créer,
servez-vous de la commande <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=brconfig&amp;sektion=8">
brconfig(8)</a> qui peut aussi être utilisée pour créer un
pont après le démarrage.

<p>
<h3>Astuces sur les ponts</h3>

<ul>
<li>Il est HAUTEMENT recommandé de ne filtrer que sur une seule
interface. Bien qu'il soit possible de filtrer sur les deux, vous
devez vraiment en connaître toutes les implications avant de pouvoir
le faire de la bonne manière.

<li>En utilisant l'option <i>blocknonip</i> de
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=brconfig&amp;sektion=8"> brconfig(8)</a>
ou dans
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridgename.if&amp;sektion=5">
bridgename.bridge0</a>, vous pouvez empêcher le trafic non-IP (comme
IPX ou NETBEUI) de passer oûtre votre filtre. Dans certaines
situations, cela peut-être important et vous devez savoir qu'un pont
fonctionne pour tous les types de trafic, pas seulement IP.

<li>Un pont requiert que les interfaces réseau soient en mode
"Promiscuous" -- elles écoutent TOUT le trafic réseau, pas seulement
celui leur étant dirigé. Ceci augmentera la charge du processeur et
du bus. Certaines cartes ne fonctionnent pas correctement dans ce
mode, le circuit TI ThunderLAN
(<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tl&amp;sektion=4">tl(4)</a>)
en est un exemple.
</ul>

<a name="PXE"></a>
<h2>6.10 - Comment démarrer en utilisant PXE ? (i386, amd64)</h2>
PXE ("Preboot Execution Environment", environnement d'exécution avant
démarrage) permet de démarrer un ordinateur à partir du réseau plutôt
que d'un disque dur, une disquette ou un CD-ROM. A l'origine, cette
technologie a été développée par Intel mais est maintenant supportée par
la plupart des contrôleurs réseau et des constructeurs. Sachez qu'il
existe plusieurs protocoles de démarrage par le réseau, PXE étant
relativement récent. Traditionnellement, un démarrage PXE est effectué
en utilisant des ROMs présentes sur la carte réseau ou la carte mère elle-
même, mais plusieurs disquettes permettant de démarrer en PXE sont
disponibles sur différentes sources. Beaucoup de ROMs présentes sur des
anciens contrôleurs supportent le démarrage en réseau mais sont
incompatibles avec PXE ; s'il est équipé de tels contrôleurs, un
système OpenBSD/i386 ou amd64 ne pourra pas être démarré par le réseau.


<p>
<h3>Comment fonctionne un démarrage PXE ?</h3>
Tout d'abord, il serait sage de savoir <a href="faq14.html#Boot386">comment
se déroule le processus de démarrage d'OpenBSD/i386 ?</a> sur les
plates-formes i386 et amd64. Au démarrage, chaque interface compatible PXE
émet une requête DHCP en broadcast sur le réseau. Le serveur
DHCP lui attribue alors une adresse IP en lui indiquant l'emplacement du fichier
à exécuter sur le serveur
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tftp&amp;sektion=1">
tftp(1)</a>. Ce fichier se charge ensuite de gérer le reste du
démarrage. Sous OpenBSD
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pxeboot&amp;sektion=8&amp;arch=i386">pxeboot</a>
remplace le fichier
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">boot(8)</a>
standard. Il est alors capable de charger et d'exécuter
un noyau (comme <tt>bsd</tt> ou <a href="faq4.html#bsd.rd">
<tt>bsd.rd</tt></a>) à partir du serveur tftp(1).

<h3>Comment le mettre en place ?</h3>
Le point évident est que vous avez besoin d'une machine ou d'un
contrôleur compatible avec un démarrage PXE. Certaines documentations
précisent que toutes les cartes modernes sont compatibles PXE, mais
c'est tout simplement faux -- de nombreux systèmes à bas prix n'incluent
pas de ROMs PXE ou utilisent un ancien protocole de démarrage sur
réseau. Vous avez également besoin d'un serveur <a href="#DHCP">DHCP</a>
configuré ainsi qu'un serveur TFTP.

<p>
En admettant qu'une machine sous OpenBSD serve les fichiers de démarrage
(cela n'étant PAS obligatoire), le fichier <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd.conf&amp;sektion=5">
dhcpd.conf</a> de votre serveur DHCP devra contenir la ligne suivante :
<pre>
    filename "pxeboot";
</pre>
afin de pouvoir offrir ce fichier de démarrage à une station de
travail. Par exemple :

<pre>
    shared-network LOCAL-NET {
            option  domain-name "example.com";
            option  domain-name-servers 192.168.1.3, 192.168.1.5;

            subnet 192.168.1.0 netmask 255.255.255.0 {
                    option routers 192.168.1.1;
                    <b>filename "pxeboot";</b>
                    range 192.168.1.32 192.168.1.127;
                    default-lease-time 86400;
                    max-lease-time 90000;
            }
    }
</pre>

<p>
Vous devrez aussi activer le service <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=tftpd&amp;sektion=8">tftpd(8)
</a>. Pour ce faire, il suffit de configurer <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=inetd&amp;sektion=8">inetd(8)
</a>. L'installation standard d'OpenBSD fournit une ligne d'exemple dans
<tt>inetd.conf</tt> qui devrait vous satisfaire :
<pre>
    #tftp  dgram   udp  wait  root  /usr/libexec/tftpd   tftpd -s /tftpboot
</pre>

Retirez simplement le caractère '#' et envoyez à inetd(8) un signal -HUP
afin que celui-ci relise son fichier <tt>/etc/inetd.conf</tt>. Les
fichiers accessibles par tftpd(8) sont contenus dans un répertoire
particulier, ici <tt>/tftpboot</tt>, que nous utiliserons pour cet
exemple. Bien évidemment, ce répertoire doit être créé et contenir les
fichiers nécessaires. Pour un démarrage PXE, vous n'aurez typiquement
besoin que de quelques fichiers :

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pxeboot&amp;sektion=8&amp;arch=i386">pxeboot</a>,
le chargeur de démarrage (offre la même fonction que
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i386">boot</a>
pour un démarrage sur disque).
<li><a href="faq4.html#bsd.rd">bsd.rd</a>, le noyau d'installation ou
<tt>bsd</tt>, un noyau adapté.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot.conf&amp;sektion=8&amp;arch=i386">/etc/boot.conf</a>,
le fichier de configuration de boot.
</ul>

Notez que <tt>/etc/boot.conf</tt> n'est nécessaire qu'au cas où vous
souhaiteriez démarrer un noyau ne se nommant pas <tt>bsd</tt>, ou que
les options par défaut de pxeboot ne vous conviennent pas (par exemple
si vous utilisez une console série). Vous pouvez tester votre serveur
tftpd(8) en utilisant un client
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tftp&amp;sektion=1">tftp(1)</a>
afin de vérifier que vous pouvez bien récupérer les fichiers nécessaires.

<p>
Une fois vos serveurs DHCP et TFTP démarrés, vous êtes prêt pour un
essai. Vous devez activer PXE sur votre système ou votre carte réseau ;
consultez la documentation fournie avec votre matériel. Une fois que PXE
est activé, vous devriez voir apparaître des lignes similaires à celles-
ci :

<pre>
    Intel UNDI, PXE-2.0 (build 067)
    Copyright (C) 1997,1998 Intel Corporation

    For Realtek RTL 8139(X) PCI Fast Ethernet Controller v1.00 (990420)

    DHCP MAC ADDR: 00 E0 C5 C8 CF E1
    CLIENT IP: 192.168.1.76  MASK: 255.255.255.0  DHCP IP: 192.168.1.252
    GATEWAY IP: 192.168.1.1
    probing: pc0 com0 com1 apm pxe![2.1] mem[540k 28m a20=on]
    disk: hd0*
    net: mac 00:e0:c5:c8:cf:e1, ip 192.168.1.76, server 192.168.1.252
    >> OpenBSD/i386 PXEBOOT 1.00
    boot>
</pre>

A présent, vous obtenez l'invite de commandes standard d'OpenBSD. Si vous
tapez simplement "<tt>bsd.rd</tt>" pour récupérer le fichier <tt>bsd.rd</tt>
à partir du serveur TFTP.

<pre>
    >> OpenBSD/i386 PXEBOOT 1.00
    boot> bsd.rd
    booting tftp:bsd.rd: 4375152+733120 [58+122112+105468]=0x516d04
    entry point at 0x100120

    Copyright (c) 1982, 1986, 1989, 1991, 1993
            The Regents of the University of California.  All rights reserved.

    Copyright (c) 1995-2007 OpenBSD.  All rights reserved.  http://www.OpenBSD.org

    OpenBSD 4.2 (RAMDISK_CD) #468: Tue Aug 28 11:02:17 MDT 2007
      ...
</pre>

Le noyau d'installation <a href="faq4.html#bsd.rd">bsd.rd</a> va
maintenant se lancer.

<p>

<h3>Est-il possible de démarrer d'autres noyaux que <tt>bsd.rd</tt> en
utilisant PXE ?</h3>

Oui, bien qu'avec les outils actuellement présents dans OpenBSD, le
démarrage PXE ne soit essentiellement prévu que pour installer le
système d'exploitation.

<a name="CARP"></a>
<h2>6.11 - Protocole de redondance d'adresse commune (CARP)</h2>
<h3>6.11.1 - Qu'est-ce que CARP et comment fonctionne-t-il ?</h3>
<!-- This article written by Sunny Raspet, slr@mordac.info, and
released under the BSD license -->

<p>
CARP ("Common Address Redundancy Protocol") est un outil aidant à la
redondance du système en ayant plusieurs ordinateurs créant une
interface réseau unique entre eux, afin que si l'un d'eux ne fonctionne
plus, un autre puisse répondre à sa place ; cet outil permet aussi de
mettre en place un certain partage de charge entre les différents
systèmes. CARP est une avancée par rapport au VRRP ("Virtual Router
Redundancy Protocol" - protocole de redondance de routeur virtuel)
standard. Il a été développé une fois que VRRP fut considéré comme non
suffisamment libre à cause d'un brevet Cisco pouvant le couvrir. Pour
plus d'informations sur les origines de CARP et les problèmes légaux
entourant VRRP, rendez-vous sur <a href="../../lyrics.html#35">cette
page</a>.

<p>
Afin d'éviter tout problème légal, Ryan McBride (avec l'aide de Michael
Shalayeff, Marco Pfatschbacher et Markus Friedl) a conçut CARP de
manière à être fondamentalement différent. Si l'inclusion de la
cryptographie reste le changement le plus visible, il n'en reste pas
moins un seul parmi beaucoup d' autres.

<p>
Comment fonctionne-t-il ? CARP est un protocole multicast. Il regroupe
plusieurs systèmes physiques en une ou plusieurs adresses virtuelles.
L'un d'eux est le maître et répond aux paquets destinés au groupe, alors
que les autres se comportent comme des "hot spares" (remplacement à
chaud et automatique du maître). Peu importe les adresses IP et MAC de
l'interface physique locale, les paquets envoyés vers l'adresse CARP
reviennent avec les informations CARP.

<p>
A intervalles paramétrables, le maître annonce son état sur le port IP
112. Si le maître est déconnecté, les autres systèmes du groupe CARP
commencent à annoncer leur présence. L'hôte qui parvient à s'annoncer le
plus fréquemment devient le nouveau maître. Lorsque le système principal
est reconnecté, il se transforme par défaut en hôte de secours, bien
qu'il soit possible de configurer un hôte spécifique en tant que maître
par défaut lorsque cela est faisable (ex. un hôte est un Sun Fire
V120 rapide et les autres sont des SPARCstation IPCs, comparativement plus
lentes).

<p>
Bien que les équipements à haute redondance et tolérance de pannes
minimisent le besoin de CARP, ils ne le suppriment pas. Il n'existe pas
de matériel à tolérance de pannes capable de gérer le fait que quelqu'un
débranche le cordon d'alimentation ou que l'administrateur système tape
<tt>reboot</tt> dans la mauvaise fenêtre. L'utilisation de CARP aide à
rendre transparent une mise à jour ou un redémarrage du point de vue des
utilisateurs, ainsi que le test d'un programme ou une mise à jour
matérielle : si cela ne fonctionne pas, vous pouvez basculer sur le
reste du groupe jusqu'à ce que le problème soit résolu.

<p>
Il existe cependant certaines situations où CARP ne pourra pas vous
venir en aide. La conception de CARP est telle que les membres d'un
groupe doivent appartenir au même réseau physique avec une adresse IP
fixe, bien que depuis l'introduction de la directive carpdev il n'y ait
plus besoin d'adresse IP pour les interfaces physiques. De même, les
services nécessitant une connexion constante au serveur (tels que SSH ou
IRC) ne seront pas transférés de manière transparente aux autres
systèmes, bien que dans ce cas, CARP puisse aider à minimiser le temps
d'arrêt. CARP, lui-même, ne synchronise pas les données entre
applications, ceci doit être fait au travers de "procédés alternatifs"
tels que
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pfsync&amp;sektion=4">pfsync(4)</a>
(pour du filtrage redondant),
<a href="http://rsync.samba.org/">rsync</a>, pour dupliquer
manuellement les données entre les machines, ou tout ce qui semble
approprié à votre application.

 

<h3>6.11.2 - Configuration</h3>

<p>
Le contrôle de CARP s'effectue en deux endroits :
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">
sysctl(8)</a> et <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a>. Regardons tout d'abord les paramètres sysctls.

<p>
La première variable sysctl, <tt>net.inet.carp.allow</tt>, définit si
l'hôte gère ou non les paquets CARP. Bien évidemment, ceci est
nécessaire à l'utilisation de CARP. Cette variable sysctl est activée
par défaut.

<p>
La seconde, <tt>net.inet.carp.arpbalance</tt>, est utilisée pour la
répartition de charge ("load balancing"). Si cette fonctionnalité est
activée, CARP effectue une empreinte (hachage) de l'IP originaire de la
requête. Cette empreinte est ensuite utilisée pour sélectionner à partir
du groupe l'hôte virtuel qui prendra en charge cette requête. Cette
fonctionnalité est désactivée par défaut.

<p>
La troisième, <tt>net.inet.carp.log</tt>, enregistre les erreurs CARP.
Désactivée par défaut.

<p>
La quatrième, <tt>net.inet.carp.preempt</tt> active la sélection
naturelle parmi les hôtes CARP. Le plus à même d'effectuer le travail (à
savoir, celui qui est capable de s'annoncer le plus fréquemment)
deviendra le maître. Celle-ci est désactivée par défaut, ce qui signifie
qu'un système qui n'est pas maître ne tentera pas de (re)gagner ce
status.

<p>
Toutes ces variables sysctl sont documentées dans
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=3">sysctl(3)</a>.

<p>
Pour ce qui concerne le reste de la configuration de CARP, nous
dépendrons d'<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a>. Les commandes <tt>advbase</tt> et <tt>advskew</tt>,
spécifiques à CARP, définissent l'intervalle entre les annonces CARP.
La formule (en secondes) est <tt>advskew</tt> divisée par 256 puis
ajoutée à <tt>advbase</tt>. <tt>advbase</tt> peut être utilisée pour
diminuer le trafic réseau ou autoriser une plus grande latence avant
qu'un hôte de sauvegarde ne prenne le relais ; <tt>advskew</tt> vous
permet de contrôler quel hôte sera le maître sans trop de délais de
basculement (si cela est nécessaire).

<p>
Ensuite, <tt>pass</tt> crée un mot de passe et <tt>vhid</tt> définit le
numéro d'identification d'hôte virtuel du groupe CARP. Vous devez
assigner un numéro unique pour chaque groupe CARP, même s'ils partagent
(pour des raisons de répartition de charge) la même adresse IP. CARP est
limité à 255 groupes.

<p>
Enfin, <tt>carpdev</tt> spécifie l'interface appartenant à ce groupe
CARP particulier. Par défaut, n'importe quelle interface possédant une
adresse IP dans le même sous-réseau que celui assigné à l'interface CARP
sera utilisée.

<p>
Voyons l'emploi de ces différents paramètres dans une configuration
simple. Admettons que vous déployez deux serveurs Web identiques,
<i>rachael</i>
(192.168.0.5) et <i>pris</i> (192.168.0.6), afin de remplacer un ancien système
à l'adresse 192.168.0.7. Les commandes :

<blockquote><pre>
rachael# <b>ifconfig carp0 create</b>
rachael# <b>ifconfig carp0 vhid 1 pass tyrell carpdev fxp0 \
&nbsp;&nbsp;&nbsp;&nbsp;192.168.0.7 netmask 255.255.255.0</b>
</pre></blockquote>

<p>
créent l'interface carp0 et lui donnent un vhid de 1, le mot de passe
<i>tyrell</i>, l'adresse IP 192.168.0.7 de masque 255.255.255.0 et
assignent fxp0 en tant qu'interface membre. Afin de rendre ces
changements permanents après un redémarrage, vous pouvez créer un
fichier <tt>/etc/hostname.carp0</tt> ressemblant à :

<blockquote><pre>
inet 192.168.0.7 255.255.255.0 192.168.0.255 vhid 1 pass tyrell carpdev
fxp0
</pre></blockquote>

Notez qu'il faut ajouter l'adresse de diffusion ("broadcast") en plus du
vhid et du mot de passe.
Ce champ est nécessaire et est souvent cause d'erreurs en cas d'oubli.

<p>
Faites la même chose sur <i>pris</i>. Le système démarrant en premier
son interface CARP deviendra le maître (en admettant que "preempt" est
désactivé ; sinon, c'est l'inverse qui se produit).

<p>
Mais admettons que vous ne déployez pas cette solution à partir de zéro.
<i>Rachael</i> était déjà en place à l'adresse 192.168.0.7. Comment allez-
vous gérer cette situation ? Heureusement, CARP sait gérer ce genre de
situation. Vous assignez simplement l'adresse à l'interface CARP et laissez
vide l'adresse de l'interface physique spécifiée par le mot-clef `carpdev'.
Cependant, il est plus propre d'avoir une adresse
IP différente pour chaque système, cela rend les accès et la surveillance
individuels bien plus simples.

<p>
Ajoutons un nouveau niveau de complexité ; nous souhaitons que
<i>rachael</i> reste maître lorsque cela est possible. Plusieurs raisons
peuvent nous pousser à cela : différences matérielles, simple préjudice,
"si ce système n'est pas maître, c'est qu'il y a un problème", ou
simplement connaître le maître par défaut sans avoir à recourir à des
scripts envoyant par courriel l'analyse de la sortie d'ifconfig.

<p>
Sur <i>rachael</i>, nous utiliserons la variable sysctl créée
précédemment puis nous éditerons <tt>/etc/sysctl.conf</tt> afin de
rendre ce paramètre permanent.

<blockquote><pre>
rachael# <b>sysctl net.inet.carp.preempt=1</b>
</pre></blockquote>

<p>Configurons également <i>pris</i> :

<blockquote><pre>
pris# <b>ifconfig carp0 advskew 100</b>
</pre></blockquote>

<p>
Ceci décale les annonces de <i>pris</i>, ce qui signifie que
<i>rachael</i> sera maître s'il est fonctionnel.

<p>
Notez que si vous utilisez PF sur une machine CARP, vous devez utiliser
"proto carp" sur toutes les interfaces concernées, avec une ligne
similaire à : <blockquote><pre> pass on fxp0 proto carp keep state
</pre></blockquote>

<h3>6.11.3 - Répartition de charge ("load balancing")</h3>

<p>
Effectuons une avance rapide de quelques mois. Notre entreprise de
l'exemple précédent a grossi au point qu'un seul serveur Web interne
arrive tout juste à gérer la charge. Que faire ? CARP à la rescousse. Il
est temps d'essayer la répartition de charge. Créons une nouvelle interface
et un nouveau groupe CARP sur <i>rachael</i> :

<blockquote><pre>
rachael# <b>ifconfig carp1 create</b>
rachael# <b>ifconfig carp1 vhid 2 advskew 100 pass bryant carpdev fxp0 \
&nbsp;&nbsp;&nbsp;&nbsp;192.168.0.7 netmask 255.255.255.0</b>
</pre></blockquote>

<p>
Sur <i>pris</i>, nous allons également créer un nouveau groupe et une
nouvelle interface, puis activer la variable sysctl "preempt" :

<blockquote><pre>
pris# <b>ifconfig carp1 create</b>
pris# <b>ifconfig carp1 vhid 2 pass bryant carpdev fxp0 \
&nbsp;&nbsp;&nbsp;&nbsp;192.168.0.7 netmask 255.255.255.0</b>
pris# <b>sysctl net.inet.carp.preempt=1</b>
</pre></blockquote>

<p>
A présent nous avons deux groupes CARP avec la même adresse IP. Chaque
groupe est dirigé vers un hôte différent, ce qui signifie que
<i>rachael</i> restera maître du premier groupe, mais que <i>pris</i>
lui succédera comme maître dans le second.

<p>
Tout ce qu'il nous reste à faire désormais est d'activer la variable
contrôlant la répartition de charge sur les deux machines, comme nous
l'avons vu précédemment :

<blockquote><pre>
# <b>sysctl net.inet.carp.arpbalance=1</b>
</pre></blockquote>

<p>
Bien que ces exemples ne soient que pour un cluster de deux machines, le
même principe reste valable avec plus de systèmes. Notez en revanche
qu'il n'est pas assuré que vous parveniez à une distribution de 50/50
sur les deux machines : CARP utilise une empreinte de l'adresse IP d'origine
afin de savoir quel système répondra à la requête, indépendamment de la
charge.

<h3>6.11.4 - Plus d'information sur CARP</h3>
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=carp&amp;sektion=4">carp(4)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">sysctl(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=3">sysctl(3)</a>
<li><a href="http://www.countersiege.com/doc/pfsync-carp/">"Firewall
Failover with pfsync and CARP"</a> (Redondance de pare-feu avec pfsync
et CARP) par Ryan McBride
</ul>

<a name="OpenNTPD"></a>
<h2>6.12 - Utiliser OpenNTPD</h2>
Une horloge précise est importante pour plusieurs applications informatiques.
Cependant, plusieurs personnes ont remarqué que leur montre à 5 euros
est plus précise que leur ordinateur à 2000 euros. Certes, connaître la
date et l'heure est une chose importante. Mais souvent, il est plus
important de synchroniser plusieurs machines afin qu'elles s'accordent
sur la date et l'heure actuelles.
Durant un temps, <a href="http://www.ntp.org">ntp.org</a> a produit une
application "Network Time Protocol"
(<a href="http://www.ietf.org/rfc/rfc1305.txt">RFC1305</a>,
<a href="http://www.ietf.org/rfc/rfc2030.txt">RFC2030</a>),
disponible dans le système des <a href="faq15.html#Ports">ports</a>,
et qui peut être utilisée pour synchroniser les horloges des machines à
travers Internet. Cependant, c'est un programme difficile à configurer,
dont le code est difficile à auditer, et qui nécessite une quantité de
mémoire vive conséquente. En somme, c'est un programme qui rend bien des
services à certaines personnes mais qui est loin d'être une solution
pour tous les utilisateurs.

<p>
<a href="http://www.openntpd.org">OpenNTPD</a> est une tentative pour
résoudre certains de ces problèmes en créant un programme compatible NTP
qui soit facile à administrer, sûr, simple et qui vous permette d'avoir
une horloge exacte sur votre ordinateur.
Le service
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ntpd&amp;sektion=8">ntpd(8)</a>
d'OpenBSD est contrôlé  travers le fichier de configuration
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ntpd.conf&amp;sektion=5"><tt>/etc/ntpd.conf</tt></a>
facile à comprendre.

<p>
En activant tout simplement ntpd(8) dans <a
href="faq10.html#rc">rc.conf.local</a>, l'horloge de votre ordinateur
avancera légèrement et restera synchronisée avec les serveurs de <a
href="http://www.pool.ntp.org/">pool.ntp.org</a>, une collection de
serveurs de temps publics.

Une fois votre horloge réglée de manière précise, ntpd la gardera à un
haut degré d'exactitude. Cependant, si votre horloge est décalée de plus
de quelques minutes, il est <i>vivement</i> recommandé de la régler plus
précisément au démarrage car la synchronisation d'une horloge très
décalée pourrait prendre des jours, voire des semaines. Vous pouvez
la régler manuellement en utilisant l'option "<tt>-s</tt>" de ntpd ou
tout autre moyen permettant de mettre l'horloge de votre système à
l'heure.

<a name="OpenNTPDaccurate"></a>
<h3>6.12.1 - "Mais OpenNTPD n'est pas aussi exact que l'application de
ntp.org !"</h3>
C'est probablement vrai.
Ce n'est pas un des <a
href="http://www.openntpd.org/fr/goals.html">objectifs de la conception</a>
d'OpenNTPD. Ce programme a été d'abord conçu pour être libre, simple,
fiable et sécurisé.
Si vous avez réellement besoin d'une précision de l'ordre de la micro-
seconde, alors OpenNTPD n'est pas pour vous. Utilisez plutôt le ntpd de
ntp.org. Ce dernier restera disponible dans les ports et comme paquetage.
Nous n'avons aucun plan ou souhait de rendre OpenNTPD bouffi en y
intégrant toutes les fonctionnalités possibles et imaginables.

<a name="OpenNTPDharmful"></a>
<h3>6.12.2 - "Quelqu'un a prétendu qu'OpenNTPD était 'nuisible' !"</h3>
Certaines personnes n'ont pas compris le but d'OpenNTPD, à savoir un
moyen de synchroniser l'horloge de votre ordinateur qui soit simple,
sécurisé et facile à maintenir.

Si la maintenance d'un temps aussi exact que possible est une chose
importante, un certain nombre d'utilisateurs ont rapporté de meilleurs
résultats avec OpenNTPD par rapport au programme ntpd de ntp.org. Si la
sécurité est importante, le code d'OpenNTPD est beaucoup plus lisible
(et donc auditable) et a été écrit en utilisant les appels de fonction
natifs d'OpenBSD tels que
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=strlcpy&amp;sektion=3">strlcpy</a>,
au lieu d'utiliser des fonctions plus portables telles que
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=strcpy&amp;sektion=3">strcpy</a>.
Il a été écrit avec des principes sécurité dès le début. La sécurité n'a
pas été ajoutée par la suite. Si le fait d'amener autant de personnes
que possible à utiliser la synchronisation du temps est une chose
précieuse, OpenNTPD rend une telle entreprise très facile pour beaucoup
de personnes. Si cela est "nuisible", alors nous souhaitons ce genre de
nuisance.

<p>
Il y a des applications pour lesquelles le programme ntpd de ntp.org est
plus approprié, cependant nous croyons qu'OpenNTPD est plus que
suffisant pour une large majorité d'utilisateurs.

<p>
Une réponse plus complète donnée par l'un des mainteneurs d'OpenNTPD et
concernant ce fait est disponible
<a href="http://www.advogato.org/person/dtucker/diary.html?start=52">ici</a>.

<a name="OpenNTPDNoServe"></a>
<h3>6.12.3 - Pourquoi mes autres machines ne peuvent pas se synchroniser
avec OpenNTPD?</h3>

Par défaut, ntpd(8) n'écoute sur aucune adresse.
Ainsi, pour l'utiliser en tant que serveur, vous devez décommenter la
ligne "<tt>#listen&nbsp;on&nbsp;*</tt>" dans
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ntpd.conf&amp;sektion=5">/etc/ntpd.conf</a>
et redémarrer le service ntpd(8).
Bien entendu, si vous préférez écouter sur une adresse particulière
plutôt que sur toutes celles disponibles, remplacez "*" par l'adresse
correspondante.

<p>
Lorsque ntpd(8) écoute il se peut que les autres machines ne puissent
toujours pas se synchroniser !

Lorsque que le service ntpd(8) vient juste de démarrer (par exemple si
vous venez de le redémarrer suite à un changement dans ntpd.conf) il se
peut qu'il refuse la synchronisation des clients en attendant que
lui-même ajuste sa propre horloge a un certain degré de stabilité.
Lorsque ntpd(8) considère que son information temporelle est stable, il
l'annonce par le message "clock now synced" dans
<tt>/var/log/daemon</tt>. Même si l'horloge système est assez correcte
au démarrage, cela peut prendre jusqu'à 10 minutes avant d'être
synchronisé et des heures voire des jours si celle-ci est décalée.

<a name="Wireless"></a>

<h2>6.13 - Quels sont les types de cartes Sans Fil supportées par OpenBSD ?</h2>
OpenBSD supporte un certain nombre de chipsets sans fil :
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=awi&amp;sektion=4">awi(4)</a>
AMD 802.11 PCnet Mobile.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=an&amp;sektion=4">an(4)</a>
Aironet Communications 4500/4800.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wi&amp;sektion=4">wi(4)</a>
Prism2/2.5/3. <sup>(AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=atw&amp;sektion=4">atw(4)</a>
ADMtek ADM8211.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ath&amp;sektion=4">ath(4)</a>
driver for Atheros IEEE 802.11a/b/g. <sup>(AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=iwi&amp;sektion=4">iwi(4)</a>
Intel PRO/Wireless 2200BG/2225BG/2915ABG IEEE 802.11a/b/g. <sup>(NFF)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ipw&amp;sektion=4">ipw(4)</a>
Intel PRO/Wireless 2100 IEEE 802.11b. <sup>(NFF)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=atu&amp;sektion=4">atu(4)</a>
Atmel AT76C50x USB IEEE 802.11b. 
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ral&amp;sektion=4">ral(4)</a>
and <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ural&amp;sektion=4">ural(4)</a> [USB]
Ralink Technology RT25x0 IEEE 802.11a/b/g. <sup>(AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rtw&amp;sektion=4">rtw(4)</a>
Realtek 8180 IEEE 802.11b. <sup>(AP)</sup>

<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=acx&amp;sektion=4">acx(4)</a>
TI ACX100/ACX111. <sup>(NFF) (AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pgt&amp;sektion=4">pgt(4)</a>
Conexant/Intersil Prism GT Full-MAC. <sup>(NFF) (AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rum&amp;sektion=4">rum(4)</a>
Ralink Technology RT2501USB. <sup>(AP)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=wpi&amp;sektion=4">wpi(4)</a>
Intel PRO/Wireless 3945ABG. <sup>(NFF)</sup>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=uath&amp;sektion=4">uath(4)</a>
Atheros AR5005UG/AR5005UX USB2.0 (en cours de développement). <sup>(NFF)</sup>
</ul>

<sup>(AP)</sup> signifie que la carte peut être utilisée comme point
d'accès.<br>
<sup>(NFF)</sup> signifie que la puce nécessite un firmware non-libre
qui ne peut pas être inclu dans OpenBSD.

<p>
Les adaptateurs basés sur ces composants peuvent être utilisés de la
même façon que n'importe quel autre adaptateur réseau pour connecter un
système OpenBSD à un réseau sans fil existant, et sont configurés de
façon standard à l'aide d'
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">ifconfig(8)</a>
(prière de consulter les pages du manuel pour les détails précis).
Certaines cartes peuvent aussi être utilisées en mode "Host-Based
Access Point", ce qui leur permet d'être utilisées comme un point
d'accès sans fil pour votre réseau, intégré à votre pare-feu.

<p>
Notez que pour utiliser les cartes à base de chipset Intel, vous devrez
récupérer les firmwares dont Intel refuse la <a href="faq1.html#ReallyFree">
libre</a> distribution, ce qui empêche qu'ils soient inclus dans OpenBSD.
Lorsque cela est possible, les pages de manuel correspondantes incluent
les informations de contact afin que vous puissiez contacter les bonnes
personnes chez les constructeurs pour leur faire savoir ce que vous
pensez de cette situation ou de les informer sur le produit que vous
avez acheté à la place.

<p>
Une autre méthode pour permettre à un pare-feu OpenBSD de fournir un
accès sans fil est d'utiliser une carte conventionnelle et un point
d'accès externe en mode pont. Cette méthode a l'avantage de vous
permettre de positionner l'antenne là où elle est la plus efficace.

<a name="Multipath"></a>
<h2>6.14 - Comment puis-je mettre en oeuvre un routage multi-chemin à
      coût égal ?</h2>

<p>
Le routage multi-chemin à coût égal permet d'avoir de multiples routes
vers le même réseau, tel que la route par défaut (0.0.0.0/0), dans la
table de routage.
Lorsque le noyau recherche une route pour déterminer où acheminer des
paquets destinés à un réseau donné, il pourra alors choisir parmi les
routes à coût égal.
Dans la majorité des cas, un routage multi-chemin est utilisé pour
redonder des connexions "montantes" telles que les connexions vers
Internet.

<p>
La commande
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=route&amp;sektion=8">route(8)</a>
est employée pour ajouter, modifier et supprimer des routes dans la
table de routage.
L'argument <tt>-mpath</tt> est utilisé lors de l'ajout de routes
s'inscrivant dans un politique de routage multi-chemin.

<blockquote><pre>
# <b>route add -mpath default 10.130.128.1</b>
# <b>route add -mpath default 10.132.0.1</b>
</pre></blockquote>

<p>
Vérifiez les routes :

<blockquote><pre>
# <b>netstat -rnf inet | grep default</b>
default     10.130.128.1      UGS       2      134      -     fxp1
default     10.132.0.1        UGS       0      172      -     fxp2
</pre></blockquote>

<p>
A travers cet exemple, nous pouvons voir que la route par défaut pointe
vers 10.130.128.1, accessible par le biais de l'interface fxp1 tandis
que l'autre route par défaut pointe vers 10.132.0.1 qui est accessible
par le biais de l'interface fxp2.

<p>
Etant donné que le fichier
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mygate&amp;sektion=5"
>mygate(5)</a> ne supporte pas encore les routes par défaut
multi-chemin, les commandes précitées devraient être ajoutées à la fin
des fichiers
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5"
>hostname.if(5)</a> correspondant aux interfaces fxp1 et fxp2. Le
fichier <tt>/etc/mygate</tt> devrait être supprimé.

<dl>
<dt><b>/etc/hostname.fxp1</b></dt>
<dd><tt>!route add -mpath default 10.130.128.1</tt></dd>
<dt><b>/etc/hostname.fxp2</b></dt>
<dd><tt>!route add -mpath default 10.132.0.1</tt></dd>
</dl>

<p>
Enfin, n'oubliez pas d'activer le support de routes multi-chemin à
l'aide de la variable sysctl(3) adéquate.

<blockquote><pre>
# <b>sysctl net.inet.ip.multipath=1</b>
# <b>sysctl net.inet6.ip6.multipath=1</b>
</pre></blockquote>

<p>
Assurez-vous d'éditer
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5"
>sysctl.conf(5)</a>
pour rendre les modifications permanentes.

<p>
Maintenant essayez d'effectuer un traceroute vers des destinations
différentes.
Le noyau partagera le traffic entre les différentes routes multi-chemin.

<blockquote><pre>
# <b>traceroute -n 154.11.0.4</b>
traceroute to 154.11.0.4 (154.11.0.4), 64 hops max, 60 byte packets
 1  10.130.128.1  19.337 ms  18.194 ms  18.849 ms
 2  154.11.95.170  17.642 ms  18.176 ms  17.731 ms
 3  154.11.5.33  110.486 ms  19.478 ms  100.949 ms
 4  154.11.0.4  32.772 ms  33.534 ms  32.835 ms

# <b>traceroute -n 154.11.0.5</b>
traceroute to 154.11.0.5 (154.11.0.5), 64 hops max, 60 byte packets
 1  10.132.0.1  14.175 ms  14.503 ms  14.58 ms
 2  154.11.95.38  13.664 ms  13.962 ms  13.445 ms
 3  208.38.16.151  13.964 ms  13.347 ms  13.788 ms
 4  154.11.0.5  30.177 ms  30.95 ms  30.593 ms
</pre></blockquote>

<p>
Pour de plus amples informations concernant la manière de choisir une
route, veuillez vous référer à la
<a href="http://www.ietf.org/rfc/rfc2992.txt">RFC2992</a>, "Analysis of
an Equal-Cost Multi-Path Algorithm".

<p>
Il est utile de noter que si une interface utilisée par une route
multi-chemin tombe (perte de signal par exemple), le noyau 
acheminera tout de même des paquets à travers cette interface. Ces
paquets seront bien entendus perdus.
Il est hautement recommandé d'utiliser
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifstated&amp;sektion=8"
>ifstated(8)</a> pour vérifier l'état des interfaces et ajuster la table
de routage si besoin.


<p>
<font color="#0000e0">
<a href="index.html">[Index de la FAQ]</a>
<a href="faq5.html">[Section 5 - Construire le Système à partir des Sources]</a>
<a href="faq7.html">[Section 7 - Contrôles du clavier et de l'affichage]</a></font>

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../images/back.gif"
border="0" alt="[back]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
<!--
Originally [OpenBSD: faq6.html,v 1.265 ]<br>
$Translation: faq6.html,v 1.112 2008/03/26 16:04:49 gapz Exp $<br>
-->
$OpenBSD: faq6.html,v 1.88 2008/03/31 20:01:44 tobias Exp $
</small>

</body>
</html>
