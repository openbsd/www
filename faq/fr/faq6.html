<html>
<head>
<title>6.0 - Mise en place du r&eacute;seau</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2002 by OpenBSD.">
</head>

<body bgcolor= "#ffffff" text= "#000000">

<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif">
<p>
<h2><font color=#e00000>6.0 - Mise en place du r&eacute;seau</font> 
  <hr></h2>
<p></p>

<p>
<ul>
  <h3>Table des mati&egrave;res</h3>
  <li><A href= "#Intro" >6.0.1 - Avant d'aller plus loin</a>
  <li><a href= "#Setup" >6.1 - Configuration r&eacute;seau initiale</a>
  <li><a href= "#PF"    >6.2 - Packet Filter (PF)</a> 
  <li><a href= "#NAT"   >6.3 - Traduction d'adresses</a> 
  <li><a href= "#DHCP"  >6.4 - Protocole de Configuration Dynamique d'H&ocirc;te
    (DHCP)</a>
    <li><a href= "#PPP"   >6.5 - Protocole Point &agrave; Point</a>
  <li><A href= "#Tuning">6.6 - Optimisation des param&egrave;tres r&eacute;seau</a> 
  <li><a href= "#NFS"   >6.7 - Utilisation de NFS</a> 
  <li><a href= "#DNS"   >6.8 - Service de Noms - DNS, BIND, et named</a> 
    <li><a href= "#PPTP"  >6.9 - Mise en place d'une connexion PPTP sous OpenBSD</a>
</ul>
<p></p>
<hr>

<br>
<P>
<a name= "Intro"></a>
<A name="6.0.1"></a>
<H2>6.0.1 - Avant d'aller plus loin</h2>
<P> Le lecteur sera plus &agrave; l'aise pour lire ce document s'il a lu 
  auparavant - et m&ecirc;me partiellement - la section <a href="faq5.html">Configuration 
  du noyau</a> de la FAQ, et les pages du manuel Unix <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&sektion=8">ifconfig(8)</a> 
  et <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&sektion=1">netstat(1)</a>.
<P> Si vous &ecirc;tes un administrateur r&eacute;seau et que vous mettez en 
place 
  des protocoles de routage, si vous utilisez une machine OpenBSD pour assurer 
  des fonctions de routage, ou si vous avez besoin d'approfondir vos connaissances 
  des r&eacute;seaux IP, vous devriez lire <a href="http://www.3com.com/corpinfo/en_US/technology/tech_paper.jsp?DOC_ID=135">Comprendre 
  l'adressage IP</a> (voici <a href="http://www.3com.com/other/pdfs/infra/corpinfo/en_US/501302.pdf">un 
  autre lien</a>). C'est un excellent document expliquant les concepts 
  fondamentaux 
  pour travailler avec des r&eacute;seaux IP et particuli&egrave;rement quand 
  vous g&eacute;rez ou &ecirc;tes responsable de plus d'un r&eacute;seau. 
<p> Si vous manipulez des applications comme des serveurs web, des serveurs ftp, 
  ou des serveurs de messagerie, <a href="http://the.rfceditor.org/rfc.html">lire 
  les RFCs</a> pourrait vous &ecirc;tre tr&egrave;s b&eacute;n&eacute;fique. Il 
  est plus que probable que vous ne les lirez pas toutes. Choisissez les sujets 
  qui vous int&eacute;ressent ou dont vous avez besoin dans votre environnement 
  r&eacute;seau, cherchez les dans les RFCs et essayez d'en comprendre les fondements. 
  Les RFCs d&eacute;finissent plusieurs (des milliers de) standards pour les protocoles 
  de l'Internet et comment ceux-ci sont cens&eacute;s fonctionner. <a name= "Setup"></a> 
  <a name="6.1"></a> 
<h2>6.1 - Configuration r&eacute;seau initiale</h2>

<p>
<a name= "Setup.1"></a>
<a name="6.1.1"></a>
<h3>6.1.1 - Identification et configuration des interfaces r&eacute;seau</h3>
<p></p>

<p> Pour commencer, il vous faudra d'abord identifier votre interface r&eacute;seau. 
  Dans OpenBSD, les interfaces sont nomm&eacute;es d'apr&egrave;s le type de carte 
  et non pas d'apr&egrave;s le type de connexion. Vous pouvez voir l'initialisation 
  de votre carte r&eacute;seau durant le processus de d&eacute;marrage, ou apr&egrave;s 
  le processus de d&eacute;marrage en utilisant la commande <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&sektion=8">dmesg(8)</a>. 
  Vous pouvez aussi voir votre interface r&eacute;seau en utilisant la commande<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&sektion=8"> 
  ifconfig(8)</a>. Par exemple, voici la sortie fournie par dmesg pour une carte 
  r&eacute;seau Fast Ethernet Intel, qui utilise fxp comme nom de p&eacute;riph&eacute;rique.</p>

<ul><pre>
fxp0 at pci0 dev 10 function 0 "Intel 82557" rev 0x0c: irq 5, address 00:02:b3:2b:10:f7
inphy0 at fxp0 phy 1: i82555 10/100 media interface, rev. 4
</pre></ul>

<p>Si vous ne connaissez pas le nom de p&eacute;riph&eacute;rique affect&eacute; 
  &agrave; votre carte, consultez <a href="../../fr/plat.html">la liste du mat&eacute;riel 
  support&eacute;</a> pour votre plateforme. Vous y trouverez une liste de plusieurs 
  noms communs de carte et leur nom de p&eacute;riph&eacute;rique OpenBSD. Il 
  suffira alors de combiner le nom r&eacute;duit de p&eacute;riph&eacute;rique 
  (comme fxp) et un nombre affect&eacute; par le noyau pour obtenir un nom d'interface 
  (comme fxp0).</p>
<p>Vous pouvez trouver quelles interfaces ont &eacute;t&eacute; identifi&eacute;es 
  en utilisant l'utilitaire <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&sektion=8">ifconfig(8)</a>. 
  La commande suivante affichera toutes les interfaces r&eacute;seau sur un syst&egrave;me. 
  Cet exemple de sortie nous montre une seule interface ethernet, une <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp&sektion=4">fxp(4)</a>.</p>

<ul><pre>
$ <strong>ifconfig -a</strong>
lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 33224
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x4
        inet6 ::1 prefixlen 128
        inet 127.0.0.1 netmask 0xff000000 
lo1: flags=8008&lt;LOOPBACK,MULTICAST&gt; mtu 33224
fxp0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        media: Ethernet autoselect (100baseTX full-duplex)
        status: active
        inet 10.0.0.38 netmask 0xffffff00 broadcast 10.0.0.255
        inet6 fe80::202:b3ff:fe2b:10f7%fxp0 prefixlen 64 scopeid 0x1
pflog0: flags=0&lt;&gt; mtu 33224
sl0: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt; mtu 296
sl1: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt; mtu 296
ppp0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500
ppp1: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500
tun0: flags=10&lt;POINTOPOINT&gt; mtu 3000
tun1: flags=10&lt;POINTOPOINT&gt; mtu 3000
enc0: flags=0&lt;&gt; mtu 1536
bridge0: flags=0&lt;&gt; mtu 1500
bridge1: flags=0&lt;&gt; mtu 1500
vlan0: flags=0&lt;&gt; mtu 1500
vlan1: flags=0&lt;&gt; mtu 1500
gre0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1450
gif0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif1: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif2: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif3: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
</pre></ul>

<p>Comme vous pouvez le constater, <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&sektion=8">ifconfig(8)</a> 
  nous fournit beaucoup plus d'informations que nous ne pourrions en avoir besoin 
  &agrave; ce stade. N&eacute;anmoins, il nous permet de voir notre interface. 
  Dans l'exemple pr&eacute;cit&eacute;, la carte a d&eacute;j&agrave; &eacute;t&eacute; 
  configur&eacute;e. C'est &eacute;vident puisque l'acc&egrave;s &agrave; un
  réseau IP est configuré sur l'interface fxp0, 
  d'o&ugrave; les valeurs &quot;inet 10.0.0.38 netmask 0xffffff00 broadcast 10.0.0.255&quot;. 
  De plus, les drapeaux<b> UP</b> et <b>RUNNING</b> sont positionn&eacute;s. </p>
<p>Finalement, vous remarquerez que plusieurs autres interfaces sont activ&eacute;es 
  par d&eacute;faut. Ce sont des interfaces virtuelles qui servent &agrave; diff&eacute;rentes 
  fonctions. Les pages du manuel suivantes les d&eacute;crivent : </p>
<ul>
  <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lo&sektion=4">lo</a> 
    - Interface de bouclage
  <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflog&sektion=4">pflog</a> 
    - Interface de journalisation du filtre de paquets Packet Filter
  <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sl&sektion=4">sl</a> 
    - Interface r&eacute;seau SLIP
  <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&sektion=4">ppp</a> 
    - Protocole Point &agrave; Point 
  <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tun&sektion=4">tun</a> 
    - Interface r&eacute;seau tunnel 
  <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=enc&sektion=4">enc</a> 
    - Interface d'encapsulation 
  <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&sektion=4">bridge</a> 
    - Interface de pont Ethernet 
  <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=vlan&sektion=4">vlan</a> 
    - Interface d'encapsulation IEEE 802.1Q 
  <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gre&sektion=4">gre</a> 
    - Interface d'encapsulation GRE/MobileIP 
  <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gif&sektion=4">gif</a> 
    - Interface tunnel IPv4/IPv6 g&eacute;n&eacute;rique 
</ul>

<p>Si votre interface r&eacute;seau n'est pas configur&eacute;e, la premi&egrave;re 
  &eacute;tape consiste &agrave; cr&eacute;er le fichier <strong>/etc/hostname.xxx</strong>. 
  Remplacez xxx par le nom de votre interface. A partir des informations  
  des exemples pr&eacute;c&eacute;dents, ce nom serait <strong>/etc/hostname.fxp0</strong>. 
  Le format de ce fichier est simple : </p>
<ul><pre>
address_family address netmask broadcast [other options]
</pre></ul>

<p>(Vous trouverez beaucoup plus de d&eacute;tails concernant le format de ce 
  fichier dans la page de manuel <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&sektion=5">hostname.if(5)</a>.)</p>
<p>Un fichier typique de configuration d'interface, configur&eacute; pour une 
  adresse IPv4, ressemble à ceci : </p>
<ul><pre>
$ <strong>cat /etc/hostname.fxp0</strong>
inet 10.0.0.38 255.255.255.0 NONE
</pre></ul>

<p>Vous pouvez aussi sp&eacute;cifier le type de m&eacute;dia Ethernet si vous 
  le souhaitez, par exemple, forcer le mode 100baseTX full-duplex.</p>
<ul><pre>
inet 10.0.0.38 255.255.255.0 NONE media 100baseTX media-opt full-duplex
</pre></ul>

<p>(Bien entendu, vous ne devriez jamais forcer le mode full duplex &agrave; moins 
  que les deux extr&eacute;mit&eacute;s de la connexion soient param&eacute;tr&eacute;es 
  pour opérer dans ce mode ! En l'absence de besoins sp&eacute;cifiques, 
  les param&egrave;tres de m&eacute;dia doivent &ecirc;tre exclus.)</p>
<p>Ou peut-&ecirc;tre souhaitez-vous utiliser des drapeaux sp&eacute;ciaux sp&eacute;cifiques 
  &agrave; un type d'interface. Le format du fichier hostname n'est gu&egrave;re
  différent !</p>
<ul><pre>
$ <strong>cat /etc/hostname.vlan0</strong>
inet 172.21.0.0 255.255.255.0 NONE vlan 2 vlandev fxp1
</pre></ul>

<p>L'&eacute;tape suivante consiste &agrave; configurer votre passerelle. Pour 
  cela, mettez simplement l'adresse IP de la passerelle dans le fichier <strong>/etc/mygate</strong>. 
  Ceci aura pour effet de configurer votre passerelle au d&eacute;marrage. Ensuite, 
  vous devriez configurer vos serveurs de noms, et votre fichier <strong>/etc/hosts</strong> 
  (consultez la page du manuel <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hosts&sektion=5">hosts(5)</a>). 
  Pour configurer vos serveurs de noms, cr&eacute;ez un fichier appel&eacute; 
  <strong>/etc/resolv.conf</strong>. Plus d'informations sur le format 
  de ce fichier sont disponibles en consultant la page du manuel <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&sektion=5">resolv.conf(5)</a>. 
  Mais pour une utilisation standard, voici un exemple. Dans cet exemple, vos 
  serveurs de noms sont 125.2.3.4 et 125.2.3.5. Vous appartenez au domaine &quot;yourdomain.com&quot;.</p>
<ul><pre>
$ <strong>cat /etc/resolv.conf</strong>
search yourdomain.com
nameserver 125.2.3.4
nameserver 125.2.3.5
lookup file bind
</pre></ul>

<p>Vous pouvez alors soit red&eacute;marrer soit ex&eacute;cuter 
  le script <strong>/etc/netstart</strong>. Vous pouvez faire cela simplement 
  en saisissant (en tant que root) : </p>
<ul><pre>
# <strong>sh /etc/netstart</strong>
writing to routing socket: File exists
add net 127: gateway 127.0.0.1: File exists
writing to routing socket: File exists
add net 224.0.0.0: gateway 127.0.0.1: File exists
</pre></ul>

<p>Vous remarquerez que quelques erreurs sont g&eacute;n&eacute;r&eacute;es. 
  En ex&eacute;cutant ce script, vous reconfigurez des choses qui ont d&eacute;j&agrave; 
  &eacute;t&eacute; configur&eacute;es. Ainsi, quelques routes existent d&eacute;j&agrave; 
  dans la table de routage du noyau. Votre syst&egrave;me est maintenant op&eacute;rationnel. 
  Vous pouvez v&eacute;rifier que votre interface a &eacute;t&eacute; correctement 
  configur&eacute;e avec la commande <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&sektion=8">ifconfig(8)</a>. 
  Vous pouvez aussi v&eacute;rifier vos routes gr&acirc;ce &agrave; <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&sektion=1">netstat(1)</a> 
  ou <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=route&sektion=8">route(8)</a>. 
  Voici un example d'utilisation de ces deux commandes pour afficher vos tables 
  de routage : </p>
<ul><pre>
$ <strong>netstat -rn</strong>
Routing tables

Internet:
Destination        Gateway            Flags     Refs     Use    Mtu  Interface
default            10.0.0.1           UGS         0       86      -  fxp0
127/8              127.0.0.1          UGRS        0        0      -  lo0
127.0.0.1          127.0.0.1          UH          0        0      -  lo0
10.0.0/24          link#1             UC          0        0      -  fxp0
10.0.0.1           aa:0:4:0:81:d      UHL         1        0      -  fxp0
10.0.0.38          127.0.0.1          UGHS        0        0      -  lo0
224/4              127.0.0.1          URS         0        0      -  lo0

Encap:
Source             Port  Destination        Port  Proto SA(Address/SPI/Proto)

$ <strong>route show</strong>
Routing tables

Internet:
Destination      Gateway            Flags
default          10.0.0.1           UG
127.0.0.0        LOCALHOST          UG
localhost        LOCALHOST          UH
10.0.0.0         link#1             U
10.0.0.1         aa:0:4:0:81:d      UH
10.0.0.38        LOCALHOST          UGH
BASE-ADDRESS.MCA LOCALHOST          U
</pre></ul>

<p>
<a name= "Setup.2"></a>
<a name="6.1.2"></a>
<h3>6.1.2 - Configuration de votre machine OpenBSD en passerelle </h3>
<p></p>

<p>Ceci est l'information de base dont vous avez besoin pour configurer votre 
  machine OpenBSD en passerelle (appel&eacute;e aussi routeur). Si vous utilisez 
  OpenBSD en routeur sur Internet, nous vous sugg&eacute;rons de lire aussi les 
  instructions de configuration du filtre de paquet Packet Filter ci-apr&egrave;s 
  pour bloquer tout trafic potentiellement malicieux. De m&ecirc;me, vu la faible 
  disponibilit&eacute; d'adresses <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&sektion=4">IPv4</a> 
  chez les fournisseurs d'acc&egrave;s r&eacute;seau et les registres r&eacute;gionaux, 
  vous devriez aussi lire la partie concernant la traduction d'adresses afin 
  de conserver votre espace d'adressage IP. </p>
<p>Le noyau GENERIC a d&eacute;j&agrave; la fonction n&eacute;cessaire pour effectuer 
  le routage IP, mais celle-ci doit &ecirc;tre activ&eacute;e. Vous devriez faire 
  cela &agrave; l'aide de l'utilitaire <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&sektion=8">sysctl(8)</a>. 
  Pour effectuer cette modification de mani&egrave;re permanente, &eacute;ditez 
  le fichier <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&sektion=5">/etc/sysctl.conf(5)</a> 
  pour autoriser le routage IP. Pour ce faire, ajoutez la ligne suivante dans 
  ce fichier de configuration.</p>
<ul><pre>
net.inet.ip.forwarding=1
</pre></ul>

<p>Pour faire ce changement sans red&eacute;marrage, utilisez directement l'utilitaire 
  <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&sektion=8">sysctl(8)</a>. 
  N&eacute;anmoins, il faut se rappeler que ce changement n'existera plus apr&egrave;s 
  red&eacute;marrage, et devra &ecirc;tre effectu&eacute; en tant que root.</p>
<ul><pre>
# <strong>sysctl -w net.inet.ip.forwarding=1</strong>
net.inet.ip.forwarding: 0 -&gt; 1
</pre></ul>

<p>Maintenant, modifiez les routes sur les autres h&ocirc;tes des deux c&ocirc;t&eacute;s. 
  Il y a plusieurs utilisations possibles de OpenBSD comme routeur, en utilisant 
  des logiciels comme <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=routed&sektion=8">routed(8)</a>, 
  <a href="http://www.gated.org">gated</a>, <a href="http://www.mrtd.net">mrtd</a>, 
  et <a href="http://www.zebra.org">zebra</a>. La collection de ports de OpenBSD 
  contient zebra, gated, et mrtd. OpenBSD supporte plusieurs interfaces T1, HSSI, 
  ATM, FDDI, Ethernet, et s&eacute;rie (PPP/SLIP). </p>
<p>
<a name= "Setup.3"></a>
<a name="6.1.3"></a>
<h3>6.1.3 - Configuration d'alias sur une interface.</h3>
<p>OpenBSD poss&egrave;de un m&eacute;canisme simple pour configurer des alias 
  sur une interface. Pour faire cela, &eacute;ditez le fichier <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&sektion=5"><i>/etc/hostname.&lt;if&gt;</i></a>. 
  Ce fichier est lu durant la phase de d&eacute;marrage par le script <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&sektion=8">/etc/rc(8)</a>, 
  qui fait partie de la <a href="../faq10.html#rc">hi&eacute;rarchie de d&eacute;marrage 
  rc</a>. Par exemple, nous supposons que l'utilisateur a une interface <b>dc0</b> 
  sur le r&eacute;seau 192.168.0.0. D'autres informations utiles : </p>
<ul>
  <li>l'adresse IP de dc0 est 192.168.0.2 
  <li>le masque de sous-r&eacute;seau est 255.255.255.0 
</ul>

<p>Quelques remarques &agrave; propos des alias. Dans OpenBSD, vous utilisez 
  uniquement le nom d'interface. Il n'y a pas de diff&eacute;rence entre le premier 
  alias et le second alias. OpenBSD ne s'y r&eacute;f&egrave;re pas en tant que 
  dc0:0 et dc0:1 comme le font d'autres syst&egrave;mes d'exploitation. Si vous 
  faites r&eacute;f&eacute;rence &agrave; une adresse IP sp&eacute;cifique en 
  alias avec ifconfig, ou si vous ajoutez un alias, assurez-vous de saisir &quot;<tt>ifconfig 
  int alias</tt>" au lieu de "<tt>ifconfig int</tt>" &agrave; la ligne de commande. 
  Vous pouvez effacer des alias avec &quot;<tt>ifconfig int delete</tt>". 
<p>En supposant que vous disposez de plusieurs adresses IP en alias 
appartenant au m&ecirc;me sous-r&eacute;seau IP, la configuration du masque de sous-r&eacute;seau 
  pour chaque alias sera 255.255.255.255. Il n'est pas nécessaire d'avoir le m&ecirc;me 
  masque de sous-r&eacute;seau que celui de la premi&egrave;re adresse IP affect&eacute;e 
  &agrave; l'interface. Dans cet exemple, <i>/etc/hostname.dc0</i>, deux alias 
  sont ajout&eacute;s &agrave; l'interface dc0, qui, rappelons-le, a &eacute;t&eacute; 
  configur&eacute;e avec l'adresse IP 192.168.0.2 et un masque de sous-r&eacute;seau 
  255.255.255.0. 
<ul><pre>
# <b>cat /etc/hostname.dc0</b>
inet 192.168.0.2 255.255.255.0 media 100baseTX
inet alias 192.168.0.3 255.255.255.255
inet alias 192.168.0.4 255.255.255.255
</pre></ul>

<p>Une fois ce fichier modifi&eacute; comme indiqu&eacute;, il suffit de red&eacute;marrer 
  pour que les changements prennent effet. Vous pouvez, toutefois, activer les 
  aliases &agrave; la main &agrave; l'aide de l'utilitaire <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&sektion=8">ifconfig(8)</a>. 
  Pour activer le premier alias, vous utiliseriez la commande : </p>
<ul><pre>
# <b>ifconfig dc0 inet alias 192.168.0.3 netmask 255.255.255.255</b>
</pre></ul>

<p> Pour voir ces aliases, vous devez utiliser la commande : </p>

<ul><pre>
$ <b>ifconfig -A</b>
dc0: flags=8863&lt;UP,BROADCAST,NOTRAILERS,RUNNING,SIMPLEX,MULTICAST&gt;
        media: Ethernet manual
        inet 192.168.0.2  netmask 0xffffff00 broadcast 192.168.0.255
        inet 192.168.0.3 netmask 0xffffffff broadcast 192.168.0.3
</pre></ul>



<p>
<a name= "6.2"></a>
<a name= "PF"></a>
<h2>6.2 - Packet Filter (PF)</h2>
<p></p>
<p>
<h5>Remarque : Packet filter est le syst&egrave;me de filtrage dans OpenBSD 
&agrave; 
  partir de la version 3.0. Si vous recherchez la FAQ IPF/IPNAT pour les versions 
  pr&eacute;c&eacute;dentes de OpenBSD, cliquez <a href="../faqipf.html">ici</a>.</h5>
<p>Le sous-syst&egrave;me Packet Filter a &eacute;t&eacute; cr&eacute;&eacute; pour fournir 
  deux services, la gestion des permissions de routage au niveau paquet et l'association 
  d'h&ocirc;tes/sous-r&eacute;seaux &agrave; une plage d'adresses externes. Les 
  fichiers de configuration pour ces deux services sont <i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&sektion=5">/etc/pf.conf(5)</a></i> 
  et <i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nat.conf&sektion=5">/etc/nat.conf(5)</a></i>. 
</p>
<p>Pour d&eacute;marrer ces services, vous avez besoin d'&eacute;diter <i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&sektion=8">/etc/rc.conf(8)</a></i> 
  et de mettre : </p>
<ul><pre>
pf=YES
</pre></ul>

<p>Si vous utilisez la traduction d'adresses, vous aurez tr&egrave;s probablement 
  besoin de mettre la valeur <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&sektion=8">sysctl(8)</a> 
  de <tt>net.inet.ip.forwarding</tt> &agrave; 1. Vous pouvez le faire en 
  d&eacute;commentant les lignes correspondantes dans <i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&sektion=5">/etc/sysctl.conf(5)</a></i> 
  puis red&eacute;marrez votre ordinateur.</p>
<p>Si le support Packet Filter est inclus dans votre noyau mais que vous ne l'avez 
  pas activ&eacute; dans votre fichier <i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&sektion=8">/etc/rc.conf(8)</a></i>,<i> 
  </i>vous pouvez toujours l'activer &agrave; l'aide de la commande <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pfctl&sektion=8">pfctl(8)</a>.</p>
<ul><pre>
# <b>pfctl -R /etc/pf.conf</b>
# <b>pfctl -N /etc/nat.conf</b>
# <b>pfctl -e</b>
</pre></ul>

<p>La premi&egrave;re ligne configure le filtrage, en utilisant <i>/etc/pf.conf</i> 
  et la seconde configure la traduction d'adresses, en utilisant <i>/etc/nat.conf</i> 
  (la <a href="#NAT">Section 6.3, Traduction d'adresses</a> fournit plus de d&eacute;tails 
  sur la traduction d'adresses), et finalement, la derni&egrave;re ligne active 
  PF.</p>
<p>Ceci peut aussi &ecirc;tre combin&eacute; en une seule ligne de commande : </p>
<ul><pre>
# <strong>pfctl -R /etc/pf.conf -N /etc/nat.conf -e</strong>
</pre></ul>
<p>Si vous effectuez des changements sur <i>/etc/pf.conf</i> apr&egrave;s le d&eacute;marrage 
  de PF, vous pouvez recharger les r&egrave;gles en rechargeant le fichier appropri&eacute; : </p>
<ul><pre>
# <b>pfctl -R /etc/pf.conf</b>
</pre></ul>

<p>Ce document va couvrir ci-apr&egrave;s quelques configurations basiques de 
  <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&sektion=5">pf.conf(5)</a> 
  et <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nat.conf&sektion=5">nat.conf(5)</a>. 
  Vous pouvez aussi voir le <a href="#sample_pf.conf">jeu de r&egrave;gles r&eacute;sultant</a> 
  qui inclut toutes les instructions de configuration, expliqu&eacute;es plus 
  en d&eacute;tail ci-apr&egrave;s. Vous pouvez obtenir d'autres informations concernant 
  Packet Filter sur le <a href="http://www.benzedrine.cx/pf.html">site web Packet 
  Filter</a> et dans le <a href="http://www.inebriated.demon.nl/pf-howto/"> HOWTO 
  Packet Filter</a>.</p>
<p>
<h3>Packet Filter</h3>
<p></p>

<p>Afin d'activer Packet Filter au d&eacute;marrage, vous aurez besoin de modifier 
  <i>/etc/rc.conf </i>afin que ce fichier contienne la ligne <tt>pf=YES</tt>. 
  Packet Filter (pf) est contr&ocirc;l&eacute; par <i>/etc/pf.conf</i>, fichier 
  lu au d&eacute;marrage. Pour une explication plus d&eacute;taill&eacute;e, 
  voir <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&sektion=5">pf.conf(5)</a>. 
  Dans les exemples suivants, <tt>fxp0</tt> repr&eacute;sente l'interface externe 
  connect&eacute;e &agrave; internet. Ceci sera diff&eacute;rent pour vous selon 
  l'interface ethernet pr&eacute;sente sur votre machine. Les r&egrave;gles ci-apr&egrave;s 
  supposent une connectivit&eacute; internet permanente telle qu'utilisée
  pour un serveur web.</p>
<p>Les r&egrave;gles Packet Filter sont trait&eacute;es de mani&egrave;re s&eacute;quentielle 
  du haut vers le bas ; visualiser chaque paquet devant traverser chaque r&egrave;gle 
  avant d'atteindre sa destination aide &agrave; comprendre ce type de fonctionnement. 
</p>
<p>Par exemple, la base de r&egrave;gles par d&eacute;faut fournie autorise tous 
  les paquets en entr&eacute;e, et tous les paquets en sortie : </p>
<ul><pre>
pass out all 
pass in all
</pre></ul>

Ces r&egrave;gles sont &eacute;quivalentes &agrave; : 
<ul><pre>
pass in from any to any
pass out from any to any
</pre></ul>

<p>qui peuvent &ecirc;tre interpr&eacute;t&eacute;es comme &quot;laisser passer 
  les paquets &agrave; partir de n'importe quelle source vers n'importe quelle 
  destination&quot;, avec un &quot;sur n'importe quelle interface (qui est toujours 
  implicite si aucune interface n'est sp&eacute;cifi&eacute;e) pour n'importe 
  quelle famille d'adresses, <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inet&sektion=4">inet 
  (v4)</a> ou <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inet6&sektion=4">inet6 
  (v6)</a>&quot; implicite.</p>
<p>Bien &eacute;videmment, ceci n'est pas vraiment un filtre. Un filtrage plus 
  utile sera bas&eacute; sur la famille d'adresses (IPv4 ou IPv6), le(s) protocole(s) 
  et le(s) port(s) utilis&eacute;s par les services qu'on souhaite filtrer. N'importe 
  quel protocole list&eacute; dans <i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=protocols&sektion=5">/etc/protocols(5)</a></i> 
  peut &ecirc;tre sp&eacute;cifi&eacute;, par son nom ou son num&eacute;ro, mais 
  nous allons nous limiter dans ce document &agrave; <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcp&sektion=4">tcp(4)</a>, 
  <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=udp&sektion=4">udp(4)</a> 
  et <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=icmp&sektion=4">icmp(4)</a>. 
</p>
<p>Maintenant supposons que nous ne voulons pas autoriser en entr&eacute;e les 
  connexions IPv4 au port TCP 3306 (MySQL) parce que la connexion &agrave; la 
  base de donn&eacute;es doit &ecirc;tre uniquement faite &agrave; partir du localhost. 
  Notre base de r&egrave;gles serait comme suit : </p>
<ul>
  <pre>
pass out all
pass in all
block in on fxp0 inet proto tcp from any to any port 3306
</pre>
</ul>

<p>Ceci peut &ecirc;tre interpr&eacute;t&eacute; comme suit : &quot;bloquer tout 
  les paquets IPv4 (inet) en entr&eacute;e &agrave; destination du port tcp 3306, 
  de n'importe quelle source vers n'importe quelle destination.&quot; Il est &agrave; 
  noter qu'il est obligatoire de sp&eacute;cifier un protocole avec tout filtre 
  bas&eacute; sur les ports, et qu'il est recommand&eacute; de sp&eacute;cifier 
  la famille d'adresses. Pour les services d&eacute;finis dans le fichier <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=services&sektion=5">/etc/services(5)</a> 
  , le nom du service peut &eacute;galement &ecirc;tre utilis&eacute;, comme <i>www 
  </i>ou <i>mysql</i>. Un paquet destin&eacute; au port tcp 3306 sur l'interface 
  <tt>fxp0</tt> va passer la premi&egrave;re r&egrave;gle &quot;pass in&quot; 
  puis sera bloqu&eacute; par la r&egrave;gle &quot;block in port 3306&quot;. 
  Si l'ordre de nos r&egrave;gles est invers&eacute; (souvenez-vous, l'ordre est 
  important) en entr&eacute;e : </p>
<ul>
  <pre>
pass out all
block in on fxp0 inet proto tcp from any to any port 3306
pass in all
</pre>
</ul>

<p>Les paquets destin&eacute;s au port tcp 3306 passeront parce que la derni&egrave;re 
  r&egrave;gle autorise tous les paquets &agrave; passer. Il est important de 
  se rappeler de ceci lors de l'&eacute;criture de r&egrave;gles de filtrage de paquets : 
  <b>la derni&egrave;re r&egrave;gle correspondante gagne</b>.</p>
<p>Bien s&ucirc;r, il y a des exceptions &agrave; chaque r&egrave;gle. L'option 
  <em>quick</em> bloque le paquet &agrave; la premi&egrave;re r&egrave;gle qui 
  correspond &agrave; ce dernier. Reprenons notre exemple pr&eacute;c&eacute;dent. 
  Si nous ajoutons <em>quick</em> &agrave; la r&egrave;gle &quot;block in&quot; : </p>
<ul>
  <pre>
pass out all
block in quick on fxp0 inet proto tcp from any to any port 3306
pass in all
</pre>
</ul>

<p>Un paquet destin&eacute; &agrave; notre machine sur le port tcp 3306 va atteindre 
  la r&egrave;gle &quot;block in quick&quot; et sera bloqu&eacute; imm&eacute;diatement. 
  Tous les paquets destin&eacute;s &agrave; d'autres ports ou d'autres protocoles 
  ne trouveront aucune r&egrave;gle correspondante jusqu'&agrave; ce qu'ils atteignent 
  la r&egrave;gle &quot;pass in&quot; qui autorise tous les paquets &agrave; passer.</p>
<p><b>Interdiction par d&eacute;faut </b></p>

<p>La plus s&ucirc;re des politiques de filtrage de paquets est une politique 
  d'interdiction par d&eacute;faut. Tout trafic non explicitement autoris&eacute; 
  est refus&eacute;. Cette politique est bien plus s&ucirc;re que d'interdire 
  explicitement chaque service prot&eacute;g&eacute;, permet d'avoir des bases 
  de r&egrave;gles plus petites, et peut prot&eacute;ger d'une mauvaise configuration 
  accidentelle d'un service laiss&eacute; expos&eacute;.</p>
<p>Voyons maintenant un autre exemple de base de r&egrave;gles et expliquons les 
  r&egrave;gles une par une. Voici un exemple pour un serveur web avec une politique 
  d'interdiction par d&eacute;faut qui autorise uniquement les connexions ssh 
  (pour l'administration) et les connexions http (port 80) et https (port 443).</p>
<ul><pre>
pass in quick on fxp0 inet proto tcp from any to any port 22
pass in quick on fxp0 inet proto tcp from any to any port 80
pass in quick on fxp0 inet proto tcp from any to any port 443
block in quick on fxp0 from any to any
pass out on fxp0 from any to any
</pre></ul>

<p>Ceci autorise les connexions en entr&eacute;e de n'importe o&ugrave; vers les 
  ports tcp 22 (ssh), 80 (http), 443 (https). Toutes les autres tentatives de connexions 
  en entr&eacute;e sont bloqu&eacute;es. Les connexions sortantes sont toutes 
  autoris&eacute;es. Cette base de r&egrave;gles est assez herm&eacute;tique. 
  Mais si vous vouliez autoriser uniquement vos h&ocirc;tes internes appartenant 
  au bloc d'adresses 1.1.1.0 de se connecter en ssh, et autoriser les connexions 
  &agrave; partir de l'externe &agrave; http et https ? 
<ul><pre>
pass in quick on fxp0 inet proto tcp from 1.1.1.0/24 to any port 22
pass in quick on fxp0 inet proto tcp from any to any port 80
pass in quick on fxp0 inet proto tcp from any to any port 443
block in quick on fxp0 from any to any
pass out on fxp0 from any to any
</pre></ul>

<p>Pas mal ! Mais si une seule machine (1.1.1.1) doit &ecirc;tre
autoris&eacute;e &agrave; 
  administrer le serveur web &agrave; distance ? Dans ce cas, il suffit de
  changer la ligne suivante : </p>
<ul><pre>
pass in quick on fxp0 inet proto tcp from 1.1.1.0/24 to any port 22
</pre></ul>
en : 
<ul><pre>
pass in quick on fxp0 inet proto tcp from 1.1.1.1/32 to any port 22
</pre></ul>
<p><b></b> 
</p>

<b>R&egrave;gles typiques</b> 
<p>Voici quelques r&egrave;gles typiques que tout le monde peut utiliser (en supposant 
  que fxp0 est l'interface externe connect&eacute;e &agrave; internet). D'abord, 
  une protection basique contre l'usurpation d'adresses doit &ecirc;tre mise en
  place. Ces adresses ne devraient (normalement) pas &ecirc;tre routables sur 
  l'Internet et m&ecirc;me si ce n'est pas le cas, elles sont tr&egrave;s 
  rarement l&egrave;gitimes et doivent &ecirc;tre bloqu&eacute;es :
<ul><pre>
block in quick on fxp0 inet from { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 } to any
block out quick on fxp0 inet from any to { 127.0.0.1/8, 192.168.0.0/16, \ 
172.16.0.0/12, 10.0.0.0/8 }
</pre></ul>

<p>Notre base de r&egrave;gles commence &agrave; &ecirc;tre correcte ; une fois
tout rassembl&eacute;, voici &agrave; quoi cela ressemble : </p>
<ul>
  <pre># n'autoriser personne &agrave; usurper des adresses non-routables

block in quick on fxp0 inet from { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 } to any
block out quick on fxp0 inet from any to { 127.0.0.1/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 }

# autoriser uniquement notre machine d'administration &agrave; se connecter via ssh

pass in quick on fxp0 inet proto tcp from 1.1.1.1/32 to any port 22

# autoriser les autres &agrave; utiliser http et https

pass in quick on fxp0 inet proto tcp from any to any port 80
pass in quick on fxp0 inet proto tcp from any to any port 443
# finalement, bloquer le rester avec une interdiction par d&eacute;faut
# et laisser passer le trafic sortant

pass out on fxp0 from any to any
</pre>
</ul>
<p></p>

<b>Journalisation de paquets</b> 
<p>C'est encore mieux mais peut encore &ecirc;tre am&eacute;lior&eacute;. Et si
nous souhaitons journaliser toute tentative de connexion vers le port 22 (ssh) 
qui sera bloqu&eacute;e par notre pare-feu ? Facile, Packet Filter peut
g&eacute;rer cela avec le mot-cl&eacute; 
  <i>log</i>: 
<ul><pre>
pass in quick on fxp0 inet proto tcp from 1.1.1.1/32 to any port 22
block in log quick on fxp0 inet proto tcp from any to any port 22
</pre></ul>
<p>Ces r&egrave;gles autorisent notre machine d'administration distante 
&agrave; se connecter au port 22, mais interdit et journalise toutes les autres 
tentatives de connexion au port 22.</p>
<p>Les paquets journalis&eacute;s sont envoy&eacute;s &agrave; l'interface pflog0, 
  surveill&eacute;e par <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&sektion=8">pflogd(8)</a>, 
  qui va enregistrer les paquets dans le fichier /var/log/pflog au format
  binaire <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcpdump&sektion=8">tcpdump(8)</a>. pflogd(8) est d&eacute;marr&eacute; par d&eacute;faut par <i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&sektion=8">/etc/rc(8)</a></i> 
  si pf est activ&eacute; dans <i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&sektion=8">/etc/rc.conf(8)</a></i>.Vous 
  pouvez lire ces fichiers de log en utilisant la commande suivante :
<ul><pre>
# <b>tcpdump -n -e -ttt -r /var/log/pflog</b>
</pre></ul>
<p></p>
<p>Il faut &ecirc;tre conscient qu'utiliser tcpdump pour surveiller le fichier 
  pflog ne donne pas un affichage en temps r&eacute;el. Si vous souhaitez obtenir 
  un tel affichage, vous pourriez utiliser la commande : 
<ul><pre>
# <b>tcpdump -i pflog0</b>
</pre></ul>
<p>tcpdump peut aussi &ecirc;tre utilis&eacute; pour r&eacute;duire le champ 
d'investigation et faciliter le d&eacute;boguage : </p>
<ul><pre>
# <b>tcpdump -e -i pflog0 port 80</b>
</pre></ul>
<p>Ceci n'affecte pas les donn&eacute;es du fichier <i>/var/log/pflog</i>.</p>
<p>Lors de l'analyse des logs, un soin particulier devra &ecirc;tre pris avec 
  le d&eacute;codage verbeux de protocole par tcpdump (activ&eacute; &agrave; l'aide 
  de l'option -v). Les d&eacute;codeurs de protocole de tcpdump n'ont pas un 
  historique irréprochable en termes de s&eacute;curit&eacute;. En 
  th&eacute;orie du moins, une 
  attaque &agrave; retardement peut &ecirc;tre possible &agrave; travers les champs 
  donn&eacute;es partiels de paquets journalis&eacute;s. </p>
<p></p>
<p> Un soin suppl&eacute;mentaire devra &ecirc;tre pris concernant l'acc&egrave;s 
  aux logs. Pflogd capture 96 octets du paquet et le journalise. 
  L'acc&egrave;s aux journaux pourrait fournir un acc&egrave;s partiel 
  &agrave; des informations sensibles contenues dans le champ donn&eacute;e du 
  paquet (par exemple lors des connexions <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=telnet&sektion=1">telnet(1)</a> 
  ou <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftp&sektion=1">ftp(1)</a>). 
</p>
<p><b>Protocoles multiples</b></p>

<p>Comment faire lorsqu'il est n&eacute;cessaire d'autoriser les connexions 
vers un service utilisant plusieurs protocoles, comme bind qui utilise TCP et 
UDP ? Packet Filter vous permet de regrouper des options sous forme d'une 
liste (plus de d&eacute;tails &agrave; propos des listes seront donn&eacute;s 
par la suite) : 
<ul>
  <pre>
# Laisser passer le trafic DNS pour BIND
pass in quick on fxp0 inet proto { tcp, udp } from any to any port 53
</pre>
</ul>
<p>Notez les espaces des deux c&ocirc;t&eacute;s des caract&egrave;res '{ }'. 
  Ceci est plus lisible que l'alternative que vous auriez pu utiliser : </p>
<ul>
  <pre>
pass in quick on fxp0 inet proto tcp from any to any port 53
pass in quick on fxp0 inet proto udp from any to any port 53
</pre>
</ul>
<p></p>

<p> <a name="normalization"></a> <b> Normalisation de paquets</b> </p>
<p>Certains syst&egrave;mes d'exploitation et applications ont du mal &agrave; 
  g&eacute;rer les paquets anormaux ou fragment&eacute;s. Il est donc parfois 
  b&eacute;n&eacute;fique de pouvoir normaliser les paquets avant de les transmettre 
  &agrave; leur destination finale. Ceci est effectu&eacute; gr&acirc;ce &agrave; 
  la directive <b>scrub,</b> utilis&eacute;e comme suit :
<ul><pre>
scrub in all
</pre></ul>
<p>Ceci engendre une charge additionnelle sur le syst&egrave;me. Il n'y a donc 
  aucune raison d'utiliser cette commande mis &agrave; part lors de la protection 
  d'&eacute;quipements ayant des mauvaises mises en oeuvre TCP/IP.</p>
<p> <b>Options IP</b></p>
<p>Par d&eacute;faut, PF bloque les paquets contenant des options IP. Ceci peut 
  rendre le travail plus difficile &agrave; des outils de &quot;prise d'empreinte 
  des syst&egrave;mes d'exploitation&quot; comme nmap. Si vous avez une application 
  qui n&eacute;cessite de tels paquets, comme le multicast ou l'IGMP, vous pouvez 
  utiliser la directive <b>allow-opts</b> : 
<ul><pre>
pass in quick on fxp0 allow-opts
</pre></ul>
<p></p>

<p> <b>Drapeaux TCP, connexions &eacute;tablies et maintien d'&eacute;tat </b></p>
<p>Packet Filter peut aussi filtrer les paquets en se basant sur les drapeaux 
  TCP et maintenir les connexions &eacute;tablies et l'&eacute;tat des connexions. 
  Il est recommand&eacute; que tous les utilisateurs qui souhaitent filtrer les 
  paquets selon les drapeaux TCP comprennent le r&ocirc;le de chaque drapeau. 
  Par exemple, si vous vouliez interdire tous les paquets avec les drapeaux FIN, 
  URG, et PSH positionn&eacute;s (comme par exemple lors d'une tentative de prise 
  d'empreinte avec nmap), vous pourriez utiliser une r&egrave;gle comme suit :
<ul><pre>
block in quick on fxp0 inet proto tcp from any to any flags FUP/FUP
</pre></ul>
<p>(Remerciements &agrave; <a href=mailto:halogen@nol.net>Kyle Hargraves</a> pour 
  cette astuce) </p>
<p>Une autre fonctionnalit&eacute; utile de Packet Filter est sa capacit&eacute; 
  &agrave; maintenir l'&eacute;tat. Le maintien d'&eacute;tat a &eacute;t&eacute; 
  d&eacute;crit comme &quot;je ne parle pas avant qu'on me parle&quot;; en d'autres 
  termes, une fois une connexion est &eacute;tablie, les paquets n'ont plus besoin 
  de traverser les bases de r&egrave;gles. C'est une fonctionnalit&eacute; tr&egrave;s 
  puissante qui permet d'&eacute;crire des r&egrave;gles plus simples et plus 
  s&ucirc;res. </p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p>Par exemple, voyons comment peut s'appliquer le maintien d'&eacute;tat &agrave; 
  notre base de r&egrave;gles pr&eacute;c&eacute;dente. En r&eacute;sum&eacute;, 
  nous autorisons un acc&egrave;s d'administration &agrave; partir de notre classe 
  C au port 22 (ssh) et tout trafic web entrant vers les ports 80 (http) et 443 
  (https). Nous bloquons tout autre trafic. Mais si je voulais faire un <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh&sektion=1">ssh(1)</a> 
  &agrave; partir du serveur web ? Et si j'avais besoin d'utiliser <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=lynx&sektion=1">lynx(1)</a> 
  pour chercher quelque chose dans la FAQ ? Eh bien, je ne peux pas parce que 
  j'ai bloqu&eacute; toutes les connexions entrantes autres que celles &agrave; 
  destination des ports sp&eacute;cifi&eacute;s. Bien que c'est la plus s&ucirc;re 
  des m&eacute;thodes, cela peut devenir assez g&eacute;nant. En ajoutant le mot-cl&eacute; 
  <em>keep state</em> &agrave; notre r&egrave;gle &quot;pass out&quot;, nous pouvons 
  automatiquement autoriser les connexions entrantes en r&eacute;ponse &agrave; 
  des connexions que nous avons initi&eacute;, comme la navigation web. Attention, 
  nous avons besoin de sp&eacute;cifier le protocole pour lequel nous maintenons 
  l'&eacute;tat.</p>
<ul>
  <pre>
block in fxp0 inet proto tcp all
pass in quick on fxp0 inet proto tcp from 1.1.1.0/24 to any port 22
pass in quick on fxp0 from any to any port 80
pass in quick on fxp0 from any to any port 443

pass out on fxp0 inet proto tcp from any to any keep state
</pre>
</ul>
<p>Cette petite modification va am&eacute;liorer la flexibilit&eacute; et la s&eacute;curit&eacute; 
  de notre base de r&egrave;gles de fa&ccedil;on spectaculaire : par exemple, 
  dans la base de r&egrave;gles ci-dessus, nous autorisons tout trafic tcp 
  vers les 
  ports 80 et 443. On peut verrouiller nos r&egrave;gles un peu plus. Afin qu'une 
  connexion tcp s'&eacute;tablisse, nous avons seulement besoin de laisser le 
  &quot;tcp handshake&quot; initial avoir lieu. Une fois effectu&eacute;, on peut 
  bloquer le trafic vers ce port et laisser notre r&egrave;gle &quot;keep state&quot; 
  g&eacute;rer la connexion. Pour autoriser la poign&eacute;e de main tcp
  initiale, 
  nous avons uniquement besoin d'autoriser les paquets avec un drapeau SYN positionn&eacute; 
  et un drapeau ACK non positionn&eacute;. En laissant passer uniquement les paquets 
  avec un SYN positionn&eacute;, il est possible de se pr&eacute;munir contre
  plusieurs formes 
  de scan de ports comme le scan FIN. flags S/SA signifie : des deux drapeaux 
  S (SYN) et A (ACK), seulement SYN peut &ecirc;tre positionn&eacute;. Les 
  autres 
  drapeaux ne sont pas investigu&eacute;s. Les r&egrave;gles ressemblent 
  maintenant &agrave; : 
<ul>
  <pre>block in on fxp0 inet proto tcp all

pass in quick on fxp0 inet proto tcp from 1.1.1.0/24 to any port 22 \
flags S/SA keep state
pass in quick on fxp0 inet proto tcp from any to any port 80 \
flags S/SA keep state
pass in quick on fxp0 inet proto tcp from any to any port 443 \
flags S/SA keep state
block out on fxp0 inet proto tcp all
pass out on fxp0 proto tcp all flags S/SA keep state</pre>
</ul>
<p></p>
<p></p>
<p></p>
<p></p>
<p>Commen&ccedil;ons &agrave; lier les choses ensemble en mettant toutes les r&egrave;gles 
  que nous avons cr&eacute;e jusqu'&agrave; pr&eacute;sent dans une m&ecirc;me 
  base de r&egrave;gles. Cette base de r&egrave;gles supporte IPv4, a une politique 
  d'interdiction par d&eacute;faut, autorise les connexions d'administration &agrave; 
  partir d'un r&eacute;seau local uniquement (via ssh) et autorise le trafic entrant 
  vers les ports 80 (http) et 443 (https). Elle prot&egrave;ge aussi contre 
  des adresses usurp&eacute;es non-routables, et bloque tous les paquets qui 
  sont trop fragment&eacute;s pour pouvoir &ecirc;tre inspect&eacute;s. Une 
  configuration typique pour un serveur web public. Voici &agrave; quoi
  ressemblerait <i>/etc/pf.conf</i> : 
</p>
<ul>
  <pre>
# nettoyer les paquets anormaux et fragment&eacute;s
scrub in all


# n'autoriser personne &agrave; usurper des adresses non-routables
block in quick on fxp0 inet from { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 } to any
block out quick on fxp0 inet from any to { 127.0.0.1/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 }

# par d&eacute;faut, interdire tous les paquets entrants, except&eacute; ceux
# explicimtement autoris&eacute;s par les r&egrave;gles suivantes
block in on fxp0 all

# autoriser les autres &agrave; utiliser http et https
pass in quick on fxp0 inet proto tcp from any to any port 80 \
flags S/SA keep state
pass in quick on fxp0 inet proto tcp from any to any port 443 \
flags S/SA keep state

# et laisser le trafic sortant passer en maintenant l'&eacute;tat des connexions
# &eacute;tablies 
# laisser passer tous les protocoles (y compris TCP, UDP, et ICMP) et 
# maintenir l'&eacute;tat correspondant de telle fa&ccedil;on que les serveurs DNS puissent
# r&eacute;pondre &agrave; nos propres requ&ecirc;tes DNS (UDP).
pass out on fxp0 from any to any keep state
</pre>
</ul>
<p></p>
<p>Bien que cet ensemble de r&egrave;gles soit correct, Packet Filter poss&egrave;de 
  quelques fonctionnalit&eacute;s qui vous permetteront de rendre votre fichier 
  <i>/etc/pf.conf</i> encore plus lisible et plus facilement maintenable.</p>
<p><b>Listes</b></p>

<p>Les listes sont des &quot;raccourcis&quot; utiles pour &eacute;crire des r&egrave;gles 
  plus simples et plus claires sous PF. Par exemple, comment faire si nous avons 
  besoin d'autoriser des connexions &agrave; un service utilisant plusieurs protocoles, 
  comme BIND, qui utilise TCP et UDP ?
<ul><pre>
pass in quick on fxp0 inet proto { tcp, udp } from any to any port 53
</pre></ul>
Notez les espaces des deux c&ocirc;t&eacute;s des caract&egrave;res '{ }'.
<p></p>
<p>Des groupes d'adresses IP en relation peuvent &ecirc;tre regroup&eacute;s 
dans des listes ; ces listes peuvent &ecirc;tre employ&eacute;es l&agrave; o&ugrave; une 
  seule adresse IP serait utilis&eacute;e dans une r&egrave;gle. Nos 
  r&egrave;gles d'anti-usurpation d'adresses en sont un exemple : 
<ul><pre>
# don't allow anyone to spoof non-routeable addresses
block in quick on fxp0 inet from { 127.0.0.0/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 } to any
block out quick on fxp0 inet from any to { 127.0.0.1/8, 192.168.0.0/16, \
172.16.0.0/12, 10.0.0.0/8 }
</pre></ul>
<p><b></b>
</p>

<b>Expansion de variable </b> 
<p>Un probl&egrave;me avec le pr&eacute;c&eacute;dent exemple de <i>pf.conf </i>est 
  de devoir changer un certain nombre de lignes si vous avez besoin de changer 
  votre interface, ou de changer une adresse IP. Le nombre de changements &agrave; 
  effectuer peut &ecirc;tre diminu&eacute; en utilisant l'expansion de variable : </p>
<ul><pre>
NoRouteIPs="{ 127.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, 10.0.0.0/8 }"
ExtIF="fxp0"
block in quick on $ExtIF from $NoRouteIPs to any
block out quick on $ExtIF from any to $NoRouteIPs
</pre></ul>
<p></p>

<p> <a name="sample_pf.conf"></a> <b>Mettons tout ensemble</b></p>
<p> Maintenant, mettons tout ensemble et voyons l'&eacute;l&eacute;gance de ce 
  fichier : 
<ul>
  <pre>
# D&eacute;finition de variables utiles

ExtIF="fxp0"              # Interface externe
IntNet="1.1.1.0/24"       # Notre réseau interne
NoRouteIPs="{ 127.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, 10.0.0.0/8 }"
Services="{ www, https }"

# Nettoyage des paquets anormaux et fragmentés
scrub in all

# n'autoriser personne &agrave; usurper des adresses non-routables
block in quick on $ExtIF from $NoRouteIPs to any
block out quick on $ExtIF from any to $NoRouteIPs

# par d&eacute;faut, interdire tous les paquets entrants, except&eacute; ceux
# explicimtement autoris&eacute;s par les r&egrave;gles suivantes
block in on fxp0 all

# autoriser les autres à utiliser http et https
pass in quick on $ExtIF inet proto tcp from any to any port $Services \
flags S/SA keep state

# et laisser le trafic sortant passer en maintenant l'&eacute;tat des connexions
# &eacute;tablies 
# laisser passer tous les protocoles (y compris TCP, UDP, et ICMP) et 
# maintenir l'&eacute;tat correspondant de telle fa&ccedil;on que les serveurs DNS puissent
# r&eacute;pondre &agrave; nos propres requ&ecirc;tes DNS (UDP).
pass out on fxp0 from any to any keep state</pre>
</ul>
<p></p>

<p> Si vous rencontrez des probl&egrave;mes, vous pouvez activer 
la journalisation sur des r&egrave;gles individuelles pour trouver la cause des probl&egrave;mes :
<ul><pre>
pass in log quick on fxp0 from 1.1.1.0/24 to any port 22
</pre></ul>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflogd&sektion=8">pflogd(8)</a> 
&eacute;crira les paquets journalis&eacute;s dans /<i>var/log/pflog</i>. Il 
faut se rappeler que <i>/var/log/pflog</i> 
est un fichier binaire, destin&eacute; &agrave; &ecirc;tre lu par <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcpdump&sektion=8">tcpdump(8)</a>, 
et PAS DIRECTEMENT par des &ecirc;tres humains. 
<p></p>
<p> Quand vous modifiez le fichier de configuration pour journaliser des 
paquets, n'oubliez pas de taper <b>pfctl -R /etc/pf.conf</b> pour la prise en 
compte des modifications ! </p>

<p>
<h3>Diff&eacute;rences entre PF et IPF</h3>
<p></p>
<p>Packet Filter (PF) a &eacute;t&eacute; con&ccedil;u pour &ecirc;tre tr&egrave;s 
  compatible avec le fichier de r&egrave;gles <i>ipf.rules </i> de IPF. N&eacute;anmoins, 
  PF n'est pas simplement un rempla&ccedil;ant immédiat d'IPF. Les principales 
  diff&eacute;rences de syntaxe pour les r&egrave;gles de filtrage (pf.conf) sont 
  les suivantes : </p>
<ul>
  <li><b>group et head:</b> ces options ne sont plus utilis&eacute;es, vu que 
    les r&egrave;gles de filtrage sont optimis&eacute;es &agrave; la vol&eacute;e. 
    Si vous migrez vos anciennes bases de r&egrave;gles IPF, vous devriez effacer 
    toute d&eacute;finition <em>group</em> ou <em>head</em> et r&eacute;ordonner 
    manuellement vos r&egrave;gles, en s'assurant que les s&eacute;mantiques n'ont 
    pas chang&eacute;. </li>
  <li><b>level:</b> pour la journalisation, PF n'accepte pas une option <em>level</em> 
    pour le mot-cl&eacute; <i>log</i>, puisqu'elle n'est pas effectu&eacute; 
    par <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=syslogd&sektion=8">syslogd(8)</a>, 
    mais par un d&eacute;mon de journalisation s&eacute;par&eacute;. Pour 
    analyser un type particulier de trafic, comme cela pourrait se faire avec 
    l'option<em> level</em>, 
    utilisez une des options disponibles de <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tcpdump&sektion=8">tcpdump(8)</a>.</li>
  <li><b>keep frags:</b> Ceci a &eacute;t&eacute; remplac&eacute; par la normalisation 
    r&eacute;alis&eacute;e par le mot-cl&eacute; <a href="#normalization">scrub</a>.</li>
  <li><b>R&egrave;gles @n :</b> PF n'a pas de support pour l'utilisation des pr&eacute;fixes 
    @n pour ins&eacute;rer des r&egrave;gles &agrave; des points particuliers 
    dans la liste des r&egrave;gles comme le permet IPF. Pour voir les 
    num&eacute;ros de r&egrave;gles que PF a affect&eacute;, utilisez la commande <tt>pfctl -sr</tt></li>
</ul>

<p>
<a name="6.3"></a>
<a name="NAT"></a>
<h2>6.3 - Traduction d'adresses</h2>
<p></p>
<p>
<h5>Remarque : Packet filter est le syst&egrave;me de filtrage de OpenBSD &agrave; 
  partir de la version 3.0. Si vous recherchez la FAQ IPF/IPNAT pour les versions 
  ant&eacute;rieures de OpenBSD, cliquez <a href="../faqipf.html">ici</a>.</h5>
<p></p>
<a name="nat1.0"></a>
<h3><u>6.3.1 Introduction &agrave; la traduction d'adresses (NAT)</u></h3>

<a name="nat1.1"></a> 
<p> Bas&eacute;e sur la <a href="http://www.geektools.com/rfc/rfc1631.txt">RFC 
  1631</a>, la traduction d'adresses fournit un moyen facile pour faire correspondre 
  des r&eacute;seaux internes &agrave; une seule adresse internet (r&eacute;elle) 
  routable. Ceci est tr&egrave;s utile si vous n'avez pas des adresses officiellement 
  attribu&eacute;es &agrave; chaque h&ocirc;te de votre r&eacute;seau interne. 
  Quand vous mettez en place des r&eacute;seaux priv&eacute;s/internes, vous pouvez 
  b&eacute;n&eacute;ficier de blocs d'adresses r&eacute;serv&eacute;s (attribu&eacute;s 
  dans la <a href="http://www.geektools.com/rfc/rfc1918.txt">RFC 1918</a>) tels 
  les blocs suivants : </p>

<p>
10.0.0.0/8 (10.0.0.0 - 10.255.255.255)<br>
172.16.0.0/12 (172.16.0.0 - 172.31.255.255)<br>
192.168.0.0/16 (192.168.0.0 - 192.168.255.255)<br>
</p>

<p>On suppose que l'utilisateur a d&eacute;j&agrave; install&eacute; et configur&eacute; 
  une machine OpenBSD avec deux cartes r&eacute;seaux (une connect&eacute;e &agrave; 
  Internet et l'autre connect&eacute;e au r&eacute;seau local). </p>
<p><br>
  <a name="nat1.3"></a> <b>Configuration</b> </p>
<p>A des fins d'exemple, nous allons utiliser le syst&egrave;me d&eacute;crit 
  ci-apr&egrave;s. Votre configuration est tr&egrave;s probablement diff&eacute;rente, 
  alors soyez prudent quand vous reprenez cet exemple.</p>
<ul>
  <b>Interfaces r&eacute;seaux : </b> 
  <ul>
    Intel EtherExpress Pro/100 <b>fxp0</b><br>
    Connect&eacute;e au LAN (ou WAN) EXTERNE<br>
    <b>Adresse IP : </b>24.5.0.5<br>
    <b>Masque de sous-r&eacute;seau : </b>255.255.255.0<br>
    <br>
    Compaq Netelligent 10/100Mb <b>tl0</b><br>
    Connect&eacute;e au LAN INTERNE<br>
    <b>Adresse IP : </b>192.168.1.1<br>
    <b>Masque de sous-r&eacute;seau : </b>255.255.255.0<br>
  </ul>
  <br>
  <b>Adresse IP externe, routable sur Internet (fournie par le FAI, un fournisseur 
  d'acc&egrave;s c&acirc;ble dans ce cas)<br>
  </b> 
  <ul>
    <b>Adresse IP : </b>24.5.0.5<br>
    <b>Masque de sous-r&eacute;seau : </b>255.255.255.0<br>
    <b>Passerelle : </b>24.5.0.1<br>
  </ul>
  <br>
  <b>R&eacute;seau local</b><br>
  <ul>
    <p>Dans cet environnement donn&eacute; en exemple, les machines sur le r&eacute;seau 
      interne utilisent 192.168.1.xxx (o&ugrave; xxx est un nombre unique) comme 
      plan d'adressage. Il peut y avoir une vari&eacute;t&eacute; de syst&egrave;mes 
      d'exploitation sur le r&eacute;seau interne, tel que Windows 98, Windows 
      NT, OpenBSD et Linux, mais le syst&egrave;me d'exploitation de la machine 
      cliente n'est pas un souci pour la traduction d'adresses. Pour les exemples, 
      le client auquel nous nous int&eacute;resserons a 192.168.1.40 comme adresse 
      IP. </p>
  </ul>
  <br>
  <b>Diagramme de Configuration</b> 
  <ul>
    <pre>
+-----+              +---------+          +----------+
| Hub |--------- tl0 |   NAT   | fxp0 ----| Internet |
+-----+              +---------+          +----------+
| |
| +-- Client A
+---- More clients 

		      +--------------------------+
		      |          LEGEND          |
		      +--------------------------+
		      |  NIC fxp0 - 24.5.0.5     |
		      |  NIC tl0  - 192.168.1.1  |
		      | Client A  - 192.168.1.40 |
		      +--------------------------+

</pre>
  </ul>
</ul>

<br>
<a name="nat2.0"></a>
<h3><u>6.3.2 Traduction d'adresses</u></h3>
<br>
<a name="nat2.1"></a> <b>Introduction &agrave; la traduction d'adresses</b>
<p>Chaque noeud sur Internet requiert une adresse IP unique. Avec IPv4, il y a 
  un nombre fini et r&eacute;duit d'adresses IP distinctes disponibles, et par 
 cons&eacute;quent, ces adresses ne sont pas gratuites. La plupart des FAIs 
 &agrave; 
  faible co&ucirc;t limitent un site &agrave; un nombre d'adresses entre 1 et 
  30, et alors que de grandes organisations peuvent avoir les moyens pour se permettre 
  un large bloc d'adresses, dans la plupart des cas, il y a quelques b&eacute;n&eacute;fices 
  relatifs et des risques consid&eacute;rables &agrave; avoir chaque ordinateur 
  adressable individuellement sur Internet.</p>
<p>La traduction d'adresses, ou NAT (Network Address Translation), (connu aussi 
  sous le nom de &quot;IP Masquerading&quot; si vous avez une exp&eacute;rience 
  Linux) permet de mettre plusieurs ordinateurs &quot;derri&egrave;re&quot; une 
  seule (ou un petit nombre) adresse IP. Chaque ordinateur &quot;interne&quot; 
  a une adresse IP attribu&eacute;e localement et non enregistr&eacute;e (d'apr&egrave;s 
  la <a href="http://www.geektools.com/rfc/rfc1918.txt">RFC 1918</a>), et tous 
  utilisent la m&ecirc;me adresse IP externe, simultan&eacute;ment. </p>
<p> La NAT fonctionne de mani&egrave;re plut&ocirc;t simple. Quand un client sur 
  le LAN veut se connecter sur une machine sur Internet, il envoie un paquet TCP 
  avec une requ&ecirc;te de connexion. L'en-t&ecirc;te TCP contient l'adresse 
  IP du client (192.168.1.40 par exemple) et l'adresse IP du h&ocirc;te distant 
  (123.45.67.89 par exemple). La machine effectuant la NAT intercepte ce paquet 
  TCP et change l'adresse IP du client 192.168.1.40 avec l'adresse IP de la machine 
  connect&eacute;e sur Internet (24.5.0.5 par exemple). Ceci va faire croire &agrave; 
  la machine distante que la connexion vient de la machine de NAT, et non pas 
  de la machine cliente. La machine distante renvoie alors les r&eacute;ponses 
  &agrave; la machine de NAT comme si c'&eacute;tait cette derni&egrave;re qui 
  se connecte. Quand la machine de NAT re&ccedil;oit les r&eacute;ponses, elle 
  change rapidement l'adresse IP destination (la sienne) avec l'adresse IP du 
  client puis les envoie au client. Le client normalement n'a pas d'id&eacute;e 
  sur ce qui se passe et la connectivit&eacute; Internet est transparente pour 
  l'utilisateur et ses applications.</p>
<p> L'exemple ci-dessous montre la NAT un peu plus clairement : </p>

<ul>
  <pre>
Client ----------------- tl0 [ NAT ] fxp0 ---------- Hôte distant
192.168.1.40 --- 192.168.1.1 [ NAT ] 24.5.0.5 --- 123.45.67.89

Paquet TCP SORTANT                     	Paquet TCP SORTANT
De: 192.168.1.40    &gt;&gt;=== NAT ===&gt;&gt;     Vers: 24.5.0.5
De: 123.45.67.89                        Vers: 123.45.67.89

Paquet TCP ENTRANT                      Paquet TCP ENTRANT
De: 123.45.67.89 			De: 123.45.67.89
Vers: 192.168.1.40  &lt;&lt;=== NAT ===&lt;&lt;     Vers: 24.5.0.5
</pre>
</ul>

<br>
<a name="nat2.2"></a> <b>Pourquoi utiliser la NAT?</b> 
<p>Quand j'ai r&eacute;alis&eacute; que j'avais la possibilit&eacute; d'avoir 
  un modem c&acirc;ble dans mon nouvel appartement, j'ai aussi r&eacute;alis&eacute; 
  que j'avais un petit probl&egrave;me. Comment fournir un acc&egrave;s Internet 
  &agrave; mes colocataires vu que le modem c&acirc;ble est dans ma chambre ? 
  Quelques options s'offraient &agrave; moi comme l'obtention d'adresses IP suppl&eacute;mentaires, 
  la mise en place d'un serveur proxy, ou la mise en place de la NAT. (L'exemple
du c&acirc;ble modem domestique ne doit pas vous tromper. La NAT est assez 
  puissante pour masquer un grand r&eacute;seau avec des centaines voire des milliers 
  d'ordinateurs !)</p>
<p>Il y a plusieurs raisons pour lesquelles j'ai choisi la NAT. La raison num&eacute;ro 
  1 est l'&eacute;conomie d'argent. J'ai deux colocataires, et partager les co&ucirc;ts 
  est certainement attractif. De plus, chaque colocataire a son propre PC et j'en 
  ai moi-m&ecirc;me trois, ce qui fait cinq ordinateurs &agrave; connecter, mais 
  mon FAI autorise seulement trois adresses IP par domicile. Cela signifie 
  qu'il n'y avait pas assez d'adresses IP pour permettre &agrave; chaque 
  machine d'avoir un acc&egrave;s direct &agrave; Internet en simultan&eacute;. </p>
<p>En utilisant la NAT, chaque machine aura une adresse IP interne unique mais 
  partagera avec les autres la seule adresse IP fournie par mon FAI. Le co&ucirc;t 
  chute. </p>

<p> <a name="nat2.4"></a> <b>Mise en place</b></p>

<p>Pour activer la NAT sur votre machine OpenBSD, vous aurez besoin d'activer 
  PF. Ceci peut &ecirc;tre facilement réalisé en &eacute;ditant les fichiers 
  list&eacute;s ci-apr&egrave;s (effectuez les changements dans le fichier pour 
  qu'il ressemble &agrave; l'exemple ci-apr&egrave;s) : </p>
<p><b>/etc/rc.conf</b> (ce fichier est utilis&eacute; pour lancer les services 
  au d&eacute;marrage) </p>

<ul>
  <pre>
pf=YES</pre>
</ul>

<p>
<b>/etc/sysctl.conf</b>
</p>

<ul><pre>
net.inet.ip.forwarding=1
</pre></ul>

<p>Apr&egrave;s que ces changements aient &eacute;t&eacute; effectu&eacute;s, 
  la machine est maintenant pr&ecirc;te pour la configuration de la NAT.</p>
<p><a name="nat2.5"></a> <b>Configuration</b> </p>

<p>La premi&egrave;re &eacute;tape consiste &agrave; configurer le fichier de 
  configuration de PF (<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pf.conf&sektion=5">/etc/pf.conf</a></i>). 
  Dans la suite de ce chapitre, nous allons autoriser le trafic &agrave; traverser 
  le pare-feu sans aucune interf&eacute;rence. Le fichier devrait ressembler
  &agrave; : </p>
<ul><pre>
pass in all
pass out all
</pre></ul>

<p>Encore une fois, vous pouvez lire <a href="#PF">FAQ 6, Packet Filter</a> pour 
  plus d'informations</p>
<p>Le fichier de configuration de la NAT (<i><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nat.conf&sektion=5">/etc/nat.conf</a></i>) 
  a une syntaxe tr&egrave;s simple. Pour la configuration d&eacute;crite plus 
  haut, le fichier devrait contenir la ligne suivante : </p>

<ul><pre>
nat on fxp0 from 192.168.1.0/24 to any -&gt; 24.5.0.5
</pre></ul>

<p> Voici une explication de cette ligne. </p>

<ul>
  <strong>"nat"</strong> 
  <p>Ceci indique que la commande que vous donnez est une r&egrave;gle de NAT.</p>
  <p><strong>"fxp0"</strong> </p>
</ul>
<ul>
  <p>Ceci est l'interface r&eacute;seau qui est connect&eacute;e &agrave; Internet.</p>
</ul>

<ul>
  <b>"192.168.1.0/24"</b> 
  <p>l'adresse IP et le masque sous-r&eacute;seau (au format CIDR). Combin&eacute;s, 
    ils d&eacute;clarent que &quot;n'importe quelle adresse IP comprise entre 
    192.168.1.1 et 192.168.1.254 inclus&quot; doit faire l'objet d'une correspondance.</p>
</ul>

<ul>
  <b>"24.5.0.5"</b> 
  <p> C'est l'adresse IP externe utilis&eacute;e pour la translation des adresses 
    IP internes. </p>
</ul>

<a name="nat2.6"></a> <b>Ex&eacute;cution</b> 
<p>Une fois la configuration termin&eacute;e, il y a deux mani&egrave;res 
  d'activer la NAT. La premi&egrave;re (et meilleure si possible) est de red&eacute;marrer 
  votre machine OpenBSD. Ceci est accompli &agrave; l'aide de la commande &quot;<i>reboot</i>&quot;. 
</p>
<p>Si vous voulez configurer la NAT &agrave; partir de la ligne de commande, utilisez 
  les commandes suivantes : </p>

<ul><pre>
# <b>pfctl -N /etc/nat.conf</b>
# <b>pfctl -e</b>
</pre></ul>

<p>La premi&egrave;re ligne sert &agrave; charger les r&egrave;gles de NAT dans 
  PF (et &agrave; purger les anciennes r&egrave;gles), la ligne suivante active 
  PF. Cependant, red&eacute;marrer est le meilleur moyen pour s'assurer que tout 
  va &ecirc;tre lanc&eacute; comme pr&eacute;vu au red&eacute;marrage.</p>
<p><b>Remarque : </b>afin de recharger les r&egrave;gles de NAT (au cas 
o&ugrave; vous auriez &eacute;dit&eacute; le fichier mais vous ne voulez pas 
red&eacute;marrer), 
  ex&eacute;cutez juste la premi&egrave;re commande encore une fois. La configuration 
  sera purg&eacute;e et recharg&eacute;e.</p>


<h3><u><a name="nat3.0"></a>6.3.3 Base de connaissances NAT</u></h3>

<a name="nat3.1"></a> <b>V&eacute;rification de l'&eacute;tat de la NAT</b> 
<p>Pour conna&icirc;tre l'&eacute;tat de la NAT ou &ecirc;tre s&ucirc;r que votre 
  configuration a &eacute;t&eacute; prise en compte, utilisez l'option &quot;-ss&quot;. 
  Cette option va lister toutes les sessions de NAT en cours : </p>
<ul><pre>
# pfctl -ss
TCP  192.168.1.40:2132 -&gt; 24.5.0.5:53136 -&gt; 65.42.33.245:22       TIME_WAIT:TIME_WAIT
TCP  192.168.1.40:2492 -&gt; 24.5.0.5:55011 -&gt; 65.42.33.245:22       ESTABLISHED:ESTABLISHED
UDP  192.168.1.40:2491 -&gt; 24.5.0.5:60527 -&gt; 24.2.68.33:53       2:1
</pre></ul>

<p> Explications (de la premi&egrave;re ligne, les autres &eacute;tant similaires) : 
</p>
<ul>
  <b>"192.168.1.40:2132"</b> 
  <p>Ceci vous donne l'adresse IP de la machine du LAN qui utilise la NAT (192.168.1.40). 
    Le num&eacute;ro de port utilis&eacute; pour faire la connexion (2132) est 
    affich&eacute; juste apr&egrave;s.</p>
</ul>
<ul>
  <b>"24.5.0.5:53136"</b> 
  <p> Ceci montre que la connexion va vers Internet &agrave; travers l'adresse 
    IP 24.5.0.5 et le port 53136.</p>
</ul>
<ul>
  <b>"65.42.33.245:22"</b> 
  <p>L'adresse IP et le port auxquels le client se connecte.</p>
</ul>
<ul>
  <b>"TIME_WAIT:TIME_WAIT"</b> 
  <p> Ceci indique l'&eacute;tat dans lequel la connexion TCP se trouve d'apr&egrave;s 
    PF. </p>
</ul>

<a name="nat3.2"></a> <b> Probl&egrave;mes avec le FTP et la NAT</b> 
<p>Il y a quelques limitations &agrave; la NAT, la plus commun&eacute;ment rencontr&eacute;e 
  &eacute;tant avec FTP. Vous pouvez utiliser FTP de deux fa&ccedil;ons : passive 
  et active. De ces deux fa&ccedil;ons, le FTP passif est consid&eacute;r&eacute; 
  comme &eacute;tant plus s&eacute;curis&eacute;.</p>
<p>Avec le FTP actif, quand un utilisateur se connecte &agrave; un serveur FTP 
  distant et demande une information ou un fichier, le client FTP envoie au serveur 
  un num&eacute;ro de port al&eacute;atoire sur lequel le serveur va se connecter 
  au client et transf&eacute;rer l'information. Ceci est un probl&egrave;me pour 
  les utilisateurs tentant d'acc&eacute;der &agrave; des serveurs FTP &agrave; 
  partir de leur r&eacute;seau interne. Quand le serveur FTP envoie l'information, 
  il l'envoie &agrave; l'adresse externe (celle de la machine de NAT) sur un port 
  al&eacute;atoire. Quand la machine de NAT recevra ce paquet, et parce qu'elle 
  n'a aucune correspondance pour ce paquet inconnu et aucune correspondance pour 
  ce port, elle bloquera le paquet et ne le livrera pas. </p>
<p> Avec le mode FTP passif (s&eacute;lectionn&eacute; par d&eacute;faut par le 
  client <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftp&sektion=1">ftp(1)</a> de 
  OpenBSD), le client &eacute;met une requ&ecirc;te au serveur pour que ce dernier 
  choisisse un port al&eacute;atoire sur lequel il sera en attente d'une connexion 
  de donn&eacute;es. Le serveur informe le client du port qu'il a choisi, et ce 
  dernier se connecte &agrave; ce port pour transf&eacute;rer les donn&eacute;es. 
  Malheureusement, ceci n'est pas toujours possible ou souhaitable. ftp(1) utilise 
  ce mode par d&eacute;faut; pour forcer le mode FTP actif, utilisez le drapeau 
  -A de ftp, ou d&eacute;sactivez le mode passif en saisissant la commande suivante : </p>
<dl><dt>
<pre>passive off
</pre>
</dt></dl>
Au prompt ftp&gt;. 
<p></p>
<P>PacketFilter fournit une autre solution &agrave; cette situation : la redirection 
  du trafic FTP &agrave; travers un serveur proxy FTP, un programme qui agit pour 
  &quot;guider&quot; votre trafic FTP &agrave; travers les filtres. Le proxy FTP 
  utilis&eacute; par OpenBSD et PF est <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftp-proxy&sektion=8">ftp-proxy(8)</a>. 
  Pour l'activer, mettez quelque chose qui ressemble &agrave; la ligne suivante 
  dans votre fichier <i>/etc/nat.conf</i> :
<ul><pre>
rdr on tl0 from any to any port 21 -&gt; 127.0.0.1 port 8081
</pre></ul>
<p>Une explication concise de cette ligne est : &quot;le trafic sur l'interface 
  interne est redirig&eacute; vers le serveur proxy tournant sur cette machine 
  et &eacute;coutant sur le port 8081&quot;.</p>
<p>Si tout va bien, il est apparent que le serveur proxy a besoin d'&ecirc;tre 
  d&eacute;marr&eacute; sur la machine OpenBSD, ceci est effectu&eacute; en ins&eacute;rant 
  la ligne suivante dans <i>/etc/inetd.conf.</i></p>
<ul>
  <pre>127.0.0.1:8081 stream tcp nowait root /usr/libexec/ftp-proxy ftp-proxy
</pre>
</ul>
<p>puis il faut soit red&eacute;marrer le syst&egrave;me soit envoyer un signal 
  'HUP' &agrave; <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=inetd&sektion=8">inetd(8)</a>. 
  Une des mani&egrave;res d'envoyer le signal 'HUP' est : </p>
<ul><pre>
kill -HUP `cat /var/run/inetd.pid`
</pre></ul>
<p>vous noterez que le ftp-proxy est &agrave; l'&eacute;coute sur le port 8081, 
  le m&ecirc;me port que celui sur lequel la r&egrave;gle rdr envoie le trafic 
  FTP. Le choix du port 8081 est arbitraire, bien qu'il soit judicieux, vu qu'il 
  n'est utilis&eacute; par aucune autre application.</p>
<p><br>
  <a name="nat3.3"></a> <b>Redirection de trafic</b></p>
<p>Pour certaines applications, vous pourriez avoir besoin de rediriger le trafic 
  en entr&eacute;e ou en sortie pour un protocole donn&eacute; vers une machine 
  sp&eacute;cifique derri&egrave;re le syst&egrave;me de filtrage. Un exemple 
  d'un tel besoin serait une machine du r&eacute;seau interne faisant office de 
  serveur web devant &ecirc;tre acc&eacute;d&eacute; par le monde externe (ou 
  bien s&ucirc;r, le ftp-proxy(8) d&eacute;j&agrave; &eacute;voqu&eacute;). Les 
  connexions en entr&eacute;e vers votre adresse IP Internet valide ne pourront 
  s'effectuer, &agrave; moins que votre machine de NAT fasse également serveur 
  web. 
 Pour cel&agrave;, nous utilisons la directive 'rdr' de la NAT dans le fichier de r&egrave;gles 
  pour dire vers o&ugrave; rediriger une connexion particuli&egrave;re.</p>
<p>Pour notre exemple, supposons que le serveur web r&eacute;side sur le LAN avec 
  l'adresse IP 192.168.1.80. Le fichier de r&egrave;gles NAT n&eacute;cessite 
  une nouvelle directive pour g&eacute;rer &ccedil;a. Ajoutez une ligne similaire 
  &agrave; la ligne suivante dans <i>/etc/nat.conf</i> : </p>
<ul><pre>
rdr on fxp0 from any to any port 80 -&gt; 192.168.1.80 port 80
</pre></ul>

<p> L'explication pour chaque partie de cette ligne suit.</p>
<ul>
  <b>"rdr"</b> 
  <p>Ceci est la commande que vous donnez au syst&egrave;me de NAT. Elle informe 
    le syst&egrave;me de NAT que cette entr&eacute;e est une entr&eacute;e pour 
    rediriger une connexion.</p>
  <p><b>"on fxp0"</b> </p>
  <p>C'est l'interface r&eacute;seau qui est connect&eacute;e &agrave; Internet.</p>
</ul>
<ul>
  <p> <b>"from any to any"</b> </p>
  <p>Ceci indique quelles adresses IP doivent &ecirc;tre redirig&eacute;es (de 
    n'importe quelle adresse en entr&eacute;e sur fxp0, comme indiqu&eacute; pr&eacute;c&eacute;demment, 
    vers n'importe quelle adresse IP destination)</p>
</ul>
<ul>
  <p><b>"port 80"</b> </p>
</ul>
<ul>
  <p>C'est le port en entr&eacute;e (80) qui doit &ecirc;tre redirig&eacute;. 
    Le num&eacute;ro &quot;80&quot; n'est pas n&eacute;cessaire. On peut utiliser 
    aussi &quot;port www&quot; pour sp&eacute;cifier une redirection du port 80. 
    Si vous voulez utiliser un nom au lieu d'un num&eacute;ro, le nom de service 
    et le port correspondant doivent exister dans le fichier <i>/etc/services.</i></p>
</ul>
<ul>
  <b>"192.168.1.80 port 80"</b> 
  <p>L'adresse IP de la machine du LAN vers laquelle les paquets doivent &ecirc;tre 
    redirig&eacute;s. Notez que le port destination n'a PAS besoin de correspondre 
    au port en entr&eacute;e. Par exemple, la ligne suivante et valide, et 
    potentiellement utile : </p>
  <pre>
rdr on fxp0 from any to any port 8080 -&gt; 192.168.1.40 port 80
</pre>
  <p>Cette ligne redirigera le trafic en entr&eacute;e arrivant sur le port 8080 
    vers un serveur web tournant sur une machine du r&eacute;seau interne, sur 
    le port &quot;standard&quot; 80.</p>
  <p></p>
</ul>
<p>Quand la modification est finie, rechargez les r&egrave;gles de NAT, et la 
  redirection prendra effet imm&eacute;diatement. </p>
<p><b>N&eacute;gation</b> </p>
<p>Parfois, vous aurez besoin de faire des exceptions &agrave; une r&egrave;gle 
  de NAT ou de redirection. Voici un exemple. AOL Instant Messenger est connu 
  pour se faufiler furtivement &agrave; travers les firewalls en utilisant n'importe 
  quel port disponible. Vous trouverez peut-&ecirc;tre que le ftp-proxy interf&egrave;re 
  avec AIM quand ce dernier choisit de sortir &agrave; travers le port 21. Dans 
  le cas o&ugrave; vous consid&eacute;rez cela comme mauvais (beaucoup de gens 
  passent beaucoup de temps &agrave; essayer de bloquer AIM !), vous aurez besoin 
  d'exclure les adresses IP utilis&eacute;es par les serveurs AIM du trafic redirig&eacute; 
  par la ligne de redirection vers le ftp-proxy. Vous pouvez faire cela gr&acirc;ce 
  &agrave; la ligne suivante :
<ul><pre>
rdr on tl0 from any to ! 64.12.163.199 port 21 -&gt; 127.0.0.1 port 8081
</pre></ul>
Interpr&eacute;tation: Redirige le trafic en entr&eacute;e sur l'interface tl0 
&agrave; destination du port 21 et sauf vers 64.12.163.199 (le serveur AIM avec 
lequel les utilisateurs avaient des probl&egrave;mes) au port 8081 du h&ocirc;te 
local (sur lequel normalement ftp-proxy &eacute;coute). Maintenant, il faut &ecirc;tre 
conscient qu'il y a plusieurs serveurs AIM, et si cette application vous int&eacute;resse, 
vous aurez probablement &agrave; manipuler les adresses des serveurs AIM (64.12.0.0/16 
est potentiellement plus judicieux bien qu'il y aura probabflement des interf&eacute;rences 
avec des serveurs n'appartenant pas &agrave; AOL). 
<p></p>

<br>
<a name="nat3.4"></a> <b>NAT contre Proxy</b> 
<p>La diff&eacute;rence entre la NAT et un proxy applicatif r&eacute;side dans 
  le fait qu'un proxy agit comme un interm&eacute;diaire entre Internet et les 
  machines connect&eacute;es au LAN. C'est tr&egrave;s bien, cependant chaque 
  application que vous voudrez ex&eacute;cuter sur votre machine et qui devra 
  se connecter &agrave; Internet &agrave; travers le serveur proxy DEVRA savoir 
  comment utiliser un proxy. Toutes les applications ne savent pas faire &ccedil;a 
  (et sp&eacute;cialement les jeux). De plus, il n'y a pas des proxies applicatifs 
  pour tous les services Internet actuels. La NAT fait correspondre de mani&egrave;re 
  transparente votre r&eacute;seau interne &agrave; une adresse donn&eacute;e 
  pour qu'il puisse se connecter &agrave; Internet. Le seul avantage en termes 
  de s&eacute;curit&eacute; &agrave; utiliser un proxy par rapport &agrave; la 
  NAT est que le proxy peut poss&eacute;der des fonctionnalit&eacute;s de s&eacute;curit&eacute;, 
  et peut filtrer le trafic d'apr&egrave;s le contenu, pour prot&eacute;ger votre 
  machine Windows contre un virus macro, ou pour prot&eacute;ger votre logiciel 
  client contre les d&eacute;bordements de tampon...etc. La maintenance 
  de ce type de filtres est souvent lourde.</p>
<p>&nbsp;</p>
<p><a name="nat4.0"></a> <b>6.3.4 Liens et r&eacute;f&eacute;rences crois&eacute;es</b></p>

<p> Fichiers OpenBSD : 
<ul>
  <li>/etc/nat.conf - fichier de r&egrave;gles NAT
  <li>/etc/rc.conf - doit &ecirc;tre &eacute;dit&eacute; pour lancer la NAT et 
    PF au d&eacute;marrage 
  <li>etc/sysctl.conf - doit &ecirc;tre &eacute;dit&eacute; pour activer le routage 
    IP
</ul>
<p></p>

<p> Liens Internet &agrave; propos de la NAT : 
<ul>
  <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nat.conf&sektion=5">page 
    du manuel nat.conf</a>
  <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pfctl&sektion=8">page 
    du manuel pfctl</a>
  <li><a href="http://www.geektools.com/rfc/rfc1631.txt">http://www.geektools.com/rfc/rfc1631.txt</a>
</ul>
<p>

<br>

<p> 
<a name= "DHCP"></a>
<a name= "6.4"></a> 
<h2>6.4 - Protocole de Configuration Dynamique d'H&ocirc;te
    (DHCP)</h2>
<p></p>

<h3>6.4.1 Client DHCP</h3>
<p>Pour utiliser le client DHCP <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient&sektion=8">dhclient(8)</a> 
  inclus avec OpenBSD, &eacute;ditez /etc/hostname.xl0 (ceci suppose que votre 
  interface ethernet principale est xl0. La votre pourrait &ecirc;tre ep0 
  ou fxp0 ou quelque chose d'autre !) et tout ce que vous avez besoin d'y mettre 
  est le mot-cl&eacute; 'dhcp' 
<pre>
# <strong>echo dhcp &gt;/etc/hostname.xl0</strong>
</pre>
<p>Ceci fera en sorte que le client DHCP d&eacute;marre automatiquement au d&eacute;marrage. 
  OpenBSD va r&eacute;cup&eacute;rer son adresse IP, sa passerelle par d&eacute;faut, 
  et les serveurs DNS &agrave; partir du serveur DHCP.</p>
<p>Si vous voulez d&eacute;marrer le client dhcp &agrave; partir de la ligne de 
  commande, assurez vous que le fichier /etc/dhclient.conf existe puis essayez : </p>
<PRE>
# <strong>dhclient fxp0</strong>
</pre>
<p>o&ugrave; fxp0 est l'interface sur laquelle vous voulez recevoir les informations 
  par dhcp.</p>
<p>Peu importe comment vous d&eacute;marrez dhclient, vous pouvez &eacute;diter 
  le fichier /etc/dhclient.conf pour ne pas mettre &agrave; jour les informations 
  DNS d'apr&egrave;s les informations fournies par le serveur dhcp en d&eacute;commentant 
  d'abord les lignes 'request' (ce sont des exemples de param&eacute;trages par 
  d&eacute;faut, mais vous devez les d&eacute;commenter pour privil&eacute;gier 
  vos param&egrave;tres par rapport aux param&egrave;tres par d&eacute;faut de 
  dhclient). </p>
<pre>
request subnet-mask, broadcast-address, time-offset, routers,
      domain-name, domain-name-servers, host-name, lpr-servers, ntp-servers;
</pre>
<p>puis <b>supprimer</b> domain-name-servers. Bien &eacute;videmment, vous pourriez 
  supprimer le hostname, ou d'autres param&egrave;tres aussi.</p>
<P>
<h3>6.4.2 Serveur DHCP</h3>

<p>Si vous voulez utiliser OpenBSD comme serveur DHCP <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd&sektion=8">dhcpd(8)</a>
,   &eacute;ditez /etc/rc.conf. Modifiez ce fichier de telle fa&ccedil;on
&agrave;   ce qu'il contienne dhcpd_flags="-q" au lieu de dhcpd_flags=NO. Mettez
les interfaces   sur lesquelles vous voulez que dhcpd <b>&eacute;coute</b> dans
/etc/dhcpd.interfaces.</p> 
<pre> # <strong>echo xl1 xl2 xl3 &gt;/etc/dhcpd.interfaces</strong> </pre>
<p>Puis &eacute;ditez /etc/dhcpd.conf. Les options sont plut&ocirc;t explicites.</p>
<pre>
        option  domain-name "xyz.mil";
        option  domain-name-servers 192.168.1.3, 192.168.1.5;

        subnet 192.168.1.0 netmask 255.255.255.0 {
                option routers 192.168.1.1;

                range 192.168.1.32 192.168.1.127;
        }
</pre>
<p> Ceci indiquera à vos clients dhcp de rajouter le domaine xyz.mil aux requ&ecirc;tes 
  DNS (ainsi, si l'utilisateur saisit la commande 'telnet joe' alors il sera dirigé 
  vers joe.xyz.mil). De plus, les clients dhcp seront dirigés vers les serveurs 
  DNS 192.168.1.3 et 192.168.1.5. Pour les h&ocirc;tes se trouvant sur le m&ecirc;me 
  r&eacute;seau qu'une interface ethernet de la machine OpenBSD, qui est dans 
  la plage d'adresses 192.168.1.0/24, une adresse IP entre 192.168.1.32 et 192.168.1.127 
  leur sera affect&eacute;e. </p>
<p>Si voulez d&eacute;marrer dhcpd à partir de la ligne de commande, apr&egrave;s 
  avoir &eacute;dit&eacute; /etc/dhcpd.conf, essayez : 
<PRE>
# <strong>dhcpd -q fxp0</strong> </PRE>
o&ugrave; fxp0 est une interface sur laquelle vous voulez que le serveur dhcp 
r&eacute;ponde aux requ&ecirc;tes. Le drapeau -q rend dhcpd silencieux, autrement 
il est tr&egrave;s bavard. 
<P> Si vous fournissez un service DHCP &agrave; une machine Windows, vous voudriez 
  peut-&ecirc;tre que dhcpd donne une adresse d'un serveur 'WINS' au client. Pour 
  cela, rajoutez la ligne suivante dans /etc/dhcpd.conf :
<pre> option netbios-name-servers
192.168.92.55; </pre>
(o&ugrave; 192.168.92.55 est l'adresse IP du serveur Windows ou Samba.) Voir <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcp-options&sektion=5">dhcp- 
options(5)</a> pour d'autres options dont pourraient avoir besoin vos clients 
DHCP. 
<p> <a name= "PPP"></a> <a
name= "6.5"></a> 
<h2>6.5 - Protocole Point &agrave; Point</h2>
<p>Le Protocole Point &agrave; Point (PPP) est le protocole g&eacute;n&eacute;ralement 
  utilis&eacute; pour cr&eacute;er une connexion &agrave; votre FAI via votre 
  modem. OpenBSD a deux mani&egrave;res de faire ceci.</p>

<ul>
  <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppd&sektion=8">pppd(8)</a> 
    - Qui est le d&eacute;mon ppp du noyau.
  <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&sektion=8">ppp(8)</a> 
    - Qui est le d&eacute;mon ppp en mode utilisateur. 
</ul>

<p>Le premier que nous allons couvrir est le d&eacute;mon ppp en mode
  utilisateur. Pour commencer, vous aurez besoin de quelques informations 
  simples 
  &agrave; propos de votre FAI. Voici une liste des informations utiles dont 
  vous aurez besoin : </p>
<ul>
  <li>Le num&eacute;ro d'appel de votre FAI
  <li>Votre serveur de noms 
  <li>Votre nom d'utilisateur et votre mot de passe
  <li>Votre passerelle
</ul>

<p>Quelques unes de ces informations sont optionnelles, mais sont utiles lors 
  de la configuration de votre ppp. Le d&eacute;mon ppp en mode
  utilisateur utilise le fichier <a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.conf.sample">/etc/ppp/ppp.conf</a> 
  comme fichier de configuration. Il y a beaucoup de fichiers utiles dans <b>/etc/ppp 
  </b> contenant des configurations diverses et vari&eacute;es pour plusieurs 
  types de situations. Vous devriez naviguer dans ce r&eacute;pertoire.</p>
<p>Vous devrez aussi vous assurez, si vous n'utilisez pas le noyau GENERIC, que 
  vous avez la ligne suivante dans votre fichier de configuration du noyau : </p>

<ul><pre><strong>
pseudo-device   tun             2
</strong></pre></ul>


<h3>Mise en place initiale - pour PPP(8)</h3>
<p>La mise en place initiale pour le d&eacute;mon PPP en mode utilisateur 
  consiste &agrave; &eacute;diter le fichier <b>/etc/ppp/ppp.conf</b>. Ce fichier 
  n'existe pas par d&eacute;faut, mais il y a un fichier <b>/etc/ppp/ppp.conf.sample</b> 
  que vous pouvez &eacute;diter pour cr&eacute;er votre propre fichier <b>/etc/ppp/ppp.conf</b>. 
  Je vais commencer ici par la configuration la plus simpliste et probablement 
  la plus utilis&eacute;e. Voici un fichier <b>ppp.conf</b> qui va cr&eacute;er 
  une connexion vers votre FAI et configurer votre route par d&eacute;faut et 
  votre serveur de noms. Avec ce fichier, les seules informations dont vous 
  aurez besoin sont votre num&eacute;ro de t&eacute;l&eacute;phone FAI, votre 
  nom d'utilisateur et votre mot de passe. </p>
<ul>
<pre>
default:
set log Phase Chat LCP IPCP CCP tun command     
set device /dev/cua01                           
set speed 115200     
set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \"\" AT OK-AT-OK ATE1Q0 OK\\dATDT\\T TIMEOUT 40 CONNECT"
</pre>
</ul>

<p>La section en dessous de la balise <b>default:</b> sera ex&eacute;cut&eacute;e 
  &agrave; chaque fois. Ici, nous param&eacute;trons toutes nos informations critiques. 
  Avec &quot;set log&quot;, nous param&eacute;trons nos niveaux de journalisation. 
  Ceci peut &ecirc;tre modifi&eacute;, r&eacute;f&eacute;rez vous &agrave; <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&sektion=8">ppp(8)</a> 
  pour plus d'informations concernant le param&eacute;trage des niveaux de logs. 
  Notre p&eacute;riph&eacute;rique est configur&eacute; avec &quot;set device&quot;. 
  C'est le port sur lequel le modem est connect&eacute;. Dans cet exemple, le 
  modem est sur le port s&eacute;rie 2. Le port s&eacute;rie 1 est donc /dev/cua00. 
  Avec &quot;set speed&quot;, nous param&eacute;trons la vitesse de notre connexion 
  modem et avec &quot;set dial&quot; nous configurons nos param&egrave;tres d'appel. 
  Nous pouvons aussi param&eacute;trer une p&eacute;riode d'inactivit&eacute; 
  au bout de laquelle nous serons d&eacute;connect&eacute;s, etc. Cependant, cette 
  ligne devrait rester pratiquement telle quelle.</p>
<p> Maintenant, nous pouvons avancer et param&eacute;trer les informations sp&eacute;cifiques 
  &agrave; notre FAI. Nous faisons ceci en ajoutant une nouvelle balise en dessous 
  de la section <b>default:</b>. Cette balise peut prendre n'importe quel nom, 
  le plus facile &eacute;tant le nom de votre FAI. Ici j'utiliserais <b>monfai:</b> 
  comme balise faisant r&eacute;f&eacute;rence &agrave; notre FAI. Voici une configuration 
  simple qui inclus tout le n&eacute;cessaire pour nous connecter : </p>

<p>

<ul>
<pre>
monfai:
set phone 1234567   
set login "ABORT NO\\sCARRIER TIMEOUT 5 ogin:--ogin: ppp word: ppp"
set timeout 120   
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
add default HISADDR 
enable dns
</pre>
</ul>

<p>Ici, nous avons configur&eacute; l'information essentielle pour ce FAI. La premi&egrave;re 
  option &quot;set phone&quot; param&egrave;tre le num&eacute;ro d'appel de votre 
  FAI. &quot;set login&quot; configure nos options d'authentification. La minuterie 
  de connexion est positionn&eacute;e &agrave; 5. Ceci veut dire que nous allons 
  abandonner notre tentative de connexion apr&egrave;s 5 secondes s'il n'y a pas 
  de porteuse. Autrement, l'application attendra de recevoir un &quot;login:&quot; 
  et r&eacute;pondra par votre nom d'utilisateur et votre mot de passe. Dans cet 
  exemple, notre nom d'utilisateur = ppp et notre mot de passe = ppp. Ces valeurs 
  devront &ecirc;tre modifi&eacute;es. La ligne &quot;set timeout&quot; positionne 
  la p&eacute;riode d'inactivit&eacute; pour la dur&eacute;e de la connexion &agrave; 
  120 secondes. La ligne &quot;set ifaddr&quot; est un peu difficile &agrave; 
  comprendre. Voici une explication plus d&eacute;taill&eacute;e. </p>
<ul><pre>
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
</pre></ul>

<p>Dans la ligne pr&eacute;c&eacute;dente, nous avons adopt&eacute; le format 
  &quot;<b>set ifaddr [myaddr[/nn] [hisaddr[/nn] [netmask [triggeraddr]]]]</b>&quot;. 
  La premi&egrave;re adresse IP sp&eacute;cifi&eacute;e est l'adresse IP que nous 
  voulons. Si vous avez une adresse IP statique, vous la fixez ici. Dans notre 
  exemple nous utilisons /0 qui dit qu'aucun des octets de cette adresse IP ne 
  doit correspondre &agrave; son &eacute;quivalent dans l'adresse IP choisie, 
  donc toute l'adresse IP peut &ecirc;tre remplac&eacute;e. La seconde adresse 
  IP sp&eacute;cifi&eacute;e est ce &agrave; quoi nous nous attendons comme
  adresse IP de leur part. Si vous la connaissez, vous pouvez la 
  sp&eacute;cifier. Encore 
  une fois, dans notre ligne nous ne savons pas ce qui sera attribu&eacute;, alors 
  nous les laissons nous le dire. La troisi&egrave;me option est notre masque 
  de sous-r&eacute;seau, ici positionn&eacute; &agrave; 255.255.255.0. Si triggeraddr 
  est sp&eacute;cifi&eacute;, il est utilis&eacute; au lieu de myaddr dans la 
  n&eacute;gociation 
  IPCP initiale. Cependant, seulement une adresse dans la plage de myaddr sera 
  accept&eacute;e. C'est utile lors de la n&eacute;gociations avec quelques 
  impl&eacute;mentations 
  PPP qui n'attribueront aucune adresse IP &agrave; moins que l'autre partie demande 
  &quot;0.0.0.0&quot;. </p>
<p>L'autre option utilis&eacute;e est &quot;add default HISADDR&quot;. Celle-ci 
  configure notre route par d&eacute;faut pour pointer sur leur adresse IP. 
  Cette option est 'persistante', dans le sens o&ugrave; si leur adresse IP 
  change, notre route sera automatiquement 
  mise &agrave; jour. Avec &quot;enable dns&quot;, nous disons &agrave; notre 
  FAI d'authentifier nos adresses de serveur de noms. NE faites pas &ccedil;a 
  si vous avez un DNS local, vu que ppp va simplement le contourner en mettant 
  quelques lignes 'nameserver' dans /etc/resolv.conf.</p>

<h3>Utilisation de PPP(8)</h3>

<p>Maintenant que nous avons configur&eacute; notre fichier <b>ppp.conf</b>,
nous pouvons commencer &agrave; essayer de se connecter &agrave; notre FAI. Je 
vais d&eacute;tailler quelques arguments commun&eacute;ment utilis&eacute;s 
avec ppp. </p>
<ul>
  <li><b>ppp -auto myisp</b> - Ceci va ex&eacute;cuter ppp, configurer vos interfaces 
    et vous connecter &agrave; votre FAI puis mettra le programme en arri&egrave;re 
    plan. 
  <li><b>ppp -ddial myisp</b> - Ceci est similaire &agrave; -auto, mais si votre 
    connexion tombe, ppp tentera de vous reconnecter.
</ul>
<p>En utilisant <b>/usr/sbin/ppp</b> sans options, vous serez en mode interactif. 
  A partir de l&agrave;, vous pouvez interagir directement avec votre modem, ce 
  qui est tr&egrave;s bien pour d&eacute;boguer votre fichier <b>ppp.conf</b>. 
</p>
<h3>extras ppp(8) </h3>
<p>Dans certaines situations, vous voudriez ex&eacute;cuter des commandes lorsque 
  votre connexion est &eacute;tablie ou rompue. Il y a deux fichiers que vous 
  pouvez cr&eacute;er pour ce genre de situations : <b>/etc/ppp/ppp.linkup</b> 
  et <b>/etc/ppp/ppp.linkdown</b>. Des configurations typiques peuvent &ecirc;tre 
  consult&eacute;es ici : </p>
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkup.sample">ppp.linkup</a>
<li><a href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkdown.sample">ppp.linkdown</a>
</ul>

<p>Vous pourrez trouver de plus amples informations dans <a href="http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/userppp.html">la 
  section User PPP du guide FreeBSD</a>. </p>
<p>&nbsp;</p>

<p>
<a name= "Tuning"></a>
<a name= "6.6"></a>
<h2>6.6 - Optimisation des param&egrave;tres r&eacute;seau</h2>

<H3>6.6.1 - Comment puis-je param&eacute;trer mon noyau pour avoir un nombre plus 
  important de tentatives et des timeouts plus longs sur les sessions TCP ?</h3>
<p>Vous utiliseriez normalement ceci pour r&eacute;gler des probl&egrave;mes de 
  routage ou de connexion. Bien &eacute;videmment, pour un maximum d'efficacit&eacute;, 
  les deux c&ocirc;t&eacute;s de la connexion doivent utiliser des valeurs similaires.</p>
<p>Pour param&eacute;trer cela, utilisez <tt>sysctl</tt> et augmentez les 
  valeurs de : </p>
<pre>
net.inet.tcp.keepinittime
net.inet.tcp.keepidle
net.inet.tcp.keepintvl
</pre>
<p>En utilisant sysctl -a, vous pouvez voir la valeur actuelle de ces param&egrave;tres 
  et celle d'autres param&egrave;tres. Pour modifier une valeur, utilisez <tt>sysctl 
  -w</tt>, comme dans <tt>sysctl -w net.inet.tcp.keepidle=28800</tt>. </p>
<h3>6.6.2 - Comment puis-je activer les broadcasts dirigés ? </h3>
<p>Normalement, vous ne devrez pas faire &ccedil;a. Ceci autorise quelqu'un &agrave; 
  envoyer du trafic vers des adresses broadcast de votre/vos r&eacute;seau(x) 
  connect&eacute;s si vous utilisez OpenBSD comme routeur.</p>
Il y a quelques cas, dans des r&eacute;seaux ferm&eacute;s, o&ugrave; &ccedil;a 
pourrait &ecirc;tre utile, particuli&egrave;rement quand vous utilisez d'anciennes 
impl&eacute;mentations du protocole NetBIOS. L'activation se fait par sysctl : 
<tt>sysctl -w net.inet.ip.directed-broadcast=1</tt>. Documentez vous sur les <a href="http://www.netscan.org">attaques 
smurf </a> si vous voulez savoir pourquoi cette option est désactivée par défaut. 
<H3>6.6.3 - Je ne souhaite pas que mon noyau alloue dynamiquement un port donn&eacute;</h3>
<p>Il y a aussi un sysctl pour cela. Traduction d'une partie de <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&sektion=8">sysctl(8)</a> : </p>
<PRE>
Param&eacute;tre la liste des ports TCP r&eacute;serv&eacute;s qui ne 
doivent pas &ecirc;tre allou&eacute;s dynamiquement par le noyau. 
Ceci peut être utilisé pour empêcher les démons de prendre 
un port spécifié qu'un autre programme utilise pour 
son fonctionnement. Les éléments de la liste peuvent être
séparés par des virgules et/ou des espaces.

   sysctl -w net.inet.tcp.baddynamic=749,750,751,760,761,871

Il est aussi possible d'ajouter ou de supprimer des ports 
de la liste courante. 

   sysctl -w net.inet.tcp.baddynamic=+748
   sysctl -w net.inet.tcp.baddynamic=-871
</pre>

<p>
<a name= "NFS"></a>
<a name="6.7"></a>
<h2>6.7 - Utilisation de NFS</h2>
<p></p>
<p></p>
<p></p>
<p></p>
<p>NFS, ou Network File System, est utilis&eacute; pour partager un syst&egrave;me 
  de fichiers &agrave; travers le r&eacute;seau. Les quelques pages de manuel 
  &agrave; lire avant d'essayer de configurer NFS sont : </p>
<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nfsd&sektion=8">nfsd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mountd&sektion=8">mountd(8)</a>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&sektion=5">exports(5)</a>
</ul>

<p>Cette section va vous guider &agrave; travers les &eacute;tapes n&eacute;cessaires 
  pour configurer NFS de mani&egrave;re simple. Cet exemple concerne un serveur 
  sur un LAN, avec des clients acc&eacute;dant &agrave; NFS sur le LAN. Nous n'allons 
  pas aborder la s&eacute;curisation de NFS. Nous supposerons que vous avez 
  d&eacute;j&agrave; configur&eacute; le filtrage de paquets ou une autre protection 
  de type pare-feu, pour vous pr&eacute;munir contre les acc&egrave;s externes. 
  Si vous autorisez les r&eacute;seaux externes &agrave; acc&eacute;der &agrave; 
  votre serveur NFS, et vous avez des informations sensibles stock&eacute;es dessus, 
  nous vous recommandons fortement d'utiliser <a href="../faq13.html">IPsec</a>. 
  Autrement, n'importe qui pourra potentiellement voir votre trafic NFS. Quelqu'un 
  pourrait aussi pr&eacute;tendre avoir l'adresse IP que vous autorisez &agrave; 
  acc&eacute;der &agrave; votre serveur NFS. Il y a plusieurs attaques qui peuvent 
  r&eacute;sulter. Proprement param&eacute;tr&eacute;, IPsec peut prot&eacute;ger 
  contre ce type d'attaques. 
<p>Une autre consigne de s&eacute;curit&eacute; importante. N'ajoutez pas simplement 
  un syst&egrave;me de fichiers sur /etc/exports sans aucune liste de h&ocirc;te(s) 
  autoris&eacute;(s). Sans liste d'h&ocirc;tes autoris&eacute;s &agrave; monter 
  un r&eacute;pertoire particulier, n'importe qui peut atteindre votre serveur 
  NFS sera capable de monter des exports NFS. 
<P> La configuration consiste en un serveur avec l'adresse IP <b>10.0.0.1</b>. 
  Ce serveur servira NFS uniquement pour les clients dans ce r&eacute;seau. La 
  premi&egrave;re &eacute;tape de la configuration consiste &agrave; configurer 
  votre fichier <i>/etc/exports</i>. Ce fichier liste quel(s) syst&egrave;me(s) 
  de fichiers vous souhaitez rendre accessible(s) via NFS et d&eacute;finit quel(s) 
  h&ocirc;te(s) est/sont autoris&eacute;(s) &agrave; y acc&eacute;der. Il y a 
  plusieurs options que vous pouvez utiliser dans votre fichier <i>/etc/exports</i>, 
  et il serait fort souhaitable que vous lisiez la page de manuel <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&sektion=5">exports(5)</a>. 
  Pour cet exemple, voici &agrave; quoi ressemble le fichier <i>/etc/exports</i>:</p>

<ul><pre>
#
# NFS exports Database
# See exports(5) for more information.  Be very careful, misconfiguration
# of this file can result in your filesystems being readable by the world.
/work -alldirs -ro -network 10.0.0 -mask 255.255.255.0
</pre></ul>

<p>Cela veut dire que le syst&egrave;me de fichiers local <b>/work</b> sera partag&eacute; 
  via NFS. <b>-alldirs</b> sp&eacute;cifie que les clients seront capables de 
  monter n'importe quel point en dessous du point de montage <b>/work</b>. <b>-ro</b> 
  sp&eacute;cifie que l'acc&egrave;s se fait uniquement en lecture seule (read 
  only). Les deux derniers arguments sp&eacute;cifient que seulement les clients 
  appartenant au r&eacute;seau 10.0.0.0 et utilisant un masque de sous-r&eacute;seau 
  de 255.255.255.0 seront autoris&eacute;s &agrave; monter ce syst&egrave;me de 
  fichiers. Ceci est important pour des serveurs accessibles &agrave; partir de 
  r&eacute;seaux diff&eacute;rents.</p>
<p>Une fois votre fichier <i>/etc/exports </i>configur&eacute;, vous pouvez mettre 
  en place votre serveur NFS. Tout d'abord, vous devriez vous assurer que les 
  options NFSSERVER et NFSCLIENT figurent dans votre configuration du noyau. (Le 
  noyau GENERIC inclut ces options). Ensuite, vous devrez positionner <strong>nfs_server=YES</strong> 
  dans <i>/etc/rc.conf</i>. Ceci lancera nfsd(8) et mountd(8) au red&eacute;marrage. 
  Vous pouvez d&eacute;marrer les d&eacute;mons vous-m&ecirc;me. Ces d&eacute;mons 
  doivent &ecirc;tre d&eacute;marr&eacute;s en tant que root, et vous devez vous 
  assurer que portmap(8) tourne sur votre syst&egrave;me. Voici un exemple de 
  d&eacute;marrage de nfsd(8) qui fera office de serveur sur TCP et UDP en utilisant 
  4 d&eacute;mons. Vous devriez param&eacute;trer un nombre appropri&eacute; de 
  d&eacute;mons NFS pour prendre en charge le nombre maximal de requ&ecirc;tes 
  simultan&eacute;es auxquelles vous voulez que votre serveur r&eacute;ponde.</p>

<P>

<ul><pre>
# <strong>/sbin/nfsd -tun 4</strong>
</pre></ul>

<p>Vous devrez aussi lancer mountd(8). C'est le d&eacute;mon qui r&eacute;pond 
  r&eacute;ellement aux requ&ecirc;tes de montage NFS. Pour d&eacute;marrer mountd(8), 
  assurez vous qu'un fichier mounttab vide existe, et ex&eacute;cutez le d&eacute;mon : 
<p>

<ul><pre>
# <strong>echo -n &gt;/var/db/mountdtab</strong>
# <strong>/sbin/mountd</strong>
</pre></ul>

<P>Si vous effectuez des changements dans /etc/exports alors que NFS est en marche, 
  vous devez en pr&eacute;venir mountd &agrave; l'aide d'un signal HUP: 
<UL><PRE>
# <strong>kill -HUP `cat /var/run/mountd.pid`</strong>
</pre></ul>

<P>

<h3>V&eacute;rification de l'&eacute;tat NFS</h3>

<p>A partir de l&agrave;, vous pouvez v&eacute;rifier que tous ces d&eacute;mons 
  sont actifs et sont enregistr&eacute;s aupr&egrave;s du sous-système RPC. 
  Pour cela, utilisez rpcinfo(8).
<p>

<ul><pre>
$ <strong>rpcinfo -p 10.0.0.1</strong>
   program vers proto   port
    100000    2   tcp    111  portmapper
    100000    2   udp    111  portmapper
    100005    1   udp    633  mountd
    100005    3   udp    633  mountd
    100005    1   tcp    916  mountd
    100005    3   tcp    916  mountd
    100003    2   udp   2049  nfs
    100003    3   udp   2049  nfs
    100003    2   tcp   2049  nfs
    100003    3   tcp   2049  nfs
</pre></ul>

<p>Durant une utilisation normale, il y a quelques autres utilitaires qui vous 
  permettent de voir ce qui se passe au niveau NFS. Un de ces derniers est <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=showmount&sektion=8">showmount(8)</a> 
  , qui vous autorise &agrave; voir quels r&eacute;pertoires sont mont&eacute;s 
  et quels clients les monte. Il y a aussi nfsstat(8) qui donne des statistiques 
  beaucoup plus verbeuses. Pour utiliser showmount(8), essayez <b>/usr/bin/showmount 
  -a host</b>. Par exemple : 
<P>

<ul><pre>
$ <strong>/usr/bin/showmount -a 10.0.0.1</strong>
All mount points on 10.0.0.1:
10.0.0.37:/work
</pre></ul>

<h3>Montage de syst&egrave;mes de fichiers NFS </h3>

<p>Les syst&egrave;mes de fichiers doivent &ecirc;tre mont&eacute;s &agrave; l'aide 
  de la commande mount(8), ou plus sp&eacute;cifiquement, <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount_nfs&sektion=8">mount_nfs(8)</a>. 
  Pour monter un syst&egrave;me de fichiers /work du h&ocirc;te 10.0.0.1 sur le 
  syst&egrave;me de fichiers local /mnt, faites (notez que vous n'avez pas besoin 
  d'utiliser une adresse IP, mount r&eacute;sout les noms d'h&ocirc;te) : 
<p>

<ul><pre>
# <strong>mount -t nfs 10.0.0.1:/work /mnt</strong>
</pre></ul>

<p>Pour monter ce syst&egrave;me de fichiers au d&eacute;marrage, ajoutez la ligne 
  suivante &agrave; /<i>etc/fstab</i> : 
<p>

<ul><pre>
10.0.0.1:/work /mnt nfs rw 0 0
</pre></ul>

<p>Il est important d'utiliser <tt>0 0</tt> &agrave; la fin de cette ligne pour 
  que votre machine n'essaye pas d'effectuer un fsck sur le syst&egrave;me de 
  fichiers NFS au d&eacute;marrage !!! Les autres options de s&eacute;curit&eacute; 
  standard comme noexec, nodev, et nosuid devraient &ecirc;tre utilis&eacute;es 
  l&agrave; o&ugrave; elles s'appliquent. Par exemple :
<p>

<ul><pre>
10.0.0.1:/work /mnt nfs rw,nodev,nosuid 0 0
</pre></ul>

<p>De cette mani&egrave;re, aucun p&eacute;riph&eacute;rique ou programme suid 
  sur le serveur NFS ne pourront contourner les mesures de s&eacute;curit&eacute; 
  sur le client NFS. Si vous ne montez pas des applications que vous devez ex&eacute;cuter 
  en tant que client NFS, rajoutez noexec &agrave; cette liste.
<p>
<a name= "DNS"></a>
<a name="6.8"></a>
<h2>6.8 - Service de Noms - DNS, BIND, et named</h2>
<p></p>

<h3>6.8.1 Qu'est ce que le DNS ? </h3>

<p>Domain Name Service est un service r&eacute;seau qui permet &agrave; des domaines 
  de r&eacute;seaux IP de fournir des services de r&eacute;solution nom vers IP 
  et IP vers nom en r&eacute;ponse &agrave; une requ&ecirc;te. Votre installation 
  OpenBSD est configur&eacute;e par d&eacute;faut comme client DNS mais pas comme 
  serveur DNS. En clair, votre installation OpenBSD peut effectuer des requ&ecirc;tes 
  DNS &agrave; destination d'un serveur de noms pour l'adresse d'une machine, 
  mais elle ne peut pas r&eacute;pondre &agrave; des requ&ecirc;tes DNS par
  elle-m&ecirc;me, 
  &agrave; moins que vous ne la configuriez pour qu'elle le fasse.</p>
<p>Ma machine OpenBSD est actuellement connect&eacute;e &agrave; Internet via 
  mon FAI, alors je peux utiliser l'utilitaire <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nslookup&sektion=8">nslookup(8)</a> 
  pour effectuer des requ&ecirc;tes DNS : </p>

<ul><pre>
$ <strong>nslookup www.openbsd.org</strong>
Server:  ns4.us.prserv.net
Address:  165.87.201.244

Non-authoritative answer:
Name:    www.openbsd.org
Address:  129.128.5.191
</pre></ul>

<p><b>165.87.201.24</b> est le serveur de noms qui a r&eacute;pondu, parce que 
  c'est le serveur de noms que mon FAI m'a demand&eacute; d'utiliser avec mon 
  compte et dont l'adresse a &eacute;t&eacute; entr&eacute;e dans <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&sektion=5">/etc/resolv.conf</a>. 
  Mais la r&eacute;ponse ne fait pas autorit&eacute;. Pour une r&eacute;ponse 
  qui fait autorit&eacute;, il nous faut trouver le serveur responsable du domaine 
  <i>openbsd.org</i> et lui demander l'adresse de <i>www.openbsd.org</i> : </p>
<p>&nbsp;</p>

<ul><pre>
# Identify the name servers for openbsd.org
# with the help of my ISP's name server.
$ <strong>nslookup -type=NS openbsd.org</strong>
Server:  ns4.us.prserv.net
Address:  165.87.201.244

Non-authoritative answer:
openbsd.org     nameserver = cvs.openbsd.org
openbsd.org     nameserver = gandalf.sigmasoft.com
openbsd.org     nameserver = cs.colorado.edu
openbsd.org     nameserver = ns.appli.se
openbsd.org     nameserver = zeus.theos.com

Authoritative answers can be found from:
cvs.openbsd.org internet address = 199.185.137.3
gandalf.sigmasoft.com   internet address = 198.144.202.98
cs.colorado.edu internet address = 128.138.243.151
ns.appli.se     internet address = 194.198.196.230
zeus.theos.com  internet address = 199.185.137.1

# Use the info gained to query for an authoritative
# resolution: query the authoritative zeus.theos.com.
$ <strong>nslookup www.openbsd.org zeus.theos.com</strong>
Server:  zeus.theos.com
Address:  199.185.137.1

Name:    www.openbsd.org
Address:  129.128.5.191
</pre></ul>

<p><i>zeus.theos.com</i>, comme vous vous en doutez, est sous OpenBSD et il est 
  correctement configur&eacute; pour &ecirc;tre serveur DNS du domaine <i>openbsd.org</i>.</p>
<p><a name="DNS.1.1"></a> <a name="6.8.1.1"></a> </p>

<h3>6.8.1.1 O&ugrave; puis-je en apprendre plus sur le DNS et son impl&eacute;mentation 
  sous OpenBSD ?</h3>
<ul>
  <li>Consultez les RFCs <a href="http://www.faqs.org/rfcs/rfc1033.html">1033</a>, 
    <a href="http://www.faqs.org/rfcs/rfc1034.html">1034</a>, et <a href="http://www.faqs.org/rfcs/rfc1035.html">1035</a> 
    pour plus d'informations sur le syst&egrave;me de noms de domaines Internet</li>
  <li>Lisez le livre <i><a href="../../books.html#6">DNS and BIND</a> </i> de O'Reilly 
    Associates.</li>
  <li>Lisez le <a href="http://www.openbsd.org/cgi-bin/man.cgi">Manuel OpenBSD</a> 
    et sp&eacute;cialement les pages suivantes : 
    <ul>
      <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&sektion=1">dig(1)</a> 
      </li>
      <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=nslookup&sektion=8">nslookup(8)</a> 
      </li>
      <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gethostbyname&sektion=3">gethostbyname(3)</a> 
      </li>
      <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=named&sektion=8">named(8)</a> 
      </li>
      <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolver&sektion=3">resolver(3)</a> 
      </li>
      <li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolver&sektion=5">resolver(5)</a> 
      </li>
    </ul>
  </li>
</ul>
La commande <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&sektion=1">dig(1)</a> 
est particuli&egrave;rement utile, parce qu'elle peut envoyer une requ&ecirc;te 
&agrave; un domaine et afficher l'information dans pratiquement le m&ecirc;me 
format que celui requis pour les fichiers de configuration BIND. Vous pouvez utiliser 
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&sektion=1">dig(1)</a> 
pour analyser la configuration de serveurs de noms qui, selon vous, sont correctement 
configur&eacute;s afin de comparer votre configuration &agrave; la leur. 
<h3>6.8.2 Est-ce que ma machine &agrave; besoin d'&ecirc;tre un serveur de noms 
  ?</h3>

<p>Si vous n'&ecirc;tes pas s&ucirc;r que vous ayez besoin que votre machine soit 
  un serveur DNS, alors ne la configurez pas pour en &ecirc;tre un. L'installation 
  OpenBSD n'active pas, par d&eacute;faut, le serveur de noms de domaine sur votre 
  machine, malgr&eacute; que tous les fichiers n&eacute;cessaires soient install&eacute;s. 
  Pour la plupart des stations de travail, il suffit d'avoir le fichier <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=hosts&sektion=5">/etc/hosts</a> 
  qui fait la correspondance ip-nom pour les machines locales et le fichier <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&sektion=5">/etc/resolv.conf</a> 
  pour indiquer quels sont les serveurs DNS que vous devez utiliser pour r&eacute;soudre 
  le nom de machines sur intranet ou internet.</p>
<p>D'un autre c&ocirc;t&eacute;, vous pourriez avoir besoin de configurer votre 
  machine en tant que serveur de noms : </p>

<ul>
  <li>Si vous avez un LAN IP sur lequel vous ne souhaitez pas r&eacute;pliquer 
    les fichiers &quot;hosts&quot; des adresses locales sur chacune des machines. 
    Dans ce cas, vous pouvez configurer votre machine OpenBSD en serveur DNS et 
    r&eacute;pondre aux requ&ecirc;tes des autres machines sur votre LAN. 
    <ul>
      <li><b>Remarque : </b>Il n'y a aucune restriction pratique au nombre de serveurs 
        DNS sur un LAN. N'importe quelle machine ou toutes les machines peuvent 
        offrir un service DNS si elles sont configur&eacute;es pour le faire. 
        Le fait qu'un de ces serveurs fasse autorit&eacute; ou pas en dehors de 
        votre LAN (ou s'il est tout simplement connu en dehors de votre LAN) est 
        un facteur de configuration qui est typiquement contr&ocirc;l&eacute; 
        &agrave; un cran plus haut dans la hi&eacute;rarchie des domaines.</li>
    </ul>
  </li>
  <li>Si vous avez un LAN IP sur lequel r&eacute;sident des machines 
  identifiables via une requ&ecirc;te DNS par d'autres machines sur un autre 
  LAN IP ou WAN.</li>
  <li>Si vous rencontrez des difficult&eacute;s lors de la r&eacute;solution du 
    nom de h&ocirc;te local vers une adresse IP, ou la r&eacute;solution d'autres 
    noms locaux vers des adresses IP malgr&eacute; le fait que vous avez des fichiers 
    <i>/etc/hosts</i> et <i>/etc/resolv.conf</i> corrects (par exemple, Netscape 
    sous OpenBSD a parfois ce comportement car il utilise son propre m&eacute;canisme 
    de r&eacute;solution au lieu d'utiliser simplement <i>gethostbyname(3)</i> 
    pour rechercher des adresses.)</li>
</ul>

<p>Une autre raison est la vitesse d'ex&eacute;cution. Vu que la r&eacute;solution 
  de noms est un processus it&eacute;ratif, dans lequel le serveur de noms envoie 
  des requ&ecirc;tes r&eacute;p&eacute;titives &agrave; d'autres serveurs de noms 
  pour des adresses dans des domaines ext&eacute;rieurs, la r&eacute;solution 
  de noms peut prendre un peu plus de temps si vous avez une connexion modem &agrave; 
  Internet et vous envoyez des requ&ecirc;tes &agrave; votre propre serveur DNS 
  concernant des adresses distantes (votre serveur va alors, et de mani&egrave;re 
  it&eacute;rative, demander l'information &agrave; des serveurs de noms distants 
  via le modem) que si vous envoyez la requ&ecirc;te au serveur de noms de votre 
  FAI (qui a probablement une connexion plus rapide vers des serveurs de noms 
  distants).</p>
<h3>6.8.3 Quels sont les composants logiciels du serveur DNS ?</h3>
<ul>
  <li>named <i>("name daemon")</i></li>
  <li>Les fichiers de configuration dans la hi&eacute;rarchie de r&eacute;pertoires 
    sous <i>/var/named/</i></li>
</ul>

<h4>6.8.3.1 Quelle version de BIND est support&eacute;e ?</h4>
<p>BIND est le nom d'une sp&eacute;cification pour un serveur de noms de domaine. 
  La mise en oeuvre de BIND est constitu&eacute;e par un ensemble de composants 
  de service de noms.</p>
<p> Il y a trois versions distinctes de BIND : </p>

<ol>
<li>BIND 4</li>
<li>BIND 8</li>
<li>BIND 9</li>
</ol>

<p>Tel qu'il est install&eacute;, le <b>named</b> de OpenBSD g&egrave;re BIND 
  4.x. 
<h4>6.8.3.2 Quelles sont quelques unes des alternatives &agrave; fournir le service 
  DNS via l'impl&eacute;mentation par d&eacute;faut BIND 4.X ?</h4>
<ul>
  <li>L'impl&eacute;mentation BIND 9.x qui se trouve sous <i>/usr/ports/net/bind9</i>.(Voir 
    <a href="../../fr/ports.html">ports</a>) 
</ul>

<h5>6.8.3.2.1 Note de<u> s&eacute;curit&eacute;</u></h5>
<p>Si vous utilisez ces impl&eacute;mentations alternatives pour le service de 
  noms de domaines, vous fournissez un service r&eacute;seau critique &agrave; 
  travers des logiciels qui n'ont peut-&ecirc;tre pas &eacute;t&eacute; soumis 
  au m&ecirc;me examen minutieux que le d&eacute;mon <b>named</b> de l'installation 
  de base, <a href="http://www.openbsd.org/security.html">audit&eacute; au niveau 
  s&eacute;curit&eacute;</a>. Ceci est n'est pas &agrave; prendre &agrave; la 
  l&eacute;g&egrave;re, puisque si un serveur de noms de domaines est compromis, 
  les applications de r&eacute;solution de noms utilisant ce serveur de noms peuvent 
  &ecirc;tre redirig&eacute;s vers des sites imposteurs. </p>
<h3>6.8.4 Que dois-je installer ?</h3>
<p>Si la configuration r&eacute;seau par d&eacute;faut de OpenBSD a &eacute;t&eacute; 
  param&eacute;tr&eacute;e correctement durant l'installation, tout est d&eacute;j&agrave; 
  install&eacute;. Vous avez juste &agrave; configurer le d&eacute;mon named.</p>
<h3>6.8.5 Comment puis-je configurer le DNS ?</h3>
<p>Vous configurez le DNS de OpenBSD en &eacute;ditant et/ou en cr&eacute;ant 
  des fichiers qui contr&ocirc;lent le d&eacute;mon <tt>named</tt>. Ces fichiers 
  r&eacute;sident par d&eacute;faut dans le r&eacute;pertoire <i>/var/named</i> 
  et ces sous-r&eacute;pertoires, sp&eacute;cialement le fichier <i>/var/named/named.boot</i> 
  qui est le fichier d'initialisation de <b>named</b>. Il y a aussi quelques &eacute;tapes 
  de configuration qui doivent &ecirc;tre effectu&eacute;es dans <i>/etc</i>.
</p>
<p>Dans ce document, nous allons configurer le d&eacute;mon named sur <i>nemo.yewtopia.com</i> 
  pour &ecirc;tre le serveur de noms primaire pour le (tout petit !) domaine <i>yewtopia.com</i>. 
  L'adresse de <i>nemo.yewtopia.com</i> est <i>192.168.1.9</i>. Deux autres machines 
  sont sur le m&ecirc;me sous-r&eacute;seau, <i>crater.yewtopia.com </i>&agrave; 
  l'adresse 192.168.1.1 et <i>earhart.yewtopia.com</i> &agrave; l'adresse 192.168.1.2.</p>

<h4>6.8.5.1 Configuration &agrave; effectuer dans <i>/var/named</i></h4>

<h5>6.8.5.1.1 <i>/var/named/named.boot</i></h5>

<ul><pre>
; tell what subdir has the lookup database files
directory       /namedb

; type    domain   source host/file backup file
cache     .	   root.cache
primary   0.0.127.IN-ADDR.ARPA  localhost.rev

; example primary server config:
primary  yewtopia.com yewtopia
primary  1.168.192.IN-ADDR.ARPA yewtopia.rev
</pre></ul>

<p>Ceci sp&eacute;cifie au processus d'initialisation dans quel sous-r&eacute;pertoire 
  et sous quels noms de fichiers il trouvera les fichiers de configuration pour 
  <i>yewtopia.com</i>.
<h5>6.8.5.1.2 <i>/var/named/namedb/localhost.rev</i></h5>

<ul><pre>
; Reverse lookup for localhost interface
@       IN      SOA     nemo.yewtopia.com.
your_id.nemo.yewtopia.com.  (
                                14      ; Serial
                                3600    ; Refresh
                                900     ; Retry
                                3600000 ; Expire
                                3600 )  ; Minimum
        IN      NS      nemo.yewtopia.com.
1       IN      PTR     localhost.yewtopia.com.
</pre></ul>

<h5>6.8.5.1.3 <i>/var/named/namedb/yewtopia</i></h5>

<ul><pre>
; yewtopia.com domain database
yewtopia.com.        IN      SOA     nemo.yewtopia.com.
your_id.nemo.yewtopia.com.  (
                                14      ; Serial
                                3600    ; Refresh
                                900     ; Retry
                                3600000 ; Expire
                                3600 )  ; Minimum
                     IN      NS      nemo.yewtopia.com.

; Addresses
localhost.yewtopia.com.      IN A    127.0.0.1
crater.yewtopia.com.         IN A    192.168.1.1
earhart.yewtopia.com.        IN A    192.168.1.2
nemo.yewtopia.com.           IN A    192.168.1.9
</pre></ul>

<h5>6.8.5.1.4 <i>/var/named/namedb/yewtopia.rev</i></h5>

<ul><pre>
; yewtopia domain reverse lookup database
1.168.192.in-addr.arpa. IN      SOA     nemo.yewtopia.com.
your_id.nemo.yewtopia.com.  (
                                14      ; Serial
                                3600    ; Refresh
                                900     ; Retry
                                3600000 ; Expire
                                3600 )  ; Minimum
1.168.192.in-addr.arpa. IN      NS      nemo.yewtopia.com.

; Addresses
1.1.168.192.in-addr.arpa. IN PTR crater.yewtopia.com.
2.1.168.192.in-addr.arpa. IN PTR earhart.yewtopia.com.
9.1.168.192.in-addr.arpa. IN PTR nemo.yewtopia.com.
</pre></ul>

<h4>6.8.5.2 Configuration &agrave; effectuer dans <i>/etc</i></h4>

<h5>6.8.5.2.1 <i>/etc/resolv.conf</i></h5>
<p>Assurez-vous que <i>/etc/resolv.conf </i>pointe sur le domaine de la machine 
  locale (au lieu du serveur de nom de votre FAI par exemple) de telle fa&ccedil;on 
  que les requ&ecirc;tes de r&eacute;solution de noms soient envoy&eacute;es au 
  <b>named</b> que vous avez configur&eacute; !</p>
<ul><pre>
domain yewtopia.com
lookup file bind
</pre></ul>

<h4>6.8.5.2.2 <i>/etc/hosts</i></h4>

<p>Si vous avez pr&eacute;c&eacute;demment ajout&eacute; des adresses de diverses 
  machines dans le fichier <i>/etc/hosts</i>, vous devriez remettre votre fichier 
  <i>/etc/hosts </i>dans sa configuration par d&eacute;faut : </p>
<ul><pre>
# Host addresses
127.0.0.1       localhost       localhost.localdomain
192.168.1.9     nemo            nemo.yewtopia.com
</pre></ul>

<p>&nbsp; </p>
<p>Pour que la r&eacute;solution assur&eacute;e par <b> named</b> ne soit pas 
  contourn&eacute;e en faveur d'adresses (probablement d&eacute;pass&eacute;es) 
  dans le fichier <i>/etc/hosts</i>. <u>Assurez-vous que vous avez au moins une 
  entr&eacute;e <i>localhost</i></u> ou votre r&eacute;seau ne d&eacute;marrera 
  pas proprement ! Notez aussi que <i>nemo </i>doit appara&icirc;tre dans son 
  propre fichier d'h&ocirc;tes vous verrez un message (quasi-inoffensif) au d&eacute;marrage 
  lorsque <i>/etc/netstart </i>fait appel &agrave; <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=route&sektion=8">route(8)</a> 
  pour ajouter <i>nemo </i>(dont le nom appara&icirc;t dans <i>/etc/myname</i>).</p>
<h4>6.8.5.3 Utilisation de <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=dig&sektion=1">dig(1)</a> 
  pour analyser les r&eacute;sultats</h4>

<ul><pre>
$ <strong>dig @nemo.yewtopia yewtopia any any</strong>

; &lt;&lt;&gt;&gt; DiG 2.2 &lt;&lt;&gt;&gt; @nemo.yewtopia yewtopia any any
; (1 server found)
;; res options: init recurs defnam dnsrch
;; got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 59904
;; flags: qr rd ra; Ques: 1, Ans: 2, Auth: 0, Addit: 1
;; QUESTIONS:
;;      yewtopia, type = ANY, class = ANY

;; ANSWERS:
yewtopia.        3600   SOA     nemo.yewtopia.
your_id.nemo.yewtopia. (
                        14      ; serial
                        3600    ; refresh (1 hour)
                        900     ; retry (15 mins)
                        3600000 ; expire (41 days 16 hours)
                        3600 )  ; minimum (1 hour)
yewtopia.        3600   NS      nemo.yewtopia.

;; ADDITIONAL RECORDS:
nemo.yewtopia.   3600   A       192.168.1.9

;; Total query time: 4 msec
;; FROM: nemo to SERVER: nemo.yewtopia.  192.168.1.9
;; WHEN: Tue May  2 23:47:19 2000
;; MSG SIZE  sent: 25  rcvd: 102
</pre></ul>

<h3>6.8.6 Comment et quand se d&eacute;marre et s'arr&ecirc;te le DNS ? </h3>
<h4>6.8.6.1 D&eacute;marrer le DNS</h4>
<p>Le d&eacute;mon <b>named</b> est lanc&eacute; lors du d&eacute;marrage du syst&egrave;me 
  &agrave; partir de <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&sektion=8">/etc/rc</a> 
  si la ligne par d&eacute;faut dans <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&sektion=8">/etc/rc.conf</a> 
  : </p>
<ul><pre>
named_flags=NO          # for normal use: ""
</pre></ul>

<p> est remplac&eacute;e par :</p>

<ul><pre>
named_flags=""          # for normal use: ""
</pre></ul>

<p>De m&ecirc;me, v&eacute;rifier les lignes suivantes dans /etc/rc.conf : </p>
<ul><pre>
named_user=named                # Named should not run as root unless necessary
named_chroot=/var/named         # Where to chroot named if not empty
</pre></ul>

<p>Ces valeurs par d&eacute;faut conviennent pour pratiquement toutes les configurations.</p>
<p>Pour d&eacute;marrer <b>named</b> &agrave; la main, utilisez la commande <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ndc&sektion=8">ndc(8)</a>. 
  Par exemple : </p>
<ul>
  <pre>
# <strong>ndc start</strong>
ou
# <strong>ndc restart</strong>
</pre>
</ul>

<h4>6.8.6.2 Arr&ecirc;ter le DNS</h4>

<p>La meilleure mani&egrave;re d'arr&ecirc;ter le d&eacute;mon <b>named</b> est 
  d'utiliser la commande <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ndc&sektion=8">ndc(8)</a>. 
  Par exemple : </p>
<ul><pre>
# <strong>ndc stop</strong>
</pre></ul>

<p>Si cela &eacute;choue, trouvez l'identifiant du processus 
  (PID) de named et utilisez la commande <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=kill&sektion=1">kill(1)</a> 
  pour arr&ecirc;ter le processus. Le PID de <b>named</b> quand ce dernier est 
  actif se trouve dans la premi&egrave;re ligne du fichier <i>/var/named/named.pid</i> 
</p>
<ul><pre>
# <strong>cat /var/named/named.pid</strong>
4608
named -t /var/named -u named
# <strong>kill -KILL 4608</strong>
</pre></ul>

<h4>6.8.6.3 Red&eacute;marrer le DNS avec une configuration modifi&eacute;e</h4>

<p>Pour amener une instance en cours du d&eacute;mon <b>named </b> &agrave; red&eacute;marrer 
  en rechargeant la configuration apr&egrave;s que vous ayez effectu&eacute; des 
  changements, envoyez-lui un signal &quot;hangup&quot; : </p>
<ul><pre>
# <strong>kill -HUP 4608</strong> 
</pre></ul>

<p> ou utilisez la commande <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ndc&sektion=8">ndc(8)</a> 
  comme ceci : </p>

<ul><pre>
# <strong>ndc reload</strong>
</pre></ul>

<h3>6.8.7 Comment puis-je bloquer les requ&ecirc;tes AXFR ?</h3>
<p> exemple : 
<ul><pre>
garden:/home/jeremy$<strong>  host -l openssh.com</strong>
openssh.com.            NS      zeus.theos.com.
openssh.com.            NS      cvs.openbsd.org.
openssh.com.            NS      gandalf.sigmasoft.com.
openssh.com.            NS      cs.colorado.edu.
openssh.com.            NS      ns.appli.se.
openssh.com.            A       199.185.137.4
cvs.openssh.com.        A       199.185.137.4
localhost.openssh.com.  A       127.0.0.1
</pre></ul>
<p>Cette information est utile lors du d&eacute;boguage du DNS, mais dans certains 
  cas vous ne voudriez pas qu'elle soit disponible publiquement de mani&egrave;re 
  permanente. Si vous utilisez une &quot;classless in-addr&quot; (rfc2137) comme 
  classe inverse, host -l pourrait afficher tout domaine que votre syst&egrave;me 
  h&eacute;berge ! On peut rem&eacute;dier facilement &agrave; ce comportement 
  gr&acirc;ce &agrave; la clause &quot;allow-transfer&quot; dans votre fichier 
  de zone. 
<p>Si vous utilisez Bind8, vous devez sp&eacute;cifier les h&ocirc;tes que vous 
  voulez autoriser &agrave; transf&eacute;rer des zones dans votre/vos fichier(s) 
  de zone individuel(s) :
<ul><pre>
zone "foo.com" in {
        type master;
        file "directory/zonefile";
        allow-transfer {
          127.0.0.1;
          10.0.0.6;
          10.0.255.12;
        };
};
</pre></ul>
<p>Vous pouvez aussi bloquer les transferts vers tous les domaines en &eacute;ditant 
  /var/named.conf et en ajoutant le param&egrave;tre 'allow-transfer' &agrave; 
  la section 'options' du fichier de configuration : </p>
<ul><pre>
   options {
        allow-transfer { 127.0.0.1; };
    };
</pre></ul>
<p>La m&eacute;thode Bind8 fonctionne aussi avec Bind9. </p>
<p>Si vous utilisez Bind 4 (le d&eacute;faut sous OpenBSD), vous pouvez 
&eacute;diter /var/named/named.boot et utilisez l'option 'xfrnets'. </p>
<ul><pre>
xfrnets 209.142.221.5 12.7.96.7
; type    domain                source host/file                backup file
cache     .                                                     root.cache
primary   0.0.127.IN-ADDR.ARPA  localhost.rev
</pre></ul>
<p><br>
  Bind 4 autorise le transfert &agrave; partir de classes enti&egrave;res donc 
  ce n'est pas vraiment exacte. Typiquement, les seuls h&ocirc;tes qui ont besoin 
  d'effectuer des transferts sont vos serveurs DNS esclaves et les h&ocirc;tes 
  &agrave; partir desquels vous souhaitez d&eacute;boguer (127.0.0.1 est usuellement 
  un h&ocirc;te &agrave; qui on peut autoriser les transferts !) Bloquer les requ&ecirc;tes 
  AXFR ajoute un niveau suppl&eacute;mentaire de s&eacute;curit&eacute;, mais 
  peut emp&ecirc;cher le d&eacute;boguage DNS qui se r&eacute;v&egrave;le 
  parfois utile. (Merci &agrave; <a href=mailto:ntang@nachtwache.org>Nicholas Tang</a> 
  pour cette remarque)</p>
<p></p>
<h3>6.8.8 Que ne m'avez vous pas dit &agrave; propos de la mise en place du DNS 
  ? </h3>
<p>Il y a beaucoup de choses que nous ne vous avons pas dit. Par exemple, comment 
  configurer le DNS de telle mani&egrave;re &agrave; ce que les requ&ecirc;tes 
  pour les domaines intranet qui ne sont pas visibles &agrave; partir de la racine 
  la hi&eacute;rarchie de domaines soient relay&eacute;es &agrave; des serveurs 
  au sein de votre entreprise. Lisez <a href="#DNS.1.1">les documents que nous 
  vous avons recommand&eacute;</a> pour plus d'informations concernant le DNS. 
</p>
<p><a name= "PPTP"></a> <a name="6.9"></a> </p>

<h2>6.9 - Mise en place d'une connexion PPTP sous OpenBSD</h2>
<p><b>REMARQUE : </b> Ceci ne s'applique pas &agrave; <b>TOUS</b> les fournisseurs 
  d'acc&egrave;s ADSL, mais l'essentiel de ce que vous devez conna&icirc;tre se 
  trouve dans cette configuration typique. Cette configuration a &eacute;t&eacute; 
  valid&eacute;e avec <a href="http://www.inode.at">Inode</a>, un fournisseur 
  d'acc&egrave;s ADSL en Autriche. </p>
<p>Pour commencer, vous avez besoin d'installer pptp. Le port se trouve sous <i>/usr/ports/net/pptp</i>. 
  Consultez <a href="../faq8.html#Ports">FAQ 8, Ports</a> pour plus d'informations 
  concernant l'arborescence de ports OpenBSD. </p>

<p>A cause d'un conflit entre le support au niveau noyau <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=gre&sektion=4">gre(4)</a> 
  et pptp, vous aurez besoin de re-compiler votre noyau en supprimant le support 
  pour gre(4). </p>

<p>&nbsp; </p>

<ul>
  Correctif pour supprimer le support GRE(4) : 
  <pre>
Index: GENERIC
===================================================================
RCS file: /cvs/src/sys/conf/GENERIC,v
retrieving revision 1.66
diff -u -r1.66 GENERIC
--- sys/conf/GENERIC    2000/10/13 04:21:14     1.66
+++ sys/conf/GENERIC    2000/12/26 19:55:31
@@ -97,6 +97,6 @@
 pseudo-device  ksyms   1	# kernel symbols device
 pseudo-device  bridge  2	# network bridging support
 pseudo-device vlan    2	# IEEE 802.1Q VLAN
-pseudo-device  gre     1	# GRE encapsulation interface
+#pseudo-device gre     1	# GRE encapsulation interface
 #pseudo-device strip   1   # Starmode Radio IP interface
 pseudo-device  pty     64      # pseudo-terminals
 
</pre>
</ul>

<p>Pour recompiler votre noyau, utilisez cvs pour r&eacute;cup&eacute;rer OpenBSD 
  (consultez la page web <a href="../../stable.html">OpenBSD Stable</a> pour plus 
  d'informations), appliquer le patch pr&eacute;c&eacute;dent, et reconstruisez 
  votre noyau en suivant les instructions indiqu&eacute;es dans <a href="faq5.html#Building">FAQ 
  5, Configuration du noyau</a>. </p>
<p>Apr&egrave;s avoir reconstruit le noyau et install&eacute; le package <b>pptp</b>, 
  vous devez &eacute;diter quelques fichiers pour mettre en place votre connexion. 
  Ce package utilise le <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&sektion=8">ppp(8)</a> 
  fourni avec OpenBSD, alors si vous &ecirc;tes familier avec ppp(8), la configuration 
  est pratiquement la m&ecirc;me. Consultez <a href="#PPP">FAQ 6, Protocole Point 
  &agrave; Point</a>. </p>

<ul>
<li>1 - /etc/ppp/options
<li>2 - /etc/ppp/pap-secrets
</ul>

<p>La configuration suivante est tr&egrave;s probablement tout ce dont vous avez 
  besoin dans le fichier <i>/etc/ppp/options</i> : </p>
<ul><pre>
# <strong>cat /etc/ppp/options</strong>
name "LOGINNAME"
noauth
noipdefault
defaultroute
debug
</pre></ul>

<p> <tt>LOGINNAME</tt> doit &ecirc;tre remplac&eacute; avec votre nom d'utilisateur.</p>

<p><i>/etc/ppp/pap-secrets</i> devrait contenir une ligne comme la suivante : 
<ul><pre>
# <strong>cat /etc/ppp/pap-secrets</strong>
LOGINNAME 10.0.0.138 PASSWORD
</pre></ul>

<p>O&ugrave; LOGINNAME est votre nom d'utilisateur et PASSWORD est votre mot de 
  passe. 10.0.0.138 est l'adresse IP attribu&eacute;e &agrave; votre MODEM dans 
  le cas o&ugrave; vous utilisez l'ADSL, etc. Assurez-vous que ce fichier est 
  en lecture seule pour root uniquement (mode 600). </p>
<h3>6.9.1 - Attribution d'une adresse &agrave; votre interface r&eacute;seau</h3>
<p>Dans l'exemple ci-dessus, notre modem a une interface pr&eacute;configur&eacute;e 
  avec l'adresse 10.0.0.138. Maintenant, nous avons besoin d'affecter une 
  adresse 
  &agrave; NOTRE interface. Le mieux est de choisir une adresse IP proche de celle 
  donn&eacute;e par votre MODEM, ou utiliser l'adresse statique qui vous est attribu&eacute;e. 
  Consultez <a href="#Setup">FAQ 6, Mise en place initiale</a> pour plus d'informations 
  concernant le param&eacute;trage d'interfaces.</p>
<p>Une fois votre interface configur&eacute;e, vous devriez &ecirc;tre capable 
  de cr&eacute;er une connexion pptp avec la commande : </p>

<ul><pre>
# <strong>/usr/local/sbin/pptp 10.0.0.138 &</strong>
</pre></ul>

<p>Puisque que nous utilisons le ppp(8) fourni avec OpenBSD, deux programmes sont 
  d&eacute;marr&eacute;s. Vous pouvez arr&ecirc;ter pptp en &quot;tuant&quot; 
  ces deux programmes : </p>
<ul><pre>
# <strong>kill -9 [pid of pppd]</strong>
% <strong>kill -9 [pid of pptp]</strong>
</pre></ul>

<p>Il est recommand&eacute; d'ouvrir <tt>/var/log/messages</tt> dans un autre 
  terminal, pour tracer d'&eacute;ventuels probl&egrave;mes.</p>
<ul>
<pre>
# <strong>tail -f /var/log/messages</strong>
</pre></ul>
<p></p>

<p>Nous vous sugg&eacute;rons aussi de mettre la commande de d&eacute;marrage 
  dans <i>/etc/rc.local</i> pour vous connecter automatiquement au d&eacute;marrage.</p>
<p> <font color= "#0000e0"> <a href= "index.html">[Retour &agrave; l'Index G&eacute;n&eacute;ral]</a> 
  <a href= "faq5.html">[Vers la Section 5.0 - Configuration du noyau]</a> <a href= "faq7.html">[Vers 
  la Section 7.0 - Param&eacute;trage du clavier]</a> </font> </p>

<p>
<hr>
<a href= "index.html"><img height= "24" width= "24" src= "../../images/back.gif" border= "0" alt= "[back]"></a> 
<a href= "mailto:www@openbsd.org">www@openbsd.org</a> <br>
<small>Originally [OpenBSD: faq6.html,v 1.133 2002/05/23 13:10:11 dhartmei Exp]<br>
$Translation: faq6.html,v 1.16 2003/05/12 12:00:54 saad Exp $<br>
$OpenBSD: faq6.html,v 1.6 2003/05/12 19:07:12 jufi Exp $ </small> 
</body>
</html>
