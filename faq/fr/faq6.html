<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>6 - Le r&eacute;seau</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name= "resource-type" content= "document">
<meta name= "description"   content= "the OpenBSD FAQ page">
<meta name= "keywords"      content= "openbsd,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1998-2004 by OpenBSD.">
</head>

<body bgcolor="#ffffff" text="#000000">
<!-- passes validator.w3.org, please keep it this way -->

<img alt="[OpenBSD]" height=30 width=141 src="../../images/smalltitle.gif">
<p>
<font color="#0000e0">
<a href="index.html">[Index de la FAQ]</a>
<a href="faq5.html">[Section 5 - Construire le Syst&egrave;me &agrave; partir des Sources]</a>
<a href="../faq7.html">[Section 7 - Contr&ocirc;les du clavier et de l'affichage]</a></font>

<h1><font color="#e00000">6 - Le r&eacute;seau</font></h1>
<!-- UNCOMMENT ONLY WHEN THE FILE IS OUT OF SYNC

<hr>
<p>
<b><font color="#e00000">Remarque Importante :</font></b> Le contenu de
   ce fichier est obsol&egrave;te. Consultez la version anglaise 
   <a href="../faq6.html">ici</a> pour des informations &agrave; jour.

<p>
Si vous souhaitez contribuez &agrave; l'effort de traduction,
pri&egrave;re de consulter
<a href="../../fr/translation.html">la page de traduction</a>.

-->
<hr>

<p>
<h3>Table des mati&egrave;res</h3>
<ul>
<li><a href= "#Intro" >6.1 - Avant d'aller plus loin</a>
<li><a href= "#Setup" >6.2 - Configuration initiale du r&eacute;seau</a>
<li><a href= "#PF"    >6.3 - Comment filtrer et utiliser un pare-feu sous
OpenBSD ?</a>
<li><a href= "#DHCP"  >6.4 - Protocole d'attribution dynamique des adresses
(DHCP)</a>
<li><a href= "#PPP"   >6.5 - Protocole Point &agrave; Point (PPP)</a>
<li><a href= "#Tuning">6.6 - Optimisation des param&egrave;tres
r&eacute;seau</a>
<li><a href= "#NFS"   >6.7 - Utilisation de NFS</a>
<li><a href= "#PPTP"  >6.8 - Mise en place d'une connexion PPTP sous OpenBSD</a>
<li><a href= "#Bridge">6.9 - Mise en place d'un pont ("bridge") avec OpenBSD</a>
<li><a href= "#PXE"   >6.10 - Comment d&eacute;marrer en utilisant PXE ?</a>
</ul>

<hr>

<p>
<a name="Intro"></a>
<h2>6.1 - Avant d'aller plus loin</h2>

<p>
Afin de permettre une meilleure compr&eacute;hension de ce document, vous
devriez lire et assimiler au moins partiellement la section <a
href="faq5.html">Construire le Syst&egrave;me &agrave; partir des Sources</a> de
la FAQ ainsi que le manuel <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a> et <a href=
"http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&amp;sektion=1">netstat(1)
</a>.

<p>
Si vous &ecirc;tes administrateur de r&eacute;seau et que vous mettez en place
des protocoles de routage, si vous utilisez OpenBSD en tant que routeur, ou si
vous souhaitez en savoir plus sur les r&eacute;seaux IP, vous devriez lire "<a
href="http://www.3com.com/other/pdfs/infra/corpinfo/en_US/501302.pdf">
Understanding IP Addressing</a>" (Comprendre l'adressage IP). Il s'agit d'un
excellent document. Vous pouvez vous appuyer sur celui-ci afin de vous aider
&agrave; travailler sur les r&eacute;seaux IP, surtout si vous en avez un ou
plusieurs sous votre responsabilit&eacute;.

<p>
Si vous travaillez sur des applications telles que des serveurs web, des
serveurs ftp et des serveurs de messagerie, vous pourriez
b&eacute;n&eacute;ficier de la <a
href="http://www.rfc-editor.org/rfc.html">lecture des RFCs</a>. A priori, vous
ne pourrez pas toutes les lire. Choisissez les sujets qui vous
int&eacute;ressent ou les technologies que vous utilisez sur votre
r&eacute;seau. Lisez-les et voyez comment ces technologies fonctionnent. Les
RFCs standardisent beaucoup (plusieurs milliers) de protocoles Internet et la
fa&ccedil;on dont ils sont cens&eacute;s fonctionner.

<p>
<a name="Setup"></a>
<h2>6.2 - Configuration initiale du r&eacute;seau</h2>

<p>
<a name="Setup.1"></a>
<h3>6.2.1 - Identifier et configurer vos interfaces r&eacute;seau</h3>

<p>
Pour commencer, vous devez d'abord identifier votre interface r&eacute;seau.
Sous OpenBSD, les interfaces sont nomm&eacute;es &agrave; partir du type de la
carte r&eacute;seau, pas du type de la connexion. Vous pouvez voir
l'initialisation de votre carte pendant la proc&eacute;dure de d&eacute;marrage,
ou apr&egrave;s celle-ci en utilisant la commande <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dmesg&amp;sektion=8">dmesg(8)
</a>. Vous avez aussi la possibilit&eacute; de voir votre carte r&eacute;seau
gr&acirc;ce &agrave; l'utilisation de la commande <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a>. Voici par exemple la sortie de la commande dmesg pour une carte
Intel Fast Ethernet qui utilise le nom de p&eacute;riph&eacute;rique fxp.

<blockquote><pre>
fxp0 at pci0 dev 10 function 0 "Intel 82557" rev 0x0c: irq 5, address
00:02:b3:2b:10:f7
inphy0 at fxp0 phy 1: i82555 10/100 media interface, rev. 4
</pre></blockquote>

<p>
Si vous ne connaissez pas le nom du p&eacute;riph&eacute;rique associ&eacute;
&agrave; votre carte, regardez dans la liste des <a
href="../../fr/plat.html">plates-formes actuellement support&eacute;es</a> par votre
architecture. Vous pourrez y trouver le nom des cartes les plus courantes et
leur &eacute;quivalent sous OpenBSD. Ajoutez au nom alphab&eacute;tique du
p&eacute;riph&eacute;rique (par exemple fxp) le num&eacute;ro assign&eacute; par
le noyau et vous aurez le nom de votre interface (par exemple fxp0).

<p>
Vous pouvez conna&icirc;tre quelles interfaces r&eacute;seaux ont
&eacute;t&eacute; identifi&eacute;es &agrave; l'aide de l'utilitaire <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a>. La commande suivante montrera toutes les interfaces
r&eacute;seau d'un syst&egrave;me. Cet exemple montre qu'il n'y a qu'une seule
interface ethernet physique: <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp&amp;sektion=4">fxp(4)</a>
.

<blockquote><pre>
$ <strong>ifconfig -a</strong>
lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 33224
        inet 127.0.0.1 netmask 0xff000000
        inet6 ::1 prefixlen 128
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x5
lo1: flags=8008&lt;LOOPBACK,MULTICAST&gt; mtu 33224
fxp0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        address: 00:04:ac:dd:39:6a
        media: Ethernet autoselect (100baseTX full-duplex)
        status: active
        inet 10.0.0.38 netmask 0xffffff00 broadcast 10.0.0.255
        inet6 fe80::204:acff:fedd:396a%fxp0 prefixlen 64 scopeid 0x1
pflog0: flags=0&lt;&gt; mtu 33224
pfsync0: flags=0&lt;&gt; mtu 2020
sl0: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt; mtu 296
sl1: flags=c010&lt;POINTOPOINT,LINK2,MULTICAST&gt; mtu 296
ppp0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500
ppp1: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500
tun0: flags=10&lt;POINTOPOINT&gt; mtu 3000
tun1: flags=10&lt;POINTOPOINT&gt; mtu 3000
enc0: flags=0&lt;&gt; mtu 1536
bridge0: flags=0&lt;&gt; mtu 1500
bridge1: flags=0&lt;&gt; mtu 1500
vlan0: flags=0&lt;&gt; mtu 1500
        address: 00:00:00:00:00:00
vlan1: flags=0&lt;&gt; mtu 1500
        address: 00:00:00:00:00:00
gre0: flags=9010&lt;POINTOPOINT,LINK0,MULTICAST&gt; mtu 1450
carp0: flags=0&lt;&gt; mtu 1500
carp1: flags=0&lt;&gt; mtu 1500
gif0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif1: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif2: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
gif3: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
</pre></blockquote>

<p>
Comme vous pouvez le voir, &agrave; ce point <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a> nous fourni beaucoup plus d'informations que n&eacute;cessaire.
Mais nous pouvons tout de m&ecirc;me voir notre interface. Dans l'exemple
pr&eacute;c&eacute;dent, la carte est d&eacute;ja configur&eacute;e. Ceci est
&eacute;vident de part la pr&eacute;sence d'une configuration r&eacute;seau IP
pour fxp0, &agrave; savoir &quot;inet 10.0.0.38 netmask 0xffffff00 broadcast
10.0.0.255&quot;. Les indicateurs <strong>UP</strong> et
<strong>RUNNING</strong> sont &eacute;galement pr&eacute;sents.

<p>
Finalement, vous noterez que d'autres interfaces sont activ&eacute;es par
d&eacute;faut. Il s'agit d'interfaces virtuelles servant diff&eacute;rentes
fonctions. Les manuels suivants les d&eacute;crivent:

<ul>
<!-- XXXrelease -->
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=lo&amp;sektion=4">lo</a>
 - Interface "Loopback"
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pflog&amp;sektion=4&amp;manpa
th=OpenBSD+3.5">pflog</a>
 - Interface d'enregistrement du filtre de paquet (PF)
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=sl&amp;sektion=4">sl</a>
 - Interface SLIP (protocole Internet sur ligne s&eacute;rie)
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=4">ppp</a>
 - Protocole point &agrave; point
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=tun&amp;sektion=4">tun</a>
 - Interface de tunnel
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=enc&amp;sektion=4">enc</a>
 - Interface d'encapsulation
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4">bridge
</a>
 - Interface de pont Ethernet
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=vlan&amp;sektion=4">vlan</a>
 - Interface d'encapsulation EEE 802.1Q
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=gre&amp;sektion=4">gre</a>
 - Interface d'encapsulation GRE/MobileIP
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=gif&amp;sektion=4">gif</a>
 - Interface g&eacute;n&eacute;rique de tunnel IPv4/IPv6
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=carp&amp;sektion=4">carp</a>
 - Interface du protocole de redondance d'adresse (CARP)
</ul>

<p>
Si votre interface n'est pas configur&eacute;e, la premi&egrave;re chose
&agrave; faire est de cr&eacute;er le fichier <i>/etc/hostname.xxx</i>,
o&ugrave; xxx repr&eacute;sente le nom de votre interface. A partir des
informations des exemples pr&eacute;c&eacute;dents, le nom du fichier sera
<i>/etc/hostname.fxp0</i>. Le format de ce fichier est simple:<br>

<blockquote><pre>
address_family address netmask broadcast [autres options]
</pre></blockquote>

(Beaucoup plus d'informations sur la syntaxe de ce fichier sont disponibles dans
le manuel <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5">
hostname.if(5)</a>.)

<p>
Un fichier de configuration typique pour une interface IPv4 ressemblera
&agrave;:

<blockquote><pre>
$ <strong>cat /etc/hostname.fxp0</strong>
inet 10.0.0.38 255.255.255.0 NONE
</pre></blockquote>

<p>
Vous pouvez &eacute;galement sp&eacute;cifier le type de media d'une connexion
Ethernet pour, par exemple, forcer le mode 100baseTX full-duplex.

<blockquote><pre>
inet 10.0.0.38 255.255.255.0 NONE media 100baseTX mediaopt full-duplex
</pre></blockquote>

<p>
(Bien entendu, vous ne devriez jamais forcer le mode full duplex &agrave; moins
que les deux extr&eacute;mit&eacute;s de la connexion ne soient
configur&eacute;es ainsi ! Si ce n'est pour des besoins sp&eacute;cifiques, la
configuration du type de media n'est pas n&eacute;cessaire.)

<p>
Vous pouvez aussi vouloir utiliser des indicateurs sp&eacute;cifiques &agrave;
une certaine interface. Le format du fichier hostname ne change que tr&egrave;s
peu.

<blockquote><pre>
$ <strong>cat /etc/hostname.vlan0</strong>
inet 172.21.0.0 255.255.255.0 NONE vlan 2 vlandev fxp1
</pre></blockquote>

<p>
La prochaine &eacute;tape consiste &agrave; d&eacute;finir votre passerelle par
d&eacute;faut. Pour ce faire, renseignez simplement le fichier
<i>/etc/mygate</i> avec l'adresse IP de votre passerelle. Ceci permettra de
configurer automatiquement votre route par d&eacute;faut au d&eacute;marrage. A
pr&eacute;sent, vous pouvez indiquer l'adresse de vos serveurs de noms et
renseigner le fichier <i>/etc/hosts</i> (voir la page de manuel <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=hosts&amp;sektion=5">hosts(5)
</a>). Pour configurer vos serveurs de noms, vous devez cr&eacute;er un fichier
nomm&eacute; <i>/etc/resolv.conf</i>. Vous pouvez en savoir plus sur le format
de ce fichier dans la page de manuel <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=resolv.conf&amp;sektion=5">
resolv.conf(5)</a>. Voici un exemple d'utilisation standard. Dans cet exemple,
vos serveurs de noms sont 125.2.3.4 et 125.2.3.5. Vous faites &eacute;galement
partie du domaine &quot;example.com&quot;.

<blockquote><pre>
$ <strong>cat /etc/resolv.conf</strong>
search example.com
nameserver 125.2.3.4
nameserver 125.2.3.5
lookup file bind
</pre></blockquote>

<p>
A pr&eacute;sent, vous pouvez soit red&eacute;marrer, soit lancer le script
<strong>/etc/netstart</strong>. Vous pouvez l'ex&eacute;cuter simplement en
tapant (en tant que root):

<blockquote><pre>
# <strong>sh /etc/netstart</strong>
writing to routing socket: File exists
add net 127: gateway 127.0.0.1: File exists
writing to routing socket: File exists
add net 224.0.0.0: gateway 127.0.0.1: File exists
</pre></blockquote>

<p>
Notez que plusieurs erreurs sont apparues. En ex&eacute;cutant ce script, vous
reconfigurez certaines choses qui le sont d&eacute;j&agrave;. De fait, certaines
routes sont d&eacute;ja pr&eacute;sentes dans la table de routage du noyau. A
pr&eacute;sent, votre syst&egrave;me devrait &ecirc;tre en &eacute;tat de
fonctionnement. Une nouvelle fois, vous pouvez v&eacute;rifier que votre
interface a &eacute;t&eacute; correctement configur&eacute;e avec <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a>. Vous pouvez &eacute;galement v&eacute;rifier vos routes via <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=netstat&amp;sektion=1">
netstat(1)</a> ou <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=route&amp;sektion=8">route(8)
</a>. Si vous avez des probl&egrave;mes de routage, vous pouvez utiliser
l'option -n de la commande route(8) qui affichera l'adresse IP plut&ocirc;t que
d'effectuer une requ&ecirc;te DNS et d'afficher le nom d'h&ocirc;te. Voici un
exemple qui vous permettra de voir vos tables de routage en utilisant ces deux
programmes.

<blockquote><pre>
$ <strong>netstat -rn</strong>
Routing tables

Internet:
Destination        Gateway            Flags     Refs     Use    Mtu  Interface
default            10.0.0.1           UGS         0       86      -  fxp0
127/8              127.0.0.1          UGRS        0        0      -  lo0
127.0.0.1          127.0.0.1          UH          0        0      -  lo0
10.0.0/24          link#1             UC          0        0      -  fxp0
10.0.0.1           aa:0:4:0:81:d      UHL         1        0      -  fxp0
10.0.0.38          127.0.0.1          UGHS        0        0      -  lo0
224/4              127.0.0.1          URS         0        0      -  lo0

Encap:
Source             Port  Destination        Port  Proto SA(Address/SPI/Proto)

$ <strong>route show</strong>
Routing tables

Internet:
Destination      Gateway            Flags
default          10.0.0.1           UG
127.0.0.0        LOCALHOST          UG
localhost        LOCALHOST          UH
10.0.0.0         link#1             U
10.0.0.1         aa:0:4:0:81:d      UH
10.0.0.38        LOCALHOST          UGH
BASE-ADDRESS.MCA LOCALHOST          U
</pre></blockquote>

<p>
<a name="Setup.2"></a>
<h3>6.2.2 - Mettre en place une passerelle OpenBSD</h3>

<p>
Voici les informations n&eacute;cessaires &agrave; la mise en place d'une
passerelle OpenBSD (appel&eacute; aussi routeur). Si vous devez installer
OpenBSD pour en faire un routeur Internet, nous vous sugg&eacute;rons de lire
les instructions sur la mise en place du filtre de paquets (plus loin) afin de
bloquer le trafic non-autoris&eacute;. Avec le peu de disponibilit&eacute;
d'adresses <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ip&amp;sektion=4">IPv4</a> de
la part des fournisseurs d'acc&egrave;s &agrave; Internet ainsi que des
registres Internet r&eacute;gionaux, vous pourriez vouloir vous renseigner sur
la translation d'adresses (NAT) afin d'&eacute;conomiser votre adressage IP.

<p>
Le noyau GENERIC est d&eacute;ja configur&eacute; pour permettre le routage IP,
mais celui-ci doit &ecirc;tre explicitement activ&eacute;. Vous pouvez l'activer
avec l'utilitaire <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">
sysctl(8)</a>. Afin d'autoriser le routage de fa&ccedil;on permanente,
&eacute;ditez le fichier <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl.conf&amp;sektion=5">
/etc/sysctl.conf</a> et ajoutez-y la ligne suivante.

<blockquote><pre>
net.inet.ip.forwarding=1
</pre></blockquote>

<p>
Pour prendre en compte ce changement sans red&eacute;marrer, vous utiliserez
directement l'utilitaire <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">
sysctl(8)</a>. Souvenez-vous que ce changement ne sera pas sauvegard&eacute; au
red&eacute;marrage et que vous devrez &ecirc;tre root pour utiliser cette
commande.

<blockquote><pre>
# <strong>sysctl net.inet.ip.forwarding=1</strong>
net.inet.ip.forwarding: 0 -&gt; 1
</pre></blockquote>

<p>
A pr&eacute;sent, modifiez les routes sur les h&ocirc;tes aux deux
extr&eacute;mit&eacute;s. Il existe beaucoup d'autres usages d'OpenBSD en tant
que routeur avec l'aide de programmes comme <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=routed&amp;sektion=8">
routed(8)</a>, <a href="http://www.gated.org">gated</a>, <a
href="http://www.mrtd.net">mrtd</a>, et <a
href="http://www.zebra.org">zebra</a>. Sous OpenBSD, zebra, gated et mrtd sont
disponibles en tant que ports. OpenBSD supporte diff&eacute;rentes interfaces
T1, HSSI, ATM, FDDI, Ethernet, et s&eacute;rie (PPP/SLIP).

<p>
<a name="Setup.3"></a>
<h3>6.2.3 - Configurer les alias sur une interface</h3>

<p>
OpenBSD poss&egrave;de un m&eacute;canisme simple pour la mise en place d'alias
IP sur une interface. Pour ce faire, il suffit d'&eacute;diter le fichier <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=hostname.if&amp;sektion=5">
<i>/etc/hostname.&lt;if&gt;</i></a>. Ce fichier est lu au boot par le script <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc&amp;sektion=8">/etc/rc(8)
</a> faisant partie de la s&eacute;quence de d&eacute;marrage <a
href="faq10.html#rc">rc</a>. Admettons par exemple qu'un utilisateur utilise
l'interface <b>dc0</b> et se trouve sur le r&eacute;seau 192.168.0.0. Autres
informations importantes:

<ul>
<li>l'adresse IP pour dc0 est 192.168.0.2
<li>le masque de sous-r&eacute;seau est 255.255.255.0
</ul>

<p>
Notes sur les alias. Sous OpenBSD, vous utilisez le nom de l'interface
uniquement. Il n'y a pas de diff&eacute;rence entre le premier et le second
alias. A la diff&eacute;rence d'autres syst&egrave;mes d'exploitation, OpenBSD
ne s'y r&eacute;f&egrave;re pas en tant que dc0:0, dc0:1. Si vous vous
r&eacute;f&eacute;rez &agrave; une adresse IP d'alias avec ifconfig ou si vous
ajoutez un alias, soyez s&ucirc;r d'utiliser la commande "<tt>ifconfig int
alias</tt>" au lieu de "<tt>ifconfig int</tt>". Vous pouvez supprimer les alias
en utilisant "<tt>ifconfig int delete</tt>".

<p>
En admettant que vous utilisiez plusieurs adresses avec alias sur le m&ecirc;me
sous-r&eacute;seau IP, le masque correspondant &agrave; chaque alias devient
255.255.255.255. Il n'est pas n&eacute;cessaire d'utiliser le masque
correspondant &agrave; l'adresse IP primaire de l'interface. Dans cet exemple,
<i>/etc/hostname.dc0</i>, deux alias sont configur&eacute;s pour le
p&eacute;riph&eacute;rique dc0, qui lui-m&ecirc;me poss&egrave;de l'adresse
192.168.0.2 avec un masque de 255.255.255.0.

<blockquote><pre>
# <b>cat /etc/hostname.dc0</b>
inet 192.168.0.2 255.255.255.0 media 100baseTX
inet alias 192.168.0.3 255.255.255.255
inet alias 192.168.0.4 255.255.255.255
</pre></blockquote>

<p>
Apr&egrave;s avoir &eacute;dit&eacute; ce fichier, il suffit de
red&eacute;marrer pour que les changements prennent effet. Mais vous pouvez
aussi cr&eacute;er les alias &agrave; la main en utilisant l'utilitaire <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a>. Pour cr&eacute;er le premier alias, lancez la commande
suivante:

<blockquote><pre>
# <b>ifconfig dc0 inet alias 192.168.0.3 netmask 255.255.255.255</b>
</pre></blockquote>

<p>
Pour voir les alias, utilisez la commande suivante:

<blockquote><pre>
$ <b>ifconfig -A</b>
dc0: flags=8863&lt;UP,BROADCAST,NOTRAILERS,RUNNING,SIMPLEX,MULTICAST&gt;
        media: Ethernet manual
        inet 192.168.0.2  netmask 0xffffff00 broadcast 192.168.0.255
        inet 192.168.0.3 netmask 0xffffffff broadcast 192.168.0.3
</pre></blockquote>


<p>
<a name="NAT"></a>
<a name="PF"></a>
<h2>6.3 - Comment filtrer et utiliser un pare-feu sous OpenBSD ?</h2>
Sous OpenBSD, le filtrage du trafic TCP/IP ainsi que la translation d'adresses
(NAT) est pris en charge par "Packet Filter" (filtre de paquet ; auquel nous
nous referrerons &agrave; pr&eacute;sent sous le nom de PF) . PF est aussi
capable de normaliser et de traiter le trafic TCP/IP, d'offrir une gestion de
la bande passante et une prioritarisation des paquets ainsi que d'&ecirc;tre
utilis&eacute; dans la cr&eacute;ation de puissants et flexibles pare-feu. Tout
ceci est d&eacute;crit dans le <a href="../pf/fr/index.html"><b>Guide de l'Utilisateur
PF</b></a>.


<p> 
<a name= "DHCP"></a>
<h2>6.4 - DHCP</h2> 

<p>
<h3>6.4.1 Client DHCP</h3>

<p>
Pour utiliser le client DHCP <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhclient&amp;sektion=8">
dhclient(8)</a> inclus avec OpenBSD, &eacute;ditez le fichier
<tt>/etc/hostname.xl0</tt>  (sous-entendu que l'interface Ethernet soit xl0. La
v&ocirc;tre pouvant &ecirc;tre aussi bien ep0 que fxp0 ou encore autre chose ! )
Tout ce que vous avez besoin d'&eacute;crire dans ce fichier est '<tt>dhcp</tt>'

<pre>
# <strong>echo dhcp &gt;/etc/hostname.xl0</strong>
</pre>

<p>
Ceci aura pour effet de d&eacute;marrer automatiquement le client DHCP au
d&eacute;marrage. OpenBSD se verra attribuer son adresse IP, sa passerelle par
d&eacute;faut et ses serveurs de noms (DNS) &agrave; partir du serveur DHCP.

<p>
Si vous souhaitez d&eacute;marrer le client dhcp &agrave; partir de la ligne de
commande, v&eacute;rifiez bien que /etc/dhclient.conf existe, puis lancez la
commande:

<pre>
# <strong>dhclient fxp0</strong>
</pre>

<p>
O&ugrave; fxp0 repr&eacute;sente l'interface que vous voulez configurer par
dhcp.

<p>
Peu importe la fa&ccedil;on dont vous d&eacute;marrez dhclient, vous pouvez
&eacute;diter /etc/dhclient.conf afin de ne <b>pas</b> mettre &agrave; jour vos
DNS &agrave; l'aide du serveur dhcp en d&eacute;commentant les lignes 'request'
(il y a des exemples de configurations, mais vous devez les d&eacute;commenter
afin de changer le comportement par d&eacute;faut de dhclient.)

<pre>
request subnet-mask, broadcast-address, time-offset, routers,
      domain-name, domain-name-servers, host-name, lpr-servers, ntp-servers;
</pre>

<p>
et <b>supprimez</b> domain-name-servers. Bien s&ucirc;r, vous pouvez
&eacute;galement supprimer hostname ainsi que d'autres options.

<p>
<h3>6.4.2 Serveur DHCP</h3>

<p>
Pour utiliser OpenBSD en tant que serveur DHCP <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd&amp;sektion=8">dhcpd(8)
</a>, &eacute;ditez le fichier <tt>/etc/rc.conf</tt>. Changez la ligne
<tt>dhcpd_flags=NO</tt> en <tt>dhcpd_flags="-q"</tt>. Placez le nom des
interfaces sur lesquelles vous souhaitez que le serveur &eacute;coute, dans le
fichier <tt>/etc/dhcpd.interfaces</tt>.

<pre>
     # <b>echo xl1 xl2 xl3 &gt;/etc/dhcpd.interfaces</b>
</pre>

<p>
Ensuite, &eacute;ditez <tt>/etc/dhcpd.conf</tt>. Les options sont plut&ocirc;t
explicites.

<pre>
        option  domain-name "example.com";
        option  domain-name-servers 192.168.1.3, 192.168.1.5;

        subnet 192.168.1.0 netmask 255.255.255.0 {
                option routers 192.168.1.1;

                range 192.168.1.32 192.168.1.127;
        }
</pre>

<p>
Ceci indique &agrave; vos clients DHCP que le domaine &agrave; ajouter aux
requ&ecirc;tes DNS est example.com (ainsi, si un utilisateur lance la commande
'telnet joe', il sera renvoy&eacute; vers joe.example.com). Les clients auront
comme serveurs DNS 192.168.1.3 et 192.168.1.5. Pour les h&ocirc;tes
pr&eacute;sents sur le sous-r&eacute;seau correspondant &agrave; l'interface du
serveur OpenBSD, &agrave; savoir dans la plage 192.168.1.0/24, ils se verront
attribuer une adresse IP entre 192.168.1.32 et 192.168.1.127. Leur passerelle
par d&eacute;faut sera 192.168.1.1.

<p>
Si vous souhaiter d&eacute;marrez dhcpd(8) &agrave; partir de la ligne de
commandes, une fois /etc/dhcpd.conf configur&eacute;, tapez:

<pre>
     # <b>touch /var/db/dhcpd.leases</b>
     # <b>dhcpd -q fxp0</b>
</pre>

<p>
La ligne incluant <tt>touch</tt> est n&eacute;cessaire afin de cr&eacute;er un
fichier <tt>dhcpd.leases</tt> vide avant que dhcpd(8) ne d&eacute;marre.
Les <a href="faq10.html#rc">scripts de d&eacute;marrage</a> d'OpenBSD se
chargeront de cr&eacute;er ce fichier au boot, mais si vous lancez dhcpd(8)
manuellement, vous devez au pr&eacute;alable cr&eacute;er ce fichier.
<tt>fxp0</tt> repr&eacute;sente l'interface sur laquelle vous voulez
r&eacute;pondre aux requ&ecirc;tes DHCP. L'option <tt>-q</tt> fait
d&eacute;marrer le serveur dhcpd(8) en mode silencieux, sinon celui-ci est
tr&egrave;s verbeux.

<p>
Si vous pr&eacute;voyez de servir DHCP &agrave; des machines Windows, pour
pourriez souhaiter donner &agrave; ces clients une adresse de serveur 'WINS'.
Pour ce faire, ajoutez simplement la ligne suivante dans votre fichier
<tt>/etc/dhcpd.conf</tt>:

<pre>
     option    netbios-name-servers    192.168.92.55;
</pre>

<p>
(o&ugrave; <tt>192.168.92.55</tt> est l'adresse IP de votre serveur Windows ou
Samba.) Reportez vous &agrave; <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcp-options&amp;sektion=5">
dhcp-options(5)</a> Si vos clients DHCP ont besoin de plus d'options, reportez
vous au manuel <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcp-options&amp;sektion=5">
dhcp-options(5)</a>.


<p>
<a name="PPP"></a>
<h2>6.5 - PPP </h2>

<p>
Le protocole point &agrave; point est g&eacute;n&eacute;ralement utilis&eacute;
afin de cr&eacute;er une connexion modem vers votre FAI (fournisseur
d'acc&egrave;s &agrave; Internet). Sous OpenBSD, deux solutions existent.

<ul>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pppd&amp;sektion=8">
pppd(8)</a>
 - Qui est l'impl&eacute;mentation noyau du d&eacute;mon ppp.
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8">ppp(8)</a>
 - Qui est l'impl&eacute;mentation ppp en espace utilisateur ("userland"). 
</ul>

<p>
Le premier que nous allons aborder est le d&eacute;mon PPP en espace
utilisateur. Pour commencer, vous aurez besoin de certaines informations
concernant votre FAI. En voici une liste non-exhaustive.

<ul>
<li>Le num&eacute;ro de t&eacute;l&eacute;phone de votre FAI
<li>Votre serveur de noms
<li>Votre nom d'utilisateur et votre mot de passe
<li>Votre passerelle
</ul>

<p>
Certaines de ces options ne sont pas obligatoires mais elles vous aideront
&agrave; la mise en place de ppp. Le fichier de configuration du d&eacute;mon
PPP est <a
href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.conf.sample">
/etc/ppp/ppp.conf</a>. Selon votre situation, les nombreux fichiers
pr&eacute;sents dans <i>/etc/ppp</i> peuvent vous aider &agrave; la mise en
place de votre configuration. Vous devriez jeter un oeil &agrave; ce
r&eacute;pertoire.

<p>
Si vous n'utilisez pas le noyau GENERIC, soyez s&ucirc;r d'inclure cette ligne
dans le fichier de configuration de votre noyau:

<blockquote><pre><strong>
pseudo-device   tun
</strong></pre></blockquote>

<p>
<h3>Configuration initiale - pour PPP(8)</h3>

<p>
La configuration initiale de PPP n&eacute;cessite l'&eacute;dition du fichier
<i>/etc/ppp/ppp.conf</i>. Ce fichier n'existe pas par d&eacute;faut, mais vous
pouvez vous inspirer du fichier <i>/etc/ppp/ppp.conf.sample</i>  afin de
cr&eacute;er votre propre <i>ppp.conf</i>. Je commencerai par une configuration
simple et g&eacute;n&eacute;ralement tr&egrave;s employ&eacute;e. Voici
rapidement un petit fichier <i>ppp.conf</i> d&eacute;finissant quelques valeurs
par d&eacute;faut:

<blockquote>
<pre>
default:
set log Phase Chat LCP IPCP CCP tun command     
set device /dev/cua01                           
set speed 115200     
set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \"\" AT OK-AT-OK ATE1Q0 OK
\\dATDT\\T TIMEOUT 40 CONNECT"
</pre>
</blockquote>

<p>
La section d&eacute;finie par le marqueur <tt>default:</tt> sera
ex&eacute;cut&eacute;e &agrave; chaque fois. Cette section recense des
informations importantes. &quot;set log&quot; d&eacute;fini le niveau de
verbosit&eacute; des logs. Il peut &ecirc;tre chang&eacute;:
r&eacute;f&eacute;rez-vous au manuel de <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8">ppp(8)</a>
pour plus d'informations concernant les niveaux d'enregistrement des
diff&eacute;rents &eacute;v&ecirc;nements. Le p&eacute;riph&eacute;rique
utilis&eacute; est indiqu&eacute; par &quot;set device&quot;. Il s'agit du port
sur lequel est pr&eacute;sent notre modem. Dans cet exemple, le modem est
branch&eacute; sur le port com 2. Ainsi, le port com 1 sera indiqu&eacute; par
<i>/dev/cua00</i>. La vitesse de la connexion est pr&eacute;cis&eacute;e par
&quot;set speed&quot; et &quot;set dial&quot; renseigne nos param&egrave;tres de
num&eacute;rotation. Avec ceci, nous pouvons changer l'expiration ("timeout") de
la connexion, etc. Ceci &eacute;tant, cette ligne ne devrait pas tellement
varier.

<p>
Maintenant, nous pouvons avancer et configurer les informations
sp&eacute;cifiques &agrave; notre FAI. Pour ce faire, nous allons rajouter une
autre section en-dessous de <b>default:</b>. Le marqueur d&eacute;finissant
cette nouvelle section pourra &ecirc;tre ce que vous d&eacute;sirez - le plus
simple &eacute;tant d'utiliser le nom de votre FAI. Ici, nous utiliserons
<b>myisp:</b> pour indiquer le commencement de la section correspondant &agrave;
notre FAI. Voici une configuration simple contenant le n&eacute;cessaire afin de
nous connecter:

<blockquote>
<pre>
myisp:
set phone 1234567   
set login "ABORT NO\\sCARRIER TIMEOUT 5 ogin:--ogin: ppp word: ppp"
set timeout 120   
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
add default HISADDR 
enable dns
</pre>
</blockquote>

<p>
Ici nous avons fourni les &eacute;l&eacute;ments essentiels concernant ce FAI.
La premi&egrave;re option, &quot;set phone&quot;, donne le num&eacute;ro de
t&eacute;l&eacute;phone du FAI. Nos options d'ouverture de session sont
renseign&eacute;es par &quot;set login&quot;. Notre "timeout" est &eacute;gal
&agrave; 5 ; ce qui signifie que notre tentative de connexion expirera
apr&egrave;s 5 secondes si aucune porteuse n'est trouv&eacute;e. Dans le cas
contraire, &quot;login:&quot; sera envoy&eacute; avec notre nom d'utilisateur et
notre mot de passe.

<p>
Dans cet exemple, notre nom d'utilisateur est: ppp ; notre mot de passe est:
ppp. Ces valeurs doivent &ecirc;tre chang&eacute;es. La ligne &quot;set
timeout&quot; permet de couper la connexion apr&egrave;s 120 secondes de
non-utilisation. L'option &quot;set ifaddr&quot; est un peu plus
compliqu&eacute;e. En voici une explication plus compl&ecirc;te.

<blockquote><pre>
set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
</pre></blockquote>

<p>
La ligne pr&eacute;c&eacute;dente se d&eacute;finit avec le format suivant:
&quot;<b>set ifaddr [myaddr[/nn] [hisaddr[/nn] [netmask
[triggeraddr]]]]</b>&quot;. La premi&egrave;re IP d&eacute;signe l'adresse IP
que nous souhaitons nous voir attribuer. Si vous avez une adresse IP statique,
vous devez l'indiquer ici. Dans notre exemple, nous utilisons la notation /0 qui
dit qu'aucun "bit" de cette adresse ne doit forc&eacute;ment correspondre et que
celle-ci peut &ecirc;tre chang&eacute;e. La deuxi&egrave;me adresse IP est celle
du FAI. La troisi&egrave;me option est notre masque de sous-r&eacute;seau, ici
d&eacute;fini &agrave; 255.255.255.0. Si triggeraddr est renseign&eacute;, il
remplacera myaddr comme adresse IP utilis&eacute;e pour la n&eacute;gociation
IPCP initiale. Cependant, seule une adresse incluse dans la gamme d'adressage
correspondant &agrave; myaddr sera accept&eacute;e. Ceci peut &ecirc;tre utile
dans la n&eacute;gociation avec certaines impl&eacute;mentations PPP qui
n'attribuent pas d'adresse IP &agrave; moins que l'initiateur de la connexion ne
demande explicitement l'adresse ``0.0.0.0''.

<p>
L'option suivante &quot;add default HISADDR&quot; attribue comme route par
d&eacute;faut l'adresse IP de votre FAI. Cette entr&eacute;e permet d'ajuster
automatiquement notre route par d&eacute;faut en cas de changement d'adresse IP
de celui-ci. &quot;enable dns&quot; est utilis&eacute; afin de
r&eacute;cup&eacute;rer la liste des serveurs DNS du FAI. N'utilisez PAS cette
option si vous avez votre propre serveur DNS local car ppp emp&ecirc;chera les
requ&ecirc;tes vers celui-ci en rempla&ccedil;ant les lignes "nameserver" de
votre fichier <i>/etc/resolv.conf</i>.

<p>
<h3>Utiliser PPP(8)</h3>

<p>
Maintenant que <i>ppp.conf</i> est configur&eacute;, nous pouvons essayer
d'initier une connexion vers notre FAI. Je d&eacute;taillerai certaines des
options les plus utilis&eacute;es:

<ul>
<li><tt>ppp -auto myisp</tt> - Cette commande lancera ppp, configurera vos
interfaces, vous connectera &agrave; votre FAI et se placera en
arri&egrave;re-plan.
<li><tt>ppp -ddial myisp</tt> - Cette commande est similaire &agrave; -auto mais
si votre connexion est rompue, ppp essayera de se reconnecter automatiquement.
</ul>

<p>
Lancer <i>/usr/sbin/ppp</i> sans options vous placera en mode interactif. A
partir de l&agrave;, vous pouvez int&eacute;ragir directement avec le modem ;
ceci peut &ecirc;tre tr&egrave;s utile pour corriger les erreurs dans votre
fichier <i>ppp.conf</i>.

<p>
<h3>Autres options de ppp(8)</h3>

<p>
Dans certaines situations, vous pourriez avoir besoin de lancer certaines
commandes au lancement ou &agrave; la coupure de votre connexion. Si vous vous
trouvez dans cette situation, il existe deux fichiers que vous pouvez
cr&eacute;er: <i>/etc/ppp/ppp.linkup</i> et <i>/etc/ppp/ppp.linkdown</i>. Des
exemples de configuration sont disponibles ici:

<ul>
<li><a
href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkup.sample">
ppp.linkup</a>
<li><a
href="http://www.openbsd.org/cgi-bin/cvsweb/src/etc/ppp/ppp.linkdown.sample">
ppp.linkdown</a>
</ul>

<p>
Plus d'informations peuvent &ecirc;tre trouv&eacute;es dans la section <a
href="http://www.freebsd.org/doc/fr_FR.ISO8859-1/books/handbook/userppp.html">
"User PPP" du Manuel de R&eacute;f&eacute;rence ("Handbook") de FreeBSD</a>.


<p>
<a name="Tuning"></a>
<h2>6.6 - Optimisation des param&egrave;tres r&eacute;seau</h2>
<!-- XXXrelease -->

<p>
<h3>6.6.1 - Comment configurer le noyau pour avoir un plus grand nombre d'essais
et augmenter le d&eacute;lai d'expiration des sessions TCP ?</h3>

<p>
G&eacute;n&eacute;ralement, vous utiliserez ceci en cas de probl&egrave;mes de
routage ou de connexion. Bien s&ucirc;r, pour que cette configuration soit la
plus effective, les deux extr&eacute;mit&eacute;s de la connexion doivent
utiliser des valeurs similaires.

<p>
Pour optimiser ceci, utilisez <tt>sysctl</tt> et augmentez les valeurs de:

<pre>
net.inet.tcp.keepinittime
net.inet.tcp.keepidle
net.inet.tcp.keepintvl
</pre>

<p>
Avec sysctl -a, vous pouvez voir les valeurs courantes de ces param&egrave;tres
(ainsi que beaucoup d'autres). Pour en changer un, tapez par exemple
<tt>sysctl net.inet.tcp.keepidle=28800</tt>.

<p>
<h3>6.6.2 - Comment activer les &eacute;missions ("broadcasts") dirig&eacute;es
?</h3>

<p>
Normalement, vous ne devriez pas utiliser ceci. Cette option permet &agrave;
quelqu'un de diriger le trafic vers la ou les adresses "broadcast" des
r&eacute;seaux sur lesquels vous &ecirc;tes connect&eacute; si vous utilisez
OpenBSD en tant que routeur.

<p>
Dans certaines situations, sur des r&eacute;seaux ferm&eacute;s, cette option
peut-&ecirc;tre utile, surtout lors de l'utilisation de vieilles
impl&eacute;mentations du protocole NetBIOS. Il s'agit d'un autre sysctl.
<tt>sysctl net.inet.ip.directed-broadcast=1</tt> active cette option. Lisez la
section sur les <a href="http://www.netscan.org">"smurf attacks"</a> si vous
voulez savoir pourquoi cette option est d&eacute;sactiv&eacute;e par
d&eacute;faut.

<p>
<h3>6.6.3 - Je ne veux pas que le noyau alloue dynamiquement un port
donn&eacute;</h3>

<p>
Il existe &eacute;galement un sysctl pour ceci. D'apr&egrave;s <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=sysctl&amp;sektion=8">
sysctl(8)</a>:

<pre>
D&eacute;finie la liste des ports TCP ne devant pas &ecirc;tre allou&eacute;s
dynamiquement par le noyau. Ceci peut &ecirc;tre utile afin d'&eacute;viter
l'appropriation d'un port sp&eacute;cifique dont un autre programme a besoin
pour fonctionner. Les &eacute;l&eacute;ments list&eacute;s peuvent &ecirc;tre
s&eacute;par&eacute;s par une virgule et/ou un espace.

 #  <strong>sysctl net.inet.tcp.baddynamic=749,750,751,760,761,871</strong>

Il est aussi possible d'ajouter ou de retirer des ports de la liste courante.

 #  <strong>sysctl net.inet.tcp.baddynamic=+748</strong>
 #  <strong>sysctl net.inet.tcp.baddynamic=-871</strong>
</pre>


<p>
<a name="NFS"></a>
<h2>6.7 - Utilisation simple de NFS</h2>

<p>
NFS ("Network File System") est utilis&eacute; afin de partager un
syst&egrave;me de fichiers &agrave; travers un r&eacute;seau. Voici un certain
nombre de manuels &agrave; lire avant la mise en place d'un serveur NFS:

<ul>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=nfsd&amp;sektion=8">nfsd(8)
</a>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=mountd&amp;sektion=8">
mountd(8)</a>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&amp;sektion=5">
exports(5)</a>
</ul>

<p>
Cette section d&eacute;taillera les &eacute;tapes n&eacute;cessaires &agrave; la
mise en oeuvre d'une configuration NFS simple. Cet exemple d&eacute;taille un
serveur et ses clients NFS sur un LAN. Il ne s'agit pas d'&eacute;tudier la
s&eacute;curisation de NFS. Nous assumerons que le filtre de paquets (PF) ou
qu'un autre type de pare-feu est configur&eacute; ain d'emp&ecirc;cher les
acc&egrave;s ext&eacute;rieurs. Si vous autorisez l'acc&egrave;s &agrave; votre
serveur NFS depuis l'ext&eacute;rieur et que vous h&eacute;bergez des
donn&eacute;es sensibles, nous vous conseillons fortement d'utiliser IPsec.
Autrement certaines personnes pourraient voir ce qui transite dans votre trafic
NFS. Quelqu'un pourrait &eacute;galement usurper l'adresse IP que vous autorisez
&agrave; se connecter &agrave; votre serveur NFS. Plusieurs types d'attaques
peuvent en d&eacute;couler. Mais lorsqu'IPsec est correctement configur&eacute;,
il offre une protection contre ces attaques.

<p>
Autre note concernant la s&eacute;curit&eacute;. Ne vous contentez pas juste
d'ajouter un syst&egrave;me de fichiers dans <i>/etc/exports</i> sans mettre en
place une liste recensant les h&ocirc;tes autoris&eacute;s &agrave; se
connecter. Sans une liste d'h&ocirc;tes autoris&eacute;s &agrave; monter un
r&eacute;pertoire particulier, n'importe qui, capable de vous atteindre, sera en
mesure de monter vos syst&egrave;mes de fichiers export&eacute;s par NFS.

<p>
NFS n&eacute;cessite le lancement de <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=portmap&amp;sektion=8">
portmap(8)</a> avant qu'il ne puisse op&eacute;rer. A partir d'OpenBSD 3.2
Portmap(8) est d&eacute;sactiv&eacute; par d&eacute;faut, vous devez donc
l'activer dans <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=rc.conf&amp;sektion=8">
rc.conf(8)</a> en changeant la ligne <tt>portmap</tt> en:

<blockquote><pre>
portmap=YES
</pre></blockquote>
et red&eacute;marrer pour que ce changement prenne effet.

<p>
Cette configurarion consiste en un serveur d'adresse IP <b>10.0.0.1</b>. Ce
serveur n'offrira NFS qu'aux clients pr&eacute;sents sur ce r&eacute;seau. La
premi&egrave;re &eacute;tape pour installer un serveur NFS est de renseigner
votre fichier <i>/etc/exports</i>. Ce fichier liste les syst&egrave;mes de
fichiers que vous souhaitez rendre accessibles par NFS et d&eacute;finit qui peut
y acc&eacute;der. Beaucoup d'options sont disponibles pour l'&eacute;dition de
ce fichier et vous devriez lire la page de manuel <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=exports&amp;sektion=5">
exports(5)</a>. Pour cet exemple, notre fichier <i>/etc/exports</i> ressemblera
&agrave;:

<blockquote><pre>
#
# NFS exports Database
# See exports(5) for more information.  Be very careful, misconfiguration
# of this file can result in your filesystems being readable by the world.
/work -alldirs -ro -network 10.0.0 -mask 255.255.255.0
</pre></blockquote>

<p>
Ceci signifie que le syst&egrave;me de fichiers local <tt>/work</tt> sera
accessible par NFS. L'option <tt>-alldirs</tt> permet au client de monter
n'importe quel r&eacute;pertoire sous le point de montage <tt>/work</tt>.
L'option <tt>-ro</tt> exporte le syst&egrave;me de fichiers en lecture seule.
Les deux derniers arguments sp&eacute;cifient que seuls les clients
pr&eacute;sents dans le r&eacute;seau 10.0.0.0 utilisant un masque de
255.255.255.0 seront autoris&eacute;s &agrave; monter ce syst&egrave;me de
fichiers. Ceci est important pour certains serveurs accessibles sur
diff&eacute;rents r&eacute;seaux.

<p>
Une fois que votre fichier <i>/etc/exports</i> est configur&eacute;, vous pouvez
mettre en place votre serveur NFS. Tout d'abord, v&eacute;rifiez que les options
NFSSERVER &amp; NFSCLIENT sont bien pr&eacute;sentes dans votre fichier de
configuration noyau. (Le noyau GENERIC inclus ces options.) Ensuite, il vous
faut inclure la ligne <tt>nfs_server=YES</tt> dans le fichier
<i>/etc/rc.conf</i>. Ceci aura pour effet de d&eacute;marrer nfsd(8) et
mountd(8) au red&eacute;marrage. A pr&eacute;sent, vous pouvez lancer les
d&eacute;mons manuellement. Ils doivent &ecirc;tre lanc&eacute;s sous root et
vous devez v&eacute;rifier que portmap(8) est bien d&eacute;marr&eacute; sur
votre syst&egrave;me. Voici un exemple de lancement de nfsd(8) servant les
requ&ecirc;tes TCP et UDP et utilisant 4 d&eacute;mons. Vous devriez utiliser un
nombre appropri&eacute; de d&eacute;mons NFS en fonction du nombre maximum de
connexions concurrentes que vous souhaitez servir.

<blockquote><pre>
# <strong>/sbin/nfsd -tun 4</strong>
</pre></blockquote>

<p>
Vous devez non seulement d&eacute;marrer le serveur nfsd(8) mais &eacute;galement
mountd(8). Il s'agit du service qui se charge de passer les requ&ecirc;tes de
montage &agrave; NFS. Pour d&eacute;marrer mountd(8), soyez s&ucirc;r qu'un
fichier mountdtab vide existe puis lancez le d&eacute;mon:

<blockquote><pre>
# <strong>echo -n &gt;/var/db/mountdtab</strong>
# <strong>/sbin/mountd</strong>
</pre></blockquote>

<p>
Si vous faites des changements au fichier /etc/exports alors qu'NFS est
d&eacute;ja en fonction, vous devez en informer mountd ! Lancez-lui simplement
un signal HUP:

<blockquote><pre>
# <strong>kill -HUP `cat /var/run/mountd.pid`</strong>
</pre></blockquote>

<p>
<h3>Statistiques NFS</h3>

<p>
Maintenant, vous pouvez v&eacute;rifier que tous ces d&eacute;mons sont
lanc&eacute;s et enregistr&eacute;s avec RPC. Pour ce faire, utilisez
rpcinfo(8).

<blockquote><pre>
$ <strong>rpcinfo -p 10.0.0.1</strong>
   program vers proto   port
    100000    2   tcp    111  portmapper
    100000    2   udp    111  portmapper
    100005    1   udp    633  mountd
    100005    3   udp    633  mountd
    100005    1   tcp    916  mountd
    100005    3   tcp    916  mountd
    100003    2   udp   2049  nfs
    100003    3   udp   2049  nfs
    100003    2   tcp   2049  nfs
    100003    3   tcp   2049  nfs
</pre></blockquote>

<p>
Dans le cadre d'une utilisation normale, d'autres utilitaires peuvent vous
permettre de voir ce qui se passe au niveau NFS. Un de ces utilitaires est <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=showmount&amp;sektion=8">
showmount(8)</a>, qui permet de voir ce qui est mont&eacute; et par qui. Il
existe aussi nfsstat(8) qui affiche beacoup plus de statistiques. Pour utiliser
showmount(8), essayez la commande <tt>/usr/bin/showmount -a h&ocirc;te</tt>. Par
exemple:

<blockquote><pre>
$ <strong>/usr/bin/showmount -a 10.0.0.1</strong>
All mount points on 10.0.0.1:
10.0.0.37:/work
</pre></blockquote>

<p>
<h3>Monter des syst&egrave;mes de fichiers NFS</h3>

<p>
Les syst&egrave;mes de fichiers NFS doivent &ecirc;tre mont&eacute;s par
mount(8), ou plus pr&eacute;cis&eacute;ment, <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=mount_nfs&amp;sektion=8">
mount_nfs(8)</a>. Pour monter le syst&egrave;me de fichiers <i>/work</i> sur
10.0.0.1 vers le syst&egrave;me de fichiers local <i>/mnt</i>, il vous suffit de
lancer la commande suivante (notez qu'il n'est pas n&eacute;cessaire d'utiliser
une adress IP ; mount r&eacute;soudra les noms d'h&ocirc;tes):

<blockquote><pre>
# <strong>mount -t nfs 10.0.0.1:/work /mnt</strong>
</pre></blockquote>

<p>
Pour que ce syst&egrave;me de fichiers soit mont&eacute; au d&eacute;marrage,
ajoutez la ligne suivante dans votre <i>/etc/fstab</i>:

<blockquote><pre>
10.0.0.1:/work /mnt nfs rw 0 0
</pre></blockquote>

<p>
Il est important que vous utilisiez <tt>0 0</tt> &agrave; la fin de la ligne
afin que votre machine ne lance pas un fsck sur ce syst&egrave;me de fichiers
NFS au boot !!! Les autres options standards, comme noexec, nodev, nosuid
peuvent &ecirc;tre employ&eacute;es lorsqu'elles sont applicables. Par exemple:

<blockquote><pre>
10.0.0.1:/work /mnt nfs rw,nodev,nosuid 0 0
</pre></blockquote>

<p>
Ainsi, aucun p&eacute;riph&eacute;rique ni programme setuid pr&eacute;sent sur
le serveur NFS ne peut compromettre la s&eacute;curit&eacute; du client. Si vous
ne montez pas de programmes que vous souhaitez utiliser sur le client NFS,
ajoutez l'option noexec &agrave; cette ligne.

<p>
<a name="PPTP"></a>
<h2>6.8 - Mise en place d'une connexion PPTP sous OpenBSD</h2>

<p>
<strong>NOTE:</strong> Cette section ne s'applique pas &agrave;
<strong>TOUS</strong> les fournisseurs ADSL, mais beaucoup d'informations
peuvent y &ecirc;tre glan&eacute;es. Cette configuration a &eacute;t&eacute;
confirm&eacute;e comme fonctionnelle pour <a
href="http://www.inode.at">Inode</a>, un fournisseur d'acc&egrave;s autrichien
et <a href="http://www.kpn.nl">KPN</a>, un fournisseur d'acc&egrave;s
hollandais.

<p>
Pour commencer, vous devez installer pptp. Le port est situ&eacute; sous
<i>/usr/ports/net/pptp</i>. Lisez la <a href="faq8.html#Ports">FAQ 8, Qu'est que
l'arborescences des ports ?</a> pour de plus amples renseignements concernant
l'arbre des ports sous OpenBSD.

<p>
Bien qu'il n'ait pas besoin de p&eacute;riph&eacute;rique <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=gre&amp;sektion=4">gre(4)</a>
, PPTP utilise l'encapsulation GRE. Afin de permettre au noyau de recevoir les
paquets encapsul&eacute;s par GRE, lancez la commande suivante:
<blockquote><pre>
# sysctl net.inet.gre.allow=1
</pre></blockquote>
Puis ajoutez la ligne suivante dans votre fichier <i>/etc/sysctl.conf</i>:
<blockquote><pre>
net.inet.gre.allow=1
</pre></blockquote>
Ce qui permettra de sauvegarder ce changement au red&eacute;marrage.

<p>
Une fois le paquetage <b>pptp</b> install&eacute; et le fichier
<i>/etc/sysctl.conf</i> &eacute;dit&eacute;, vous devez renseigner un certain
nombre de fichiers afin de configurer votre connexion. Ce paquetage utilise le
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ppp&amp;sektion=8">ppp(8)</a>
pr&eacute;sent dans OpenBSD, donc si vous &ecirc;tes familier avec l'utilisation
de celui-ci, la mise en place vous semblera similaire.
R&eacute;f&eacute;rez-vous &eacute;galement &agrave; la <a href="#PPP">FAQ 6,
Protocole Point &agrave; Point</a>.

<ul>
<li>1 - /etc/ppp/options
<li>2 - /etc/ppp/pap-secrets
</ul>

<p>
En ce qui concerne le fichier <i>/etc/ppp/options</i>, la configuration suivante
devrait r&eacute;pondre &agrave; la plupart des besoins:

<blockquote><pre>
# <strong>cat /etc/ppp/options</strong>
name "LOGINNAME"
noauth
noipdefault
defaultroute
debug
</pre></blockquote>

<p>
<tt>LOGINNAME</tt> doit &ecirc;tre remplac&eacute; par votre identifiant de
connexion.

<p>
Ins&eacute;rez une ligne similaire &agrave; celle qui suit dans
<i>/etc/ppp/pap-secrets</i>:

<blockquote><pre>
# <strong>cat /etc/ppp/pap-secrets</strong>
LOGINNAME 10.0.0.138 PASSWORD
</pre></blockquote>

<p>
O&ugrave; LOGINNAME repr&eacute;sente votre identifiant de connexion et PASSWORD
votre mot de passe. 10.0.0.138 &eacute;tant l'adresse IP de votre modem au cas
o&ugrave; vous utiliseriez l'ADSL, etc. Faites attention que ce fichier ne soit
accessible que par root et en lecture seule (mode 600).

<p>
<h3>6.8.1 - Assigner une adresse IP &agrave; votre interface</h3>

<p>
Dans l'exemple pr&eacute;c&eacute;dent, votre modem avait une adresse
pr&eacute;configur&eacute;e de 10.0.0.138. Nous devons maintenant assigner une
adresse &agrave; NOTRE interface. Il est pr&eacute;f&eacute;rable d'utiliser une
adresse proche de celle donn&eacute;e à votre MODEM ou l'adresse IP statique
qui vous est assign&eacute;e. Plus d'information sur la mise en place des
interfaces est disponible dans la <a href="#Setup">FAQ 6, Configuration initiale
du r&eacute;seau</a>.

<p>
Une fois votre interface configur&eacute;e, vous devriez &ecirc;tre en mesure de
cr&eacute;er une connexion pptp &agrave; l'aide de la commande:

<blockquote><pre>
# <strong>/usr/local/sbin/pptp 10.0.0.138 &amp;</strong>
</pre></blockquote>

<p>
Puisque ppp(8) est utilis&eacute;, deux processus sont d&eacute;marr&eacute;s.
Vous pouvez arr&ecirc;ter pptp en tuant ces deux processus:

<blockquote><pre>
# <strong>kill -9 [pid de pppd]</strong>
$ <strong>kill -9 [pid de pptp]</strong>
</pre></blockquote>

<p>
Il est recommand&eacute; d'ouvrir <tt>/var/log/messages</tt> dans un autre
terminal afin de diagnostiquer d'&eacute;ventuels probl&egrave;mes.

<blockquote>
<pre>
# <strong>tail -f /var/log/messages</strong>
</pre></blockquote>

<p>
Nous vous conseillons &eacute;galement de placer les commandes de
d&eacute;marrage dans le fichier <i>/etc/rc.local</i> afin que la connexion soit
lanc&eacute;e &agrave; chaque fois que la machine d&eacute;marre.


<a name="Bridge"></a>
<h2>6.9 - Mise en place d'un pont ("bridge") avec OpenBSD</h2>

<p>
Un pont ("<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridge&amp;sektion=4">bridge
</a>") est un lien entre deux (ou plusieurs) r&eacute;seaux
s&eacute;par&eacute;s. A l'inverse d'un routeur, les paquets sont
transf&eacute;r&eacute;s &agrave; travers le pont de mani&egrave;re "invisible"
-- au niveau logique, les deux segments de r&eacute;seau semblent n'en faire
qu'un de chaque c&ocirc;t&egrave; du pont. Le pont ne transf&egrave;rera que les
paquets passant d'un segment &agrave; l'autre, ce qui entre autres, permet de
r&eacute;duire le trafic sur un r&eacute;seau complexe tout en permettant
&agrave; n'importe quel noeud d'acc&eacute;der &agrave; un autre en cas de
besoin.

<p>
Notez qu'&agrave; cause de sa nature "invisible", une interface faisant partie
d'un pont peut, ou non ,poss&eacute;der une adresse IP. Si c'est le cas,
l'interface aura deux modes d'op&eacute;ration, l'un comme faisant parti du pont
et l'autre se comportant comme une interface normale. Si aucune interface ne
poss&egrave;de d'adresse IP, le pont fera transiter le trafic mais ne sera pas
administrable par le r&eacute;seau (ce qui peut &ecirc;tre une
fonctionnalit&eacute; voulue).

<p>
<h3>Exemple d'application d'un pont</h3>

<p>
Un des mes racks poss&egrave;de un certain nombre d'anciens syst&egrave;mes,
lesquels ne sont pas &eacute;quip&eacute;s de carte r&eacute;seau 10BASE-TX.
Bien qu'ils poss&egrave;dent des ports AUI ou AAUI, ma r&eacute;serve de
transmetteurs est limit&eacute;e &agrave; des c&acirc;bles coaxiaux. Une des
machines de cette rang&eacute;e est un serveur d'acc&egrave;s terminal sous
OpenBSD, toujours allum&eacute;e et connect&eacute;e au r&eacute;seau &agrave;
haut d&eacute;bit. L'ajout d'une seconde carte &eacute;quip&eacute;e d'un port
coaxial permettra d'utiliser cette machine comme un pont vers le r&eacute;seau
coaxial.

<p>
Ce syst&egrave;me a, pour le moment, deux cartes r&eacute;seau, une Intel
EtherExpress/100 (<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=fxp&amp;sektion=4"><tt>fxp0
</tt></a>) et une carte 3c590-Combo (<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&amp;sektion=4"><tt>ep0
</tt></a>) pour le port coaxial. <tt>fxp0</tt> fait le lien avec le reste du
r&eacute;seau et poss&egrave;de donc une adresse IP, <tt>ep0</tt>, ne faisant
quant &agrave; elle que du "bridging", n'en poss&egrave;de pas. Les machines
connect&eacute;es sur le segment coaxial communiqueront comme les autres
pr&eacute;sentes sur le reste du r&eacute;seau. A pr&eacute;sent, voyons comment
arriver &agrave; ce r&eacute;sultat.

<p>
Le fichier <tt>hostname.fxp0</tt> contient les informations concernant la carte
<tt>fxp0</tt>. Cette machine est configur&eacute;e pour DHCP, donc le fichier
ressemble &agrave; celui-ci:

<blockquote>
<pre>
$ <b>cat /etc/hostname.fxp0</b>
dhcp NONE NONE NONE NONE
</pre>
</blockquote>

<p>
Ici, aucune surprise.

<p>
Comme vous pouvez le deviner, la configuration de la carte <tt>ep0</tt> est un
peu diff&eacute;rente:

<blockquote>
<pre>
$ <b>cat /etc/hostname.ep0</b>
up media 10base2
</pre>
</blockquote>

<p>
Ici, nous demandons au syst&egrave;me d'activer cette interface en utilisant <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ifconfig&amp;sektion=8">
ifconfig(8)</a> et de la configurer pour du 10BASE-2 (coaxial). Aucune adresse
ou information similaire n'est n&eacute;cessaire pour cette interface. Les
options possibles pour la carte <tt>ep</tt> sont disponibles en d&eacute;tail
dans le <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ep&amp;sektion=4">manuel</a>.

<p>
A pr&eacute;sent, il nous faut param&eacute;trer le pont. Un pont est
initialis&eacute; par l'existence d'un fichier du type <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridgename.if&amp;sektion=5">
<tt>bridgename.bridge0</tt></a>.  Dans ma situation, voici un exemple possible:

<blockquote>
<pre>
$ <b>cat /etc/bridgename.bridge0</b>
add fxp0
add ep0
up
</pre>
</blockquote>

<p>
Cela indique de mettre en place un pont constitu&eacute; de deux interfaces,
fxp0 et ep0 et de l'activer. Est-ce que l'ordre dans lequel les cartes sont
&eacute;nonc&eacute;es est important ? Non, souvenez-vous qu'un pont est
tr&egrave;s sym&eacute;trique -- les paquets entrent et sortent dans les deux
directions.

<p>
C'est tout ! Red&eacute;marrez et vous aurez un pont fonctionnel.

<p>
<h3>Le filtrage sur un pont ("filtering bridge")</h3>

Bien qu'il existe certainement des usages pour de simples ponts du genre
&eacute;voqu&eacute;, il est probable que vous souhaitiez FAIRE quelquechose
avec les paquets qui le traversent. Comme vous pouvez vous en douter, <a
href="#PF">Packet Filter</a> peut &ecirc;tre utilis&eacute; pour restreindre le
trafic traversant votre pont (pont filtrant).

<p>
Gardez &agrave; l'esprit que de part la nature d'un pont, les m&ecirc;mes
donn&eacute;es traversent les deux interfaces, ce qui signifie que vous n'avez
besoin de filtrer que sur l'une d'entre elles. Vos d&eacute;claration par
d&eacute;faut "Pass all" ressembleront &agrave; l'exemple suivant:

<blockquote>
<pre>
pass in  on ep0  all
pass out on ep0  all
pass in  on fxp0 all
pass out on fxp0 all
</pre>
</blockquote>

<p>
Maintenant, admettons que je souhaite filtrer le trafic dirig&eacute; vers les
vieux syst&egrave;mes &eacute;voqu&eacute;s pr&eacute;c&eacute;demment, ne
permettant qu'aux protocoles Web et SSH de les atteindre. Dans ce cas, nous
allons autoriser tout le trafic entrant et sortant sur l'interface ep0, mais
nous filtrerons sur l'interface fxp0 en utilisant "keep state" pour prendre en
charge les donn&eacute;es retourn&eacute;es:

<blockquote>
<pre>
# Autoriser le trafic entrant et sortant sur ep0
pass in quick on ep0 all
pass out quick on ep0 all

# Bloquer tout le trafic sur fxp0
block in  on fxp0 all
block out on fxp0 all

pass in quick on fxp0 proto tcp from any to any port {22, 80} \
     flags S/SA keep state
</pre>
</blockquote>

<p>
Notez que cette r&egrave;gle bloquera tout, &agrave; l'exception des
requ&ecirc;tes entrantes HTTP et SSH, vers la machine qui fait le pont ainsi
qu'en direction des autres noeuds "derri&egrave;re" elle. Il est possible
d'obtenir d'autres r&eacute;sultats en filtrant sur l'autre interface.

<p>
Pour surveiller et contr&ocirc;ler le pont que vous venez de cr&eacute;er,
servez-vous de la commande <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=brconfig&amp;sektion=8">
brconfig(8)</a> qui peut aussi &ecirc;tre utilis&eacute;e pour cr&eacute;er un
pont apr&egrave;s le d&eacute;marrage.

<p>
<h3>Astuces sur les ponts</h3>

<ul>
<li>Il est HAUTEMENT recommand&eacute; de ne filtrer que sur une seule
interface. Bien qu'il soit possible de filtrer sur les deux, vous devez vraiment
en conna&icirc;tre toutes les implications avant de pouvoir le faire de la bonne
mani&egrave;re.

<li>En utilisant l'option <i>blocknonip</i> de <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=brconfig&amp;sektion=8">
brconfig(8)</a> ou dans <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=bridgename.if&amp;sektion=5">
bridgename.bridge0</a>, vous pouvez emp&ecirc;cher le trafic non-IP (comme IPX
ou NETBEUI) de passer o&ucirc;tre votre filtre. Dans certaines situations, cela
peut-&ecirc;tre important et vous devez savoir qu'un pont fonctionne pour tous
les types de trafic, pas seulement IP.

<li>Un pont requiert que les interfaces r&eacute;seau soient en mode
"Promiscuous" -- elles &eacute;coutent TOUT le trafic r&eacute;seau, pas
seulement celui leur &eacute;tant dirig&eacute;. Ceci augmentera la charge du
processeur et du bus. Certaines cartes ne fonctionnent pas correctement dans ce
mode, le circuit TI ThunderLAN (<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=tl&amp;sektion=4">tl(4)</a>)
en est un exemple.
</ul>

<a name="PXE"></a>
<h2>6.10 - Comment d&eacute;marrer en utilisant PXE ? (i386, amd64)</h2>
PXE ("Preboot Execution Environment", environnement d'ex&eacute;cution avant
d&eacute;marrage) permet de d&eacute;marrer un ordinateur &agrave; partir du
r&eacute;seau plut&ocirc;t que d'un disque dur, une disquette ou un CDROM. A
l'origine, cette technologie a &eacute;t&eacute; d&eacute;velopp&eacute;e par
Intel mais est maintenant support&eacute;e par la plupart des contr&ocirc;leurs
r&eacute;seau et des constructeurs. Sachez qu'il existe plusieurs protocoles de
d&eacute;marrage par le r&eacute;seau, PXE &eacute;tant relativement
r&eacute;cent. Traditionnellement, un d&eacute;marrage PXE est effectu&eacute;
en utilisant des ROMs pr&eacute;sentes sur la carte r&eacute;seau ou la carte
m&egrave;re elle-m&ecirc;me, mais plusieurs disquettes permettant de
d&eacute;marrer en PXE sont disponibles sur diff&eacute;rentes sources. Beaucoup
de ROMs pr&eacute;sentes sur des anciens contr&ocirc;leurs supportent le
d&eacute;marrage en r&eacute;seau mais sont imcompatibles avec PXE ; s'il est
&eacute;quip&eacute; de tels contr&ocirc;lleurs, un syst&egrave;me OpenBSD/i386
ou amd64 ne pourra pas &ecirc;tre d&eacute;marr&eacute; &agrave; par le
r&eacute;seau.



<p>
<h3>Comment fonctionne un d&eacute;marrage PXE ?</h3>
Tout d'abord, il serait sage de savoir <a href="../faq14.html#Boot386">comment se
d&eacute;roule le processus de d&eacute;marrage d'OpenBSD/i386 ?</a> sur les
platformes i386 et amd64. Au d&eacute;marrage, chaque interface compatible PXE
&eacute;met une requ&ecirc;te DHCP en broadcast sur le r&eacute;seau. Le serveur
DHCP lui attribue alors une adresse IP en lui indiquant l'emplacement du fichier
&agrave; ex&eacute;cuter sur le serveur
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tftp&amp;sektion=1">
tftp(1)</a>. Ce fichier se charge ensuite de g&eacute;rer le reste du
d&eacute;marrage. Sous OpenBSD, <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pxeboot&amp;sektion=8&amp;arc
h=i386">pxeboot</a>, remplace le fichier <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i
386">boot(8)</a> standard. Il est alors capable de charger et d'ex&eacute;cuter
un noyau (comme <tt>bsd</tt> ou <a href="faq4.html#bsd.rd"><tt>bsd.rd</tt></a>)
&agrave; partir du serveur tftp(1).

<h3>Comment le mettre en place ?</h3>
Le point &eacute;vident est que vous avez besoin d'une machine ou d'un
contr&ocirc;leur compatible avec un d&eacute;marrage PXE. Certaines
documentations pr&eacute;cisent que toutes les cartes modernes sont compatibles
PXE, mais c'est tout simplement faux -- de nombreux syst&egrave;mes &agrave;
bas prix n'incluent pas de ROMs PXE ou utilisent un ancien protocole de
d&eacute;marrage sur r&eacute;seau. Vous avez &eacute;galement besoin d'un
serveur <a href="#DHCP">DHCP</a> configur&eacute; ainsi qu'un serveur TFTP.

<p>
En admettant qu'une machine sous OpenBSD serve les fichiers de d&eacute;marrage
(ceci n'est PAS obligatoire), le fichier <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=dhcpd.conf&amp;sektion=5">
dhcpd.conf</a> de votre serveur DHCP devra contenir la ligne suivante:
<pre>
    filename "pxeboot";
</pre>
afin de pouvoir offrir ce fichier de d&eacute;marrage &agrave; une station de
travail. Par exemple:

<pre>
    shared-network LOCAL-NET {
            option  domain-name "example.com";
            option  domain-name-servers 192.168.1.3, 192.168.1.5;

            subnet 192.168.1.0 netmask 255.255.255.0 {
                    option routers 192.168.1.1;
                    <b>filename "pxeboot";</b>
                    range 192.168.1.32 192.168.1.127;
                    default-lease-time 86400;
                    max-lease-time 90000;
            }
    }
</pre>

<p>
Vous devrez aussi activer le service <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=tftpd&amp;sektion=8">tftpd(8)
</a>. Pour ce faire, il suffit de configurer <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=inetd&amp;sektion=8">inetd(8)
</a>. L'installation standard d'OpenBSD fournit une ligne d'exemple dans
<tt>inetd.conf</tt> qui devrait vous satisfaire:
<pre>
    #tftp  dgram   udp  wait  root  /usr/libexec/tftpd   tftpd -s /tftpboot
</pre>

Retirez simplement le caract&egrave;re '#' et envoyez &agrave; inetd(8) un
signal -HUP afin que celui-ci relise son fichier <tt>/etc/inetd.conf</tt>. Les
fichiers accessibles par tftpd(8) sont contenus dans un r&eacute;pertoire
particulier, ici <tt>/tftpboot</tt>, que nous utiliserons pour cet exemple. Bien
&eacute;videmment, ce r&eacute;pertoire doit &ecirc;tre cr&eacute;&eacute; et
contenir les fichiers n&eacute;cessaires. Pour un d&eacute;marrage PXE, vous
n'aurez typiquement besoin que de quelques fichiers:

<ul>
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=pxeboot&amp;sektion=8&amp;arc
h=i386"
>pxeboot</a>, le chargeur de d&eacute;marrage (offre la m&ecirc;me fonction que
<a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot&amp;sektion=8&amp;arch=i
386">boot</a> pour un d&eacute;marrage sur disque).
<li><a href="faq4.html#bsd.rd">bsd.rd</a>, le noyau d'installation ou
<tt>bsd</tt>, un noyau adapt&eacute;.
<li><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=boot.conf&amp;sektion=8&amp;a
rch=i386"
>boot.conf</a>, le fichier de configuration de boot.
</ul>

Notez que <tt>boot.conf</tt> n'est n&eacute;cessaire qu'au cas o&ugrave; vous
souhaiteriez d&eacute;marrer un noyau ne se nommant pas <tt>bsd</tt>, ou que les
options par d&eacute;faut de pxeboot ne vous conviennent pas. Vous pouvez tester
votre serveur tftpd(8) en utilisant un client
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=tftp&amp;sektion=1">
tftp(1)</a> afin de v&eacute;rifier que vous pouvez bien r&eacute;cup&eacute;rer
les fichiers n&eacute;cessaires.

<p>
Une fois vos serveurs DHCP et TFTP d&eacute;marr&eacute;s, vous &ecirc;tes
pr&ecirc;t pour un essai. Vous devez activer PXE sur votre syst&egrave;me ou
votre carte r&eacute;seau ; consultez la documentation fournie avec votre
mat&eacute;riel. Une fois que PXE est activ&eacute;, vous devriez voir
appara&icirc;tre des lignes similaires &agrave; celles-ci:

<pre>
    Intel UNDI, PXE-2.0 (build 067)
    Copyright (C) 1997,1998 Intel Corporation

    For Realtek RTL 8139(X) PCI Fast Ethernet Controller v1.00 (990420)

    DHCP MAC ADDR: 00 E0 C5 C8 CF E1
    CLIENT IP: 192.168.1.76  MASK: 255.255.255.0  DHCP IP: 192.168.1.252
    GATEWAY IP: 192.168.1.1
    probing: pc0 com0 com1 apm pxe![2.1] mem[540k 28m a20=on]
    disk: hd0*
    net: mac 00:e0:c5:c8:cf:e1, ip 192.168.1.76, server 192.168.1.252
    >> OpenBSD/i386 PXEBOOT 1.00
    boot>
</pre>

A pr&eacute;sent, vous obtenez l'invite de commandes standard d'OpenBSD. Tapez
simplement "<tt>bsd.rd</tt>" pour r&eacute;cup&eacute;rer le fichier homonyme
&agrave; partir du serveur TFTP.

<pre>
    >> OpenBSD/i386 PXEBOOT 1.00
    boot> bsd.rd
    booting tftp:bsd.rd: 4375152+733120 [58+122112+105468]=0x516d04
    entry point at 0x100120

    Copyright (c) 1982, 1986, 1989, 1991, 1993
            The Regents of the University of California.  All rights reserved.

    Copyright (c) 1995-2004 OpenBSD.  All rights reserved. 
http://www.OpenBSD.org

    OpenBSD 3.5 (RAMDISK_CD) #25: Thu Mar 19 23:16:56 EST 2004
      ...
</pre>

Le noyau d'installation <a name="faq4.html#bsd.rd">bsd.rd</a> va maintenant se
lancer.

<p>

<h3>Est-il possible de d&eacute;marrer d'autres noyaux que <tt>bsd.rd</tt> en
utilisant PXE ?</h3>

Oui, bien qu'avec les outils actuellement pr&eacute;sents dans OpenBSD 3.5, le
d&eacute;marrage PXE ne soit essentiellement pr&eacute;vu que pour installer le
syst&egrave;me d'exploitation.



<p>
<font color="#0000e0">
<a href="index.html">[Index de la FAQ]</a>
<a href="faq5.html">[Section 5 - Construire le Syst&egrave;me &agrave; partir des Sources]</a>
<a href="../faq7.html">[Section 7 - Contr&ocirc;les du clavier et de l'affichage]</a></font>

<p>
<hr>
<a href="index.html"><img height="24" width="24" src="../../images/back.gif"
border="0" alt="[back]"></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
Originally [OpenBSD: faq6.html,v 1.195 ]<br>
$Translation: faq6.html,v 1.26 2004/10/06 16:43:37 saad Exp $<br>
$OpenBSD: faq6.html,v 1.12 2004/10/07 10:23:59 jufi Exp $
</small>

</body>
</html>
