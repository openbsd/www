<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Häufig gestellte Fragen zu OpenSSH</title>
<link rev= "made" href= "mailto:www@openbsd.org">
<meta name= "resource-type" content= "document">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="Content-Language" content="de">
<meta name= "description"   content= "Die FAQ-Seite des OpenSSH-Projekts">
<meta name= "keywords"      content= "OpenSSH,SSH,Secure Shell,faq">
<meta name= "distribution"  content= "global">
<meta name= "copyright"     content= "This document copyright 1999-2004 OpenBSD.">
</head>

<body bgcolor= "#ffffff" text= "#000000" link= "#23238E">
<a href="index.html"><img alt="[OpenSSH]" height="30" width="141" src="../images/smalltitle.gif" border="0"></a>
<p>

<h1>OpenSSH FAQ (Häufig gestellte Fragen)</h1>

<strong>Datum: 12.04.2004</strong>

<hr>

<blockquote>
<h3><a href= "#1.0">1.0 - Was ist OpenSSH und wo kann ich es bekommen?</a></h3>
<ul>
<li><a href= "#1.1">1.1 - Was ist OpenSSH und wo kann ich es herunterladen?</a>
<li><a href= "#1.2">1.2 - Warum sollte es eingesetzt werden?</a>
<li><a href= "#1.3">1.3 - Welche Betriebssysteme werden unterstützt?</a>
<li><a href= "#1.4">1.4 - Was ist mit Copyrights, Benutzung und Patenten?</a>
<li><a href= "#1.5">1.5 - Wo sollte ich um Hilfe fragen?</a>
</ul>

<h3><a href= "#2.0">2.0 - Allgemeine Fragen</a></h3>
<ul>
<li><a href= "#2.1">2.1 - Warum benutzt ssh/scp Verbindungen auf den unteren Ports? Meine Firewall blockiert diese.</a>
<li><a href= "#2.2">2.2 - Warum ist der ssh Client setuid root?</a>
<li><a href= "#2.3">2.3 - Warum hat SSH 2.3 Probleme beim Interoperieren mit OpenSSH 2.1.1?</a>
<li><a href= "#2.4">2.4 - Warum gibt OpenSSH folgendes aus: Dispatch protocol error: type 20</a>
<li><a href= "#2.5">2.5 - Alte Versionen des kommerziellen SSH verschlüsseln ,host keys' mit IDEA.</a>
<li><a href= "#2.6">2.6 - Was sind das für Warnmeldungen über Schlüssellängen?</a>
<li><a href= "#2.7">2.7 - X11- und/oder ,agent'-Weiterleitung funktioniert nicht.</a>
<li><a href= "#2.8">2.8 - Nach dem Upgrade auf OpenSSH habe ich keine SSH2-Unterstützung mehr.</a>
<li><a href= "#2.9">2.9 - sftp/scp kann keine Verbindung aufbauen, obwohl ssh funktioniert.</a>
<li><a href= "#2.10">2.10 - Werdet ihr [foo] zu scp hinzufügen?</a>
<li><a href= "#2.11">2.11 - Wie verwende ich Port-Weiterleitung?</a>
<li><a href= "#2.12">2.12 - Meine ssh-Verbindung friert ein oder steigt nach N Minuten Inaktivität aus.</a>
<li><a href= "#2.13">2.13 - Wie rufe ich scp auf, um eine Datei zu kopieren, die einen Doppelpunkt beinhaltet?</a>
<li><a href= "#2.14">2.14 - Warum teilt OpenSSH seine Version den Clients mit?</a>
</ul>

<h3><a href= "#3.0">3.0 - Fragen zum portablen OpenSSH</a></h3>
<ul>
<li><a href= "#3.1">3.1 - Unechte PAM-Authentifikationsmeldungen in den Logdateien.</a>
<li><a href= "#3.2">3.2 - Leere Passwörter sind bei der PAM-Authentifikation nicht erlaubt.</a>
<li><a href= "#3.3">3.3 - ssh(1) benötigt sehr lange zum Verbinden oder zum Einloggen</a>
<li><a href= "#3.4">3.4 - ,Can't locate module net-pf-10'-Meldungen im Log unter Linux.</a>
<li><a href= "#3.5">3.5 - Passwortauthentifikation funktioniert nicht unter Slackware 7.0 oder Red Hat 6.x</a>
<li><a href= "#3.6">3.6 - Configure oder sshd(8) beschweren sich über fehlende RSA-Unterstützung</a>
<li><a href= "#3.7">3.7 - ,scp: command not found'-Fehler</a>
<li><a href= "#3.8">3.8 - Kann die Passphrase nicht lesen</a>
<li><a href= "#3.9">3.9 - ,configure' fehlt oder make versagt</a>
<li><a href= "#3.10">3.10 - Hängt beim Verlassen von ssh</a>
<li><a href= "#3.11">3.11 - Wieso hängt ssh beim Beenden?</a>
<li><a href= "#3.12">3.12 - Ich habe ein Upgrade auf OpenSSH 3.1 durchgeführt und dann ging X11-Weiterleitung nicht mehr.</a>
<li><a href= "#3.13">3.13 - Ich habe ein Upgrade auf OpenSSH 3.8 durchgeführt und dann gingen einige X11-Programme nicht mehr.</a>
<li><a href= "#3.14">3.14 - Ich habe meinen öffentlichen Schlüssel in authorized_keys kopiert, aber public-key-Authentifizierung funktioniert immernoch nicht.</a>
</ul>

</blockquote>

<hr>

<h2><u><a name= "1.0">1.0 - Was ist OpenSSH und wo kann ich es bekommen?</a></u></h2>

<h2><a name= "1.1">1.1 - Was ist OpenSSH und wo kann ich es herunterladen?</a></h2>

<p>
OpenSSH ist eine <b>FREIE</b> Version der SSH-Suite von
Netzwerkverbindungs-Tools, auf die sich eine steigende Anzahl
von Leuten im Internet verlassen. Viele Benutzer von telnet,
rlogin, ftp und anderen solchen Programmen haben noch nicht
realisiert, dass ihr Passwort unverschlüsselt über
das Internet übertragen wird, aber so ist es. OpenSSH
verschlüsselt den gesamten Verkehr (inklusive Passwörtern),
um Mithören (eavesdropping), ,Entführen von Verbindungen'
(connection hijacking) und andere Angriffe auf Netzwerkebene
effektiv zu eliminieren.

<p>
Die OpenSSH-Suite beinhaltet das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh&amp;sektion=1">ssh(1)</a>-Programm,
das rlogin und telnet ersetzt, und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=scp&amp;sektion=1">scp(1)</a>,
das <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=rcp&amp;sektion=1">rcp(1)</a>
und <a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ftp&amp;sektion=1">ftp(1)</a>
ersetzt. OpenSSH beinhaltet auch
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sftp&amp;sektion=1">sftp(1)</a> und
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sftp-server&amp;sektion=8">sftp-server(8)</a>,
die eine einfache Lösung für Dateiübertragungen realisieren.
Sie basieren auf dem
<a href="../txt/draft-ietf-secsh-filexfer-02.txt">secsh-filexfer</a>-IETF-Entwurf.


<p><strong>OpenSSH besteht aus mehreren Programmen.</strong>

<ul>
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sshd&amp;sektion=8">sshd(8)</a> - Serverprogramm, das auf der Servermaschine läuft. Es lauscht, ob es Verbindungswünsche von Clientmaschinen gibt und führt dann eine Authentifikation durch, bevor es den Client bedient.
Das Verhalten wird von der Konfigurationsdatei <i><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=sshd_config&amp;sektion=5">
sshd_config(5)</a></i> verwaltet.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh&amp;sektion=1">ssh(1)</a> - Dies ist das Clientprogramm, das benutzt wird, um sich auf einer anderen Maschine einzuloggen oder dort Kommandos auszuführen. <i>slogin</i> ist ein weiterer Name für dieses Programm.
Das Verhalten wird von der systemweiten Konfigurationsdatei <i><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh_config&amp;sektion=5">
ssh_config(5)</a></i> und den benutzerspezifischen
<i>$HOME/.ssh/config</i>-Dateien verwaltet.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=scp&amp;sektion=1">scp(1)</a> - Kopiert Dateien sicher von einer Maschine zur anderen.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh-keygen&amp;sektion=1">ssh-keygen(1)</a> - Wird benutzt, um ,Pubkey'-Authentifikations-Schlüssel (RSA oder DSA) zu erzeugen (Hostschlüssel und Benutzer-Authentifikationsschlüssel).
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh-agent&amp;sektion=1">ssh-agent(1)</a> - Authentifikationsagent.  Er kann benutzt werden, um RSA-Schlüssel für die Authentifikation bereitzuhalten.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh-add&amp;sektion=1">ssh-add(1)</a> - Wird benutzt, um neue Schlüssel beim Agenten zu registrieren.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sftp-server&amp;sektion=8">sftp-server(8)</a> - SFTP-Server-Subsystem.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sftp&amp;sektion=1">sftp(1)</a> - Sicheres Dateiübertragungsprogramm.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh-keyscan&amp;sektion=1">ssh-keyscan(1)</a> - Sammelt ssh-,public keys' ein.
<li><a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh-keysign&amp;sektion=8">ssh-keysign(8)</a> - ssh Hilfsprogramm für hostbasierende Authentifikation.
</ul>

<h3>Herunterladen</h3>

<p>
OpenSSH erscheint in zwei herunterladbaren Distributionen: der nativen <a
href="openbsd.html">OpenBSD</a>-Distribution und der Multiplattform
<a href="portable.html">Portable</a> Distribution. Wenn du OpenSSH für
eine aktuelle Version von OpenBSD oder zur Integration in ein Projekt
benötigst, möchtest du vermutlich die <a
href="openbsd.html">OpenBSD</a>-Distribution. Falls du OpenSSH für
eine andere Plattform oder für eine ältere OpenBSD-Version
benötigst, möchtest du vermutlich die <a
href="portable.html">Portable</a>-Distribution.

<p>
Wenn du herunterlädst, verwende bitte einen ,<a
href="portable.html#mirrors">mirror</a>' in deiner Nähe.

<h2><a name= "1.2">1.2 - Warum sollte es eingesetzt werden?</a></h2>

<p>
OpenSSH ist eine Sammlung von Werkzeugen, die dir hilft, deine
Netzwerkverbindungen sicherer zu machen. Hier ist eine Liste der
Funktionalitäten:


<ul>
	<li>Starke Authentifikation.  Schließt verschiedene Sicherheitslöcher (z.B. IP-, ,routing'-, und DNS-,spoofing').
	<li>Verbesserte Privatsphäre.  Alle Verbindungen werden automatisch und transparent verschlüsselt.
	<li>Sichere X11-Sitzungen.  Das Programm setzt DISPLAY auf der Servermaschine automatisch und leitet alle X11-Verbindungen über den sicheren Kanal weiter.
	<li>Willkürliche TCP/IP-Ports können durch den verschlüsselten Kanal in beide Richtungen gelenkt werden (z.B. für e-cash-Transaktionen).
	<li>Für normale Benutzer wird keine Schulung und kein Training benötigt.
	<li>Vertraut nie dem Netzwerk. Minimales Vertrauen auf der Gegenseite der Verbindung. Minimales Vertrauen gegenüber den Domain Name Servern. Pure RSA-Authentifikation vertraut nichts und niemandem, bis auf den ,private key'.
	<li>Der Client authentifiziert die Servermaschine am Beginn jeder Verbindung mit RSA, um ,trojanischen Pferden' (durch ,routing'- oder DNS-,spoofing') und ,man-in-the-middle'-Angriffen vorzubeugen, und der Server tut das gleiche mit der Clientmaschine bevor er <i>.rhosts</i>- oder <i>/etc/hosts.equiv</i>-Authentifikation erlaubt (um DNS-, ,routing'- oder IP-,spoofing' vorzubeugen).
	<li>Die ,host authentication key'-Distribution kann zentral laufen, wird jedoch automatisch, sobald die erste Verbindung zur Maschine geöffnet wird.
	<li>Jeder Benutzer kann beliebig viele RSA-Authentifikationsschlüssel zur eigenen Verwendung erzeugen.
	<li>Das Serverprogramm hat seinen eigenen RSA-Schlüssel, der jede Stunde automatisch neu erzeugt wird.
	<li>Ein Authentifikationsagent, der auf dem Laptop oder der Workstation des Benutzers läuft, kann benutzt werden, um die RSA-Authentifikationsschlüssel des Anwenders zu halten.
	<li>Die Software kann auch ohne root-Privilegien installiert und benutzt werden (mit eingeschränkter Funktionalität).
	<li>Der Client ist in systemweiten und benutzerspezifischen Konfigurationsdateien anpassbar.
	<li>Optionale Kompression aller Daten mittels gzip (inklusive ,forwarded X11'- und TCP/IP-Daten), was zu bedeutenden Beschleunigungen auf langsamen Verbindungen führen kann.
	<li>Kompletter Ersatz für rlogin, rsh und rcp.
</ul>

<p>
Zur Zeit werden fast alle Übertragungen in Computernetzwerken
unverschlüsselt durchgeführt. Als Konsequenz kann jeder, der
Zugriff auf irgendeine Maschine in diesem Netzwerk hat, alle Verbindungen
abhören. Das wird auch von Hackern, neugierigen Administratoren,
Arbeitgebern, Kriminellen, Industriespionen und Regierungen so
durchgeführt.
Einige Netzwerke senden derartig viel elektromagnetische Strahlung ab,
dass Daten sogar in großer Entfernung noch aufgefangen werden
können.


<p>
Wenn du dich einloggst, wird dein Passwort im Klartext übertragen.
Daher kann dann jeder Lauscher deinen Account zu jeglicher Tat benutzen.
Es gibt weltweit viele Zeugnisse dafür, dass Cracker auf dem Rechner
eines Opfers unbemerkt ein Programm gestartet haben, welches ohne Wissen des
Anwenders einfach nur das Netzwerk belauscht und Passwörter gesammelt
hat. Programme, die das tun, gibt es im Internet oder können von einem
kompetenten Programmierer innerhalb weniger Stunden selbst geschrieben
werden.


<p>
Firmen haben Geschäftsgeheimnisse, Patentanträge in Vorbereitung,
Preisinformationen, Informationen über Vertragspartner, Kundendaten,
Personendaten, Finanzdaten, etc. Zur Zeit kann jeder mit Zugriff auf das
Netzwerk (jede Maschine im Netzwerk) alles belauschen, was im Netzwerk
vor sich geht, und das noch ohne die normalen Zugriffsbeschränkungen.


<p>
Vielen Firmen ist nicht bewusst, dass Informationen so einfach aus ihrem
Netzwerk gesammelt werden können. Sie vertrauen darin, dass ihre
Daten sicher sind, da niemand wissen kann, dass dort vertrauliche
Informationen kursieren, oder auch, weil dort so viele andere Daten
übertragen werden. Dies ist keine sichere Einstellung.


<h2><a name= "1.3">1.3 - Welche Betriebssysteme werden unterstützt?</a></h2>

<p>
Obwohl OpenSSH unter <a href="http://www.openbsd.org/">OpenBSD</a> entwickelt
wird, gibt es eine breite Palette an Portierungen auf andere Betriebssysteme.
Die portable Version von OpenSSH wird von
<a href="mailto:djm@openbsd.org">Damien Miller</a> geleitet. Einen
schnellen Überblick über die portable Version von OpenSSH gibt
dir <a href="portable.html">http://www.openssh.com/portable.html</a>.
Betriebssysteme, die zur Zeit unterstützt werden, sind:


<ul>
	<li>OpenBSD
	<li>NetBSD
	<li>FreeBSD
	<li>AIX
	<li>HP-UX
	<li>IRIX
	<li>Linux
	<li>NeXT
	<li>SCO
	<li>SNI/Reliant Unix
	<li>Solaris
	<li>Digital Unix/Tru64/OSF
	<li>Mac OS X
	<li>Cygwin
</ul>

<p>
Eine Liste der Anbieter, die OpenSSH in ihre Distributionen einbinden,
befindet sich auf der <a href="users.html">OpenSSH-Benutzerseite</a>.

<h2><a name= "1.4">1.4 - Was ist mit Copyrights, Benutzung und Patenten?</a></h2>
<p>
Die OpenSSH Entwickler haben sehr hart versucht, OpenSSH frei
von Patent- oder Copyrightproblemen zu halten. Dazu mussten einige
Optionen aus OpenSSH entfernt werden. Nämlich die Unterstützung
für patentierte Algorithmen.

<p>
OpenSSH unterstützt keinerlei patentierte Transportalgorithmen.
Im SSH1-Modus sind nur 3DES und Blowfish möglich.
Im SSH2-Modus können nur 3DES, Blowfish, CAST128, Arcfour und AES
ausgewählt werden. Der patentierte IDEA-Algorithmus wird nicht
unterstützt.

<p>
OpenSSH bietet Unterstützung für sowohl das SSH1- als auch das
SSH2-Protokoll.

<p>
Seit das RSA-Patent ausgelaufen ist, gibt es keinerlei Beschränkungen
mehr für Software, die den RSA-Algorithmus benutzen, inklusive OpenBSD.

<h2><a name= "1.5">1.5 - Wo sollte ich um Hilfe fragen?</a></h2>
<p>
Es gibt mehrere Stellen, die du um Hilfe bitten kannst. Zusätzlich
zur <a href="http://www.openssh.com/">OpenSSH-Webseite</a> gibt es
mehrere Mailinglisten, in denen du dein Glück versuchen kannst.
Bevor du das tust, durchsuche bitte alle Mailinglisten-Archive um
zu sehen, ob deine Frage vielleicht schon beantwortet wurde. Die
OpenSSH-Mailingliste wurde archiviert und steht in durchsuchbarer Form unter
<a href="http://marc.theaimsgroup.com/?l=openssh-unix-dev&amp;r=1&amp;w=2">theaimsgroup.com</a>
zur Verfügung.

<p>
Mehr Informationen über das Abonnieren von OpenSSH-bezogenen
Mailinglisten gibt es unter
<a href="list.html">OpenSSH-Mailinglisten</a>.

<p>
Informationen zum Senden von Fehlermeldungen können auf der OpenSSH
<a href="report.html">,Fehler melden'</a>-Seite gefunden werden.

<h2><u><a name= "2.0">2.0 - Allgemeine Fragen</a></u></h2>

<h2><a name= "2.1">2.1 - Warum benutzt ssh/scp Verbindungen auf den unteren Ports?</a></h2>
<p>
Der OpenSSH-Client benutzt die unteren Ports für rhosts- und
rhosts-rsa-Authentifikation, da der Server dem Benutzernamen vertrauen muss,
den der Client liefert. Um das zu umgehen, kannst du das Beispiel weiter unten
in deine <i>ssh_config</i>- oder <i>~/.ssh/config</i>-Datei kopieren.

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<b>UsePrivilegedPort no</b>
                </td>
        </tr>
</table>
</blockquote>

<p>
Oder du kannst diese Option auf der Kommandozeile angeben, indem du die
Option <b>-o</b> des <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh&amp;sektion=1">ssh(1)</a>-Kommandos
benutzt.

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
$ <b>ssh -o "UsePrivilegedPort no" host.com</b>
                </td>
        </tr>
</table>
</blockquote>

<h2><a name= "2.2">2.2 - Warum ist der ssh-Client setuid root?</a></h2>

<p>
In Verbindung mit der vorhergehenden Frage (<a href="#2.1">2.1</a>)
braucht OpenSSH root-Authorität, um sich an die unteren und privilegierten
Ports binden zu können, um dann eine <i>rhosts-Authentifikation</i>
durchzuführen. Genauso notwendig ist dieser privilegierte Port
für rhosts-rsa-Authentifikation zu älteren SSH-Versionen.

<p>
Zusätzlich gilt sowohl für <i>rhosts-rsa-Authentifikation</i>
(in Protokollversion 1) als auch für <i>hostbasierte Authentifikation</i>
(in Protokollversion 2), dass der ssh-Client Zugang zum
,<i>private host key</i>' braucht, um die Clientmaschine am Server
anzumelden.
OpenSSH-Versionen vor 3.3 benötigten das <code>ssh</code>-Binary
mit gesetztem setuid-Bit, um das zu erreichen, aber du kannst das Bit
löschen, wenn du diese Authentifizierungsmethoden nicht
benutzen willst.

<p>
Beginnend mit OpenSSH 3.3 ist <code>ssh</code> standardmäßig nicht
setuid. <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh-keysign">ssh-keysign</a>
wird benutzt, um die privaten Hostschlüssel auszulesen, und ssh benutzt
standardmäßig keine privilegierten Quellports. Wenn du
doch einen benutzen willst, musst du das setuid-Bit von <code>ssh</code>
per Hand setzen.

<h2><a name= "2.3">2.3 - Warum hat SSH 2.3 Probleme beim Interoperieren mit OpenSSH 2.1.1?</a></h2>

<p>
SSH 2.3 und frühere Versionen haben einen Fehler in ihrer
HMAC-Implementierung. Ihr Code hat nicht die komplette Ausgabe des Datenblocks
von der Auswahl bereitgestellt, sondern stattdessen eben nur 128 Bits.
Bei längeren Anfragen konnte dann SSH 2.3 eben nicht mit OpenSSH
zusammenarbeiten.

<p>
OpenSSH 2.2.0 erkennt, dass SSH 2.3 diesen Fehler hat. In
zukünftigen Versionen von SSH wird dieser Fehler behoben sein.
Alternativ kannst du das folgende in deine <i>/etc/sshd2_config</i> von
SSH 2.3 einfügen.

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<b>Mac hmac-md5</b>
               </td>
        </tr>
</table>
</blockquote>

<h2><a name= "2.4">2.4 - Warum gibt OpenSSH folgendes aus: Dispatch protocol error: type 20</a></h2>

<p>
Probleme bei der Zusammenarbeit treten auf, weil ältere Versionen
von OpenSSH noch keine Unterstützung für ,session rekeying' hatten.
Das kommerzielle SSH 2.3 versucht diese Funktionalität abzulehnen, und es kann
zum Einfrieren der Verbindung kommen, oder die Fehlermeldung
,<b>Dispatch protocol error: type 20 </b>' kann zu lesen sein.
Das Problem wird entweder durch ein Upgrade auf eine aktuelle
OpenSSH-Version oder Abschalten des ,rekeying' durch Hinzufügen des
folgenden in die <i>ssh2_config</i> oder <i>sshd2_config</i> vom
kommerziellen SSH 2.3 behoben.


<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<b>RekeyIntervalSeconds 0</b>
                </td>
        </tr>
</table>
</blockquote>

<h2><a name= "2.5">2.5 - Alte Versionen des kommerziellen SSH verschlüsseln ,host keys' mit IDEA.</a></h2>

<p>
Die alten Versionen von SSH haben einen patentierten Algorithmus benutzt,
um ihren <i>/etc/ssh/ssh_host_key</i> zu verschlüsseln. Das Problem
manifestiert sich darin, dass der <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=sshd&amp;sektion=8">sshd(8)</a>
seinen Hostschlüssel nicht lesen kann. Um das Problem zu lösen, benutze
das Kommando weiter unten, um deinen ssh_host_key zu 3DES zu konvertieren.
<b>HINWEIS:</b> Benutze das <a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh-keygen&amp;sektion=1">ssh-keygen(1)</a>-Programm
von dem kommerziellen SSH-Produkt und *NICHT* OpenSSH für
das Beispiel weiter unten.

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
# <b>ssh-keygen -u -f /etc/ssh/ssh_host_key</b>
                </td>
        </tr>
</table>
</blockquote>

<h2><a name= "2.6">2.6 - Was sind das für Warnungen über Schlüssellängen?</a></h2>

<p>
Das
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh-keygen&amp;sektion=1">ssh-keygen(1)</a>
des kommerziellen SSH-Programms hat einen Fehler beinhaltet, der dazu
führte, dass es von Zeit zu Zeit ,Pubkey'-Authentifikationsschlüssel (RSA oder
DSA) generiert hat, deren ,Most Significant'-Bit (MSB) nicht
gesetzt war. Solche Schlüssel wurden zwar als ,mit voller Länge'
angekündigt, waren aber die Hälfte der Zeit über kleiner als angekündigt.

<p>
OpenSSH wird Warnungen ausgeben, wenn es solchen Schlüsseln begegnet.
Um diese Warnungen loszuwerden, passe deine <i>known_hosts</i>-Datei an und
ersetze die falsche Schlüssellänge (normalerweise ,1024') mit
der richtigen (normalerweise ,1023').

<h2><a name= "2.7">2.7 - X11- und/oder ,agent'-Weiterleitung funktioniert nicht.</a></h2>

<p>
Prüfe deine <i>ssh_config</i> und <i>sshd_config</i>. Die
voreingestellten Konfigurationsdateien schalten den Authentifikationsagenten
und X11-Weiterleitung ab. Füge die Zeilen unten in die <i>sshd_config</i>
ein, um sie zu aktivieren:

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<b>X11Forwarding yes</b>
                </td>
        </tr>
</table>
</blockquote>

<p>
und füge die folgenden Zeilen in die <i>ssh_config</i> ein:

<blockquote>
<table border=0 width="800">
	<tr>
		<td nowrap bgcolor="#EEEEEE">
<b>ForwardAgent yes</b><br>
<b>ForwardX11 yes</b>
		</td>
	</tr>
</table>
</blockquote>

<p>
<b>HINWEIS:</b> Benutzer von Linux Mandrake 7.2: Mandrake modifiziert
die <i>XAUTHORITY</i>-Umgebungsvariable in <i>/etc/skel/.bashrc</i>
und damit das Heimatverzeichnis jedes Bash-Benutzers. Diese Variable wird
von OpenSSH gesetzt und daher muss für die oben genannten
Optionen die folgende Zeile auskommentiert werden:


<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<b># export XAUTHORITY=$HOME/.Xauthority</b>
                </td>
        </tr>
</table>
</blockquote>

<h2><a name= "2.8">2.8 - Nach dem Upgrade auf OpenSSH habe ich keine SSH2-Unterstützung mehr.</a></h2>

<p>
Die Dateien <i>sshd_config</i> oder <i>ssh_config</i> können von
Version zu Version verändert werden. Du solltest immer nach solchen
Änderungen Ausschau halten, wenn du auf eine neue Version von OpenSSH
upgradest. Nach OpenSSH 2.3.0 musst du das folgende in deine
<i>sshd_config</i> einfügen:

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<b>HostKey /etc/ssh_host_dsa_key</b><br>
<b>HostKey /etc/ssh_host_rsa_key</b>
                </td>
        </tr>
</table>
</blockquote>

<h2><a name= "2.9">2.9 - sftp/scp kann keine Verbindung aufbauen, obwohl ssh funktioniert.</a></h2>

<p>
sftp und/oder scp können beim Aufbauen der Verbindung Probleme haben,
wenn du eine Shellinitialisierung (.profile, .bashrc, .chsrc, etc.) hast,
die Ausgaben für nicht interaktive Sitzungen produziert. Diese Ausgabe
verwirrt den sftp/scp-Client. Hiermit kannst du prüfen, ob deine
Shell das tut:

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
<b>ssh yourhost /usr/bin/true</b>
                </td>
        </tr>
</table>
</blockquote>

<p>
Wenn das Kommando oben irgendeine Art von Ausgabe produziert, musst du
deine Shellinitialisierung modifizieren.

<h2><a name="2.10">2.10 - Werdet ihr [foo] zu scp hinzufügen?</a></h2>

<p>
Kurze Antwort: Nein.

<p>
Lange Antwort: scp ist nicht standardisiert. Die Beschreibung, die einer
Spezifikation am nächsten kommt, ist: ,was rcp tut'. Da das selbe Kommando
auf beiden Seiten einer Verbindung benutzt wird, bedeutet das Hinzufügen
von Funktionalitäten oder Optionen das Risiko von Inkompatibilitäten
mit anderen Implementierungen.

<p>
Neue Funktionalitäten sind eher in sftp wahrscheinlich, da das Protokoll
standardisiert ist (naja, ein
,<a href="http://www.ietf.org/internet-drafts/draft-ietf-secsh-filexfer-05.txt">
draft standard</a>') und Client sowie Server voneinander getrennt sind.

<h2><a name= "2.11">2.11 - Wie verwende ich Port-Weiterleitung?</a></h2>

<p>
Wenn sshd(8) auf dem Server auf der Gegenseite läuft, kann es möglich
sein, bestimmte Dienste durch ssh zu ,tunneln'. Das kann wünschenswert
sein, um beispielsweise POP- und SMTP-Verbindungen zu verschlüsseln,
selbst wenn die Software keine eigene Unterstützung für
verschlüsselte Verbindungen hat. Das Tunneln verwendet Port-Weiterleitung,
um eine Verbindung zwischen dem Client und dem Server herzustellen. Die
Client-Software muss hierfür in der Lage sein, auf einen nicht standardisierten
Port verbinden zu können.

<p>
Die Idee dahinter ist, dass der Client sich mit dem entfernten System über
ssh verbindet und angibt, welcher Port auf der Maschine des Clients dazu
verwendet werden soll, Verbindungen zum Server weiterzuleiten. Danach ist es
möglich, die Dienste, die verschlüsselt werden sollen (z.B. fetchmail,
irc), auf dem Client mit der Angabe des gleichen Ports, der an ssh
übergeben wurde, zu starten, und die Verbindung wird durch ssh getunnelt.

<p>
Die wichtigsten Optionen zum Tunneln sind die Optionen -L und -R, welche dem
Benutzer das Port-Weiterleiten erlauben, die Option -D, welche das dynamische
Port-Weiterleiten erlaubt und die Option -f, welche ssh zuweist, im
Hintergrund weiterzuarbeiten. Siehe weiter unten für mehr Details zu
diesen Optionen.

<p>
Dies ist ein Beispiel für eine getunnelte IRC-Sitzung von der Clientmaschine
,127.0.0.1' (localhost) zum entfernten Server ,server.example.com':

<blockquote>
<table border=0 width="800">
	<tr>
		<td nowrap bgcolor="#EEEEEE">
<b>ssh -f -L 1234:server.example.com:6667 server.example.com sleep 10<br>
irc -c '#users' -p 1234 pinky 127.0.0.1</b>
	</td>
	</tr>
</table>
</blockquote>

<p>
Dies tunnelt eine Verbindung zum IRC-Server server.example.com und tritt mit
dem Nick ,pinky' dem Channel ,#users' bei. Der lokale Port, der in diesem
Beispiel verwendet wurde, ist 1234. Es tut nichts zur Sache, welcher Port
benutzt wird, so lange er größer ist als 1023 (bedenke, nur root
kann Sockets auf privilegierten Ports öffnen) und keine Störung
mit bereits verwendeten Ports auftritt. Die Verbindung wird zum Port 6667
auf dem entfernten Server weitergeleitet, da das der Standardport für
IRC-Dienste ist.

<p>
Der Remote-Befehl ,sleep 10' wurde angegeben, um dem Dienst, der getunnelt
werden soll, eine gewisse Zeit (10 Sekunden in diesem Beispiel) zu geben, um
zu starten. Wenn in der angegebenen Zeit keine Verbindung aufgebaut wurde,
wird ssh sich beenden. Falls mehr Zeit benötigt wird, kann der sleep(1)-Wert
entsprechend erhöht werden oder alternativ könnte das oben
aufgelistete Beispiel als eine Funktion in die Benutzershell eingefügt
werden. Siehe ksh(1) und csh(1) für weitere Details über
benutzerdefinierte Funktionen.

<p>
ssh besitzt des weiteren die Option -N, welche praktisch für das
Port-Weiterleiten ist: Wenn -N übergeben wurde, ist es nicht notwendig, einen
Remote-Befehl (,sleep 10' in dem Beispiel oben) anzugeben. Allerdings
führt die Benutzung dieser Option dazu, dass ssh für immer wartet
(anstatt zu beenden, wenn ein Remote-Befehl ausgeführt wurde), so dass
der Benutzer darauf achten muss, den Prozess hinterher manuell mit kill(1)
zu beenden.

<h2><a name= "2.12">2.12 - Meine ssh-Verbindung friert ein oder steigt nach N
Minuten Inaktivität aus.</a></h2>

<p>
Das ist üblicherweise das Resultat eines Paketfilters oder einem
NAT-Gerät, das die TCP-Verbindung wegen Inaktivität auslaufen
lässt. Du kannst <b>ClientAliveInterval</b> in der <i><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=sshd_config&amp;sektion=5">
sshd_config</a></i> des Servers aktivieren oder <b>ServerAliveInterval</b> in
der <i><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=ssh_config&amp;sektion=5">
ssh_config</a></i> des Clients ermöglichen (die letzte Option ist in
OpenSSH 3.8 und neuer verfügbar).

<p>
Das Aktivieren einer der beiden Optionen und das Setzen des Intervalls, das
kürzer als die benötigte Zeit ist, um die Verbindung auslaufen zu
lassen, sorgen dafür, dass die Verbindung in der Verbindungstablle des
Gerätes ,frisch' gehalten wird.

<h2><a name= "2.13">2.13 - Wie rufe ich scp auf, um eine Datei zu kopieren,
die einen Doppelpunkt beinhaltet?</a></h2>

<b><a
href="http://www.openbsd.org/cgi-bin/man.cgi?query=scp&amp;sektion=1">
scp</a></b> interpretiert den Teil vor dem Doppelpunkt als Namen des
entfernten Servers und versucht, eine Verbindung zu diesem aufzubauen. Um
das zu verhindern, greife auf die Datei mit relativer oder absoluter
Pfadangabe zu, z.B.:

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
$ scp ./source:file sshserver:
                </td>
        </tr>
</table>
</blockquote>

<h2><a name= "2.14">2.14 - Warum teilt OpenSSH seine Version den Clients mit?</a></h2>

<p>
OpenSSH, wie die meisten SSH-Implementierungen, teilt seinen Namen und seine
Version den Clients mit, wenn sie eine Verbindung aufbauen, z.B.
</p>

<blockquote>
SSH-2.0-OpenSSH_3.9
</blockquote>

<p>
Diese Information wird von den Clients und Serven verwendet, um
Protokollkompatibilitätskniffe zu aktiveren, die veränderte, fehlerhafte
oder fehlende Funktionen in der Implementierung, mit der sie reden,
zu umgehen. Dieser Protokollfunktions-Test ist weiterhin
benötigt, weil das SSH-Protokoll noch nicht als RFC veröffentlicht
wurde und weitere inkompatible Änderungen möglicherweise gemacht
werden, bevor das eintritt.
</p>

<h2><u><a name= "3.0">3.0 - Fragen zum portablen OpenSSH</a></u></h2>

<h2><a name= "3.1">3.1 - Unechte PAM-Authentifikationsmeldungen in den Logdateien.</a></h2>

<p>
Die portable Version von OpenSSH generiert unechte misslungene
Authentifikationsmeldungen bei jedem Login, etwa wie:


<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
&quot;<b>authentication failure; (uid=0) -&gt; root for sshd service</b>&quot;
                </td>
        </tr>
</table>
</blockquote>

<p>
Diese werden erzeugt, weil OpenSSH zuerst versucht herauszufinden, ob
der Anwender eine Authentifikation zum Login benötigt (z.B. leeres Passwort).
Dummerweise logt PAM alle Authentifikationversuche,
inklusive diesen hier.

<p>
Wenn es dich zu sehr stört, setze
&quot;<b>PermitEmptyPasswords no</b>&quot; in <i>sshd_config</i>. Das
wird die Meldung stilllegen, allerdings auf Kosten dessen, dass es nicht
mehr möglich ist, sich in Accounts mit leeren Passwörtern
einzuloggen. Das ist im übrigen bereits der Standard, wenn du die
mitgelieferte <i>sshd_config</i>-Datei benutzt.

<h2><a name= "3.2">3.2 - Leere Passwörter sind bei der PAM-Authentifikation nicht erlaubt.</a></h2>

<p>
Um leere Passwörter in einer OpenSSH-Version zu erlauben, die mit
PAM erzeugt wurde, musst du das ,nullok'-Flag an das Ende des
Password-Checking-Moduls in der <i>/etc/pam.d/sshd</i>-Datei
setzen. Zum Beispiel:

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
auth required/lib/security/pam_unix.so shadow nodelay nullok
                </td>
        </tr>
</table>
</blockquote>

<p>
Das muss zusätzlich zum Setzen von
&quot;<b>PermitEmptyPasswords yes</b>&quot; in der
<i>sshd_config</i>-Datei geschehen.

<p>
Es gibt einen Fallstrick beim Benutzen leerer Passwörter mit
PAM-Authentifikation: PAM wird jegliches Passwort erlauben, wenn ein Account
mit einem leeren Passwort authentifiziert wird. Das macht den Check, den
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=sshd&amp;sektion=8">sshd(8)</a>
benutzt, um zu prüfen, ob der Account ein Passwort gesetzt hat,
wirklungslos und umgeht ebenso die Richtlinie, die von
<b>PermitEmptyPasswords</b> gesetzt wurde. Aus diesem Grund raten wir
davon ab, die <b>nullok</b>-Direktive in deiner PAM-Konfigurationsdatei
zu setzen, es sei denn, du willst leere Passwörter explizit erlauben.


<h2><a name= "3.3">3.3 - ssh(1) benötigt sehr lange zum Verbinden oder zum Einloggen</a></h2>

<p>
Große Verzögerungen (mehr als 10 Sekunden) werden normalerweise
durch Probleme mit der Namensauflösung verursacht:
<ul>
<li>Einige Versionen der glibc (insbesondere glibc 2.1, die mit Red Hat 6.1
ausgeliefert wurde) können einen langen Zeitraum benötigen, um
,IPv6 zu IPv4'-Adressen von Domänennamen aufzulösen. Das kann
umgangen werden, indem die Option <b>AddressFamily inet</b> in der
<i>ssh_config</i> eingetragen wird.</li>

<li>Es könnte ein DNS-Auflösungsproblem vorliegen, entweder beim
Client oder beim Server. Du kannst den <code>nslookup</code>-Befehl auf dem
Client und dem Server verwenden, um den Namen und die IP-Adresse der Gegenseite
auflösen zu lassen. Lass zusätzlich den Namen auf dem Server
auflösen, den der Client beim Auflösen der IP-Adresse des Servers
zurückgegeben hat. Du kannst die meisten Lookups serverseitig durch
das Hinzufügen von <b>UseDNS no</b> in <i>sshd_config</i>
deaktiveren.</li>
</ul>

<p>
Verzögerungen unter 10 Sekunden können andere Ursachen haben.

<ul>

<li>OpenSSH-Versionen vor 3.8 hatten eine <i>moduli</i>-Datei mit moduli,
die kleiner waren als die, nach denen OpenSSH Ausschau hielt, und als Resultat
würde sshd am Ende moduli verwenden, die bedeutlich größer
wären als die, die angefragt wurden, was auf Kosten der Geschwindigkeit
geschah. Das Ersetzen der <i>moduli</i>-Datei wird das Problem lösen
(bedenke, dass diese Datei bei einem Upgrade in den meisten Fällen nicht
ausgetauscht wird und daher manuell ersetzt werden muss).</li>

<li>OpenSSH-Versionen vor 3.8 hatten einen Fehler in <code>ssh</code>, der
dazu führte, dass es größere moduli anforderte als erwartet
(was dann, in Kombination mit dem oben genannten Problem, in erheblichen
Geschwindigkeitseinbußen endete).
Ein Upgrade des Clients auf Version 3.8 oder höher wird das Problem
beheben.</li>

<li>Falls entweder der Server oder der Client keinen kernelbasierten
Zufallszahlengenerator besitzen (z.B. Solaris &lt; 9, AIX &lt; 5.2, HP-UX
&lt; 11.11) und kein Ersatz verfügbar ist (z.B. <a href=
"ftp://ftp.ayamura.org/pub/prngd/">prngd</a>), ist es möglich, dass ein
Programm, das von <code>ssh-rand-helper</code> zum Generieren vom Entropy
aufgerufen wird, hängt. Das kann ermittelt werden, indem es im Debug-Modus
ausgeführt wird:

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
/usr/local/libexec/ssh-rand-helper -vvv
                </td>
        </tr>
</table>
</blockquote>

Alle beachtlichen Verzögerungen sollten untersucht und behoben,
oder aber die entsprechenden Befehle aus <i>ssh_prng_cmds</i> entfernt
werden.
</li>

</ul>

<h3>Wie langsam ist ,langsam'?</h3>
Unter normalen Umständen ist die Geschwindigkeit des SSH-Logins
abhängig von der CPU-Leistung des Clients und Servers. Zum Vergleich
folgen typische Verbindungszeiten für <code>time ssh localhost
true</code> mit einem 1024-Bit-RSA-Schlüssel auf einem ansonsten
ungenutzten System. OpenSSH und OpenSSL wurden mit gcc 3.3.x compiliert.

<p>
<table>
<tr><th>CPU</th><th>Zeit (SSHv1)<a href="#3.3fn1">[1]</a></th>
	<th>Zeit (SSHv2)</th></tr>
<tr><td>170MHz SPARC/sun4m</td><td>0.74 Sek</td><td>1.25 Sek</td></tr>
<tr><td>236MHz HPPA/8200<a href="#3.3fn2">[2]</a></td><td>0.44 Sek</td>
	<td>0.79 Sek</td></tr>
<tr><td>375MHz PowerPC/604e</td><td>0.38 Sek</td><td>0.51 Sek</td></tr>
<tr><td>933MHz VIA Ezra</td><td>0.34 Sek</td><td>0.44 Sek</td></tr>
<tr><td>2.1GHz Athlon 2600+</td><td>0.14 Sek</td><td>0.22 Sek</td></tr>
</table>

<br>

<a name="3.3fn1">[1]</a> Das SSHv1 Protokoll ist zwar schneller, aber
kryptographisch schwächer als SSHv2.<br>

<a name="3.3fn2">[2]</a> Zu dem Zeitpunkt des Schreibens generiert gcc relativ
langsamen Code auf HPPA für RSA- und Diffie-Hellman-Operationen (siehe
<a href= "http://gcc.gnu.org/bugzilla/show_bug.cgi?id=7625">gcc bug #7625</a>
und <a
href="http://marc.theaimsgroup.com/?l=openssh-unix-dev&m=102646106016694">
Diskussion auf openssh-unix-dev</a>).

<h2><a name= "3.4">3.4 - ,Can't locate module net-pf-10'-Meldungen im Log unter Linux.</a></h2>

<p>
Der Linux-Kernel sucht (via modprobe) nach der Protokollfamilie 10 (IPv6).
Lade entweder das passende Kernelmodul, gib den korrekten Alias in
<i>/etc/modules.conf</i> an oder schalte IPv6 in <i>/etc/modules.conf</i> ab.


<p>
Aus irgendeinem blödsinnigen Grund kann
<i>/etc/modules.conf</i> auch <i>/etc/conf.modules</i> heißen.


<h2><a name= "3.5">3.5 - Passwortauthentifikation funktioniert nicht unter Slackware 7.0 oder Red Hat 6.x</a></h2>

<p>
Fü Slackware 7.0 musst du OpenSSH mit der libcrypt verlinken.

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
LIBS=-lcrypt ./configure [Optionen]
                </td>
        </tr>
</table>
</blockquote>

<p> Einige Versionen von Red Hat haben Passwort-Tools, die zwar MD5-style
Passwörter erstellen, die von der crypt()-Funktion des Systems jedoch
nicht verstanden werden. Wenn Passwortauthentifikation für neue
Accounts oder Accounts mit Passwörtern, die vor kurzem geändert
worden sind, fehlschlagen, es aber mit alten Accounts funktioniert, ist
das sehr wahrscheinlich der Grund. (Betroffene Accounts haben
Passwort-Zeichenketten in <i>/etc/shadow</i>, die mit <code>$1$</code>
beginnen).

<p>
Um das Problem zu behebnen, aktiviere MD5-Unterstützung in sshd
während der Entwicklungsphase, um das Problem zu beheben:

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
./configure --with-md5-passwords [Optionen]
                </td>
        </tr>
</table>
</blockquote>

<h2><a name= "3.6">3.6 - Configure oder sshd(8) beschweren sich über fehlende RSA- oder DSA-Unterstützung</a></h2>

<p>
Stelle sicher, dass deine OpenSSL-Bibliotheken mit eingebauter RSA- oder
DSA-Unterstützung erzeugt wurden, entweder intern oder durch RSAref.


<h2><a name= "3.7">3.7 - ,scp: command not found'-Fehler</a></h2>

<p>
<a href="http://www.openbsd.org/cgi-bin/man.cgi?query=scp&amp;sektion=1">scp(1)</a>
muss sich im Standard-PATH sowohl auf dem Client als auch auf dem Server
befinden. Möglicherweise musst du die Option <b>--with-default-path</b>
angeben, um einen angepassten Pfad für die Suche auf dem
Server angeben zu können. Diese Option ersetzt den Standardpfad, so dass
du sowohl alle bisherigen Verzeichnisse in deinem Pfad angeben musst als auch
das Verzeichnis, in dem scp installiert ist. Zum Beispiel:

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
$ <b>./configure --with-default-path=/bin:/usr/bin:/usr/local/bin:/path/to/scp</b>
                </td>
        </tr>
</table>
</blockquote>

<p>
Bedenke, dass die Konfiguration des Administrators des Servers Vorrang
gegenüber der Option <b>--with-default-path</b> hat. Das beinhaltet
das Rücksetzen von PATH in <i>/etc/profile</i>, PATH in
<i>/etc/environment</i> unter AIX oder (für 3.7p1 und höher) das
Setzen von PATH oder SUPATH in <i>/etc/default/login</i> unter Solaris oder
Reliant Unix.

<h2><a name= "3.8">3.8 - Kann die Passphrase nicht lesen</a></h2>

<p>
Einige Betriebssysteme setzen <i>/dev/tty</i> mit falschen Modi, was
zum Fehler beim Lesen von Passwörtern mit folgender Fehlermeldung
führt:

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
You have no controlling tty.  Cannot read passphrase.
                </td>
        </tr>
</table>
</blockquote>

<p>
Die Lösung hierzu ist, die Berechtigungen von <i>/dev/tty</i> auf 0666 zu
setzen und dann das ganze deinem Betriebssystem-Hersteller als Fehler zu
melden.


<h2><a name= "3.9">3.9 - ,configure' fehlt oder make versagt</a></h2>

<p>
Wenn es keine ,configure'-Datei in deiner tar.gz-Datei gibt, die du
heruntergeladen hast, oder make mit einem ,missing seperator'-Fehler
versagt, hast du vermutlich die OpenBSD-Distribution heruntergeladen
und versuchst, sie auf einer anderen Plattform zu kompilieren.
Bitte verwende die <a href="portable.html">portable Version</a>.


<h2><a name= "3.10">3.10 - Hängt beim Verlassen von ssh</a></h2>

<p>
OpenSSH kann beim Beenden hängen bleiben. Das kann passieren, wenn
es einen aktiven Hintergrundprozess gibt. Linux und HP-UX sind
hierfür bekannt. Das Problem kann hiermit verifiziert werden:

<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
$ <b>sleep 20 &amp; exit</b>
                </td>
        </tr>
</table>
</blockquote>

Versuche stattdessen das hier zu benutzen:
<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
$ <b>sleep 20 &lt; /dev/null &gt; /dev/null 2&gt;&amp;1 &amp;</b>
                </td>
        </tr>
</table>
</blockquote>

<p>
Ein Umgehen des Problems für bash-Anwender ist mittels eines
Einfügens von <b>"shopt -s huponexit"</b> in entweder /etc/bashrc oder
~/.bashrc möglich. Ansonsten konsultiere die Manualseite deiner Shell um
eine Option zu finden, mit der man aktiven Jobs ein HUP-Signal senden kann,
wenn man sie verlässt. Siehe <a
href="http://bugzilla.mindrot.org/show_bug.cgi?id=52">bug #52</a>
für andere Möglichkeiten, das Problem umgehen zu können.

<h2><a name= "3.11">3.11 - Wieso hängt ssh beim Beenden?</a></h2>

<p>
Beim Ausführen von
<blockquote>
<table border=0 width="800">
        <tr>
                <td nowrap bgcolor="#EEEEEE">
$ <b>ssh host command</b>
                </td>
        </tr>
</table>
</blockquote>
<b>muss</b> ssh hängenbleiben, da es zu warten hat
<ul>
<li>
bis es sicherstellen kann, dass <code>command</code> keine weiteren
Eingaben benötigt.
<li>
bis es sicherstellen kann, dass <code>command</code> keine weitere
Ausgaben zurückgibt.
<li>
bis <code>command</code> beendet ist, da der sshd den Exitstatus
von <code>command</code> an ssh weitergeben muss.
</ul>
<p>

<h2><a name= "3.12">3.12 - Ich habe ein Upgrade auf OpenSSH 3.1
durchgeführt und dann ging die X11-Weiterleitung nicht mehr.</a></h2>

Beginnend mit OpenSSH 3.1 lauscht der sshd-X11-Weiterleitungsserver
standardmäßig auf localhost; siehe auch die
Option <b>X11UseLocalhost</b> von sshd, um zum vorherigen Verhalten
zurückzukehren, wenn deine älteren X11-Clients nicht mit dieser
Konfiguration funktionieren.<p>

Im Allgemeinen sollten X11-Clients, die X11 R6 benutzen, mit dieser
Einstellung funktionieren. Einige Hersteller, einschließlich HP, setzen
X11-Clients mit R6- und R5-Bibliotheken ein, so dass einige Clients
funktionieren und andere nicht.
Das gilt z.B. für HP-UX 11.X.<p>

<h2><a name= "3.13">3.13 - Ich habe ein Upgrade auf OpenSSH 3.8
durchgeführt und dann gingen einige X11-Programme nicht
mehr.</a></h2>

<p>
Wie in den <a href="../txt/release-3.8">3.8 release notes</a> dokumentiert
worden ist, wird <code>ssh</code> standardmäßig ,untrusted X11
cookies' benutzen. Das vorherige Verhalten kann durch das Setzen von
<b>ForwardX11Trusted yes</b> in <i>sshd_config</i> wiederhergestellt werden.

<p>
Mögliche Symptome beinhalten:<br>
<code>BadWindow (invalid Window parameter)<br>
BadAccess (attempt to access private resource denied)<br>
X Error of failed request:  BadAtom (invalid Atom parameter)<br>
Major opcode of failed request:  20 (X_GetProperty)<br></code>

<h2><a name= "3.14">3.14 - Ich habe meinen öffentlichen Schlüssel
in authorized_keys kopiert, aber public-key-Authentifizierung funktioniert
immernoch nicht.</a></h2>

<p>
Typischerweise wird das durch die Dateirechte von $HOME,
$HOME/.ssh oder $HOME/.ssh/authorized_keys hervorgerufen, die mehr erlauben
als sshd standardmäßig zulässt.

<p>
In diesem Falle kann es behoben werden, indem folgendes auf dem Server
ausgeführt wird.
<blockquote>
<table border=0 width="800">
<tr>
  <td nowrap bgcolor="#EEEEEE">
$ <b>chmod go-w $HOME $HOME/.ssh</b><br>
$ <b>chmod 600 $HOME/.ssh/authorized_keys</b>
  </td>
</tr>
</table>
</blockquote>

<p>
Falls das aus irgendeinem Grund nicht möglich sein sollte, besteht die
Alternative darin, <b>StrictModes no</b> in <i>sshd_config</i> zu setzen,
jedoch wird das nicht empfohlen.

<hr>
<a href="index.html"><img height=24 width=24 src="../back.gif" border=0 alt=OpenSSH></a>
<a href="mailto:www@openbsd.org">www@openbsd.org</a>
<br>
<small>
Originally [OpenBSD: faq.html,v 1.91 ]<br>
$Translation: faq.html,v 1.51 2004/12/22 12:29:54 paldium Exp $<br>
$OpenBSD: faq.html,v 1.50 2004/12/22 20:00:13 jufi Exp $
</small>

</body>
</html>
